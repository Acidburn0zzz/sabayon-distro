--- a/src/nm-device-802-11-wireless.c
+++ b/src/nm-device-802-11-wireless.c
@@ -116,7 +116,8 @@
                                       guint8 **out_res_buf,
                                       guint32 *data_len);
 
-static int	wireless_qual_to_percent (const struct iw_quality *qual,
+static int	wireless_qual_to_percent (NMDevice *dev,
+								 const struct iw_quality *qual,
                                          const struct iw_quality *max_qual,
                                          const struct iw_quality *avg_qual);
 
@@ -244,8 +245,9 @@
 #endif
 		if (iw_get_stats (nm_dev_sock_get_fd (sk), iface, &stats, &range, has_range) == 0)
 		{
-			percent = wireless_qual_to_percent (&stats.qual, (const iwqual *)(&self->priv->max_qual),
-					(const iwqual *)(&self->priv->avg_qual));
+			percent = wireless_qual_to_percent (NM_DEVICE (self), &stats.qual,
+						(const iwqual *)(&self->priv->max_qual),
+  						(const iwqual *)(&self->priv->avg_qual));
 		}
 		nm_dev_sock_close (sk);
 	}
@@ -1148,7 +1150,8 @@
  *
  */
 static int
-wireless_qual_to_percent (const struct iw_quality *qual,
+wireless_qual_to_percent (NMDevice *dev,
+					 const struct iw_quality *qual,
                           const struct iw_quality *max_qual,
                           const struct iw_quality *avg_qual)
 {
@@ -1177,7 +1180,7 @@
 	 * are free to use whatever they want to calculate "Link Quality".
 	 */
 	if ((max_qual->qual != 0) && !(max_qual->updated & IW_QUAL_QUAL_INVALID) && !(qual->updated & IW_QUAL_QUAL_INVALID))
-		percent = (int)(100 * ((double)qual->qual / (double)max_qual->qual));
+		percent = (int) (100 * ((double) qual->qual / (double) max_qual->qual));
 
 	/* If the driver doesn't specify a complete and valid quality, we have two options:
 	 *
@@ -1243,7 +1246,7 @@
 	}
 
 	/* If the quality percent was 0 or doesn't exist, then try to use signal levels instead */
-	if ((percent < 1) && (level_percent >= 0))
+	if ((percent < 1 || !strcmp (nm_device_get_driver (dev), "ath_pci")) && (level_percent >= 0))
 		percent = level_percent;
 
 #ifdef IW_QUAL_DEBUG
@@ -3301,7 +3304,8 @@
 				nm_ap_set_freq (ap, iw_freq2float(&(iwe->u.freq)));
 				break;
 			case IWEVQUAL:
-				nm_ap_set_strength (ap, wireless_qual_to_percent (&(iwe->u.qual),
+				nm_ap_set_strength (ap, wireless_qual_to_percent (&dev->parent,
+									&(iwe->u.qual),
 									(const iwqual *)(&dev->priv->max_qual),
 									(const iwqual *)(&dev->priv->avg_qual)));
 				break;
--- a/src/nm-device-802-11-wireless.c
+++ b/src/nm-device-802-11-wireless.c
@@ -354,23 +354,15 @@
 
 	if ((data_len >= minlen) && range->we_version_compiled >= 18)
 	{
-		if (range->enc_capa & IW_ENC_CAPA_WPA)
-		{
-			caps |= (NM_802_11_CAP_PROTO_WPA
-				  | NM_802_11_CAP_KEY_MGMT_PSK
-				  | NM_802_11_CAP_KEY_MGMT_802_1X);
-		}
-		if (range->enc_capa & IW_ENC_CAPA_WPA2)
-		{
-			caps |= (NM_802_11_CAP_PROTO_WPA2
-				  | NM_802_11_CAP_KEY_MGMT_PSK
-				  | NM_802_11_CAP_KEY_MGMT_802_1X);
-		}
-
-		if (range->enc_capa & IW_ENC_CAPA_CIPHER_TKIP)
-			caps |= NM_802_11_CAP_CIPHER_TKIP;
-		if (range->enc_capa & IW_ENC_CAPA_CIPHER_CCMP)
-			caps |= NM_802_11_CAP_CIPHER_CCMP;
+		/* FIXME: Until all drivers support enc_capa ... */
+		caps |= (NM_802_11_CAP_PROTO_WPA
+			  | NM_802_11_CAP_KEY_MGMT_PSK
+			  | NM_802_11_CAP_KEY_MGMT_802_1X);
+		caps |= (NM_802_11_CAP_PROTO_WPA2
+			  | NM_802_11_CAP_KEY_MGMT_PSK
+			  | NM_802_11_CAP_KEY_MGMT_802_1X);
+		caps |= NM_802_11_CAP_CIPHER_TKIP;
+		caps |= NM_802_11_CAP_CIPHER_CCMP;
 	}
 
 	return caps;
@@ -2695,13 +2687,11 @@
 }
 
 
-#define NM_SUPPLICANT_TIMEOUT	20	/* how long we wait for wpa_supplicant to associate (in seconds) */
+#define NM_SUPPLICANT_TIMEOUT	60	/* how long we wait for wpa_supplicant to associate (in seconds) */
 
 static unsigned int
 get_supplicant_timeout (NMDevice80211Wireless *self)
 {
-	if (self->priv->num_freqs > 14)
-		return NM_SUPPLICANT_TIMEOUT * 2;
 	return NM_SUPPLICANT_TIMEOUT;
 }
 
@@ -2910,6 +2900,8 @@
 	struct wpa_ctrl *	ctrl = NULL;
 	char *			socket_path;
 	const char *		iface = nm_device_get_iface (NM_DEVICE (self));
+	const char *		wpa_driver;
+	const char *		kernel_driver;
 	gboolean			success = FALSE;
 	int				tries = 0;
 
@@ -2926,9 +2918,21 @@
 		goto exit;
 	}
 
+	/*
+	 * We want to work with the generic "wext" wpa_supplicant driver, but some kernel drivers
+	 * are just utter junk.  For those losers, we use a specific wpa_supplicant driver.
+	 */
+	kernel_driver = nm_device_get_driver (NM_DEVICE (self));
+	if (!strcmp (kernel_driver, "ath_pci"))
+		wpa_driver = "madwifi";
+	else if (!strcmp (kernel_driver, "prism54"))
+		wpa_driver = "prism54";
+	else
+		wpa_driver = "wext";
+
 	/* wpa_cli -g/var/run/wpa_supplicant-global interface_add eth1 "" wext /var/run/wpa_supplicant */
 	if (!nm_utils_supplicant_request_with_check (ctrl, "OK", __func__, NULL,
-			"INTERFACE_ADD %s\t\twext\t" WPA_SUPPLICANT_CONTROL_SOCKET "\t", iface))
+			"INTERFACE_ADD %s\t\t%s\t" WPA_SUPPLICANT_CONTROL_SOCKET "\t", iface, wpa_driver))
 		goto exit;
 	wpa_ctrl_close (ctrl);
 
@@ -2964,7 +2968,8 @@
 	struct wpa_ctrl *	ctrl;
 	gboolean			is_adhoc;
 	char *		hex_essid;
-	const char *		ap_scan = "AP_SCAN 1";
+	char *		ap_scan;
+	const char *		kernel_driver;
 	guint32			caps;
 	gboolean			supports_wpa;
 
@@ -2986,12 +2991,39 @@
 				|| (caps & NM_802_11_CAP_PROTO_WPA2);
 
 	/* Use "AP_SCAN 2" if:
+	 *
+	 * - The wireless driver does not support "AP_SCAN 1"
+	 *    (orinoco, prism54, airo, and airo_cs)
+	 *  - The wireless network is hidden and the driver does not support
+	 *    "AP_SCAN 1" with hidden networks (ipw2100, ipw2200, and ndiswrapper)
 	 * - The wireless network is non-broadcast or Ad-Hoc
 	 * - The wireless driver does not support WPA (stupid drivers...)
+	 *
+	 * Otherwise, we prefer "AP_SCAN 1".
 	 */
 	is_adhoc = (nm_ap_get_mode(ap) == IW_MODE_ADHOC);
-	if (!nm_ap_get_broadcast (ap) || is_adhoc || !supports_wpa)
+	kernel_driver = nm_device_get_driver (NM_DEVICE (self));
+	if (!strcmp (kernel_driver, "orinoco_cs"))
+		ap_scan = "AP_SCAN 2";
+	else if (!strcmp (kernel_driver, "prism54"))
+		ap_scan = "AP_SCAN 2";
+	else if (!strncmp (kernel_driver, "airo", 4))
+		ap_scan = "AP_SCAN 2";
+	else if (!strcmp (kernel_driver, "ndiswrapper") && !nm_ap_get_broadcast (ap))
+		ap_scan = "AP_SCAN 2";
+	else if (!strcmp (kernel_driver, "ipw2100") || !strcmp (kernel_driver, "ipw2200"))
+	{
+		if (nm_ap_get_broadcast (ap))
+			ap_scan = "AP_SCAN 1";
+		else
+			ap_scan = "AP_SCAN 2";
+	}
+	else if (is_adhoc)
 		ap_scan = "AP_SCAN 2";
+	else if (!supports_wpa)
+		ap_scan = "AP_SCAN 2";
+	else
+		ap_scan = "AP_SCAN 1";
 
 	/* Tell wpa_supplicant that we'll do the scanning */
 	if (!nm_utils_supplicant_request_with_check (ctrl, "OK", __func__, NULL, ap_scan))
