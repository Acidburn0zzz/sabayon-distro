diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/Kconfig linux-2.6.21-sabayon-r1/drivers/net/wireless/Kconfig
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/Kconfig	2007-05-07 10:32:03.000000000 +0200
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/Kconfig	2007-05-07 10:43:13.000000000 +0200
@@ -507,6 +507,8 @@ config PRISM54
 	  say M here and read <file:Documentation/modules.txt>.  The module
 	  will be called prism54.ko.
 
+
+
 config USB_ATMEL
 	tristate "Atmel at76c503/at76c505/at76c505a USB cards"
 	depends on USB && WLAN_80211
@@ -535,6 +537,20 @@ config USB_ZD1201
 	  To compile this driver as a module, choose M here: the
 	  module will be called zd1201.
 
+	config PRISM54_USB
+	tristate "Linksys USB wireless adapters"
+	depends on USB && IEEE80211 && WLAN_80211 && IEEE80211_SOFTMAC && EXPERIMENTAL
+	select WIRELESS_EXT
+	select FW_LOADER
+	---help---
+	  This enables support for USB wireless adapters such as
+	  Linksys WUSB54G(+P).
+	  
+	  If you enable this you will need a firmware file as well.
+	  You will need to copy this to /lib/firmware/isl3890usb.
+	  You can get this firmware file from the Prism54 project page:
+	  <http://prism54.org>
+
 source "drivers/net/wireless/hostap/Kconfig"
 source "drivers/net/wireless/prism2/Kconfig"
 source "drivers/net/wireless/bcm43xx/Kconfig"
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/Makefile linux-2.6.21-sabayon-r1/drivers/net/wireless/Makefile
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/Makefile	2007-05-07 10:32:03.000000000 +0200
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/Makefile	2007-05-07 10:41:27.000000000 +0200
@@ -33,6 +33,7 @@ obj-$(CONFIG_PCI_ATMEL)         += atmel
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
 obj-$(CONFIG_PRISM54)		+= prism54/
+obj-$(CONFIG_PRISM54_USB)	+= prism54usb/
 
 obj-$(CONFIG_USB_ATMEL)		+= at76/
 obj-$(CONFIG_HOSTAP)		+= hostap/
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54/isl_38xx.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54/isl_38xx.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54/isl_38xx.h	2007-05-07 10:10:26.000000000 +0200
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54/isl_38xx.h	2007-04-04 09:22:31.000000000 +0200
@@ -1,4 +1,5 @@
 /*
+ *
  *  Copyright (C) 2002 Intersil Americas Inc.
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -19,91 +20,10 @@
 #ifndef _ISL_38XX_H
 #define _ISL_38XX_H
 
+#include <linux/isl_38xx.h>
 #include <asm/io.h>
 #include <asm/byteorder.h>
 
-#define ISL38XX_CB_RX_QSIZE                     8
-#define ISL38XX_CB_TX_QSIZE                     32
-
-/* ISL38XX Access Point Specific definitions */
-#define ISL38XX_MAX_WDS_LINKS                   8
-
-/* ISL38xx Client Specific definitions */
-#define ISL38XX_PSM_ACTIVE_STATE                0
-#define ISL38XX_PSM_POWERSAVE_STATE             1
-
-/* ISL38XX Host Interface Definitions */
-#define ISL38XX_PCI_MEM_SIZE                    0x02000
-#define ISL38XX_MEMORY_WINDOW_SIZE              0x01000
-#define ISL38XX_DEV_FIRMWARE_ADDRES             0x20000
-#define ISL38XX_WRITEIO_DELAY                   10	/* in us */
-#define ISL38XX_RESET_DELAY                     50	/* in ms */
-#define ISL38XX_WAIT_CYCLE                      10	/* in 10ms */
-#define ISL38XX_MAX_WAIT_CYCLES                 10
-
-/* PCI Memory Area */
-#define ISL38XX_HARDWARE_REG                    0x0000
-#define ISL38XX_CARDBUS_CIS                     0x0800
-#define ISL38XX_DIRECT_MEM_WIN                  0x1000
-
-/* Hardware registers */
-#define ISL38XX_DEV_INT_REG                     0x0000
-#define ISL38XX_INT_IDENT_REG                   0x0010
-#define ISL38XX_INT_ACK_REG                     0x0014
-#define ISL38XX_INT_EN_REG                      0x0018
-#define ISL38XX_GEN_PURP_COM_REG_1              0x0020
-#define ISL38XX_GEN_PURP_COM_REG_2              0x0024
-#define ISL38XX_CTRL_BLK_BASE_REG               ISL38XX_GEN_PURP_COM_REG_1
-#define ISL38XX_DIR_MEM_BASE_REG                0x0030
-#define ISL38XX_CTRL_STAT_REG                   0x0078
-
-/* High end mobos queue up pci writes, the following
- * is used to "read" from after a write to force flush */
-#define ISL38XX_PCI_POSTING_FLUSH		ISL38XX_INT_EN_REG
-
-/**
- * isl38xx_w32_flush - PCI iomem write helper
- * @base: (host) memory base address of the device
- * @val: 32bit value (host order) to write
- * @offset: byte offset into @base to write value to
- *
- *  This helper takes care of writing a 32bit datum to the
- *  specified offset into the device's pci memory space, and making sure
- *  the pci memory buffers get flushed by performing one harmless read
- *  from the %ISL38XX_PCI_POSTING_FLUSH offset.
- */
-static inline void
-isl38xx_w32_flush(void __iomem *base, u32 val, unsigned long offset)
-{
-	writel(val, base + offset);
-	(void) readl(base + ISL38XX_PCI_POSTING_FLUSH);
-}
-
-/* Device Interrupt register bits */
-#define ISL38XX_DEV_INT_RESET                   0x0001
-#define ISL38XX_DEV_INT_UPDATE                  0x0002
-#define ISL38XX_DEV_INT_WAKEUP                  0x0008
-#define ISL38XX_DEV_INT_SLEEP                   0x0010
-
-/* Interrupt Identification/Acknowledge/Enable register bits */
-#define ISL38XX_INT_IDENT_UPDATE                0x0002
-#define ISL38XX_INT_IDENT_INIT                  0x0004
-#define ISL38XX_INT_IDENT_WAKEUP                0x0008
-#define ISL38XX_INT_IDENT_SLEEP                 0x0010
-#define ISL38XX_INT_SOURCES                     0x001E
-
-/* Control/Status register bits */
-/* Looks like there are other meaningful bits
-    0x20004400 seen in normal operation,
-    0x200044db at 'timeout waiting for mgmt response'
-*/
-#define ISL38XX_CTRL_STAT_SLEEPMODE             0x00000200
-#define	ISL38XX_CTRL_STAT_CLKRUN		0x00800000
-#define ISL38XX_CTRL_STAT_RESET                 0x10000000
-#define ISL38XX_CTRL_STAT_RAMBOOT               0x20000000
-#define ISL38XX_CTRL_STAT_STARTHALTED           0x40000000
-#define ISL38XX_CTRL_STAT_HOST_OVERRIDE         0x80000000
-
 /* Control Block definitions */
 #define ISL38XX_CB_RX_DATA_LQ                   0
 #define ISL38XX_CB_TX_DATA_LQ                   1
@@ -130,6 +50,7 @@ isl38xx_w32_flush(void __iomem *base, u3
 
 /* Fragment package definitions */
 #define FRAGMENT_FLAG_MF                        0x0001
+#define FRAGMENT_FLAG_CONTROL                   0x0002
 #define MAX_FRAGMENT_SIZE                       1536
 
 /* In monitor mode frames have a header. I don't know exactly how big those
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54/islpci_eth.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54/islpci_eth.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54/islpci_eth.c	2007-05-07 10:10:26.000000000 +0200
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54/islpci_eth.c	2007-05-07 10:18:44.000000000 +0200
@@ -136,7 +136,7 @@ islpci_eth_transmit(struct sk_buff *skb,
 				printk("islpci_eth_transmit:wds_mac\n");
 #endif
 				memmove(skb->data + 6, src, skb->len);
-				memcpy(skb->data, wds_mac, 6);
+				skb_copy_to_linear_data(skb, wds_mac, 6);
 			} else {
 				memmove(skb->data, src, skb->len);
 			}
@@ -162,13 +162,16 @@ islpci_eth_transmit(struct sk_buff *skb,
 
 			skb_put(newskb, init_wds ? skb->len + 6 : skb->len);
 			if (init_wds) {
-				memcpy(newskb->data + 6, skb->data, skb->len);
-				memcpy(newskb->data, wds_mac, 6);
+				skb_copy_from_linear_data(skb,
+							  newskb->data + 6,
+							  skb->len);
+				skb_copy_to_linear_data(newskb, wds_mac, 6);
 #ifdef ISLPCI_ETH_DEBUG
 				printk("islpci_eth_transmit:wds_mac\n");
 #endif
 			} else
-				memcpy(newskb->data, skb->data, skb->len);
+				skb_copy_from_linear_data(skb, newskb->data,
+							  skb->len);
 
 #if VERBOSE > SHOW_ERROR_MESSAGES
 			DEBUG(SHOW_TRACING, "memcpy %p %p %i wds %i\n",
@@ -303,7 +306,7 @@ islpci_monitor_rx(islpci_private *priv, 
 		skb_pull(*skb, sizeof (struct rfmon_header));
 
 	(*skb)->protocol = htons(ETH_P_802_2);
-	(*skb)->mac.raw = (*skb)->data;
+	skb_reset_mac_header(*skb);
 	(*skb)->pkt_type = PACKET_OTHERHOST;
 
 	return 0;
@@ -374,10 +377,6 @@ islpci_eth_receive(islpci_private *priv)
 	DEBUG(SHOW_BUFFER_CONTENTS, "\nrx %p ", skb->data);
 	display_buffer((char *) skb->data, skb->len);
 #endif
-
-	/* do some additional sk_buff and network layer parameters */
-	skb->dev = ndev;
-
 	/* take care of monitor mode and spy monitoring. */
 	if (unlikely(priv->iw_mode == IW_MODE_MONITOR))
 		discard = islpci_monitor_rx(priv, &skb);
@@ -398,8 +397,10 @@ islpci_eth_receive(islpci_private *priv)
 			/* Update spy records */
 			wireless_spy_update(ndev, annex->addr2, &wstats);
 
-			memcpy(skb->data + sizeof (struct rfmon_header),
-			       skb->data, 2 * ETH_ALEN);
+			skb_copy_from_linear_data(skb,
+						  (skb->data +
+						   sizeof(struct rfmon_header)),
+						  2 * ETH_ALEN);
 			skb_pull(skb, sizeof (struct rfmon_header));
 		}
 		skb->protocol = eth_type_trans(skb, ndev);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_alloc.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_alloc.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_alloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_alloc.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,136 @@
+/*
+  Copyright 2006 Jean-Baptiste Note
+
+  This file is part of islsm.
+
+  islsm is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your
+  option) any later version.
+
+  islsm is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with islsm; if not, write to the Free Software Foundation, Inc.,
+  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+/*
+  Foreword : how come we need this ? The firmware in intersil's chipsets
+  does not do memory management by itself.  When you send a frame to the
+  device: 
+  
+  - for a control frame, it treats it directly in-interrupt; 
+
+  - for a data frame, it puts a header in front of it, of length less than
+  ISLSM_80211_FW_HEADROOM, and links it into doubly-linked queues
+  depending on it's type. 
+  
+  But in all cases, *we* get to tell the firmware where to put the
+  frames in its own memory space, and we must take great care not to
+  completely screw up the firmware state by doing overwrites on active
+  control data.
+
+  Usually, for a standard data frame, the firmware will send you an ack
+  packets saying "OK, the frame that you sent at this address has been
+  dequeued, you can reclaim the associated memory".
+
+  However, for some reasons, sometimes this ack does not goes through
+  (probably when the frame is not acked).
+
+  So the driver has the possibility to send a command saying "take the
+  frame at this address, which I sent you earlier, unlink it from the
+  queue it's in, and tell me when you're done" -- this actually allows
+  you to explicitly reclaim the buffer (see islsm_empty_queue).
+
+  You can do this when you're pretty sure the frame has exceeded it's
+  expected ACK time (all of this is somewhat speculative, he) ; allowing
+  you to reclaim the associated memory for other frames.
+
+  HOWEVER, some special frames, such as the beacon, or the probe
+  request, for instance, do not follow this pattern. They occupy special
+  slots (obviously, you don't want to retransmit the beacon frame
+  everytime you want it out), and they are automatically freed with
+  special control packets (tx/rx filters, or frequency change). I don't
+  know if it's legit to reclaim them with the above command.
+
+  Thus you'll find here a: Small Block Allocator, currently dirty.
+
+  The plan is to use the control block of tx frames to chain the skbs of
+  the frames which are present (or on the verge of being present, once
+  submitted) in device memory. The normal chaining of skbs is reserved
+  for future use in the usb driver on the usbnet model.
+
+*/
+
+#ifndef _HAS_ISLSM_ALLOC_H
+#define _HAS_ISLSM_ALLOC_H
+
+#include <linux/skbuff.h>
+#include <linux/list.h>
+#include <linux/types.h>
+
+#define ISLSM_BLOCK_SIZE (1<<8)
+/* oversized for some,
+   but should be okay for all */
+/* latest firmwares (lm87) seem to need 0x60 */
+#define ISLSM_80211_FW_HEADROOM 0x70
+
+/* various kind of frames */
+
+/* control frames which do not need a response can be freed as soon as
+   they are submitted -- they are treated in-order by the firmware */
+#define      ISLSM_ALLOC_FREE_WHEN_SUBMITTED 1
+/* control frames which do need a response should not be freed so soon
+   -- one should wait for them to be transmitted back with their result,
+   as the data therein could be corrupted by a concurrent TX */
+#define      ISLSM_ALLOC_FREE_ON_RESPONSE    2
+/* standard data frames should be freed when receiving a packet in
+   islsm_input_txack -- actually i'm not really sure, maybe the frame is
+   only a status report, which *may* indicate that the slot has been
+   freed. But this seems to be usually the case. */
+#define      ISLSM_ALLOC_FREE_ON_ACK         4
+
+/* control block of the tx skbs, allocator-specific part */
+struct islsm_alloc_cb {
+	u32                     lmac_addr;
+	unsigned                flags;
+	unsigned                len;
+	/* access is serialized islsm->alloc->slock */
+	struct list_head        chain;
+};
+
+
+typedef struct mem_descr {
+	uint32_t                start_addr;
+	uint32_t                end_addr;
+	spinlock_t              slock;
+	struct list_head        indevice_skbs;
+} mem_descr_t;
+
+int                     islsm_alloc_create(mem_descr_t *, uint32_t start,
+					   uint32_t end);
+void                    islsm_alloc_destroy(mem_descr_t *);
+
+/* functions exported to other modules */
+int                     islsm_alloc(mem_descr_t *mem, struct sk_buff *skb);
+void                    islsm_free(mem_descr_t *, uint32_t addr);
+ssize_t                 islsm_alloc_dump(mem_descr_t *mem, char *buf);
+
+#define LMAC_ADDR_OF_SKB(skb) ( ((struct islsm_alloc_cb *)skb->cb)->lmac_addr )
+#define LMAC_ALLOC_FLAGS(skb) ( ((struct islsm_alloc_cb *)skb->cb)->flags )
+
+/* This is an intermediate step which relies on the old
+   allocator to do the job. Will completely redo under the hood
+   ultimately */
+static inline void 
+islsm_alloc_set_flags(struct sk_buff *skb, unsigned flags) {
+	struct islsm_alloc_cb *alloc = (void *)skb->cb;
+	alloc->flags = flags;
+}
+
+#endif				/* _HAS_ISLSM_ALLOC_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_alloc_skb.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_alloc_skb.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_alloc_skb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_alloc_skb.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,212 @@
+/*
+  Copyright 2006 Jean-Baptiste Note
+
+  This file is part of islsm.
+
+  islsm is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your
+  option) any later version.
+
+  islsm is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with islsm; if not, write to the Free Software Foundation, Inc.,
+  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+/* for sprintf */
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+/* for EXPORT_SYMBOL */
+#include <linux/module.h>
+
+#include "islsm_alloc.h"
+#include "islsm_log.h"
+
+/* simple first-fit allocation */
+static inline int
+find_first_hole(const unsigned start_addr,
+		const unsigned end_addr,
+		struct islsm_alloc_cb *cb,
+		struct list_head *head) {
+	struct islsm_alloc_cb *skb_cb;
+	struct list_head *new = &cb->chain;
+	unsigned size = cb->len;
+ 	unsigned last_free_addr = start_addr;
+
+	/* FIXME is destination address 32 bits aligned ? */
+	list_for_each_entry(skb_cb, head, chain) {
+		unsigned lmac_addr = skb_cb->lmac_addr - ISLSM_80211_FW_HEADROOM;
+		unsigned hole_size = lmac_addr - last_free_addr;
+		BUG_ON(lmac_addr < last_free_addr);
+		islog(L_ALLOC, "hole size %u\n", hole_size);
+		if (hole_size > size) {
+			cb->lmac_addr = last_free_addr + ISLSM_80211_FW_HEADROOM;
+ 			list_add_tail(new, &skb_cb->chain);
+			return 0;
+		}
+		last_free_addr = lmac_addr + skb_cb->len;
+	}
+	
+	if (end_addr - last_free_addr > size) {
+		islog(L_ALLOC, "end hole size %u\n", end_addr - last_free_addr);
+		cb->lmac_addr = last_free_addr + ISLSM_80211_FW_HEADROOM;
+		list_add_tail(new, head);
+		return 0;
+	}
+	
+	return -ENOSPC;
+}
+
+/*
+ * Warning: this function must not touch the control block in case of a
+ * failed allocation.
+ */
+int
+islsm_alloc(struct mem_descr *mem, struct sk_buff *skb)
+{
+	struct islsm_alloc_cb *alloc = (void *)skb->cb;
+	/* round to 32-bits */
+	unsigned len = ((skb->len + ISLSM_80211_FW_HEADROOM + 3) >> 2) << 2;
+	unsigned long irqflags;
+	int err;
+
+	islog(L_ALLOC, "alloc chunck of len %x\n", len);
+
+	alloc->len = len;
+
+	/* Walk through the chain of skbs and
+	   see where we can put ourselves */
+	spin_lock_irqsave(&mem->slock, irqflags);
+	err = find_first_hole(mem->start_addr, mem->end_addr,
+			      alloc, &mem->indevice_skbs);
+	spin_unlock_irqrestore(&mem->slock, irqflags);
+
+	if (!err) {
+		islog(L_ALLOC, "actually allocating skb %p\n", skb);
+		skb_get(skb);
+	}
+
+	return err;
+}
+
+void
+islsm_free(mem_descr_t *mem, uint32_t addr)
+{
+	struct list_head *head = &mem->indevice_skbs;
+	int found = 0;
+	struct islsm_alloc_cb *skb_cb;
+	unsigned long irqflags;
+
+	islog(L_ALLOC, "free address %x\n", addr);
+
+	/* get the real start-of-packet address */
+	addr -= ISLSM_80211_FW_HEADROOM;
+
+	/* walk through the chain of skbs and find the good one */
+	spin_lock_irqsave(&mem->slock, irqflags);
+	list_for_each_entry(skb_cb, head, chain) {
+		unsigned lmac_addr = skb_cb->lmac_addr - ISLSM_80211_FW_HEADROOM;
+		if ((addr >= lmac_addr) && (addr < lmac_addr + skb_cb->len)) {
+			struct sk_buff *skb = container_of((void *)skb_cb,
+							   struct sk_buff, cb);
+			list_del(&skb_cb->chain);
+			/* drop the allocator reference to this skb */
+			islog(L_ALLOC, "actually freeing skb %p\n", skb);
+			kfree_skb(skb);
+			found = 1;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&mem->slock, irqflags);
+	
+	if (!found)
+		printk(KERN_ERR "%s: unallocate bogus address %08x\n",
+		       "islsm", addr);
+	return;
+}
+EXPORT_SYMBOL(islsm_free);
+
+int
+islsm_alloc_create(mem_descr_t *mem, uint32_t start, uint32_t end)
+{
+	if (end <= start)
+		return -EINVAL;
+
+	mem->start_addr = start;
+	mem->end_addr = end;
+
+	return 0;
+}
+
+void
+islsm_alloc_destroy(mem_descr_t *mem)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&mem->slock, flags);
+	mem->start_addr = 0;
+	mem->end_addr = 0;
+
+	/* kfree the remaining skbs in the list */
+/* 	list_for_each_safe(pos, n, head) { */
+/* 		struct sk_buff *skb; */
+/* 		list_del(pos); */
+/* 		kfree_skb(skb); */
+/* 	} */
+	
+	spin_unlock_irqrestore(&mem->slock, flags);
+}
+
+/* export a sysfs function for this */
+static ssize_t
+sprint_alloc_skb(char *buf, struct sk_buff *skb) {
+	unsigned offset = 0;
+	struct islsm_alloc_cb *alloc = (void *)skb->cb;
+	unsigned char *data = (unsigned char *)skb->data;
+	int i;
+
+	offset += sprintf(buf, "%p\t%08x\t%04x\t%04x\t",
+			  skb, alloc->flags,
+			  alloc->lmac_addr-ISLSM_80211_FW_HEADROOM,
+			  alloc->len+ISLSM_80211_FW_HEADROOM);
+
+	/* print the first few bytes of data -- makes debugging easier */
+	for(i=0; i < 16 && i < skb->len; i++)
+		offset += sprintf(buf + offset, "%02x ", data[i]);
+
+	offset += sprintf(buf + offset, "...\n");
+
+	return offset;
+}
+
+ssize_t
+islsm_alloc_dump(mem_descr_t *mem, char *buf)
+{
+	struct list_head *head = &mem->indevice_skbs;
+	unsigned offset = 0;
+	struct islsm_alloc_cb *skb_cb;
+	unsigned long irqflags;
+
+	/* print header */
+	offset += sprintf(buf + offset, "skb\t\tflags\t\tlmac\tlen\tdata\n");
+
+	/* loop throught skbs */
+	spin_lock_irqsave(&mem->slock, irqflags);
+	list_for_each_entry(skb_cb, head, chain) {
+		struct sk_buff *skb;
+		skb = container_of((void *)skb_cb, struct sk_buff, cb);
+		offset += sprint_alloc_skb(buf + offset, skb);
+	}
+	spin_unlock_irqrestore(&mem->slock, irqflags);
+
+	return offset;
+}
+
+EXPORT_SYMBOL(islsm_alloc_dump);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_bra.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_bra.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_bra.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_bra.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,268 @@
+/*
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include "islsm_bra.h"
+#include "islsm_log.h"
+#include "isl_sm.h"
+
+#ifdef MADWIFI
+#define DRV_NAME "islsm"
+#else
+#include "islusb_dev.h"
+#endif
+
+#define U16_OF_STRUCT(x,struc) uint16_t x = le16_to_cpu(struc->x)
+void islsm_print_exp_if(struct s_bootrec_exp_if *exp_if, unsigned int loglvl) {
+	U16_OF_STRUCT(role,exp_if);
+	U16_OF_STRUCT(if_id,exp_if);
+	U16_OF_STRUCT(variant,exp_if);
+	U16_OF_STRUCT(btm_compat,exp_if);
+	U16_OF_STRUCT(top_compat,exp_if);
+
+	islog(loglvl, "exposed interface : "
+	      "role %i, if_id %i variant %i, "
+	      "bottom_compat %i, top_compat %i\n",
+	      role, if_id, variant,
+	      btm_compat, top_compat);
+}
+
+static void bootrec_dep_if(struct s_bootrec_dep_if *dep_if) {
+	U16_OF_STRUCT(role,dep_if);
+	U16_OF_STRUCT(if_id,dep_if);
+	U16_OF_STRUCT(variant,dep_if);
+
+	islog(L_FW, "exported interface : "
+	      "role %i, if_id %i variant %i",
+	      role, if_id, variant);
+}
+#undef U16_OF_STRUCT
+
+/* Intersil's BootRecordArea parsing function.
+ *
+ * This function should be able to check that the firmware is correct for
+ * the device. It also should set the islsm parameters accordingly, maybe
+ * looking into this header.
+ */
+static int
+islsm_parse_firmware(struct islsm *islsm,
+		     const void *const data, const unsigned len)
+{
+	struct s_bootrecord *bootrec = 0;
+	int err = 0;
+	int end = 0;
+	uint32_t *fw_data = (uint32_t *) data;
+	const uint32_t *fw_end_data = fw_data + len / sizeof(*fw_data);
+
+	FN_ENTER;
+
+	/* the start of the firmware file is filled with ARM code.
+	   skip it. */
+	while (fw_data < fw_end_data && *fw_data != 0)
+		fw_data++;
+
+	/* find the beginning of umac header after a section of zero
+	 * padding */
+	while (fw_data < fw_end_data && *fw_data == 0)
+		fw_data++;
+
+	/* we've normally reached the first bootrec */
+	bootrec = (struct s_bootrecord *)fw_data;
+	islog(L_FW, "found start of umac description at offset %td\n",
+	      fw_data - (uint32_t *)data);
+
+	while (!end) {
+		unsigned length;
+		uint32_t code;
+		char *bdata;
+
+		/* Security check */
+		err = safe_bootrecord(bootrec, (char*)fw_end_data);
+		if (err) {
+			islog(L_FW, "unsafe bootrecord, aborting\n");
+			break;
+		}
+
+		err = valid_bootrecord(bootrec);
+		if (err) {
+			islog(L_FW, "invalid bootrecord, aborting\n");
+			break;
+		}
+
+		length = le32_to_cpu(bootrec->hdr.length) * sizeof(uint32_t);
+		code = le32_to_cpu(bootrec->hdr.code);
+		bdata = bootrec->data;
+
+		switch (code) {
+		case BR_CODE_COMPONENT_ID:
+		{
+			uint32_t id = ((struct s_bootrec_comp_id*)bootrec)->id;
+			switch (be32_to_cpu(id)) {
+			case FW_FMAC:
+				islog(L_FW, "Uploading FreeMAC firmware\n");
+				islsm->fw_type = ISLSM_FW_FMAC;
+				break;
+			case FW_LM86:
+				islog(L_FW, "Uploading LM86 firmware\n");
+				islsm->fw_type = ISLSM_FW_LM86;
+				break;
+			case FW_LM87:
+				islog(L_FW, "Uploading LM87 firmware\n");
+				islsm->fw_type = ISLSM_FW_LM87;
+				/* reserve space for the CRC */
+				islsm->device_tx_header_space += sizeof(u32);
+				/* in case we're dealing with 3887
+				 * devices, we must also include
+				 * headroom for the address -- possibly
+				 * this should be done for all frames */
+				islsm->device_tx_header_space += sizeof(u32);
+				break;
+			default:
+				printk(KERN_WARNING "Uploading unsupported firmware signature %08x\n",
+				       id);
+			}
+			break;
+		}
+		case BR_CODE_COMPONENT_VERSION:
+			islog(L_FW, "Component version: '%.*s'\n", length, bdata);
+			break;
+		case BR_CODE_DESCR:
+		{
+			struct s_bootrec_descr *descr= (struct s_bootrec_descr *)bdata;
+			int16_t b0 = le16_to_cpu(descr->bound0);
+			int16_t b1 = le16_to_cpu(descr->bound1);
+			int16_t v0 = le16_to_cpu(descr->val0);
+			int16_t v1 = le16_to_cpu(descr->val1);
+			islsm->frame_mem_start = le32_to_cpu(descr->frame_mem_start);
+			islsm->frame_mem_end   = le32_to_cpu(descr->frame_mem_end);
+			memcpy(islsm->bra_rate_table,descr->rate_table,ISLSM_BRA_RATE_TABLE_SIZE);
+
+			/* Unknown fields */
+			islog(L_FW, "descriptor option, frame memory space [%x,%x],\n"
+			      " unk1 is %08x, bounds are [%i,%i]"
+			      " and associated values [%i,%i]\n",
+			      islsm->frame_mem_start,
+			      islsm->frame_mem_end,
+			      le32_to_cpu(descr->unk1),
+			      b0, b1, v0, v1);
+			break;
+		}
+		case BR_CODE_EXPOSED_IF:
+		{
+			int i;
+			struct s_bootrec_exp_if *exp_if= (void *) bdata;
+			int no = nof_exp_interfaces(bootrec);
+			if (no < 0)
+				break;
+			for(i = 0; i < no; i++)
+				islsm_print_exp_if(exp_if++,L_FW);
+			break;
+		}
+		case BR_CODE_DEPENDENT_IF:
+			/* this should make the difference between usb
+			   and pci devices, for instance */
+		{
+			int i;
+			struct s_bootrec_dep_if *dep_if= (void *) bdata;
+			int no = nof_dep_interfaces(bootrec);
+			if (no < 0)
+				break;
+			for(i = 0; i < no; i++)
+				bootrec_dep_if(dep_if++);
+			break;
+		}
+		case BR_CODE_END_OF_BRA:
+		case LEGACY_BR_CODE_END_OF_BRA:
+		{
+			struct s_bootrec_end *bootrec_end = (struct s_bootrec_end *)bootrec;
+			islog(L_FW, "final option CRC %08x\n",
+			      le16_to_cpu(bootrec_end->CRC));
+			end = 1;
+			break;
+		}
+		default:
+			islog(L_FW, "unknown option %08x length %08x, dumped:\n",
+			      code, length);
+			if (isl_debug & L_FW) {
+				isl_dump_bytes(bdata,length);
+			}
+		}
+
+		bootrec = next_bootrecord(bootrec);
+	}
+
+	/* we've reached the version string, print it */
+	if (end) {
+		islog(L_FW, "firmware version string: '%.*s'\n",
+		      FW_VERSION_STRING_LEN, (char*) bootrec);
+	}
+
+	FN_EXIT1(err);
+	return err;
+}
+
+int islsm_request_firmware(const struct firmware **fw, struct islsm *islsm) {
+	struct net_device *netdev = NETDEV_OF_ISLSM(islsm);
+	const char *fw_name = islsm->firmware_name;
+	const struct firmware *fw_entry;
+	int err;
+	
+	FN_ENTER;
+
+	err = request_firmware(fw, fw_name, &netdev->dev);
+	if (err) {
+		printk(KERN_ERR "%s: Request firmware for '%s' failed: %i\n",
+		       DRV_NAME, fw_name, err);
+		goto exit;
+	}
+
+	fw_entry = *fw;
+
+	/* parse the firmware */
+	err = islsm_parse_firmware(islsm,fw_entry->data,fw_entry->size);
+	if (err) {
+		printk(KERN_ERR "%s: Firmware parsing failed: %i\n",
+		       DRV_NAME, err);
+		goto exit_release_firmware;
+	}
+
+	islsm->rxframe_mem_start = islsm->frame_mem_end - ISLSM_RXSPACE;
+
+	/* initialize the memory allocator accordingly */
+	err = islsm_alloc_create(&islsm->memory,
+				 islsm->frame_mem_start,
+				 islsm->rxframe_mem_start);
+	if (err) {
+		printk(KERN_ERR "%s: unable to setup memory allocator\n",
+		       DRV_NAME);
+		goto exit_release_firmware;
+	}
+
+	FN_EXIT1(0);
+	return 0;
+
+ exit_release_firmware:
+	release_firmware(fw_entry);
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+EXPORT_SYMBOL(islsm_request_firmware);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_bra.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_bra.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_bra.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_bra.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,295 @@
+/*
+ *  Copyright (C) 2006 Jean-Baptiste Note
+ *  Copyright (C) 2002 Intersil Americas Inc.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef _HAS_BOOTREC_H
+#define _HAS_BOOTREC_H
+
+#include <linux/kernel.h>
+
+/*
+ * This file contains the definitions for Boot Records that
+ * are used to identify (software/hardware) components.
+ *
+ * NOTE: All bootrecords start at a 32 bit aligned address
+ * so the structs should NOT be packed
+ */
+
+#define BR_MAX_BRA_SIZE		512	/* size in bytes */
+
+#define BR_CODE_MIN			0x80000000
+#define BR_CODE_COMPONENT_ID		0x80000001
+#define BR_CODE_COMPONENT_VERSION	0x80000002
+#define BR_CODE_DEPENDENT_IF		0x80000003
+#define BR_CODE_EXPOSED_IF		0x80000004
+#define BR_CODE_DESCR			0x80000101
+#define BR_CODE_MAX			0x8FFFFFFF
+#define BR_CODE_END_OF_BRA		0xFF0000FF
+#define LEGACY_BR_CODE_END_OF_BRA	0xFFFFFFFF
+
+#ifndef VER_STRING_SIZE
+#define VER_STRING_SIZE 6		/* size in 24 bit words */
+#endif
+
+/*
+ * Each boot record is identified by a unique code, followed
+ * by the length (in 32 bit words) of the data in the record.
+ */
+struct s_bootrec_hdr {
+	uint32_t code;
+	uint32_t length;
+};
+
+/* Generic bootrecord structure that can be mapped to each bootrecord */
+struct s_bootrecord {
+	struct s_bootrec_hdr hdr;
+	char data[];
+};
+
+/* The Component ID is a unique identification of the component
+ * Component IDs are defined in "interface.h"
+ */
+
+/* endianness-independent */
+/* FIXME : is there a nice way to write this constant in C from
+   something like
+   { 'F', 'M', 'A', 'C' }
+   { 'L', 'M', '8', '6' }
+*/
+#define FW_FMAC 0x464d4143
+#define FW_LM86 0x4c4d3836
+#define FW_LM87 0x4c4d3837
+
+struct s_bootrec_comp_id {
+	struct s_bootrec_hdr hdr;
+	uint32_t id;
+};
+
+/* The Version String is a zero terminated ASCII string */
+struct s_bootrec_comp_ver {
+	struct s_bootrec_hdr hdr;
+	char ver_string[VER_STRING_SIZE * sizeof(uint32_t)];
+};
+
+/*
+ * Interfaces are defined by the following scheme
+ *
+ *  -----------------------------------------------------
+ * | 16 bits |  16 bits |  16 bits |  16 bits |  16 bits |
+ * |  role   |   if ID  |  variant | btm comp | top comp |
+ *  -----------------------------------------------------
+ *
+ * Role and Interface IDs are defined in "interface.h"
+ */
+
+/*
+ * The dependent interface defines which interfaces a component
+ * needs for its proper operation. These can be mached against
+ * the exposed interfaces of other components that are available.
+ */
+struct s_bootrec_dep_if {
+	uint16_t role;
+	uint16_t if_id;
+	uint16_t variant;
+} __attribute__((packed));
+
+/*
+ * The exposed interface defines which interfaces a component
+ * offers to other components. Bottom and Top compatibility define
+ * with which variants this interface is compatible with.
+ */
+struct s_bootrec_exp_if {
+	uint16_t role;
+	uint16_t if_id;
+	uint16_t variant;
+	uint16_t btm_compat;
+	uint16_t top_compat;
+} __attribute__((packed));
+
+void islsm_print_exp_if(struct s_bootrec_exp_if *, unsigned int);
+
+/*
+ * The description interface defines several properties of the
+ * component, such as memory layout. I'd guess the structure itself is
+ * hardware-dependent.
+ */
+
+#define ISLSM_BRA_RATE_TABLE_SIZE 20
+struct s_bootrec_descr {
+	uint32_t unk1;
+	uint32_t frame_mem_start;
+	uint32_t frame_mem_end;
+	int16_t  bound0;
+	uint16_t val0;
+	int16_t  bound1;
+	uint16_t val1;
+	uint8_t  rate_table[ISLSM_BRA_RATE_TABLE_SIZE];
+} __attribute__((packed));
+
+/* The Bootrecord End defines the end of the bootrecords.
+ * No bootrecords will follow after this one
+ */
+struct s_bootrec_end {
+	struct s_bootrec_hdr hdr;
+	uint16_t CRC;
+	uint16_t pad;
+	uint32_t MD5[4];
+};
+
+
+/*
+ * Some magic numbers
+ */
+#define PACK_MAGIC 0x5041434b
+#define FW_VERSION_STRING_LEN 70
+
+/* Some inline helper functions */
+
+static inline int safe_bootrecord(const struct s_bootrecord *bootrec, char *end_of_data) {
+	uint32_t length = le32_to_cpu(bootrec->hdr.length);
+	if (end_of_data < bootrec->data ||
+	    end_of_data < (char *)bootrec + length * sizeof(uint32_t))
+		return -1;
+	return 0;
+}
+
+/*
+ * Returns 0 if the passed bootrecord is valid, -1 otherwise.
+ */
+static inline int valid_bootrecord(const struct s_bootrecord *bootrec)
+{
+	uint32_t length = le32_to_cpu(bootrec->hdr.length);
+	uint32_t code = le32_to_cpu(bootrec->hdr.code);
+	/* length too big */
+	if (length > (BR_MAX_BRA_SIZE / sizeof(uint32_t))) {
+		printk(KERN_ERR "bra parsing: bootrecord too long (length=%u)\n", length);
+		return -1;
+	}
+
+	if(code == BR_CODE_END_OF_BRA)
+		return 0;
+
+	/* no valid code */
+	if((code < BR_CODE_MIN) || (code > BR_CODE_MAX)) {
+		printk(KERN_ERR "bra_parsing: Bootrecord illegal code\n");
+		return -1;
+	 }
+
+	return 0;
+}
+
+/*
+ * Returns the number of dependent interfaces in a bootrecord
+ * result < 0 if no valid dependent interface bootrecord is passed
+ */
+static inline int nof_dep_interfaces(const struct s_bootrecord *bootrec)
+{
+	uint32_t length = le32_to_cpu(bootrec->hdr.length);
+	uint32_t code = le32_to_cpu(bootrec->hdr.code);
+
+	if((code != BR_CODE_DEPENDENT_IF) || (valid_bootrecord(bootrec)))
+		return -1;
+
+	return (length * sizeof(uint32_t)) / sizeof(struct s_bootrec_dep_if);
+}
+
+/*
+ * Returns the number of exposed interfaces in a bootrecord.
+ * result < 0 if no valid exposed interface bootrecord is passed
+ */
+static inline int nof_exp_interfaces(const struct s_bootrecord *bootrec)
+{
+	uint32_t length = le32_to_cpu(bootrec->hdr.length);
+	uint32_t code = le32_to_cpu(bootrec->hdr.code);
+
+	if((code != BR_CODE_EXPOSED_IF) || valid_bootrecord(bootrec))
+		return -1;
+
+	return (length * sizeof(uint32_t)) / sizeof(struct s_bootrec_exp_if);
+}
+
+/*
+ * Returns the size in bytes of a bootrecord, including the header.
+ */
+static inline int bootrecord_size(const struct s_bootrecord *bootrec)
+{
+	uint32_t length = le32_to_cpu(bootrec->hdr.length);
+	return (sizeof(struct s_bootrec_hdr) + (length * sizeof(uint32_t)));
+}
+
+/*
+ * Returns a pointer to the next bootrecord
+ */
+static inline struct s_bootrecord *next_bootrecord(const struct s_bootrecord *bootrec)
+{
+	struct s_bootrecord *next;
+
+	next = (struct s_bootrecord *)((uint8_t *)bootrec + bootrecord_size(bootrec));
+	return next;
+}
+
+//----------------
+// Interface Roles
+//----------------
+// The interface Role can be client or server
+#define BR_IF_ROLE_SERVER		0x0000
+#define BR_IF_ROLE_CLIENT		0x8000
+
+//---------------
+// Interface ID's
+//---------------
+// The interface ID is a unique identification of a specific interface.
+// The following values are reserved: 0x0000, 0x0002
+//					0x0000	Reserved
+#define BR_IF_ID_ISL36356A		0x0001	// Interface between BR_COMP_ID_ISL36356A <-> Firmware
+//					0x0002	Reserved
+#define BR_IF_ID_MVC			0x0003	// MAC Virtual Coprocessor
+#define BR_IF_ID_SNMP_IF		0x0004	// SNMP Interface between Application <-> Firmware
+#define BR_IF_ID_SNWNMP_IF		0x0005	// SNWNMP Interface between Application <-> Firmware
+#define BR_IF_ID_HTTP_IF		0x0006	// HTTP Interface between Application <-> Firmware
+#define BR_IF_ID_MANUF_TST_IF		0x0007	// Manufacturing and Test Interface between Application <-> Firmware
+#define BR_IF_ID_DEBUG_IF		0x0008	// PolDebug Interface between Application <-> Firmware
+// The PRODUCT and OEM interface are conceptual interfaces for product differentiation
+#define BR_IF_ID_PRODUCT_IF		0x0009
+#define BR_IF_ID_OEM_IF			0x000A
+#define BR_IF_ID_PCIHOST_IF		0x000B  // Host PCI Interface
+#define BR_IF_ID_PCI3877_IF		BR_IF_ID_PCIHOST_IF	// 3877 <-> Host PCI Interface
+#define BR_IF_ID_DAP1_MAP		BR_IF_ID_PCIHOST_IF	// Interface between BR_COMP_ID_DAP1 <-> Micro AP Firmware
+#define BR_IF_ID_ISL37704C		0x000C	// Interface between BR_COMP_ID_ISL37704C <-> Firmware
+#define BR_IF_ID_ISL37700M		BR_IF_ID_ISL37704C	// Interface between BR_COMP_ID_ISL37700M <-> Firmware
+#define BR_IF_ID_TFTP			0x000D	// TFTP Interface Application <-> Firmware
+#define BR_IF_ID_STFTP			0x000E	// STFTP Interface between Application <-> Firmware
+#define BR_IF_ID_ISL39000		0x000F  // Interface between BR_COMP_ID_ISL39000 <-> Firmware
+#define BR_IF_ID_ISL39000M              BR_IF_ID_ISL39000  // Interface between BR_COMP_ID_ISL39000M <-> Firmware
+#define BR_IF_ID_ISL39300A              0x0010  // Interface between BR_COMP_ID_ISL39300A <-> Firmware
+#define BR_IF_ID_BOOT_IF		0x0011  // Interface of bootloader and remaining firmware
+#define BR_IF_ID_DBO1                   BR_IF_ID_BOOT_IF  // Interface between BR_COMP_ID_DBO1 <-> Firmware
+//					0x0012  Reserved
+#define BR_IF_ID_FS_IF			0x0013	// File set interface (size, format, etc)
+#define BR_IF_ID_DAP1_FS		BR_IF_ID_FS_IF	// Interface between BR_COMP_ID_DAP1 <-> File Set
+//					0x0014  Reserved
+//					0x0015  Reserved
+#define BR_IF_ID_ISL37700_UAP_IF        0x0016	// Interface between ISL37700 uAP firmware <-> Firmware
+#define BR_IF_ID_ISL39000_UAP_IF        0x0017  // Interface between ISL39000 uAP firmware <-> Firmware
+// The Primary PRODUCT and Primary OEM interface are conceptual interfaces for product differentiation
+#define BR_IF_ID_PRIMARY_PRODUCT_IF     0x0018
+#define BR_IF_ID_PRIMARY_OEM_IF         0x0019
+#define BR_IF_ID_LMAC_IF		0x001A	// Interface exposed by LMAC, see doc. 553265
+
+
+#endif /* _HAS_BOOTREC_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/isl_sm.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/isl_sm.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/isl_sm.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/isl_sm.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,361 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAVE_ISL_SM_H_
+#define _HAVE_ISL_SM_H_
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+#include <linux/list.h>
+#include <linux/firmware.h>
+
+#ifdef MADWIFI
+#include <linux/version.h>
+#include "net80211/if_media.h"
+#include "net80211/ieee80211_var.h"
+#else
+#include <net/ieee80211softmac.h>
+#define PCIUART 1
+#endif				/* MADWIFI */
+
+#include "islsm_protocol.h"
+#include "islsm_alloc.h"
+#include "islsm_uart.h"
+#include "islsm_bra.h"
+
+enum islsm_state {
+	/* in this state we just received the plug event */
+	ISLSM_PROBE = 0,
+	/* communication bridge is ok (usb, pci) */
+	ISLSM_BRIDGE_OK,
+	/* rom is ok -- the uart protocol is ok */
+	ISLSM_ROM_OK,
+	/* firmware is being uploaded */
+	ISLSM_FW_UPLOAD,
+	/* freemac has been uploaded and is ok */
+	ISLSM_FREEMAC,
+	/* softmac has been uploaded and is ok */
+	ISLSM_SOFTMAC,
+};
+
+/* callback typedefs */
+typedef int (*islsm_tx_t) (struct sk_buff *);
+
+struct islsm {
+
+	/* intersil-firmware specific state machine
+	 * variables
+	 */
+
+	/* islsm instances management */
+	unsigned                minor;
+	unsigned                islsm_state;
+
+	/*
+	 * Parameters set by the BRA parsing
+	 */
+	/* LMAC type */
+	enum islsm_fw_type      fw_type;
+	/* LMAC memory mapping */
+	/* Generic LMac framespace */
+	uint32_t                frame_mem_start;
+	uint32_t                frame_mem_end;
+	/* specialized LMac framespace */
+	/* reserved space for control frames */
+	uint32_t                txframe_mem_start;
+	uint32_t                txframe_mem_end;
+	/* reserved space for rx frames */
+	uint32_t                rxframe_mem_start;
+	/* memory allocator proper */
+	mem_descr_t             memory;
+
+	/* Rate index table */
+	/* The frame format uses indexes in a table for specifying the
+	 * sending rate of various frames. This rate table is present in
+	 * the BRA. We mirror it here for use as a lookup table */
+	char                    bra_rate_table[ISLSM_BRA_RATE_TABLE_SIZE];
+
+	/*
+	 * Other parameters (sort this mess)
+	 */
+
+	/* firmware name */
+#define ISLSM_FW_NAME_LEN 33
+	char                    firmware_name[ISLSM_FW_NAME_LEN + 1];
+
+	/* LEDs state */
+	unsigned                led_mode;
+	unsigned                led_setting;
+	
+	/* reserve this much space ahead of the skb for the needs of the
+	   hardware tx queues */
+	size_t                  device_tx_header_space;
+	/* sm_tx_header_space to be added */
+	/* sm_rx_header_space to be added (for monitor mode) */
+
+	enum islsm_versions     device_version;
+	/* signalled when particular states in the configuration have
+	   been reached : init interrupt, then mgmt readback end */
+	struct completion       dev_init_comp;
+	int                     wait_flag;
+
+	struct sm_p             smpar;
+	short                   soft_rxfilter;
+	u8                      filter_rateset[8];
+
+	/*
+	 * Parameters and data set by parsing of the EEPROM contents
+	 */
+
+	/* number of rates defined in the readback */
+	uint8_t                 pa_points_per_curve;
+
+	uint8_t                *eeprom;
+	size_t                  eeprom_size;
+	size_t                  pda_offset;
+	size_t                  pda_length;
+	/* FIXME : these arrays are *huge* (255 elements) -- we should
+	 * get rid of them */
+#ifdef MADWIFI
+	struct wlan_pda_output_limits_channel_rev0_s output_pwr_limits[IEEE80211_CHAN_MAX];
+	struct fw_cal_data_sample finfo4[IEEE80211_CHAN_MAX][ISLSM_POINTS_PER_CURVE];
+	struct wlan_pda_iq_autocal_s    finfo6[IEEE80211_CHAN_MAX];
+#else				/* MADWIFI */
+	struct wlan_pda_output_limits_channel_rev0_s output_pwr_limits[ISLSM_NR_CHANNELS + 1];
+	struct fw_cal_data_sample finfo4[ISLSM_NR_CHANNELS + 1][ISLSM_POINTS_PER_CURVE];
+	struct wlan_pda_iq_autocal_s    finfo6[ISLSM_NR_CHANNELS + 1];
+#endif
+	unsigned int		last_chan;
+
+#ifdef MADWIFI
+	struct ieee80211com     sc_ic;
+	struct ieee80211_beacon_offsets islsm_boff;
+	int                     (*ieee80211_newstate) (struct ieee80211com *,
+						       enum ieee80211_state,
+						       int);
+	struct timer_list       scan_ch;	/* AP scan timer */
+#endif				/* MADWIFI */
+
+/* 	struct timer_list       stats_update; */
+	struct net_device_stats statistics;
+#ifdef CONFIG_NET_WIRELESS
+	struct iw_statistics    iwstatistics;
+#endif				/* CONFIG_NET_WIRELESS */
+
+	/* device-specific state machine and callbacks
+	   We handle three types of devices :
+	   - usb first generation
+	   - usb second generation
+	   - pci devices
+	   These hooks are in no mean set in stone; they are here for
+	   experimentation and will give way to a cleaner approach once
+	   we have a general picture of how things work.
+	 */
+
+	/* boots the device */
+	int                     (*isl_boot) (struct net_device *);
+	int                     (*isl_stop) (struct net_device *);
+	/* transmits the data in the skb to the lmac */
+	islsm_tx_t              isl_tx;
+
+	/* device operations */
+	int                     (*isl_romboot) (struct islsm *);
+	int                     (*isl_load_fw) (struct islsm *,
+						const struct firmware *);
+
+	/* uart structure and callbacks */
+#ifdef PCIUART
+	uart_instance_t         uart;
+	void                    (*uart_prot_init) (struct islsm *);
+	void                    (*uart_cts) (struct islsm *);
+	void                    (*uart_prot_exit) (struct islsm *);
+#endif				/* PCIUART */
+
+	/* low-level stuff */
+	/* read and write from the pci side */
+	uint32_t                (*isl_read_pcireg) (struct islsm *,
+						    uint32_t address);
+	void                    (*isl_write_pcireg) (struct islsm *,
+						     uint32_t value,
+						     uint32_t address);
+	uint32_t                (*isl_read_devmem) (struct islsm *,
+						    uint32_t address);
+	void                    (*isl_write_devmem) (struct islsm *,
+						     uint32_t value,
+						     uint32_t address);
+
+	/*
+	 * It should not be needed as we can fetch it with an offsetof
+	 * macro. But this is safer in case allocations ever get out-of-line.
+	 */
+	struct net_device      *netdev;
+#ifndef MADWIFI
+	struct ieee80211_device *ieee;
+	struct ieee80211softmac_device *softmac;
+#endif
+
+	/* This is the structure below us, filled with p54u or islpci
+	 * device reference */
+	/* This must be the last item so that it points to the data
+	 * allocated beyond this structure by alloc_islsm */
+	u8 priv[];
+};
+
+/*
+ * These functions are modelled after the netdev and ieee80211 ones.
+ * The train of structs for softmac:
+ *  [netdev][ieee80211][ieee80211softmac][islsm][p54u]
+ */
+
+#ifdef MADWIFI
+#define NETDEV_OF_ISLSM(device) ((device)->netdev)
+#define ISLSM_OF_NETDEV(device) ((struct islsm *) netdev_priv(device))
+#define SET_NETDEV(device,netdevice)  ((device)->netdev = (netdevice))
+extern inline void *islsm_priv(struct net_device *dev) {
+	return ((struct islsm *)netdev_priv(dev))->priv;
+}
+
+#else
+#define NETDEV_OF_ISLSM(device) ((device)->netdev)
+#define ISLSM_OF_NETDEV(device) ((struct islsm *) ieee80211softmac_priv(device))
+static inline void *islsm_priv(struct net_device *dev) {
+	return ((struct islsm *)ieee80211softmac_priv(dev))->priv;
+}
+
+#endif /* MADWIFI */
+
+/*
+ * Control block used by islsm
+ */
+struct islsm_cb {
+	struct islsm_alloc_cb alloc;
+};
+
+struct net_device *alloc_islsm(int sizeof_priv);
+void free_islsm(struct net_device *dev);
+int register_islsm(struct net_device *netdev);
+void unregister_islsm(struct net_device *netdev);
+
+int islsm_mode_set_filter(struct net_device *netdev, int mode);
+
+extern int              islsm_wait_timeout(struct islsm *islsm,
+					   unsigned int delay);
+
+/* now the helper functions, for sending packets */
+int                     islsm_outofband_msg(struct islsm *islsm,
+					    void *buf, size_t size);
+
+int                     islsm_stats_readback(struct islsm *islsm);
+
+void                    islsm_make_control_led(struct islsm *islsm,
+					       char *buf, uint16_t mode,
+					       uint16_t perm_setting,
+					       uint16_t temp_setting,
+					       uint16_t duration);
+
+void                    islsm_make_freequeue(struct islsm *islsm,
+					     char *buf, uint8_t queue_id);
+
+int                     islsm_set_filter(struct islsm *islsm,
+					 uint16_t filter_type,
+					 const uint8_t *bssid, uint16_t magic2,
+					 uint32_t magic3, uint16_t magic8,
+					 uint16_t magic9);
+
+int                     islsm_freq_change(struct islsm *islsm,
+					  uint16_t channel, uint16_t freq,
+					  uint16_t magic1, uint16_t magic2);
+
+int                     islsm_data_tx(struct islsm *islsm, struct sm_tx_p *txp,
+				      struct sk_buff *skb);
+
+int                     islsm_eeprom_readback(struct islsm *islsm);
+
+int                     islsm_led_perm(struct islsm *islsm,
+				       uint16_t mode, uint16_t perm_setting);
+int                     islsm_led_temp(struct islsm *islsm,
+				       uint16_t temp_setting, unsigned ms);
+
+int                     islsm_ping_device(struct islsm *islsm, unsigned length);
+
+/* now the helper functions, for receiving packets */
+void                    islsm_data_input(struct sk_buff *skb);
+void                    islsm_bootup_input(struct sk_buff *skb);
+int                     islsm_parse_eeprom(struct islsm *islsm);
+
+int                     islsm_request_firmware(const struct firmware **fw,
+					       struct islsm *device);
+
+/* protocol settings */
+void                    islsm_params_init(struct islsm *islsm);
+
+/* helper function to get rid of -- replace with a standard one from one
+ * of the stacks */
+static inline unsigned int
+islsm_ref_to_chan(unsigned int ref)
+{
+	/* FIXME : only works for the B/G band, we now need it for the A
+	   band */
+#ifdef MADWIFI
+	return ieee80211_mhz2ieee(ref, IEEE80211_CHAN_2GHZ);
+#else
+	/* kludgy as hell */
+	unsigned int out;
+#define ISLSM_REF_CHAN0 0x0967
+	if (ref <= ISLSM_REF_CHAN0) {
+		printk(KERN_ERR
+		       "%s: Problem requesting channel of ref %i : too small\n",
+		       "islsm", ref);
+		return 0;
+	}
+	out = (ref - ISLSM_REF_CHAN0) / 5;
+	if (out > 14) {
+		if (ref == 2484)
+			return 14;
+		printk(KERN_ERR
+		       "%s: Problem requesting channel of ref %i : "
+		       "channel %i too big\n", "islsm", ref, out);
+		return 0;
+	}
+	return out;
+#undef ISLSM_REF_CHAN0
+#endif				/* MADWIFI */
+}
+
+int			islsm_chan_to_freq(unsigned int chan);
+unsigned int		islsm_freq_to_chan(int freq);
+
+/* Helper function for the hardware stacks, to be used to free a
+   TX skb successfully transmitted to the umac */
+static inline void
+islsm_txskb_free(struct sk_buff *skb) {
+	struct net_device *netdev = skb->dev;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	uint32_t lmac_addr = LMAC_ADDR_OF_SKB(skb);
+	unsigned flags = LMAC_ALLOC_FLAGS(skb);
+
+	if (flags & ISLSM_ALLOC_FREE_WHEN_SUBMITTED)
+		islsm_free(&islsm->memory, lmac_addr);
+
+	dev_kfree_skb_irq(skb);
+}
+
+#endif				/* _HAVE_ISL_SM_H_ */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_input.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_input.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_input.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_input.c	2007-04-12 16:57:03.000000000 +0200
@@ -0,0 +1,636 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include "isl_sm.h"
+#include "islsm_protocol.h"
+
+#include <linux/netdevice.h>
+
+#ifdef MADWIFI
+#include <linux/version.h>
+#include "net80211/if_media.h"
+#include "net80211/ieee80211_var.h"
+#include "wlan-monitor.h"
+#else
+#include <linux/etherdevice.h>
+#endif				/* MADWIFI */
+
+#include "islsm_log.h"
+
+#ifdef MADWIFI
+#define DRV_NAME "islsm"
+#else
+#include "islusb_dev.h"
+#endif
+
+static int islsm_input_lm87(struct sk_buff *skb);
+#ifndef MADWIFI
+static void islsm_to_stats(struct ieee80211_rx_stats *st,
+    struct islsm_rx_packet_header *data_head, int len);
+#endif
+static void islsm_input_fault(struct sk_buff *skb);
+
+#define N_KNOWN_RATES 12	/* Actually MAX_RATES_LENGTH, but firmware's. */
+static unsigned char islsm_rate_table[N_KNOWN_RATES] = {
+	IEEE80211_CCK_RATE_1MB,
+	IEEE80211_CCK_RATE_2MB,
+	IEEE80211_CCK_RATE_5MB,
+	IEEE80211_CCK_RATE_11MB,
+	IEEE80211_OFDM_RATE_6MB,
+	IEEE80211_OFDM_RATE_9MB,
+	IEEE80211_OFDM_RATE_12MB,
+	IEEE80211_OFDM_RATE_18MB,
+	IEEE80211_OFDM_RATE_24MB,
+	IEEE80211_OFDM_RATE_36MB,
+	IEEE80211_OFDM_RATE_48MB,
+	IEEE80211_OFDM_RATE_54MB,
+};
+
+/*
+ * Data packet input functions
+ */
+
+#ifdef MADWIFI
+# define ISLSM_IS_MODE_MONITOR(islsm) \
+	((islsm)->sc_ic.ic_opmode == IEEE80211_M_MONITOR)
+#else
+# define ISLSM_IS_MODE_MONITOR(islsm) \
+	((islsm)->ieee->iw_mode == IW_MODE_MONITOR)
+#endif
+
+static void
+input_data_frame(struct sk_buff *skb)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct islsm_rx_packet_header *data_head =
+	    (struct islsm_rx_packet_header *) (skb->data);
+	unsigned int trim_length;
+#ifdef MADWIFI
+	struct ieee80211com *ic = &islsm->sc_ic;
+	struct ieee80211_node *ni;
+#else
+	struct ieee80211_rx_stats stats;	/* XXX On stack?! */
+	struct ieee80211_hdr_3addr *hdr3;
+	struct ieee80211_hdr_4addr *hdr4;
+	unsigned short frame_ctl;
+#endif				/* MADWIFI */
+	/* we keep this information and put it in the avc header,
+	   where it will be meaningless, but there we'll be able
+	   to see it in ethereal */
+	uint16_t magic1;
+	uint16_t unknown1;
+	uint16_t unknown2;
+
+	FN_ENTER;
+
+	magic1 = le16_to_cpu(((struct islsm_id *) (skb->data))->magic1);
+	unknown1 = le16_to_cpu(data_head->unknown1);
+	unknown2 = le16_to_cpu(data_head->unknown2);
+
+	/* problem : I don't know how to report the FCS in monitor
+	 * mode ! */
+	trim_length = le16_to_cpu(((struct islsm_id *) skb->data)->length);
+	skb_pull(skb, SIZE_RX_HEADER);
+	skb_trim(skb, trim_length);
+	/* strip FCS. Needed for madwifi. How to deal with it in
+	 * monitor mode ? */
+	skb_trim(skb, skb->len - 4);
+
+	/* catch monitor mode */
+	if (ISLSM_IS_MODE_MONITOR(islsm)) {
+#ifdef MADWIFI
+#if 1
+		struct avs_80211_1_header *avs;
+		/* time scale is at 1MHZ. maybe there's a fractional part */
+		u64 clock = le64_to_cpu(data_head->timestamp);
+		uint16_t freq = le16_to_cpu(data_head->freq);
+		uint8_t rssi = data_head->signal_strength;
+		uint8_t rate = data_head->rate;
+		short rxfilter = islsm->soft_rxfilter;
+		int err;
+
+		/*
+		 * Drop bad FCS packets according to rxfilter
+		 * parameter. Per-device parameter via sysfs ?
+		 */
+		if (rxfilter && !(magic1 & rxfilter)) {
+			islog(L_SM_INPUT, "dropped skb unfit for rxfilter\n");
+			dev_kfree_skb(skb);
+			FN_EXIT0;
+			return;
+		}
+
+		/* FIXME: ideally, the rx skbs allocated will have this
+		 * headroom built-in and reallocation will be
+		 * unnecessary */
+		err = skb_cow(skb, sizeof(struct avs_80211_1_header));
+		if (err) {
+			islog(L_SM_INPUT, "dropped skb in monitor mode\n");
+			dev_kfree_skb(skb);
+			FN_EXIT0;
+			return;
+		}
+
+		/* make room for the new header and fill it. */
+		avs = (void *) skb_push(skb, sizeof (struct avs_80211_1_header));
+
+		avs->version = cpu_to_be32(P80211CAPTURE_VERSION);
+		avs->length = cpu_to_be32(sizeof (struct avs_80211_1_header));
+		avs->mactime = cpu_to_be64((u64) clock);
+		avs->hosttime = cpu_to_be64(jiffies);
+		avs->phytype = cpu_to_be32(6);	/* OFDM: 6 for (g), 8 for (a) */
+		avs->channel = cpu_to_be32(islsm_ref_to_chan(freq));
+		avs->datarate = cpu_to_be32(islsm_rate_table[rate % 12] * 5);	/* units = hundreds of kbits/s. Convert to this. */
+		/* Warning : those are given a bogus meaning for the time being ! */
+		avs->antenna = cpu_to_be32((uint32_t) unknown2);	/* unknown */
+		avs->priority = cpu_to_be32((uint32_t) magic1);	/* unknown */
+		avs->ssi_type = cpu_to_be32(3);	/* 2: dBm, 3: raw RSSI */
+		avs->ssi_signal = cpu_to_be32(rssi);	/* why put & 0x7f here ? what does the upper bit mean in original prism54 code ? */
+		avs->ssi_noise = cpu_to_be32(0);
+		avs->preamble = cpu_to_be32(0);	/*unknown */
+		avs->encoding = cpu_to_be32(0);	/*unknown */
+#endif				/* 1 */
+		skb->dev = netdev;
+		skb->protocol = htons(ETH_P_80211_RAW);
+		skb->mac.raw = skb->data;
+		skb->pkt_type = PACKET_OTHERHOST;
+		skb->ip_summed = CHECKSUM_NONE;
+
+		netif_rx(skb);
+#else
+		islsm_to_stats(&stats, data_head, skb->len);
+		if (!ieee80211_rx(islsm->ieee, skb, &stats))
+			dev_kfree_skb(skb);
+#endif /* MADWIFI */
+		FN_EXIT0;
+		return;
+	}
+
+	/*
+	 * print magic ; Remove packets with bad FCS
+	 */
+	islog(L_SM_INPUT, "receive packet with "
+	      "magic %i, unknown1 %i, unknown2 %i\n", magic1, unknown1,
+	      unknown2);
+	if (!(magic1 & ISLSM_ID_FCS_OK)) {
+		islog(L_SM_INPUT, "packet with bad FCS\n");
+		/* should be dropped. For now, we keep it, as long as
+		   we're not sure */
+	}
+#ifdef MADWIFI
+#define	IS_CTL(wh) \
+	((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL)
+	/*
+	 * From this point on we assume the frame is at least
+	 * as large as ieee80211_frame_min; verify that.
+	 */
+	if (skb->len < IEEE80211_MIN_LEN) {
+		islog(L_DEBUG, "short packet %d\n", skb->len);
+		dev_kfree_skb(skb);
+		return;
+	}
+
+	skb->protocol = ETH_P_CONTROL;	/* XXX */
+
+	/*
+	 * Locate the node for sender, track state, and then
+	 * pass the (referenced) node up to the 802.11 layer
+	 * for its use.
+	 * TODO : use a cache.
+	 * TODO : test ad-hoc / master mode with this.
+	 */
+
+	ni = ieee80211_find_rxnode(ic,
+				   (struct ieee80211_frame_min *) skb->data);
+
+	/*
+	 * Track rx rssi and do any rx antenna management.
+	 */
+
+	/*
+	 * Send frame up for processing.
+	 */
+
+	ieee80211_input(ic, skb, ni,
+			data_head->signal_strength,
+			(u32) le64_to_cpu(data_head->timestamp));
+
+	/*
+	 * Reclaim node reference.
+	 */
+	ieee80211_free_node(ni);
+
+#undef IS_CTL
+#else				/* MADWIFI */
+
+	if (skb->len < IEEE80211_HLEN) {
+		dev_kfree_skb(skb);
+		goto drop;
+	}
+
+	/* XXX Drop all this garbage and use ieee80211_rx_any when it's fixed */
+
+	switch (islsm->ieee->iw_mode) {
+	case IW_MODE_ADHOC:
+		hdr3 = (struct ieee80211_hdr_3addr *) skb->data;
+
+		frame_ctl = le16_to_cpu(hdr3->frame_ctl);
+		if (WLAN_FC_GET_TYPE(frame_ctl) == IEEE80211_FTYPE_MGMT) {
+			islsm_to_stats(&stats, data_head, skb->len);
+			hdr4 = (struct ieee80211_hdr_4addr *)skb->data;
+			ieee80211_rx_mgt(islsm->ieee, hdr4, &stats);
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+
+		if (WLAN_FC_GET_TYPE(frame_ctl) != IEEE80211_FTYPE_DATA) {
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+
+		if (compare_ether_addr(hdr3->addr3, islsm->ieee->bssid) != 0) {
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+
+		if (compare_ether_addr(hdr3->addr1, netdev->dev_addr) != 0 &&
+		    !is_broadcast_ether_addr(hdr3->addr1) &&
+		    !is_multicast_ether_addr(hdr3->addr1))
+		{
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+
+		islsm_to_stats(&stats, data_head, skb->len);
+		if (!ieee80211_rx(islsm->ieee, skb, &stats)) {
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+		break;
+
+	default:
+		hdr4 = (struct ieee80211_hdr_4addr *) skb->data;
+		frame_ctl = le16_to_cpu(hdr4->frame_ctl);
+		if (WLAN_FC_GET_TYPE(frame_ctl) == IEEE80211_FTYPE_MGMT) {
+			islsm_to_stats(&stats, data_head, skb->len);
+			ieee80211_rx_mgt(islsm->ieee, hdr4, &stats);
+			dev_kfree_skb(skb);
+			goto drop;
+		}
+
+		dev_kfree_skb(skb);
+	}
+
+ drop: /* go here for FN_EXIT0 */
+#endif				/* MADWIFI */
+	FN_EXIT0;
+	return;
+}
+
+static void islsm_input_stats(struct sk_buff *skb)
+{
+#if ISL_DEBUG
+	struct islsm_control_stats *stats = (void *) skb->data;
+	islog
+	    (L_SM_INPUT,
+	     "stats report : rx_pkt %i, %i, %i, %i, %i, %i, time %lli, %i, noise %i\n",
+	     le32_to_cpu(stats->rx_pkt), le32_to_cpu(stats->stat1),
+	     le32_to_cpu(stats->stat2), le32_to_cpu(stats->stat3),
+	     le32_to_cpu(stats->stat4), le32_to_cpu(stats->stat5),
+	     le64_to_cpu(stats->timestamp), le32_to_cpu(stats->stat6),
+	     le32_to_cpu(stats->noise));
+#endif /* ISL_DEBUG */
+	dev_kfree_skb(skb);
+	return;
+}
+
+#ifndef MADWIFI
+static void
+islsm_to_stats(struct ieee80211_rx_stats *st,
+    struct islsm_rx_packet_header *data_head, int len)
+{
+	unsigned short freq = le16_to_cpu(data_head->freq);
+	unsigned int rate = data_head->rate;
+
+	memset(st, 0, sizeof(struct ieee80211_rx_stats));
+	st->mac_time = le64_to_cpu(data_head->timestamp);
+	st->rssi = data_head->signal_strength;
+	/* FIXME: use the rate table provided by the firmware */
+	if (rate < 12)
+		st->rate = islsm_rate_table[rate];
+	st->received_channel = islsm_ref_to_chan(freq);
+	st->mask =
+	    IEEE80211_STATMASK_SIGNAL |
+	    IEEE80211_STATMASK_RSSI |
+	    IEEE80211_STATMASK_RATE;
+	st->freq = IEEE80211_24GHZ_BAND;
+	st->len = len;
+}
+#endif /* MADWIFI */
+
+static
+    void
+islsm_input_txack(struct sk_buff *skb, uint32_t lmac_addr)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+
+	if (isl_debug & L_SM_INPUT) {
+		struct islsm_control_queueemptied *free = (void *) skb->data;
+		islog(L_SM_INPUT,
+		      "tx ack : status %x, ack strength %x, sequence %04x, %x\n",
+		      free->status, le16_to_cpu(free->ack_strength),
+		      free->sequence, free->unknown);
+	}
+
+	/* if ok, then free. This should be conditioned by something
+	   (some flags) to avoid the double-free problems */
+	islsm_free(&islsm->memory, lmac_addr);
+	dev_kfree_skb(skb);
+	return;
+}
+
+static void islsm_input_freqdone(struct sk_buff *skb)
+{
+#if ISL_DEBUG
+	struct islsm_control_freqchange *freq =
+	    (struct islsm_control_freqchange *) skb->data;
+	islog(L_SM_INPUT, "frequency sucessfully set to %i MHz\n",
+	      le16_to_cpu(freq->frequency));
+#endif /* ISL_DEBUG */
+	dev_kfree_skb(skb);
+}
+
+/* first pass only copies the buffer */
+static void input_eeprom_frame(struct sk_buff *skb)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	union islsm_control_eeprom *txe = (void *) skb->data;
+	const char *data;
+	unsigned offset;
+	unsigned length;
+
+	if (islsm->fw_type == ISLSM_FW_LM86) {
+		offset = le16_to_cpu(txe->lm86.offset);
+		length = le16_to_cpu(txe->lm86.len);
+		data   = txe->lm86.data;
+	} else {
+		offset = le32_to_cpu(txe->lm87.address);
+		length = le16_to_cpu(txe->lm87.len);
+		data   = txe->lm87.data;
+	}
+
+	if (offset + length > islsm->eeprom_size)
+		printk(KERN_WARNING DRV_NAME ": eeprom data"
+		       "beyond allocated memory\n");
+	else
+		memcpy(&islsm->eeprom[offset], data, length);
+
+	/* signal we saw this frame */
+	complete(&islsm->dev_init_comp);
+
+	dev_kfree_skb(skb);
+	return;
+}
+
+/* second level input function (along with data_input at top) */
+
+static void
+islsm_input_islheader(struct sk_buff *skb)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct islsm_tx_control *rx = (void *) skb->data;
+	unsigned int trim_length = le16_to_cpu(rx->id.length);
+	unsigned int type = le16_to_cpu(rx->type);
+	uint16_t flags = le16_to_cpu(rx->id.magic1);
+	uint32_t lmac_addr = rx->req_id;
+
+	skb_pull(skb, SIZE_TX_CONTROL);
+	skb_trim(skb, trim_length);
+
+	/* free the associated frame in out image of the lmac memory
+	   map. Normally free only if bit IC_FREE is *not* set (meaning
+	   that we did not set it).
+	 */
+	if (!(flags & ISLSM_IC_FLAG_FREE))
+		islsm_free(&islsm->memory, lmac_addr);
+
+	switch (type) {
+	case ISLSM_TX_CONTROL_TYPE_FREQDONE:
+		islsm_input_freqdone(skb);
+		break;
+	case ISLSM_TX_CONTROL_TYPE_TXDONE:
+		islsm_input_txack(skb, lmac_addr);
+		break;
+	case ISLSM_TX_CONTROL_TYPE_STAT_READBACK:
+		islsm_input_stats(skb);
+		break;
+	case ISLSM_TX_CONTROL_TYPE_EEPROM_READBACK:
+		input_eeprom_frame(skb);
+		break;
+	default:
+		printk(KERN_CRIT "unknown control packet "
+		       "length %i, req_id %08x, type %04x\n",
+		       le16_to_cpu(rx->id.length), rx->req_id, type);
+		isl_dump_bytes(skb->data, skb->len);
+		/* signal something went wrong */
+		dev_kfree_skb(skb);
+	}
+
+	return;
+}
+
+/*
+ * first level input function, dispatches on id
+ */
+
+void
+islsm_data_input(struct sk_buff *skb)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	unsigned length = skb->len;
+	unsigned int magic1;
+
+	/* TODO: get the queue information from the skb cb -- there are
+	   usually two queues, control and bulk data */
+	islsm_rxdata_debug(0, skb->data, length);
+
+	if (length == 0) {
+		islog(L_DEBUG, "data_input : null packet\n");
+		goto error;
+	}
+
+	/* switch on firmware type */
+	switch (islsm->fw_type) {
+	case ISLSM_FW_LM87:
+		if (islsm_input_lm87(skb))
+			goto error;
+		break;
+	default:
+		break;
+	};
+
+	/* FIXME : is this still necessary ? */
+	skb->dev = netdev;
+
+	magic1 = le16_to_cpu(((struct islsm_id *) (skb->data))->magic1);
+
+	islog(L_SM_INPUT, "islsm input packet magic %x\n", magic1);
+	/* actually i should just check on an and with 0x8000, but until
+	 * the fields are known, i'd rather not to... */
+	switch (magic1 & ISLSM_ID_MASK) {
+	case ISLSM_ID_DATA_PKT:
+	case ISLSM_ID_MGMT_PKT:
+		input_data_frame(skb);
+		return;
+
+	case ISLSM_ID_EEPROM_READBACK:
+		islsm_input_islheader(skb);
+		return;
+
+	case ISLSM_ID_FAULT:
+		islsm_input_fault(skb);
+		return;
+
+	default:
+		islog(L_SM_INPUT, "unknown magic1 %i packet\n",
+		      magic1);
+	};
+
+ error:
+	isl_dump_bytes(skb->data, skb->len);
+	dev_kfree_skb(skb);
+	return;
+}
+
+EXPORT_SYMBOL(islsm_data_input);
+
+/*
+ * lm87 frame input
+ */
+
+static int
+islsm_input_lm87(struct sk_buff *skb)
+{
+	islsm_lm87_hdr_t *hdr = (void *)skb->data;
+	u32 crc, computed_crc;
+
+	if (skb->len < 4) {
+		printk(KERN_WARNING "Short frame received\n");
+		return -EIO;
+	}
+
+	crc = le32_to_cpu(hdr->checksum);
+	skb_pull(skb, sizeof(hdr->checksum));
+
+	computed_crc = islsm_crc((u32*)skb->data, skb->len);
+
+	if (computed_crc != crc) {
+		printk(KERN_WARNING "Invalid CRC for rx frame\n");
+		return -EIO;
+	};
+
+	return 0;
+}
+
+static
+    void
+islsm_input_fault(struct sk_buff *skb)
+{
+	printk(KERN_CRIT "ROM abort, need to implement reacting on this\n");
+	/* initiate shutdown/restart of the device */
+	return;
+}
+
+void islsm_bootup_input(struct sk_buff *skb)
+{
+	struct net_device *netdev = __dev_get_by_index(skb->iif);
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	char *buffer = (char *) skb->data;
+	unsigned length = skb->len;
+
+	/* don't do anything fancy for now */
+	islsm_rxdata_debug(0, buffer, length);
+
+	/* When receiving g, we're done !
+	 * Maybe we should split the receive OK / send go / receive g process
+	 * Someone tests this ?
+	 */
+	if (length >= 5 && !strncmp(buffer, "ERROR", 5)) {
+		printk(KERN_ERR "FW Upload not successful: (%.*s)\n",
+		       length, buffer);
+	} else if (length >= 2 && !strncmp(buffer, "OK", 2)) {
+		islog(L_DEBUG, "FW Upload successful: (%.*s)\n",
+		      length, buffer);
+		complete(&islsm->dev_init_comp);
+	} else if (length >= 1 && !strncmp(buffer, "g", 1)) {
+		islog(L_DEBUG, "FW boot successful: (%.*s)\n",
+		      length, buffer);
+		complete(&islsm->dev_init_comp);
+	}
+	dev_kfree_skb(skb);
+	return;
+}
+
+EXPORT_SYMBOL(islsm_bootup_input);
+
+/*
+ * Frame timeout management
+ */
+
+/* the timeout value must take into account the buffer preparation time
+ * and usb transmit time. And maybe the multi-rate retry mechanism.
+ * Safe value should be around 512ms */
+static void __attribute__ ((unused))
+islsm_ack_timeout(unsigned long data)
+{
+#if ISL_DEBUG
+	uint32_t frame_addr = data;
+	islog(L_SM_INPUT, "ack timeout happened for frame %x\n", frame_addr);
+#endif /* ISL_DEBUG */
+	/* this needs more reverse-engeneering and a change in semantics
+	   WRT the  empty_queue function, which really is a status
+	   inquiry */
+	/* Ask for a status of the frame */
+/* 	(void) islsm_empty_queue(txq->netdev,txq->usb_id); */
+/* 	do nothing, just reuse it */
+
+/* 	(void) islsm_txqueue_free(txq->netdev, txq->usb_id); */
+
+	/* let's hope the sending is successfull, otherwise the
+	   frame won't be freed */
+	return;
+}
+
+static inline int
+islsm_frame_timer(uint32_t frame_addr)
+{
+/* 	struct timer_list *tx_timer = &txq->tx_timer; */
+/* 	tx_timer->expires = jiffies + ISLSM_ACK_TIMEOUT; */
+/* 	tx_timer->data = (unsigned long) frame_addr; */
+/* 	tx_timer->function = islsm_ack_timeout; */
+/* 	add_timer(tx_timer); */
+	return 0;
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_ioctl.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_ioctl.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_ioctl.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,612 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+  Copyright(c) 2003 - 2005 Intel Corporation. All rights reserved.
+  Copyright (c) 2006 Red Hat, Inc.
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/wireless.h>
+#include <linux/netdevice.h>	/* needed by iw_handler */
+#include <linux/if_arp.h>
+#include <net/iw_handler.h>
+
+#include "islsm_ioctl.h"
+#include "isl_sm.h"
+#include "islsm_log.h"
+
+#ifdef MADWIFI
+#include "linux/version.h"
+#include "net80211/ieee80211_linux.h"
+#else
+#include <linux/etherdevice.h>
+#include <net/ieee80211softmac_wx.h>
+#endif				/* MADWIFI */
+
+/*
+ * private ioctl to allow experimentation
+ */
+
+#ifndef MADWIFI
+#define MAX_PKT_LEN 200
+
+static int
+islsm_ioctl_sendannouncedpkt(struct net_device *netdev,
+    struct iw_request_info *unused, union iwreq_data *u, char *extra)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	char *data;
+	size_t pktsize;
+	int err = 0;
+
+	FN_ENTER;
+
+	if (u == 0) {
+		err = -ENOTSUPP;
+		goto exit;
+	}
+
+	pktsize = u->data.length;
+
+	if (pktsize > MAX_PKT_LEN) {
+		err = -ENOTSUPP;
+		goto exit;
+	}
+
+	data = u->data.pointer;
+
+	/* note : this does not work with second-generation devices */
+	islsm_outofband_msg(islsm, data, pktsize);
+      exit:
+	FN_EXIT1(err);
+	return err;
+}
+#endif				/* MADWIFI */
+
+/* add ioctls to change the verbosity of the driver */
+
+#define SUPPORTED_WIRELESS_EXT                  16
+
+#ifdef CONFIG_NET_WIRELESS
+
+#ifndef MADWIFI
+
+/**** WARNING *****/
+/* _ALL_ of these calls are bogus except for set_channel_freq */
+/* I expect to complete statistics soon enough */
+
+struct iw_statistics *islsm_wireless_stats(struct net_device *ndev)
+{
+	struct islsm *priv = ISLSM_OF_NETDEV(ndev);
+
+	/* completely bogus */
+	return &priv->iwstatistics;
+}
+
+static int
+prism54_commit(struct net_device *ndev, struct iw_request_info *info,
+    union iwreq_data *wrqu, char *extra)
+{
+	return 0;
+}
+
+static int
+prism54_get_name(struct net_device *ndev, struct iw_request_info *info,
+    union iwreq_data *data, char *extra)
+{
+	char *capabilities;
+
+	capabilities = "IEEE 802.11b";		/* Default. Add 'a' later. */
+
+	strncpy(data->name, capabilities, IFNAMSIZ);
+	return 0;
+}
+
+static int
+prism54_set_freq(struct net_device *netdev, struct iw_request_info *info,
+		 union iwreq_data *data, char *extra)
+{
+	struct iw_freq *fwrq = &data->freq;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	unsigned int c;
+
+	if (fwrq->m < 1000 && fwrq->m >= 1 && fwrq->m <= ISLSM_NR_CHANNELS) {
+		/* we have a valid channel number */
+		c = fwrq->m;
+	} else {
+		if (fwrq->m <= 0)
+			return -EINVAL;
+		c = islsm_freq_to_chan(fwrq->m);
+		if (c == 0 || c > ISLSM_NR_CHANNELS)
+			return -EINVAL;
+	}
+
+	/* XXX Semaphore here */
+	islsm_freq_change(islsm,
+			  c, islsm_chan_to_freq(c),
+			  ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN,
+			  ISLSM_TX_CONTROL_CHANNEL_MAGIC2_SCAN);
+	islsm->last_chan = c;
+	return 0;
+}
+
+static int prism54_get_freq(struct net_device *netdev,
+   struct iw_request_info *info, union iwreq_data *data, char *extra)
+{
+	struct iw_freq *fwrq = &data->freq;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+
+	memset(fwrq, 0, sizeof(struct iw_freq));
+	fwrq->m = islsm->last_chan;
+	fwrq->e = 0;
+	fwrq->flags = 1;	/* It was a fixed setting */
+	return 0;
+}
+
+static int
+prism54_set_mode(struct net_device *ndev, struct iw_request_info *info,
+		 union iwreq_data *data, char *extra)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(ndev);
+	int mode = data->mode;
+	int err = 0;
+
+	/* XXX Locking */
+	switch (mode) {
+	case IW_MODE_MONITOR:
+		islsm->ieee->iw_mode = mode;
+		ndev->type = ARPHRD_IEEE80211;
+		break;
+
+	case IW_MODE_ADHOC:
+	case IW_MODE_INFRA:
+	/* case IW_MODE_MASTER: */ /* XXX support AP mode */
+		islsm->ieee->iw_mode = mode;
+		ndev->type = ARPHRD_ETHER;
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	if (ndev->flags & IFF_RUNNING) {
+		err = islsm_mode_set_filter(ndev, mode);
+		if (err)
+			printk(KERN_WARNING "error setting filter : %i", err);
+	}
+
+	return 0;
+}
+
+static int
+prism54_get_mode(struct net_device *ndev, struct iw_request_info *info,
+		 union iwreq_data *data, char *extra)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(ndev);
+	unsigned long flags;
+
+	spin_lock_irqsave(&islsm->ieee->lock, flags);
+	data->mode = islsm->ieee->iw_mode;
+	spin_unlock_irqrestore(&islsm->ieee->lock, flags);
+	return 0;
+}
+
+/* we use DOT11_OID_EDTHRESHOLD. From what I guess the card will not try to
+ * emit data if (sensitivity > rssi - noise) (in dBm).
+ * prism54_set_sens does not seem to work.
+ */
+
+static int
+prism54_set_sens(struct net_device *ndev, struct iw_request_info *info,
+		 struct iw_param *vwrq, char *extra)
+{
+/* 	islpci_private *priv = ISLSM_OF_NETDEV(ndev); */
+/* 	u32 sens; */
+
+/* 	/\* by default  the card sets this to 20. *\/ */
+/* 	sens = vwrq->disabled ? 20 : vwrq->value; */
+
+/* 	return mgt_set_request(priv, DOT11_OID_EDTHRESHOLD, 0, &sens); */
+	return 0;
+}
+
+static int
+prism54_get_sens(struct net_device *ndev, struct iw_request_info *info,
+		 struct iw_param *vwrq, char *extra)
+{
+/* 	islpci_private *priv = ISLSM_OF_NETDEV(ndev); */
+/* 	union oid_res_t r; */
+/* 	int rvalue; */
+
+/* 	rvalue = mgt_get_request(priv, DOT11_OID_EDTHRESHOLD, 0, NULL, &r); */
+
+	vwrq->value = 0;
+	vwrq->disabled = (vwrq->value == 0);
+	vwrq->fixed = 1;
+
+	return 0;
+}
+
+static int
+prism54_get_range(struct net_device *ndev, struct iw_request_info *info,
+		  struct iw_point *dwrq, char *extra)
+{
+	struct iw_range *range = (struct iw_range *) extra;
+
+	memset(range, 0, sizeof (struct iw_range));
+	dwrq->length = sizeof (struct iw_range);
+
+	/* set the wireless extension version number */
+	range->we_version_source = SUPPORTED_WIRELESS_EXT;
+	range->we_version_compiled = WIRELESS_EXT;
+
+	/* Now the encoding capabilities */
+	range->num_encoding_sizes = 3;
+	/* 64(40) bits WEP */
+	range->encoding_size[0] = 5;
+	/* 128(104) bits WEP */
+	range->encoding_size[1] = 13;
+	/* 256 bits for WPA-PSK */
+	range->encoding_size[2] = 32;
+	/* 4 keys are allowed */
+	range->max_encoding_tokens = 4;
+
+	/* we don't know the quality range... */
+	range->max_qual.level = 0;
+	range->max_qual.noise = 0;
+	range->max_qual.qual = 0;
+	/* these value describe an average quality. Needs more tweaking... */
+	range->avg_qual.level = -80;	/* -80 dBm */
+	range->avg_qual.noise = 0;	/* don't know what to put here */
+	range->avg_qual.qual = 0;
+
+	range->sensitivity = 200;
+
+	/* retry limit capabilities */
+	range->retry_capa = IW_RETRY_LIMIT | IW_RETRY_LIFETIME;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->r_time_flags = IW_RETRY_LIFETIME;
+
+	/* I don't know the range. Put stupid things here */
+	range->min_retry = 1;
+	range->max_retry = 65535;
+	range->min_r_time = 1024;
+	range->max_r_time = 65535 * 1024;
+
+	/* txpower is supported in dBm's */
+	range->txpower_capa = IW_TXPOW_DBM;
+
+	return 0;
+}
+
+static int
+prism54_set_scan(struct net_device *dev, struct iw_request_info *info,
+		 union iwreq_data *data, char *extra)
+{
+	/* We only do a passive scan for now. */
+	return 0;
+}
+
+static const iw_handler prism54_handler[] = {
+	prism54_commit,			/* SIOCSIWCOMMIT */
+	prism54_get_name,		/* SIOCGIWNAME */
+	NULL,				/* SIOCSIWNWID */
+	NULL,				/* SIOCGIWNWID */
+	prism54_set_freq,		/* SIOCSIWFREQ */
+	prism54_get_freq,		/* SIOCGIWFREQ */
+	prism54_set_mode,		/* SIOCSIWMODE */
+	prism54_get_mode,		/* SIOCGIWMODE */
+	(iw_handler) prism54_set_sens,	/* SIOCSIWSENS */
+	(iw_handler) prism54_get_sens,	/* SIOCGIWSENS */
+	NULL,				/* SIOCSIWRANGE */
+	(iw_handler) prism54_get_range,	/* SIOCGIWRANGE */
+	NULL,				/* SIOCSIWPRIV */
+	NULL,				/* SIOCGIWPRIV */
+	NULL,				/* SIOCSIWSTATS */
+	NULL,				/* SIOCGIWSTATS */
+	NULL,	//      prism54_set_spy,        /* SIOCSIWSPY */
+	NULL,	//      iw_handler_get_spy,     /* SIOCGIWSPY */
+	NULL,	//      iw_handler_set_thrspy,  /* SIOCSIWTHRSPY */
+	NULL,	//      iw_handler_get_thrspy,  /* SIOCGIWTHRSPY */
+	ieee80211softmac_wx_set_wap,	/* SIOCSIWAP */
+	ieee80211softmac_wx_get_wap,	/* SIOCGIWAP */
+	NULL,				/* 0x16 -- hole -- */
+	NULL,				/* SIOCGIWAPLIST depreciated */
+	prism54_set_scan,		/* SIOCSIWSCAN */
+	ieee80211softmac_wx_get_scan_results,	/* SIOCGIWSCAN */
+	ieee80211softmac_wx_set_essid,	/* SIOCSIWESSID */
+	ieee80211softmac_wx_get_essid,	/* SIOCGIWESSID */
+	NULL,	//      (iw_handler) prism54_set_nick,  /* SIOCSIWNICKN */
+	NULL,	//      (iw_handler) prism54_get_nick,  /* SIOCGIWNICKN */
+	NULL,				/* 0x1E -- hole -- */
+	NULL,				/* 0x1F -- hole -- */
+	NULL,	//      (iw_handler) prism54_set_rate,  /* SIOCSIWRATE */
+	NULL,	//      (iw_handler) prism54_get_rate,  /* SIOCGIWRATE */
+	NULL,	//      (iw_handler) prism54_set_rts,   /* SIOCSIWRTS */
+	NULL,	//      (iw_handler) prism54_get_rts,   /* SIOCGIWRTS */
+	NULL,	//      (iw_handler) prism54_set_frag,  /* SIOCSIWFRAG */
+	NULL,	//      (iw_handler) prism54_get_frag,  /* SIOCGIWFRAG */
+	NULL,	//      (iw_handler) prism54_set_txpower,       /* SIOCSIWTXPOW */
+	NULL,	//      (iw_handler) prism54_get_txpower,       /* SIOCGIWTXPOW */
+	NULL,	//      (iw_handler) prism54_set_retry, /* SIOCSIWRETRY */
+	NULL,	//      (iw_handler) prism54_get_retry, /* SIOCGIWRETRY */
+	NULL,	//      (iw_handler) prism54_set_encode,        /* SIOCSIWENCODE */
+	NULL,	//      (iw_handler) prism54_get_encode,        /* SIOCGIWENCODE */
+	NULL,				/* SIOCSIWPOWER */
+	NULL,				/* SIOCGIWPOWER */
+	NULL,				/* 0x2E -- hole -- */
+	NULL,				/* 0x2F -- hole -- */
+	NULL,				/* SIOCSIWGENIE	*/
+	NULL,				/* SIOCGIWGENIE	*/
+	NULL,				/* SIOCSIWAUTH */
+	NULL,				/* SIOCGIWAUTH */
+	NULL,				/* SIOCSIWENCODEEXT */
+	NULL,				/* SIOCGIWENCODEEXT */
+	NULL,				/* SIOCSIWPMKSA	*/
+};
+
+/* XXX MAX_PKT_LEN use below is bogus - masking with decimal 200 */
+static const struct iw_priv_args prism54_private_args[] = {
+	[0] = {			/* args for islsm_ioctl_sendannouncedpkt */
+	       .cmd = SIOCIWFIRSTPRIV,
+	       .set_args = ((IW_PRIV_TYPE_MASK & IW_PRIV_TYPE_BYTE) |	/* type of args */
+			    (IW_PRIV_SIZE_MASK & MAX_PKT_LEN))	/* max number of args */
+	       &(~IW_PRIV_SIZE_FIXED),	/* size is not fixed */
+	       .get_args = 0,	/* Type and number of args */
+	       .name = "set_announcedpkt",	/* Name of the extension */
+	       },
+};
+
+static const iw_handler prism54_private_handler[] = {
+	islsm_ioctl_sendannouncedpkt,		/* SIOCWFIRSTPRIV+15 */
+};
+
+struct iw_handler_def islsm_iw_handler_def = {
+	.num_standard = sizeof (prism54_handler) / sizeof (iw_handler),
+	.num_private = sizeof (prism54_private_handler) / sizeof (iw_handler),
+	.num_private_args =
+	    sizeof (prism54_private_args) / sizeof (prism54_private_args[0]),
+	.standard = prism54_handler,
+	.private = prism54_private_handler,
+	.private_args = prism54_private_args,
+	.get_wireless_stats = islsm_wireless_stats,
+};
+
+#else				/* MADWIFI */
+
+/*
+ * Return wireless extensions statistics.
+ */
+struct iw_statistics *
+islsm_wireless_stats(struct net_device *dev)
+{
+	struct islsm *sc = dev->priv;
+	struct ieee80211com *ic = &sc->sc_ic;
+	struct iw_statistics *is = &sc->iwstatistics;
+
+	ieee80211_iw_getstats(ic, is);
+	/* add in statistics maintained by the driver */
+/* 	is->discard.code += sc->sc_stats.ast_rx_badcrypt; */
+/* 	is->discard.retries += sc->sc_stats.ast_tx_xretries; */
+/* 	is->discard.misc += sc->sc_stats.ast_tx_encap */
+/* 			 + sc->sc_stats.ast_tx_nonode */
+/* 			 + sc->sc_stats.ast_tx_xretries */
+/* 			 + sc->sc_stats.ast_tx_fifoerr */
+/* 			 + sc->sc_stats.ast_tx_filtered */
+/* 			 + sc->sc_stats.ast_tx_nobuf */
+/* 			 + sc->sc_stats.ast_tx_nobufmgt; */
+/* 			 ; */
+/* 	is->miss.beacon = sc->sc_stats.ast_bmiss; */
+
+	return &sc->iwstatistics;
+}
+
+#include <net/iw_handler.h>
+/*
+ * Bounce functions to get to the 802.11 code. These are
+ * necessary for now because wireless extensions operations
+ * are done on the underlying device and not the 802.11 instance.
+ * This will change when there can be multiple 802.11 instances
+ * associated with a device and we must have a net_device for
+ * each so we can manipulate them individually.
+ */
+#define	ISLSM_CHAR_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 char *erq, char *extra)				\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_POINT_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 struct iw_point *erq, char *extra)			\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_PARAM_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 struct iw_param *erq, char *extra)			\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_SOCKADDR_BOUNCE(name)					\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 struct sockaddr *erq, char *extra)			\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_FREQ_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 struct iw_freq *erq, char *extra)			\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_U32_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 __u32 *erq, char *extra)				\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+#define	ISLSM_VOID_BOUNCE(name)						\
+static int								\
+islsm_ioctl_##name(struct net_device *dev, struct iw_request_info *info,	\
+		 void *erq, char *extra)				\
+{									\
+	struct islsm *sc = dev->priv;				\
+	return ieee80211_ioctl_##name(&sc->sc_ic, info, erq, extra);	\
+}
+
+ISLSM_CHAR_BOUNCE(giwname)
+    ISLSM_POINT_BOUNCE(siwencode)
+    ISLSM_POINT_BOUNCE(giwencode)
+    ISLSM_PARAM_BOUNCE(siwrate)
+    ISLSM_PARAM_BOUNCE(giwrate)
+    ISLSM_PARAM_BOUNCE(siwsens)
+    ISLSM_PARAM_BOUNCE(giwsens)
+    ISLSM_PARAM_BOUNCE(siwrts)
+    ISLSM_PARAM_BOUNCE(giwrts)
+    ISLSM_PARAM_BOUNCE(siwfrag)
+    ISLSM_PARAM_BOUNCE(giwfrag)
+    ISLSM_SOCKADDR_BOUNCE(siwap)
+    ISLSM_SOCKADDR_BOUNCE(giwap)
+    ISLSM_POINT_BOUNCE(siwnickn)
+    ISLSM_POINT_BOUNCE(giwnickn)
+    ISLSM_FREQ_BOUNCE(siwfreq)
+    ISLSM_FREQ_BOUNCE(giwfreq)
+    ISLSM_POINT_BOUNCE(siwessid)
+    ISLSM_POINT_BOUNCE(giwessid)
+    ISLSM_POINT_BOUNCE(giwrange)
+    ISLSM_U32_BOUNCE(siwmode)
+    ISLSM_U32_BOUNCE(giwmode)
+    ISLSM_PARAM_BOUNCE(siwpower)
+    ISLSM_PARAM_BOUNCE(giwpower)
+    ISLSM_PARAM_BOUNCE(siwretry)
+    ISLSM_PARAM_BOUNCE(giwretry)
+    ISLSM_PARAM_BOUNCE(siwtxpow)
+    ISLSM_PARAM_BOUNCE(giwtxpow)
+    ISLSM_POINT_BOUNCE(iwaplist)
+#ifdef SIOCGIWSCAN
+    ISLSM_POINT_BOUNCE(siwscan)
+    ISLSM_POINT_BOUNCE(giwscan)
+#endif
+    ISLSM_VOID_BOUNCE(setparam)
+    ISLSM_VOID_BOUNCE(getparam)
+    ISLSM_VOID_BOUNCE(setkey)
+    ISLSM_VOID_BOUNCE(delkey)
+    ISLSM_VOID_BOUNCE(setmlme)
+    ISLSM_VOID_BOUNCE(setoptie)
+    ISLSM_VOID_BOUNCE(getoptie)
+    ISLSM_VOID_BOUNCE(addmac)
+    ISLSM_VOID_BOUNCE(delmac)
+    ISLSM_VOID_BOUNCE(chanlist)
+
+/* Structures to export the Wireless Handlers */
+static const iw_handler islsm_handlers[] = {
+	(iw_handler) NULL,	/* SIOCSIWCOMMIT */
+	(iw_handler) islsm_ioctl_giwname,	/* SIOCGIWNAME */
+	(iw_handler) NULL,	/* SIOCSIWNWID */
+	(iw_handler) NULL,	/* SIOCGIWNWID */
+	(iw_handler) islsm_ioctl_siwfreq,	/* SIOCSIWFREQ */
+	(iw_handler) islsm_ioctl_giwfreq,	/* SIOCGIWFREQ */
+	(iw_handler) islsm_ioctl_siwmode,	/* SIOCSIWMODE */
+	(iw_handler) islsm_ioctl_giwmode,	/* SIOCGIWMODE */
+	(iw_handler) islsm_ioctl_siwsens,	/* SIOCSIWSENS */
+	(iw_handler) islsm_ioctl_giwsens,	/* SIOCGIWSENS */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWRANGE */
+	(iw_handler) islsm_ioctl_giwrange,	/* SIOCGIWRANGE */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWPRIV */
+	(iw_handler) NULL /* kernel code */ ,	/* SIOCGIWPRIV */
+	(iw_handler) NULL /* not used */ ,	/* SIOCSIWSTATS */
+	(iw_handler) NULL /* kernel code */ ,	/* SIOCGIWSTATS */
+	(iw_handler) NULL,	/* SIOCSIWSPY */
+	(iw_handler) NULL,	/* SIOCGIWSPY */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) islsm_ioctl_siwap,	/* SIOCSIWAP */
+	(iw_handler) islsm_ioctl_giwap,	/* SIOCGIWAP */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) islsm_ioctl_iwaplist,	/* SIOCGIWAPLIST */
+#ifdef SIOCGIWSCAN
+	(iw_handler) islsm_ioctl_siwscan,	/* SIOCSIWSCAN */
+	(iw_handler) islsm_ioctl_giwscan,	/* SIOCGIWSCAN */
+#else
+	(iw_handler) NULL,	/* SIOCSIWSCAN */
+	(iw_handler) NULL,	/* SIOCGIWSCAN */
+#endif				/* SIOCGIWSCAN */
+	(iw_handler) islsm_ioctl_siwessid,	/* SIOCSIWESSID */
+	(iw_handler) islsm_ioctl_giwessid,	/* SIOCGIWESSID */
+	(iw_handler) islsm_ioctl_siwnickn,	/* SIOCSIWNICKN */
+	(iw_handler) islsm_ioctl_giwnickn,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) islsm_ioctl_siwrate,	/* SIOCSIWRATE */
+	(iw_handler) islsm_ioctl_giwrate,	/* SIOCGIWRATE */
+	(iw_handler) islsm_ioctl_siwrts,	/* SIOCSIWRTS */
+	(iw_handler) islsm_ioctl_giwrts,	/* SIOCGIWRTS */
+	(iw_handler) islsm_ioctl_siwfrag,	/* SIOCSIWFRAG */
+	(iw_handler) islsm_ioctl_giwfrag,	/* SIOCGIWFRAG */
+	(iw_handler) islsm_ioctl_siwtxpow,	/* SIOCSIWTXPOW */
+	(iw_handler) islsm_ioctl_giwtxpow,	/* SIOCGIWTXPOW */
+	(iw_handler) islsm_ioctl_siwretry,	/* SIOCSIWRETRY */
+	(iw_handler) islsm_ioctl_giwretry,	/* SIOCGIWRETRY */
+	(iw_handler) islsm_ioctl_siwencode,	/* SIOCSIWENCODE */
+	(iw_handler) islsm_ioctl_giwencode,	/* SIOCGIWENCODE */
+	(iw_handler) islsm_ioctl_siwpower,	/* SIOCSIWPOWER */
+	(iw_handler) islsm_ioctl_giwpower,	/* SIOCGIWPOWER */
+};
+static const iw_handler islsm_priv_handlers[] = {
+	(iw_handler) islsm_ioctl_setparam,	/* SIOCWFIRSTPRIV+0 */
+	(iw_handler) islsm_ioctl_getparam,	/* SIOCWFIRSTPRIV+1 */
+	(iw_handler) islsm_ioctl_setkey,	/* SIOCWFIRSTPRIV+2 */
+	(iw_handler) NULL,	/* SIOCWFIRSTPRIV+3 */
+	(iw_handler) islsm_ioctl_delkey,	/* SIOCWFIRSTPRIV+4 */
+	(iw_handler) NULL,	/* SIOCWFIRSTPRIV+5 */
+	(iw_handler) islsm_ioctl_setmlme,	/* SIOCWFIRSTPRIV+6 */
+	(iw_handler) NULL,	/* SIOCWFIRSTPRIV+7 */
+	(iw_handler) islsm_ioctl_setoptie,	/* SIOCWFIRSTPRIV+8 */
+	(iw_handler) islsm_ioctl_getoptie,	/* SIOCWFIRSTPRIV+9 */
+	(iw_handler) islsm_ioctl_addmac,	/* SIOCWFIRSTPRIV+10 */
+	(iw_handler) NULL,	/* SIOCWFIRSTPRIV+11 */
+	(iw_handler) islsm_ioctl_delmac,	/* SIOCWFIRSTPRIV+12 */
+	(iw_handler) NULL,	/* SIOCWFIRSTPRIV+13 */
+	(iw_handler) islsm_ioctl_chanlist,	/* SIOCWFIRSTPRIV+14 */
+};
+
+struct iw_handler_def islsm_iw_handler_def = {
+#define	N(a)	(sizeof (a) / sizeof (a[0]))
+	.standard = (iw_handler *) islsm_handlers,
+	.num_standard = N(islsm_handlers),
+	.private = (iw_handler *) islsm_priv_handlers,
+	.num_private = N(islsm_priv_handlers),
+#undef N
+};
+
+#endif				/* MADWIFI */
+
+#endif				/* CONFIG_NET_WIRELESS */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_ioctl.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_ioctl.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_ioctl.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,30 @@
+/*
+  GPLv2, or later.
+*/
+#ifndef _ISLSM_IOCTL_H
+#define _ISLSM_IOCTL_H
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+
+/*** custom ioctls ***/
+/* get and set sm structure */
+#define	SIOCGSMSTRUCT	(SIOCDEVPRIVATE+0)
+#define	SIOCSSMSTRUCT	(SIOCDEVPRIVATE+1)
+/* get the mgmt readback results */
+#define	SIOCGSMMGMT	(SIOCDEVPRIVATE+2)
+/* send a control request with response expected,
+   get back the response */
+#define	SIOCXSMFRAME	(SIOCDEVPRIVATE+3)
+/* does not cope with the status request... */
+#define SIOCGSMSTATUS   (SIOCDEVPRIVATE+4)
+
+/* data structure exchanged during the ioctls */
+/* SIOCGSMSTRUCT : see isl_sm.h */
+/* SIOCSSMSTRUCT */
+
+struct iw_statistics   *islsm_wireless_stats(struct net_device *ndev);
+
+extern struct iw_handler_def islsm_iw_handler_def;
+
+#endif				/* _P54U_IOCTL_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_log.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_log.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_log.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_log.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,141 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+
+#include "islsm_log.h"
+
+#if ISL_DEBUG
+unsigned int     isl_debug = 0;
+module_param_named(debug, isl_debug, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(debug, "Adjust verbosity of the driver.");
+EXPORT_SYMBOL(isl_debug);
+
+void isl_dump_bytes(const void *_data, int num)
+{
+	const u8 *data = (const u8 *) _data;
+	const u8 *ptr = data;
+
+	if (num <= 0) {
+		printk("\n");
+		return;
+	}
+
+	while (num >= 16) {
+		printk(KERN_CRIT "%04x:"
+		       "%02X %02X %02X %02X %02X %02X %02X %02X "
+		       "%02X %02X %02X %02X %02X %02X %02X %02X\n",
+		       (uint16_t) (ptr - data),
+		       ptr[0], ptr[1], ptr[2], ptr[3],
+		       ptr[4], ptr[5], ptr[6], ptr[7],
+		       ptr[8], ptr[9], ptr[10], ptr[11],
+		       ptr[12], ptr[13], ptr[14], ptr[15]);
+		num -= 16;
+		ptr += 16;
+	}
+	if (num > 0) {
+		printk(KERN_CRIT "%04x:", (uint16_t) (ptr - data));
+		while (--num > 0)
+			printk("%02X ", *ptr++);
+		printk("%02X\n", *ptr);
+	}
+}
+
+EXPORT_SYMBOL(isl_dump_bytes);
+
+#endif /* ISL_DEBUG */
+
+#if ISL_DEBUG > 1
+
+static int isl_debug_func_indent;
+
+#define DEBUG_TSC 0
+#define FUNC_INDENT_INCREMENT 2
+
+#if DEBUG_TSC
+#define TIMESTAMP(d) unsigned long d; rdtscl(d)
+#else
+#define TIMESTAMP(d) unsigned long d = jiffies
+#endif
+
+static const char
+ spaces[] = "          " "          ";	/* Nx10 spaces */
+
+void
+isl_fn_enter(const char *funcname)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	indent = isl_debug_func_indent;
+	if (indent >= sizeof (spaces))
+		indent = sizeof (spaces) - 1;
+
+	printk("%08ld %s==> %s\n",
+	       d % 100000000,
+	       spaces + (sizeof (spaces) - 1) - indent, funcname);
+
+	isl_debug_func_indent += FUNC_INDENT_INCREMENT;
+}
+
+EXPORT_SYMBOL(isl_fn_enter);
+
+void
+isl_fn_exit(const char *funcname)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	isl_debug_func_indent -= FUNC_INDENT_INCREMENT;
+
+	indent = isl_debug_func_indent;
+	if (indent >= sizeof (spaces))
+		indent = sizeof (spaces) - 1;
+
+	printk("%08ld %s<== %s\n",
+	       d % 100000000,
+	       spaces + (sizeof (spaces) - 1) - indent, funcname);
+}
+
+EXPORT_SYMBOL(isl_fn_exit);
+
+void
+isl_fn_exit_v(const char *funcname, int v)
+{
+	int indent;
+	TIMESTAMP(d);
+
+	isl_debug_func_indent -= FUNC_INDENT_INCREMENT;
+
+	indent = isl_debug_func_indent;
+	if (indent >= sizeof (spaces))
+		indent = sizeof (spaces) - 1;
+
+	printk("%08ld %s<== %s: %08X\n",
+	       d % 100000000,
+	       spaces + (sizeof (spaces) - 1) - indent, funcname, v);
+}
+
+EXPORT_SYMBOL(isl_fn_exit_v);
+
+#endif				/* ISL_DEBUG > 1 */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_log.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_log.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_log.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_log.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,184 @@
+/*
+  Copyright 2005 Denis Vlasenko
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAVE_ISLSL_LOG_H_
+#define _HAVE_ISLSL_LOG_H_
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/jiffies.h>
+
+#define ISL_DEBUG 2
+
+/***********************************************************************
+** Logging: guidelines
+**
+** - Use printk() for messages which are to be always logged.
+**   Supply either 'islsm:' or '<devname>:' prefix so that user
+**   can figure out who's speaking among other kernel chatter.
+**   islsm: is for general issues (e.g. "islsm: no firmware image!")
+**   while <devname>: is related to a particular device
+**   (think about multi-card setup). Double check that message
+**   is not confusing to the average user.
+**
+** - use printk KERN_xxx level only if message is not a WARNING
+**   but is INFO, ERR etc. In general, we mostly not using these
+**
+** - Use islog() for messages which may be omitted (and they
+**   _will_ be omitted in non-debug builds). Note that
+**   message levels may be disabled at compile-time selectively,
+**   thus select them wisely. Example: L_DEBUG is the lowest
+**   (most likely to be compiled out) -> use for less important stuff.
+**
+** - Do not print important stuff with islog(), or else people
+**   will never build non-debug driver.
+*/
+
+enum {
+	/* generic debug */
+	L_DEBUG = (ISL_DEBUG > 1) * 0x0001,
+	/* function tracing -- through debugfs & relayfs */
+	L_FUNC = (ISL_DEBUG > 0) * 0x0002,
+	/* IRQ data, use with care */
+	L_IRQ = (ISL_DEBUG > 0) * 0x0004,
+	/* UART data -- through debugfs & relayfs */
+	L_DATA =  (ISL_DEBUG > 1) * 0x0008,
+	/* device IOCTLs */
+	L_IOCTL = (ISL_DEBUG > 0) * 0x0010,
+	/* raw protocol islsm frames
+	   input (R) and output (T) -- through debugfs & relayfs */
+	L_BUFR = (ISL_DEBUG > 1) * 0x0020,
+	L_BUFT = (ISL_DEBUG > 1) * 0x0040,
+	/* firmware & PDA parsing infos */
+	L_FW = (ISL_DEBUG > 0) * 0x0080,
+	L_PDA = (ISL_DEBUG > 0) * 0x0100,
+	/* allocator debug */
+	L_ALLOC = (ISL_DEBUG > 1) * 0x0200,
+	/* frame interpretation, input, output -- through debugfs & relayfs */
+	L_SM_INPUT  = (ISL_DEBUG > 0) * 0x0400,
+	L_SM_OUTPUT = (ISL_DEBUG > 0) * 0x0800,
+	L_ANY = 0xffff,
+};
+
+#if ISL_DEBUG
+extern unsigned int     isl_debug;
+#else
+enum { isl_debug = 0 };
+#endif
+
+#if ISL_DEBUG > 1
+
+void                    isl_fn_enter(const char *funcname);
+void                    isl_fn_exit(const char *funcname);
+void                    isl_fn_exit_v(const char *funcname, int v);
+
+#define FN_ENTER \
+	do { \
+		if (unlikely(isl_debug & L_FUNC)) { \
+			isl_fn_enter(__func__); \
+		} \
+	} while (0)
+
+#define FN_EXIT1(v) \
+	do { \
+		if (unlikely(isl_debug & L_FUNC)) { \
+			isl_fn_exit_v(__func__, v); \
+		} \
+	} while (0)
+#define FN_EXIT0 \
+	do { \
+		if (unlikely(isl_debug & L_FUNC)) { \
+			isl_fn_exit(__func__); \
+		} \
+	} while (0)
+
+#else
+
+#define FN_ENTER
+#define FN_EXIT1(v)
+#define FN_EXIT0
+
+#endif				/* ISL_DEBUG > 1 */
+
+#if ISL_DEBUG
+
+#define islog(chan, args...) \
+	do { \
+		if (isl_debug & (chan)) \
+			printk(args); \
+	} while (0)
+
+void                    isl_dump_bytes(const void *data, int num);
+
+#else				/* Non-debug build: */
+
+#define islog(chan, args...)
+#define isl_dump_bytes(data, num)
+
+#endif				/* ISL_DEBUG */
+
+void                    isl_print_mac(const char *head, const u8 *mac,
+				      const char *tail);
+
+/* Optimized out to nothing in non-debug build */
+static inline void
+islog_mac(int level, const char *head, const u8 *mac, const char *tail)
+{
+	if (isl_debug & level) {
+		isl_print_mac(head, mac, tail);
+	}
+}
+
+/* Useful to get __FILE__ without full leading path */
+static inline const char *sanitize_str(const char *s)
+{
+	const char             *t = strrchr(s, '/');
+	if (t)
+		return t + 1;
+	return s;
+}
+
+/* raw output data debug */
+static inline void
+islsm_txdata_debug(const unsigned int queue,
+		   const void *_data, const int len)
+{
+	if (isl_debug & L_BUFT) {
+		unsigned long int time = jiffies;
+		printk(KERN_CRIT "[OUT +%-6ld] %02x\n", time, queue);
+		isl_dump_bytes(_data, len);
+	}
+}
+
+/* raw input data debug */
+static inline void
+islsm_rxdata_debug(const unsigned int queue,
+		   const void *data, const int len)
+{
+	if (isl_debug & L_BUFR) {
+		unsigned long time = jiffies;
+		printk(KERN_CRIT "[IN +%-6ld] %02x\n", time, queue);
+		isl_dump_bytes(data, len);
+	}
+}
+
+#endif				/* _HAVE_ISLSL_LOG_H_ */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_netdev.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_netdev.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_netdev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_netdev.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,1322 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+  Copyright (c) 2006 Red Hat, Inc.
+
+  Parts of this program code are derived from the bcm43xx driver,
+  Copyright 2005 Martin Langer <martin-langer@gmx.de>, et. al.
+  Please refer there for the complete copyright statement.
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#include <linux/if_arp.h>
+#include <asm/uaccess.h>
+#include <linux/list.h>
+
+#ifdef MADWIFI
+#include <linux/version.h>
+#include "net80211/if_ethersubr.h"
+#include "net80211/if_media.h"
+#include "net80211/ieee80211_var.h"
+#endif				/* MADWIFI */
+
+#include "isl_sm.h"
+#include "islsm_protocol.h"
+#include "islsm_ioctl.h"
+#include "sent_data_ok.h"
+#include "islsm_log.h"
+
+#ifdef MADWIFI
+#define DRV_NAME "islsm"
+#else
+#include "islusb_dev.h"
+#endif
+
+MODULE_DESCRIPTION("Prism54 softmac layer driver");
+MODULE_AUTHOR("Jean-Baptiste Note <jean-baptiste.note@m4x.org>");
+MODULE_LICENSE("GPL");
+
+const char dummy_mac[ETH_ALEN] = { 0x00, 0x3d, 0xb4, 0x00, 0x00, 0x00 };
+
+#ifdef MADWIFI
+static int islsm_tx_start(struct ieee80211com *ic,
+			  struct ieee80211_node *ni, struct sk_buff *skb);
+#else
+static int islsm_reset(struct net_device *netdev);
+#endif				/* MADWIFI */
+
+static unsigned minor = 0;
+
+static int
+islsm_close(struct net_device *netdev)
+{
+#ifdef MADWIFI
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+#endif
+	// Is this called in case of a hot unplug ?
+	FN_ENTER;
+
+#ifndef MADWIFI
+	ieee80211softmac_stop(netdev);
+#endif
+
+	// Shutdown should be called unconditionally
+	if (netdev->flags & IFF_RUNNING) {
+		islog(L_DEBUG, "%s: Running on close, shutting down 802.11\n",
+		      DRV_NAME);
+/* this should pertain to stop only */
+		// Empty the lmac queues !
+		/* FIXME ; find something to replace this */
+		//islsm_empty_queues(netdev);
+#ifdef MADWIFI
+		/* stop the 802.11 ?
+		 * Done last because the bh won't run after this */
+		/* I'm not even sure i want this ; pump stops the
+		 * interface and reboots it... We don't want to look
+		 * ieee80211 state here ! */
+		ieee80211_new_state(&islsm->sc_ic, IEEE80211_S_INIT, -1);
+		islog(L_DEBUG, "%s: Shutdown ieee80211 layer\n", DRV_NAME);
+#endif
+		netif_stop_queue(netdev);
+		netdev->flags &= ~IFF_RUNNING;
+	}
+	FN_EXIT1(0);
+	return 0;
+}
+
+static void
+islsm_tx_timeout(struct net_device *netdev)
+{
+	islog(L_DEBUG, "islsm_tx_timeout called\n");
+	return;
+}
+
+static int
+islsm_transmit(struct sk_buff *skb, struct net_device *netdev)
+{
+	int err = 0;
+#ifdef MADWIFI
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+	struct ieee80211_node *ni = NULL;
+	struct ether_header *eh;
+
+	FN_ENTER;
+
+	/* first poll management queue - it has higher prio */
+	while (1) {
+		struct sk_buff *skb0;
+		struct ieee80211_node *ni;
+		struct ieee80211_cb *cb;
+
+		IF_DEQUEUE(&ic->ic_mgtq, skb0);
+		if (!skb0)
+			break;
+
+		cb = (struct ieee80211_cb *) skb0->cb;
+		ni = cb->ni;
+
+		err = islsm_tx_start(ic, ni, skb0);
+		/* silently drop management frame, argh */
+		if (err)
+			dev_kfree_skb(skb0);
+	}
+
+	if (!skb) {
+		FN_EXIT1(0);
+		return 0;
+	}
+
+	if ((netdev->flags & IFF_RUNNING) == 0) {
+		islog(L_DEBUG, "%s: %s, discard, flags %x\n",
+		      DRV_NAME, __func__, netdev->flags);
+		FN_EXIT1(-ENETDOWN);
+		return -ENETDOWN;
+	}
+
+	/*
+	 * No data frames go out unless we're associated; this
+	 * should not happen as the 802.11 layer does not enable
+	 * the xmit queue until we enter the RUN state.
+	 */
+	if (ic->ic_state != IEEE80211_S_RUN) {
+		islog(L_DEBUG, "%s: discard, state %u\n", __func__,
+		      ic->ic_state);
+		goto bad;
+	}
+
+	eh = (struct ether_header *) skb->data;
+	ni = ieee80211_find_txnode(ic, eh->ether_dhost);
+	if (ni == NULL) {
+		FN_EXIT1(0);
+		return 0;
+	}
+
+	/* packet is gonna be transmitted, update stats */
+	islsm->statistics.tx_packets++;
+	islsm->statistics.tx_bytes += skb->len;
+
+	/*
+	 * We can do the work directly now
+	 */
+
+	/*
+	 * Encapsulate the packet for transmission.
+	 */
+	skb = ieee80211_encap(ic, skb, ni);
+
+	if (skb == NULL) {
+		islog(L_DEBUG, "%s: %s discard, encapsulation failure\n",
+		      DRV_NAME, __func__);
+		goto bad;
+	}
+
+	err = islsm_tx_start(ic, ni, skb);
+	if (!err) {
+		netdev->trans_start = jiffies;
+		FN_EXIT1(0);
+		return 0;
+	}
+
+      bad:
+	if (ni)
+		ieee80211_free_node(ni);
+#endif				/* MADWIFI */
+	if (!err && skb)
+		dev_kfree_skb(skb);
+	FN_EXIT1(err);
+	return err;		/* NB: return !0 only in a ``hard error condition'' */
+}
+
+static struct net_device_stats *
+islsm_statistics(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	/* trigger a statistics update
+	   The data collected is not used for now */
+	if (netdev->flags & IFF_RUNNING)
+		(void) islsm_stats_readback(islsm);
+	return &islsm->statistics;
+}
+
+#ifdef MADWIFI
+/*
+ * Better ioctl stub
+ */
+static int
+islsm_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(ndev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+	int error;
+
+	/* before implementing locking, understand why it's
+	 * needed. Access to which structure ? -- stats for instance ?*/
+
+	switch (cmd) {
+	case SIOCETHTOOL:
+		islog(L_IOCTL, "%s: SIOCETHTOOL called, not supported\n",
+		      DRV_NAME);
+		error = -ENOTSUPP;
+		break;
+	default:
+		error = ieee80211_ioctl(ic, rq, cmd);
+		break;
+	}
+	if (error)
+		islog(L_IOCTL, "%s: problem with ioctl %02x, return value %i\n",
+		      DRV_NAME, cmd, error);
+	return error;
+}
+
+/*
+ * MADWIFI STACK SPECIFIC CALLBACKS ; dummy for now, i'll put in
+ * commentary as to whether they're needed or not
+ */
+
+/* send frame to beacon slot, freeing the previously allocated beacon
+ * slot. The frame will be emitted when an adapted rx/tx filter is
+ * set */
+
+static int
+islsm_beacon_alloc(struct net_device *netdev, struct ieee80211_node *ni)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+	struct sk_buff *skb;
+	int err;
+
+	/* get the frame from the upper layer */
+	skb = ieee80211_beacon_alloc(ic, ni, &islsm->islsm_boff);
+	if (skb == NULL)
+		return -ENOMEM;
+
+	err = islsm_data_tx(islsm, &(islsm->smpar.beacon), skb);
+	if (err)
+		dev_kfree_skb(skb);
+
+	return err;
+}
+
+static int
+islsm_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
+{
+	struct net_device *netdev = ic->ic_dev;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+
+	uint8_t *bssid;
+	uint16_t mode = ISLSM_TX_CONTROL_FILTER_NOTYPE;
+	int error = 0;
+	struct ieee80211_node *ni = 0;
+	unsigned int channel = 0;
+	struct ieee80211_channel *chan = 0;
+
+	uint16_t chan_m1, chan_m2;
+	uint16_t magic2 = ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2;
+	uint32_t magic3 = ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1;
+	uint16_t magic8 = 0;
+	uint16_t magic9 = 0;
+
+	/* what if it has never been initialized, is it safe ? */
+	del_timer(&islsm->scan_ch);
+
+	islog(L_DEBUG, "%s: %s, %s -> %s\n",
+	      DRV_NAME, __func__,
+	      ieee80211_state_name[ic->ic_state], ieee80211_state_name[nstate]);
+
+	netif_stop_queue(netdev);	/* before we do anything else */
+
+	if (nstate == IEEE80211_S_INIT) {
+		goto done;
+	}
+
+	ni = ic->ic_bss;
+
+	/* compute the elements needed for the rx/tx filter */
+	/* bssid */
+	if (nstate == IEEE80211_S_SCAN) {
+		bssid = netdev->broadcast;
+		mode = ISLSM_TX_CONTROL_FILTER_NOTYPE;
+		if (ic->ic_flags & IEEE80211_F_ASCAN) {
+			/* active scan with allocated probe request.
+			   What happens if no allocated probe ? */
+			chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_EMIT_TXSLOT;
+			chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_EMIT_TXSLOT;
+		} else {
+			chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN;
+			chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_SCAN;
+		}
+	} else {
+		bssid = ni->ni_bssid;
+		chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX;
+		chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX;
+	}
+
+	/* mode  */
+	if (nstate == IEEE80211_S_AUTH || nstate == IEEE80211_S_RUN) {
+		switch (ic->ic_opmode) {
+		case IEEE80211_M_STA:	/* infra station */
+			magic2 = ISLSM_TX_CONTROL_FILTER_MAGIC2_STA;
+			magic3 = ISLSM_TX_CONTROL_FILTER_MAGIC3_STA;
+			magic8 = ISLSM_TX_CONTROL_FILTER_MAGIC8_STA;
+			mode = ISLSM_TX_CONTROL_FILTER_STA;
+			break;
+		case IEEE80211_M_AHDEMO:
+		case IEEE80211_M_IBSS:	/* ad-hoc */
+			mode = ISLSM_TX_CONTROL_FILTER_ADHOC;
+			break;
+		case IEEE80211_M_HOSTAP:
+			mode = ISLSM_TX_CONTROL_FILTER_HOSTAP;
+			break;
+		case IEEE80211_M_MONITOR:
+			/* correct this -- doesn't work now */
+			bssid = netdev->broadcast;
+			chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX;
+			chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX;
+
+			magic2 = ISLSM_TX_CONTROL_FILTER_MAGIC2_MONITOR;
+			magic3 = ISLSM_TX_CONTROL_FILTER_MAGIC3_MONITOR;
+			mode = ISLSM_TX_CONTROL_FILTER_MONITOR;
+			break;
+		}
+	}
+
+	/* should also set rate, etc but i don't know yet how to set them */
+
+	chan = ni->ni_chan;
+	channel = ieee80211_mhz2ieee(chan->ic_freq, 0);
+
+	// FIXME : we will get errors on hot unplug. is this a problem ?
+	// This is a problem. Don't know why, but it is. It seems to
+	// make madwifi stuck. So silently ignore.
+	(void) islsm_freq_change(islsm, channel, chan->ic_freq,
+				 chan_m1, chan_m2);
+
+	(void) islsm_set_filter(islsm, mode, bssid,
+				magic2, magic3, magic8, magic9);
+
+/* what is ni_associd ?
+	more or less...
+	if (nstate == IEEE80211_S_RUN && ic->ic_opmode == IEEE80211_M_STA)
+		ath_hal_setassocid(ah, bssid, ni->ni_associd);
+	else
+		ath_hal_setassocid(ah, bssid, 0);
+	if (ic->ic_flags & IEEE80211_F_PRIVACY) {
+		for (i = 0; i < IEEE80211_WEP_NKID; i++)
+			if (ath_hal_keyisvalid(ah, i))
+				ath_hal_keysetmac(ah, i, bssid);
+	}
+*/
+	if (nstate == IEEE80211_S_RUN) {
+		islog(L_DEBUG, "%s: %s(RUN), ic_flags=0x%08x iv=%d bssid=%s "
+		      "capinfo=0x%04x chan=%d\n",
+		      DRV_NAME, __func__,
+		      ic->ic_flags, ni->ni_intval,
+		      ether_sprintf(ni->ni_bssid),
+		      ni->ni_capinfo, ieee80211_chan2ieee(ic, ni->ni_chan));
+
+		/*
+		 * Allocate and setup the beacon frame for AP or adhoc mode.
+		 */
+
+		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
+		    ic->ic_opmode == IEEE80211_M_IBSS) {
+			error = islsm_beacon_alloc(netdev, ni);
+			if (error != 0)
+				goto bad;
+		}
+
+		/*
+		 * No need for this and / or is done in the rx/tx filter packet
+		 * Configure the beacon and sleep timers.
+		 */
+/*		ath_beacon_config(sc); */
+	}
+      done:
+	/*
+	 * Invoke the parent method to complete the work.
+	 */
+	error = islsm->ieee80211_newstate(ic, nstate, arg);
+
+	if (nstate == IEEE80211_S_SCAN) {
+		/* start ap/neighbor scan timer */
+#define ISLSM_DWELLTIME 1000	/* ms */
+		mod_timer(&islsm->scan_ch,
+			  jiffies + ((HZ * ISLSM_DWELLTIME) / 1000));
+
+#undef ISLSM_DWELLTIME
+	}
+      bad:
+	netif_start_queue(netdev);
+	return error;
+}
+
+static void
+islsm_next_scan(unsigned long arg)
+{
+	struct net_device *netdev = (struct net_device *) arg;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+
+	if (ic->ic_state != IEEE80211_S_SCAN)
+		return;
+
+	/*
+	   Allocate the probe request frame.
+	   How does the driver do multiple probes on one channel ?
+	   Try to put the windows driver into this configuration
+	   see ieee80211_next_scan(struct ieee80211com *ic);
+	 */
+
+/* 	if ((ic->ic_flags & IEEE80211_F_ASCAN) && */
+/* 	    (ni->ni_chan->ic_flags & IEEE80211_CHAN_PASSIVE) == 0) { */
+/* 		IEEE80211_SEND_MGMT(ic, ni, */
+/* 				    IEEE80211_FC0_SUBTYPE_PROBE_REQ, 0); */
+/* 	} */
+
+	ieee80211_next_scan(ic);
+}
+
+static int
+islsm_init(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+	struct ieee80211_node *ni;
+	int err = 0;
+
+	uint8_t *bssid = netdev->broadcast;
+
+	// Should be the open of the device -- it's not, yet
+	FN_ENTER;
+
+	/* resize skbs in monitor mode -- good idea, leave enough
+	 * headroom to fit the prism header */
+
+	/* tell the powers that be what we really are */
+	netdev->type = (ic->ic_opmode == IEEE80211_M_MONITOR) ?
+	    ARPHRD_IEEE80211_PRISM : ARPHRD_ETHER;
+
+	/* Hardware state machine reset */
+	/* should be reset, not boot */
+	err = islsm->isl_boot(netdev);
+	if (err) {
+		printk(KERN_ERR "%s: unable to boot device\n", DRV_NAME);
+		goto done;
+	}
+
+	err = islsm_eeprom_readback(islsm);
+	if (err) {
+		printk(KERN_ERR "%s: unable to readback the eeprom\n", DRV_NAME);
+		goto done;
+	}
+
+	/* initialize protocol parameters */
+	islsm_params_init(islsm);
+
+	(void) islsm_led_perm(islsm, LED_MODE_SET, LED_RED);
+	(void) islsm_led_temp(islsm, LED_GREEN, 25);
+
+	/* submit initial data on data pipe */
+	/* this seems to allow frequency change successfully */
+	islsm_outofband_msg(islsm,
+			    magicpkt_table[islsm->device_version].data,
+			    magicpkt_table[islsm->device_version].len);
+
+	islsm_set_filter(islsm,
+			 ISLSM_TX_CONTROL_FILTER_NOTYPE, bssid,
+			 ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM3, 1,
+			 0, ISLSM_TX_CONTROL_FILTER_MAGIC9_FORM1);
+
+	// This one may not be necessary any more.
+	islsm_set_filter(islsm,
+			 ISLSM_TX_CONTROL_FILTER_NOTYPE, bssid,
+			 ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2,
+			 ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1, 0, 0);
+
+	// Start the statistics update cycle
+//      mod_timer(&islsm->stats_update, jiffies + ((HZ * ISLSM_STATSTIME) / 1000));
+
+	/* Tell others we're okay */
+	netdev->flags |= IFF_RUNNING;
+	ic->ic_state = IEEE80211_S_INIT;
+
+	/*
+	 * The hardware should be ready to go now so it's safe
+	 * to kick the 802.11 state machine as it's likely to
+	 * immediately call back to us to send mgmt frames.
+	 */
+	ni = ic->ic_bss;
+	ni->ni_chan = ic->ic_ibss_chan;
+
+	// This will set the tx/rx filter ! this is what we need.
+	//mode = ieee80211_chan2mode(ic, ni->ni_chan);
+	//if (mode != sc->sc_curmode)
+	//      ath_setcurmode(sc, mode);
+	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
+		if (ic->ic_roaming != IEEE80211_ROAMING_MANUAL)
+			ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
+	} else
+		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
+
+      done:
+	FN_EXIT1(err);
+	return err;
+}
+
+static void
+islsm_setup_freqs(struct ieee80211com *ic)
+{
+	/*
+	 * FIXME: Should be read from the device, really, but needs complete
+	 * initialization, so we don't do this for now
+	 * in the _real_ driver : init on probe seems necessary.
+	 */
+	unsigned int ieee_num, maxchans;
+	maxchans = ISLSM_NR_CHANNELS;
+	if (maxchans > IEEE80211_CHAN_MAX) {
+		islog(L_DEBUG, "%s: Channel table table too small\n", DRV_NAME);
+		maxchans = IEEE80211_CHAN_MAX;
+	}
+
+	for (ieee_num = 1; ieee_num <= ISLSM_NR_CHANNELS; ieee_num++) {
+		ic->ic_channels[ieee_num].ic_freq =
+		    ieee80211_ieee2mhz(ieee_num, IEEE80211_CHAN_2GHZ);
+		ic->ic_channels[ieee_num].ic_flags =
+		    IEEE80211_MODE_11B | IEEE80211_MODE_11G;
+		islog(L_DEBUG, "%s: setup channel ieee %i, freq %iMHz\n",
+		      DRV_NAME, ieee_num, ic->ic_channels[ieee_num].ic_freq);
+	}
+}
+
+/* needed otherwise problems in */
+static int
+islsm_setup_rates(struct net_device *dev, u_int mode)
+{
+	struct islsm *islsm = dev->priv;
+	struct ieee80211com *ic = &islsm->sc_ic;
+	struct ieee80211_rateset *rs;
+	int i, maxrates;
+	/* standard rates observed from my prism54 in hostap:
+
+	   2, basic yes rate 4, basic yes rate 11, basic yes rate 12, basic
+	   no rate 18, basic no rate 22, basic yes rate 24, basic no
+	   rate 36, basic no rate 48, basic no rate 72, basic no rate
+	   96, basic no rate 108,
+	 */
+	int rates[ISLSM_NR_RATES] =
+	    { 2, 4, 11, 12, 18, 22, 24, 36, 48, 72, 96, 108, };
+
+	/* FIXME: should check mode */
+	rs = &ic->ic_sup_rates[mode];
+	/* FIXME: Should also get them from device ! */
+	maxrates = ISLSM_NR_RATES;
+	if (maxrates > IEEE80211_RATE_MAXSIZE) {
+		islog(L_DEBUG, "%s: Rate table too small\n", DRV_NAME);
+		maxrates = IEEE80211_RATE_MAXSIZE;
+	}
+	for (i = 0; i < maxrates; i++)
+#define MADWIFI_RATE(x) ( (x) & IEEE80211_RATE_VAL )
+		rs->rs_rates[i] = MADWIFI_RATE(rates[i]);
+#undef MADWIFI_RATE
+	rs->rs_nrates = maxrates;
+	return 0;
+}
+
+/*
+ * Transmit a frame. Does the tracking of everything that needs the
+ * 802.11 layer.
+ * TODO : offloading of some encryption protocols
+ */
+
+static int
+islsm_tx_start(struct ieee80211com *ic, struct ieee80211_node *ni,
+	       struct sk_buff *skb)
+{
+	struct net_device *netdev = ic->ic_dev;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211_frame *wh = (struct ieee80211_frame *) skb->data;
+	int iswep = wh->i_fc[1] & IEEE80211_FC1_WEP;
+	int err = 0;
+	uint8_t rate = 0;
+	uint8_t rateset[8] =
+	    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
+	struct sm_tx_p *txp;
+	int i;
+
+	FN_ENTER;
+
+	/* encryption */
+	if (iswep) {
+		struct ieee80211_key *k;
+
+		/*
+		 * Construct the 802.11 header+trailer for an encrypted
+		 * frame. The only reason this can fail is because of an
+		 * unknown or unsupported cipher/key type. Be simple for
+		 * now: only use software encryption.
+		 */
+		k = ieee80211_crypto_encap(ic, ni, skb);
+		if (k == NULL) {
+			/*
+			 * This can happen when the key is yanked after the
+			 * frame was queued.  Just discard the frame; the
+			 * 802.11 layer counts failures and provides
+			 * debugging/diagnostics.
+			 */
+			printk(KERN_ERR "%s: crypto failure, dropping skb\n",
+			       DRV_NAME);
+			err = -EIO;
+			goto exit;
+		}
+
+		/* packet header may have moved, reset our local pointer */
+		wh = (struct ieee80211_frame *) skb->data;
+	}
+
+	/* type switch. This duplicates work as we should already know
+	 * if we have a mgmt frame. Anyways. */
+	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
+	case IEEE80211_FC0_TYPE_MGT:
+	case IEEE80211_FC0_TYPE_CTL:
+		/* default values for mgmt frames */
+		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
+		case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
+			/* send frame to probe slot, freeing the previously allocated probe
+			 * slot. The frame is emitted when a specific frequency change packet is
+			 * sent */
+			txp = &(islsm->smpar.probe);
+			break;
+		case IEEE80211_FC0_SUBTYPE_BEACON:
+			/* update the beacon reference ? */
+			txp = &(islsm->smpar.beacon);
+			break;
+		default:
+			txp = &(islsm->smpar.mgmt);
+			break;
+		}
+		/* common values for the mgmt frames */
+		break;
+
+	case IEEE80211_FC0_TYPE_DATA:
+		/* should do rate calculation */
+		txp = &(islsm->smpar.data);
+
+/* 		if (ic->ic_fixed_rate != -1) { */
+/* 			/\* contains if != -1 an index into the rates */
+/* 			   table provided by setup_rates. This is exactly */
+/* 			   what we want *\/ */
+/* 			rate = ic->ic_fixed_rate; */
+/* 		} */
+
+/* 		if (skb->len > ic->ic_rtsthreshold) { */
+/* //			rate |= ISLSM_TX_CTSONLY; */
+/* 			rate |= ISLSM_TX_RTSCTS; */
+/* 		} */
+
+		break;
+	default:
+		printk(KERN_ERR "%s: bad packet type\n", DRV_NAME);
+		/* We silently drop the skb without returning and error;
+		   therefore we free it */
+		dev_kfree_skb(skb);
+		err = 0;
+		goto exit;
+	}
+	/* try and see what magic4 and magic5 really mean */
+	/* do they mean that the tx must be done ASAP ? */
+	for (i = 0; i < 8; i++)
+		rateset[i] = rate;
+
+	err = islsm_data_tx(islsm, txp, skb);
+
+      exit:
+	/* we propagate the error,
+	   therefore do not free the skb */
+	FN_EXIT1(err);
+	return err;
+}
+
+/*
+ * Reset the hardware w/o losing operational state.  This is
+ * basically a more efficient way of doing ath_stop, ath_init,
+ * followed by state transitions to the current 802.11
+ * operational state.  Used to recover from errors rx overrun
+ * and to reset the hardware when rf gain settings must be reset.
+ */
+static int
+islsm_reset(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211com *ic = &islsm->sc_ic;
+	// What's the difference with ic->ni->... I don't know but i'll
+	// have to figure out for Ad-Hoc mode i guess
+	struct ieee80211_channel *chan = ic->ic_ibss_chan;
+	unsigned int channel = 0;
+
+	// Dirty code, should factor with newstate and mgtstart into a frequency
+	// change function that does all things needed...
+	uint16_t chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX;
+	uint16_t chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX;
+
+	FN_ENTER;
+
+	channel = ieee80211_mhz2ieee(chan->ic_freq, 0);
+	islsm_freq_change(islsm, channel, chan->ic_freq, chan_m1, chan_m2);
+
+	if (ic->ic_state == IEEE80211_S_RUN)
+		netif_wake_queue(netdev);	/* restart xmit */
+
+	FN_EXIT0;
+	return 0;
+}
+
+/*
+ * Setup driver-specific state for a newly associated node.
+ * Note that we're called also on a re-associate, the isnew
+ * param tells us if this is the first time or not.
+ */
+static void
+islsm_newassoc(struct ieee80211_node *ni, int isnew)
+{
+	(void) ni;
+	(void) isnew;
+	FN_ENTER;
+	FN_EXIT0;
+	return;
+}
+
+/*
+ * Callback from the 802.11 layer to update the
+ * slot time based on the current setting.
+ */
+static void
+islsm_updateslot(struct net_device *dev)
+{
+	(void) dev;
+	FN_ENTER;
+	FN_EXIT0;
+	return;
+}
+
+static int
+islsm_media_change(struct net_device *dev)
+{
+	int error;
+	FN_ENTER;
+
+	error = ieee80211_media_change(dev);
+	if (error == ENETRESET) {
+		if ((dev->flags & (IFF_RUNNING | IFF_UP)) ==
+		    (IFF_RUNNING | IFF_UP))
+			error = islsm_init(dev);
+		else
+			error = 0;
+		/* FIXME : why ? */
+		error = 0;
+	}
+
+	FN_EXIT1(error);
+	return error;
+}
+
+#else				/* MADWIFI */
+
+static int
+islsm_ioctl(struct net_device *ndev, struct ifreq *rq, int cmd)
+{
+	int error = -ENOTSUPP;
+	FN_ENTER;
+	FN_EXIT1(error);
+	return error;
+}
+
+static int
+islsm_init(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	int err = 0;
+
+	FN_ENTER;
+
+	/* resize skbs in monitor mode -- good idea, leave enough
+	 * headroom to fit the prism header */
+
+	/* tell the powers that be what we really are */
+	netdev->type = (islsm->ieee->iw_mode == IW_MODE_MONITOR) ?
+	    ARPHRD_IEEE80211 : ARPHRD_ETHER;
+
+	/* Hardware state machine reset */
+	/* this is not a reset */
+	err = islsm->isl_boot(netdev);
+	if (err) {
+		printk(KERN_ERR "%s: unable to boot device\n", DRV_NAME);
+		goto done;
+	}
+
+	err = islsm_eeprom_readback(islsm);
+	if (err) {
+		printk(KERN_ERR "%s: unable to readback the eeprom\n", DRV_NAME);
+		goto done;
+	}
+
+	/* initialize parameters
+	   once the readback is finished */
+	islsm_params_init(islsm);
+
+	(void) islsm_led_perm(islsm, LED_MODE_SET, LED_RED);
+	(void) islsm_led_temp(islsm, LED_GREEN, 25);
+
+	/* submit initial data on data pipe */
+	/* this seems to allow frequency change successfully */
+	islsm_outofband_msg(islsm,
+			    magicpkt_table[islsm->device_version].data,
+			    magicpkt_table[islsm->device_version].len);
+
+	islsm_mode_set_filter(netdev, islsm->ieee->iw_mode);
+
+	// Start the statistics update cycle
+//      mod_timer(&islsm->stats_update, jiffies + ((HZ * ISLSM_STATSTIME) / 1000));
+
+	if (islsm->last_chan == 0)	/* Nobody ran iwconfig ethX freq N */
+		islsm->last_chan = 1;
+	islsm_reset(netdev);
+
+	/* Tell others we're okay */
+	netdev->flags |= IFF_RUNNING;
+	netif_start_queue(netdev);
+
+	ieee80211softmac_start(netdev);
+
+	FN_EXIT1(0);
+	return 0;
+
+      done:
+	FN_EXIT1(err);
+	return err;
+}
+
+int islsm_mode_set_filter(struct net_device *netdev, int mode)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	int rc;
+
+	switch (mode) {
+	case IW_MODE_MONITOR:
+		rc = islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_MONITOR, netdev->broadcast,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_MONITOR,
+			ISLSM_TX_CONTROL_FILTER_MAGIC3_MONITOR,
+			0, 0);
+		if (rc != 0)
+			return rc;
+		break;
+
+	case IW_MODE_ADHOC:
+		/* Stolen from INFRA. Without this we only receive beacons. */
+		rc = islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, islsm->ieee->bssid,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM3, 1,
+			0, ISLSM_TX_CONTROL_FILTER_MAGIC9_FORM1);
+		if (rc != 0)
+			return rc;
+
+		/* INFRA uses NOTYPE, so skip ADHOC. */
+		rc = islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, islsm->ieee->bssid,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2,
+			ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1,
+			0, 0);
+		if (rc != 0)
+			return rc;
+		break;
+
+	case IW_MODE_INFRA:
+		rc = islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, netdev->broadcast,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM3, 1,
+			0, ISLSM_TX_CONTROL_FILTER_MAGIC9_FORM1);
+		if (rc != 0)
+			return rc;
+		// This one may not be necessary any more.
+		rc = islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, islsm->ieee->bssid,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2,
+			ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1,
+			0, 0);
+		if (rc != 0)
+			return rc;
+		break;
+
+	default:
+		;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(islsm_mode_set_filter);
+
+static int
+islsm_tx_start(struct net_device *netdev, struct sk_buff *skb)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct ieee80211_hdr_3addr *hdr3;
+	unsigned short frame_ctl;
+	struct sm_tx_p *txp;
+	int err;
+
+	hdr3 = (struct ieee80211_hdr_3addr *) skb->data;
+	frame_ctl = le16_to_cpu(hdr3->frame_ctl);
+
+	/* XXX Encryption goes here */
+
+	switch (WLAN_FC_GET_TYPE(frame_ctl)) {
+	case IEEE80211_FTYPE_MGMT:
+	case IEEE80211_FTYPE_CTL:
+		/* default values for mgmt frames */
+		switch (WLAN_FC_GET_STYPE(frame_ctl)) {
+		case IEEE80211_STYPE_PROBE_REQ:
+			/*
+			 * Send frame to probe slot, freeing the previously
+			 * allocated probe slot. The frame is emitted when
+			 * a specific frequency change packet is sent
+			 */
+			txp = &(islsm->smpar.probe);
+			break;
+		case IEEE80211_STYPE_BEACON:
+			/* update the beacon reference ? */
+			txp = &(islsm->smpar.beacon);
+			break;
+		default:
+			txp = &(islsm->smpar.mgmt);
+			break;
+		}
+		break;
+
+	case IEEE80211_FTYPE_DATA:
+		txp = &(islsm->smpar.data);
+		break;
+
+	default:
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	err = islsm_data_tx(islsm, txp, skb);
+	/* we propagate the error, therefore do not free the skb */
+	return err;
+}
+
+static int islsm_iee80211_xmit(struct ieee80211_txb *txb,
+    struct net_device *netdev, int pri)
+{
+	int i;
+	struct sk_buff *skb;
+
+	for (i = 0; i < txb->nr_frags; i++) {
+		skb = txb->fragments[i];
+		txb->fragments[i] = NULL; /* Take skb from ieee80211_txb_free */
+		if (islsm_tx_start(netdev, skb) != 0) {
+			dev_kfree_skb(skb);
+			break;
+		}
+	}
+	ieee80211_txb_free(txb);
+	return 0;	/* Always 0 for now. Flow control for ping -f here. */
+}
+
+static int islsm_reset(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	unsigned int chan = islsm->last_chan;
+	int freq;
+
+	// Dirty code, should factor with newstate and mgtstart into a frequency
+	// change function that does all things needed...
+	uint16_t chan_m1 = ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX;
+	uint16_t chan_m2 = ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX;
+
+	freq = islsm_chan_to_freq(chan);
+	islsm_freq_change(islsm, chan, freq, chan_m1, chan_m2);
+
+	/* mode = ISLSM_TX_CONTROL_FILTER_NOTYPE; */
+	/* (void) islsm_set_filter(netdev, mode, bssid,
+				magic2, magic3, magic8, magic9); */
+
+	return 0;
+}
+
+/*
+ * This is called from an eventd, but under spinlock. So, no GFP_KERNEL.
+ */
+static void islsm_set_bssid_filter(struct net_device *netdev, const u8 *bssid)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+
+	islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, bssid,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM3, 1,
+			0, ISLSM_TX_CONTROL_FILTER_MAGIC9_FORM1);
+
+	islsm_set_filter(islsm,
+			ISLSM_TX_CONTROL_FILTER_NOTYPE, bssid,
+			ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2,
+			ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1,
+			0, 0);
+}
+
+/* This is called from an eventd on the current softmac... */
+static void islsm_set_chan(struct net_device *netdev, u8 c)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+
+	/* XXX Semaphore here */
+	islsm_freq_change(islsm,
+			  c, islsm_chan_to_freq(c),
+			  ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX,
+			  ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX);
+	islsm->last_chan = c;
+}
+
+static void islsm_geo_init(struct ieee80211_device *ieee)
+{
+	struct ieee80211_geo geo;
+	struct ieee80211_channel *chan;
+	int i;
+	u8 channel;
+
+	memset(&geo, 0, sizeof(geo));
+
+	for (i = 0, channel = 1; channel < 15; channel++) {
+		chan = &geo.bg[i++];
+		chan->freq = islsm_chan_to_freq(channel);
+		chan->channel = channel;
+	}
+	geo.bg_channels = i;
+
+	strcpy(geo.name, "US ");	/* XXX J-B is in FR or EU. */
+
+	ieee80211_set_geo(ieee, &geo);
+}
+#endif				/* MADWIFI */
+
+struct net_device *
+alloc_islsm(int sizeof_priv)
+{
+	struct net_device *netdev;
+	struct islsm *islsm;
+#ifdef MADWIFI
+	struct ieee80211com *ic;
+	netdev = alloc_etherdev(sizeof(struct islsm)+sizeof_priv);
+#else
+	struct ieee80211_device *ieee;
+	netdev = alloc_ieee80211softmac(sizeof(struct islsm)+sizeof_priv);
+#endif				/* MADWIFI */
+	if (!netdev) {
+		printk(KERN_ERR "%s: Unable allocate netdevice.\n", DRV_NAME);
+		return NULL;
+	}
+
+	islsm = ISLSM_OF_NETDEV(netdev);
+	islsm->netdev = netdev;
+#ifndef MADWIFI
+	islsm->ieee = netdev_priv(netdev);
+	islsm->softmac = ieee80211_priv(netdev);
+#endif
+
+	/* fill netdevice callbacks */
+	netdev->open = &islsm_init;
+	netdev->stop = &islsm_close;
+	netdev->get_stats = &islsm_statistics;
+	netdev->do_ioctl = &islsm_ioctl;
+	netdev->hard_start_xmit = &islsm_transmit;
+
+	netdev->addr_len = ETH_ALEN;
+	netdev->hard_header_len =
+	    FULL_TX_CONTROL_ALLOCDATA + TX_MAX_PADDING +
+	    islsm->device_tx_header_space;
+	memcpy(netdev->dev_addr, dummy_mac, ETH_ALEN);
+/*      netdev->set_mac_address = &prism54_set_mac_address; */
+	netdev->watchdog_timeo = ISLSM_TX_TIMEOUT;
+	netdev->tx_timeout = &islsm_tx_timeout;
+
+#ifdef MADWIFI
+	netdev->get_wireless_stats = &islsm_wireless_stats;
+	ieee80211_ioctl_iwsetup(&islsm_iw_handler_def);
+#endif				/* MADWIFI */
+	/* check if this can be done right away. Race ? */
+	netdev->wireless_handlers = &islsm_iw_handler_def;
+
+#ifdef MADWIFI
+	/* fill madwifi callbacks */
+	islog(L_DEBUG, "%s: Start madwifi dev configuration\n", DRV_NAME);
+
+	ic = &islsm->sc_ic;
+
+	ic->ic_dev = netdev;
+	/* verbosity of the stack -- reduce a little */
+	ic->ic_debug = IEEE80211_MSG_ANY & (~IEEE80211_MSG_DUMPPKTS);
+	ic->ic_devstats = &islsm->statistics;
+
+
+	ic->ic_init = islsm_init;
+	ic->ic_reset = islsm_reset;
+	ic->ic_newassoc = islsm_newassoc;
+	ic->ic_updateslot = islsm_updateslot;
+
+	/* capabilities */
+	islsm_setup_freqs(ic);
+	islsm_setup_rates(netdev, IEEE80211_MODE_11B);
+	islsm_setup_rates(netdev, IEEE80211_MODE_11G);
+
+	/* XXX not right but it's not used anywhere important */
+	ic->ic_phytype = IEEE80211_T_OFDM;
+	ic->ic_opmode = IEEE80211_M_STA;
+	ic->ic_caps = IEEE80211_C_IBSS	/* ibss, nee adhoc, mode */
+	    | IEEE80211_C_HOSTAP	/* hostap mode */
+	    | IEEE80211_C_MONITOR	/* monitor mode */
+	    | IEEE80211_C_SHPREAMBLE	/* short preamble supported */
+	    | IEEE80211_C_SHSLOT	/* short slot time supported */
+	    | IEEE80211_C_TXPMGT	/* transmit power control */
+	    ;
+
+	/*
+	 * initialize management queue
+	 */
+	skb_queue_head_init(&ic->ic_mgtq);
+
+	/*
+	 * Indicate we need the 802.11 header padded to a
+	 * 32-bit boundary for 4-address and QoS frames.
+	 */
+	/* FIXME: not true in our devices where we can cope with
+	   misaligned frames */
+	ic->ic_flags |= IEEE80211_F_DATAPAD;
+
+	/* call MI attach routine. */
+	init_timer(&islsm->scan_ch);
+	islsm->scan_ch.function = islsm_next_scan;
+	islsm->scan_ch.data = (unsigned long) netdev;
+
+/* 	init_timer(&islsm->stats_update); */
+/* 	islsm->stats_update.function = islsm_stats_update; */
+/* 	islsm->stats_update.data = (unsigned long) netdev; */
+
+	ieee80211_ifattach(ic);
+
+	/* hooks into default methods */
+	islsm->ieee80211_newstate = ic->ic_newstate;
+	ic->ic_newstate = islsm_newstate;
+
+	/* complete initialization */
+	ieee80211_media_init(ic, islsm_media_change, ieee80211_media_status);
+#else
+
+	ieee = islsm->ieee;
+
+	ieee->iw_mode = IW_MODE_AUTO;	/* Needed? XXX */
+
+	ieee->modulation = IEEE80211_CCK_MODULATION;
+	ieee->mode = IEEE_B;
+	ieee->freq_band = IEEE80211_24GHZ_BAND;
+
+	islsm_geo_init(ieee);
+
+	/* default to sw encryption for now */
+	// bcm->ieee->host_build_iv = 0;
+	// bcm->ieee->host_encrypt = 1;
+	// bcm->ieee->host_decrypt = 1;
+
+	// ieee->tx_headroom = sizeof(struct bcm43xx_txhdr);
+	// ieee->set_security = bcm43xx_ieee80211_set_security;
+	ieee->hard_start_xmit = islsm_iee80211_xmit;
+
+	islsm->softmac->set_bssid_filter = islsm_set_bssid_filter;
+	islsm->softmac->set_channel = islsm_set_chan;
+#endif				/* MADWIFI */
+
+	/* LMAC initialization */
+	init_completion(&islsm->dev_init_comp);
+	islsm->minor = minor++;
+	spin_lock_init(&islsm->memory.slock);
+	INIT_LIST_HEAD(&islsm->memory.indevice_skbs);
+
+	return netdev;
+}
+// EXPORT_SYMBOL(alloc_islsm);
+
+/* Lightweight function to convert a frequency (in Mhz) to a channel number. */
+/*
+ * XXX This only serves B band currently. For A, the formula is:
+ *	channel = (freq - 5000) / 5;
+ */
+unsigned int islsm_freq_to_chan(int freq)
+{
+	unsigned char chan;
+
+	if (freq == 2484)
+		chan = 14;
+	else
+		chan = (freq - 2407) / 5;
+	return chan;
+}
+
+/* Lightweight function to convert a channel number to a frequency (in Mhz). */
+/*
+ * XXX This only serves B band currently. For A band, the formula is:
+ *	freq = 5000 + (5 * channel);
+ */
+int islsm_chan_to_freq(unsigned int chan)
+{
+	int freq;
+
+	if (chan == 14)
+		freq = 2484;
+	else
+		freq = 2407 + (5 * chan);
+
+	return freq;
+}
+
+void free_islsm(struct net_device *dev) {
+	struct islsm *islsm = ISLSM_OF_NETDEV(dev);
+#ifdef MADWIFI
+	ieee80211_ifdetach(&islsm->sc_ic);
+#endif
+	vfree(islsm->eeprom);
+	free_netdev(dev);
+	return;
+}
+// EXPORT_SYMBOL(free_islsm);
+
+int register_islsm(struct net_device *netdev) {
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+#ifdef MADWIFI
+	struct ieee80211com *ic = &islsm->sc_ic;
+#endif				/* MADWIFI */
+	int error;
+	int device_minor = islsm->minor;
+
+	islog(L_DEBUG, "%s: registering "
+	      "device %i, structure %p\n", DRV_NAME, device_minor, islsm);
+
+	error = register_netdev(netdev);
+	if (error) {
+		printk(KERN_WARNING "%s: unable to register netdevice\n",
+		       DRV_NAME);
+		goto out;
+	}
+
+	islog(L_DEBUG, "%s: Prism54 SoftMac device %i now attached to %s\n",
+	      DRV_NAME, device_minor, netdev->name);
+
+#ifdef MADWIFI
+#ifdef CONFIG_SYSCTL
+	ieee80211_sysctl_register(ic);
+#endif				/* CONFIG_SYSCTL */
+	ieee80211_announce(ic);
+#endif				/* MADWIFI */
+	return 0;
+
+ out:
+#ifdef MADWIFI
+	ieee80211_ifdetach(ic);
+#endif
+	return error;
+}
+// EXPORT_SYMBOL(register_islsm);
+
+void unregister_islsm(struct net_device *netdev) {
+#if ISL_DEBUG
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+#endif
+	islog(L_DEBUG, "%s: unregistering "
+	      "device %i, structure %p\n", DRV_NAME, islsm->minor, islsm);
+	unregister_netdev(netdev);
+}
+// EXPORT_SYMBOL(unregister_islsm);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_output.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_output.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_output.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_output.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,849 @@
+/*
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/vmalloc.h>
+
+#include "islsm_log.h"
+#include "isl_sm.h"
+#include "islsm_protocol.h"
+#include "islsm_alloc.h"
+
+static int
+islsm_tx_skb(struct sk_buff *skb)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(skb->dev);
+	int err;
+
+	/* We now have all the data to compute the CRC */
+	/* FIXME : move this down the pipeline -- at hardware level */
+	switch (islsm->fw_type) {
+	case ISLSM_FW_LM87:
+	{
+		u32 crc;
+		/* compute & write the CRC */
+		crc = islsm_crc((u32 *)skb->data, skb->len);
+		(void) skb_push(skb,sizeof(crc));
+	}
+	break;
+	default:
+		break;
+	};
+
+	BUG_ON( (long)skb->data & 3 );
+
+	err = islsm->isl_tx(skb);
+	if (err)
+		printk(KERN_ERR "%s: Hardware refused frame %p\n",
+		       "islsm", skb);
+
+	return err;
+}
+
+/* all, and only control packets, go through this function */
+static int
+islsm_make_prism_header_skb(struct sk_buff *skb, uint16_t type,
+			    uint16_t reqtype, u8 retry1, u8 retry2)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(skb->dev);
+	struct islsm_tx_control *islsm_txc;
+	uint32_t lmac_addr;
+	int len = skb->len;
+	int err;
+
+	islsm_txc = (void *) skb_push(skb, SIZE_TX_CONTROL);
+	islsm_txc->id.magic1 = cpu_to_le16(type);
+	islsm_txc->id.length = cpu_to_le16(len);
+	islsm_txc->type = cpu_to_le16(reqtype);
+	islsm_txc->retry1 = retry1;
+	islsm_txc->retry2 = retry2;
+
+	/* XXX : maybe 2.13 needs the checksum copied too */
+	err = islsm_alloc(&islsm->memory, skb);
+	if (err)
+		return err;
+
+	lmac_addr = LMAC_ADDR_OF_SKB(skb);
+	islsm_txc->req_id = lmac_addr;
+
+	err = islsm_tx_skb(skb);
+	if (err)
+		islsm_free(&islsm->memory, lmac_addr);
+
+	return err;
+}
+
+/* TX/RX/MODE packet */
+static
+    int
+islsm_make_rx_filter_skb(struct sk_buff *skb,
+			 uint16_t filter_type, const uint8_t *bssid,
+			 uint16_t magic2, uint32_t magic3,
+			 uint16_t magic8, uint16_t magic9)
+{
+	struct net_device *netdev = skb->dev;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct islsm_tx_control_filter *txcf;
+	unsigned int i;
+
+	txcf = (void *) skb_push(skb, SIZE_TX_CONTROL_FILTER);
+	memset(txcf, 0, sizeof (*txcf));
+
+	txcf->filter_type = cpu_to_le16(filter_type);
+	txcf->rxhw = cpu_to_le16(islsm->smpar.rxhw);
+
+	txcf->magic2 = cpu_to_le16(magic2);
+	txcf->magic3 = cpu_to_le32(magic3);
+	memcpy(txcf->rates, islsm->filter_rateset, sizeof (islsm->filter_rateset));
+	txcf->rx_addr = cpu_to_le32(islsm->rxframe_mem_start);
+
+	/* fixme: compute this cleverly */
+	if (islsm->device_version == ISLSM_DEVICE_USB_VER1) {
+		txcf->mru = cpu_to_le16(ISLSM_TX_CONTROL_FILTER_MAGIC7_VER1);
+	} else if (islsm->device_version == ISLSM_DEVICE_USB_VER2) {
+		txcf->mru = cpu_to_le16(ISLSM_TX_CONTROL_FILTER_MAGIC7_VER2);
+	} else {
+		/* PCI */
+		txcf->mru = cpu_to_le16(ISLSM_TX_CONTROL_FILTER_MAGIC7_PCI);
+	}
+
+	txcf->magic8 = cpu_to_le16(magic8);
+	txcf->magic9 = cpu_to_le16(magic9);
+
+	/* my mac address  */
+	memcpy(&txcf->destination[0], netdev->dev_addr, ETH_ALEN);
+
+	/* the other mac address */
+	for (i = 0; i < ETH_ALEN; i++)
+		txcf->source[i] = bssid[i];
+
+	/* what's next */
+	return islsm_make_prism_header_skb(skb,
+					   ISLSM_TX_CONTROL_NORESPONSE_ID,
+					   ISLSM_TX_CONTROL_TYPE_FILTER_SET, 0, 0);
+}
+
+/* Frequency change packet building */
+/* common filling */
+static void
+fill_basic_channel(struct islsm *islsm,
+		   struct islsm_tx_control_channel *tx_chan,
+		   unsigned int chan, unsigned int freq)
+{
+	/* we normalized this */
+	unsigned int array_index = chan;
+
+	if (islsm->finfo6[array_index].frequency != 0) {
+		/* the information was present */
+		tx_chan->freq = islsm->finfo6[array_index];
+	} else {
+#define IQ_PARAM_DEFAULT 0x8000U
+		/* fill with observed default value */
+		islog(L_PDA, "channel with only partial information "
+		      "in third array");
+/*
+  we could use the [0] as a repository for default values. for now
+  tx_chan->freq = islsm->finfo6[0];
+*/
+		tx_chan->freq.iq_param_1 = cpu_to_le16(IQ_PARAM_DEFAULT);
+		tx_chan->freq.iq_param_2 = cpu_to_le16(IQ_PARAM_DEFAULT);
+		tx_chan->freq.iq_param_3 = cpu_to_le16(IQ_PARAM_DEFAULT);
+		tx_chan->freq.iq_param_4 = cpu_to_le16(IQ_PARAM_DEFAULT);
+		tx_chan->freq.frequency = cpu_to_le16(freq);
+#undef IQ_PARAM_DEFAULT
+	}
+
+	/* This part remains to be understood ; i'm sure there are
+	   better approximations  */
+	tx_chan->pa_points_per_curve = islsm->pa_points_per_curve;
+
+	/* output levels that we want */
+	tx_chan->output_pwr_levels.val_barker = 0x38;
+	tx_chan->output_pwr_levels.val_bpsk   = islsm->output_pwr_limits[array_index].val_bpsk;
+	tx_chan->output_pwr_levels.val_qpsk   = islsm->output_pwr_limits[array_index].val_qpsk;
+	tx_chan->output_pwr_levels.val_16qam  = islsm->output_pwr_limits[array_index].val_16qam;
+	tx_chan->output_pwr_levels.val_64qam  = islsm->output_pwr_limits[array_index].val_64qam;
+
+	/* copy the curve data */
+	memcpy(tx_chan->curve_data, &islsm->finfo4[array_index],
+	       sizeof (islsm->finfo4[array_index]));
+}
+
+/* chan is the ieee channel number */
+static
+    int
+islsm_make_tx_control_channel_skb(struct sk_buff *skb, unsigned int chan,
+				  unsigned int freq, uint16_t magic1,
+				  uint16_t magic2)
+{
+	struct net_device *netdev = skb->dev;
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct islsm_tx_control_channel *tx_chan = 0;
+	size_t mysize;
+
+	mysize =
+	    islsm->device_version ==
+	    ISLSM_DEVICE_USB_VER1 ? SIZE_TX_CONTROL_CHANNEL :
+	    SIZE_TX_CONTROL_CHANNEL_VER2;
+
+	tx_chan = (void *) skb_push(skb, mysize);
+
+	memset(tx_chan, 0, sizeof (*tx_chan));
+
+	tx_chan->magic1 = cpu_to_le16(magic1);
+	tx_chan->magic2 = cpu_to_le16(magic2);
+
+	/* version 2 devices do not seem to use this ; comment out as i
+	 * don't understand what it means for now. I am under the
+	 * impression that during active scan this is wrong. */
+/* 	if (islsm_chan == 14 && magic1 == ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN) */
+/* 		tx_chan->magic1 |= cpu_to_le16(ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN_WRAP); */
+
+	fill_basic_channel(islsm, tx_chan, chan, freq);
+
+	/* version 2 devices. This is here to emphasize the difference.
+	   Of course it sits better in fill_basic_channel */
+	if (islsm->device_version != ISLSM_DEVICE_USB_VER1) {
+		/* FIXME : this is not a device_version problem but a
+		 * firmware version thing -- fix this */
+		struct islsm_tx_control_channel_ver2 *tx_chan2 = (void *) tx_chan;	/* only 4 bytes longer */
+		/* Copy at the end of the packet four limits... Don't
+		 * know why */
+		memcpy(&(tx_chan2->basic_packet.padding),
+		       &(tx_chan2->basic_packet.output_pwr_levels.val_bpsk),
+		       sizeof (tx_chan2->basic_packet.padding));
+		tx_chan2->padding = 0;
+	}
+
+	return islsm_make_prism_header_skb(skb,
+					   ISLSM_TX_CONTROL_NORESPONSE_ID,
+					   ISLSM_TX_CONTROL_TYPE_CHANNEL_CHANGE,
+					   0, 0);
+}
+
+static int
+islsm_make_control_led_skb(struct sk_buff *skb,
+			   uint16_t mode, uint16_t perm_setting,
+			   uint16_t temp_setting, uint16_t duration)
+{
+	struct islsm_tx_control_led *payload;
+
+	payload = (void *) skb_push(skb, SIZE_TX_CONTROL_LED);
+
+	payload->mode = cpu_to_le16(mode);
+	payload->led_setting_temporary = cpu_to_le16(temp_setting);
+	payload->led_setting_permanent = cpu_to_le16(perm_setting);
+	payload->temporary_setting_duration = cpu_to_le16(duration);
+
+	return islsm_make_prism_header_skb(skb,
+					   ISLSM_TX_CONTROL_NORESPONSE_ID,
+					   ISLSM_TX_CONTROL_TYPE_LED, 0, 0);
+}
+
+static
+    int
+islsm_make_freequeue_skb(struct sk_buff *skb, uint32_t lmac_addr)
+{
+	struct islsm_tx_control_freequeue *payload;
+
+	payload = (void *) skb_push(skb, SIZE_TX_CONTROL_FREEQUEUE);
+	payload->queue = cpu_to_le32(lmac_addr);
+
+	return islsm_make_prism_header_skb(skb,
+					   ISLSM_TX_CONTROL_NORESPONSE_ID,
+					   ISLSM_TX_CONTROL_TYPE_FREEQUEUE, 0, 0);
+}
+
+typedef int (* readback_t)(struct sk_buff *skb,
+			   unsigned offset, unsigned length);
+
+static int
+islsm_make_readback_skb(struct sk_buff *skb, unsigned offset, unsigned length)
+{
+	struct islsm_control_eeprom_lm86 *payload;
+	int err;
+
+	FN_ENTER;
+
+	payload = (void *) skb_push(skb, SIZE_CONTROL_EEPROM + length);
+
+	payload->offset = cpu_to_le16(offset);
+	payload->len = cpu_to_le16(length);
+	memset(payload->data, 0, length);
+
+	err = islsm_make_prism_header_skb(skb,
+					  ISLSM_ID_EEPROM_READBACK,
+					  ISLSM_TX_CONTROL_TYPE_EEPROM_READBACK,
+					  0, 0);
+
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+islsm_make_readback_skb_lm87(struct sk_buff *skb, unsigned offset, unsigned length) {
+	struct islsm_control_eeprom_lm87 *payload;
+	int err;
+
+	FN_ENTER;
+
+	payload = (void *) skb_push(skb, sizeof(*payload) + length);
+
+	payload->address = cpu_to_le32(offset);
+	payload->len = cpu_to_le16(length);
+	payload->unknown = cpu_to_le16(0xf);
+	payload->magic = cpu_to_le32(ISLSM_LOCK);
+	memset(payload->data, 0, length);
+
+	err = islsm_make_prism_header_skb(skb,
+					  ISLSM_ID_EEPROM_READBACK,
+					  ISLSM_TX_CONTROL_TYPE_EEPROM_READBACK,
+					  0, 0);
+
+	FN_EXIT1(err);
+	return err;
+}
+
+/* send packet, higly suboptimal version, and API will change.  I'd
+   really like to be able to ask the upper layers to send a skb with a
+   minimal headroom in it... */
+
+static int
+islsm_make_tx_datapkt_skb(struct sk_buff *skb, uint8_t padding, struct sm_tx_p *txp)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(skb->dev);
+	struct islsm_tx_control_allocdata *txd;
+	struct islsm_tx_control *islsm_txc;
+	/* Warning, the size field must be the size of the data payload,
+	   not the size of the payload + header */
+	unsigned size = skb->len;
+	uint16_t id_magic1;
+	int err;
+
+	/* As soon as we change the skb state, as is the case here,
+	   we cannot return an error, lest the skb is requeued */
+
+	txd = (void *) skb_push(skb, SIZE_TX_CONTROL_ALLOCDATA + padding);
+	memset(txd, 0, SIZE_TX_CONTROL_ALLOCDATA);
+
+	/* The fact that the length embeds the full header or not is
+	 * certainly specified in magic1 (so that we parse with no
+	 * backtrack) : find out how. See also examples on input */
+	txd->frame_type = cpu_to_le32(txp->frame_type);
+
+	txd->magic4 = cpu_to_le32(txp->magic4);
+	txd->magic5 = cpu_to_le32(txp->magic5);
+
+	memcpy(txd->rateset, txp->rateset, 8);
+
+	islsm_txc = (void *) skb_push(skb, SIZE_TX_CONTROL);
+
+	id_magic1 = txp->id_magic1;
+	if (padding) {
+		txd->frame_align[0] = padding;
+		id_magic1 |= ISLSM_TX_PAD_FLAG;
+	}
+
+	islsm_txc->id.magic1 = cpu_to_le16(id_magic1);
+	islsm_txc->id.length = cpu_to_le16(size);
+	islsm_txc->type = cpu_to_le16(txp->req_type);
+	islsm_txc->retry1 = txp->retry1;
+	islsm_txc->retry2 = txp->retry2;
+
+	islsm_alloc_set_flags(skb, ISLSM_ALLOC_FREE_ON_ACK);
+	err = islsm_alloc(&islsm->memory, skb);
+	if (err)
+		goto exit_free_skb;
+	islsm_txc->req_id = LMAC_ADDR_OF_SKB(skb);
+
+	err = islsm_tx_skb(skb);
+	if (!err)
+		return 0;
+
+	/* error path fall-through */
+	islsm_free(&islsm->memory, LMAC_ADDR_OF_SKB(skb));
+ exit_free_skb:
+	dev_kfree_skb(skb);
+	return 0;
+}
+
+/* functions for actual sending */
+static struct sk_buff *
+islsm_skb_alloc(struct islsm *islsm, size_t headroom, unsigned flags)
+{
+	struct net_device *ndev = NETDEV_OF_ISLSM(islsm);
+	struct sk_buff *skb;
+
+	skb = dev_alloc_skb(ISLSM_MAX_FRAME_SIZE + ISLSM_ALIGN_SPACE);
+	if (!skb)
+		return 0;
+
+	headroom += islsm->device_tx_header_space;
+
+	/* realign buffer */
+	/* This naturally makes sure that the beginning of the */
+	/* frame will be 32-bits aligned */
+	skb_push(skb, skb_headroom(skb));
+	skb_trim(skb, 0);
+	skb_reserve(skb, headroom);
+
+	skb->dev = ndev;
+	islsm_alloc_set_flags(skb, flags);
+
+	return skb;
+}
+
+static inline void
+islsm_skb_free(struct islsm *islsm, struct sk_buff *skb) {
+	dev_kfree_skb(skb);
+}
+
+static int
+islsm_config_readback(struct islsm *islsm,
+		      unsigned offset,
+		      unsigned *actual_length, unsigned length)
+{
+	struct sk_buff *eeprom_packet;
+	unsigned header_size, read_size;
+	int err;
+	readback_t readback_fill;
+
+	FN_ENTER;
+
+	switch(islsm->fw_type) {
+	case ISLSM_FW_LM86:
+	{
+		header_size = sizeof(struct islsm_control_eeprom_lm86);
+		readback_fill = islsm_make_readback_skb;
+	}
+	break;
+	case ISLSM_FW_LM87:
+	{
+		header_size = sizeof(struct islsm_control_eeprom_lm87);
+		readback_fill = islsm_make_readback_skb_lm87;
+		/* doesn't work with max value -- hangs on the last
+		 * packet of size 0x60 -- find the bug, it works for
+		 * the windows driver */
+		length = min((unsigned) 0x200, length);
+	}
+	break;
+	default:
+		err = -EINVAL;
+		goto exit;
+	}
+
+	read_size = min(length, ISLSM_MAX_CONTROL-header_size);
+	*actual_length = read_size;
+
+	eeprom_packet = islsm_skb_alloc(islsm,
+					header_size + read_size + SIZE_TX_CONTROL,
+					ISLSM_ALLOC_FREE_ON_RESPONSE);
+	if (!eeprom_packet)
+		return -ENOMEM;
+
+	err = readback_fill(eeprom_packet, offset, read_size);
+
+	if (err)
+		islsm_skb_free(islsm,eeprom_packet);
+
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+int
+islsm_set_filter(struct islsm *islsm,
+		 uint16_t filter_type, const uint8_t *bssid,
+		 uint16_t magic2, uint32_t magic3,
+		 uint16_t magic8, uint16_t magic9)
+{
+	struct sk_buff *filter_packet;
+	int err;
+
+	filter_packet = islsm_skb_alloc(islsm, FULL_TX_CONTROL_FILTER,
+					ISLSM_ALLOC_FREE_WHEN_SUBMITTED);
+	if (!filter_packet)
+		return -ENOMEM;
+
+	err = islsm_make_rx_filter_skb(filter_packet, filter_type,
+				       bssid, magic2, magic3, magic8, magic9);
+	if (err)
+		islsm_skb_free(islsm,filter_packet);
+	return err;
+}
+
+int
+islsm_stats_readback(struct islsm *islsm)
+{
+	struct sk_buff *stats_packet;
+	int err;
+
+	stats_packet = islsm_skb_alloc(islsm, 
+				       SIZE_TX_CONTROL + ISLSM_SIZE_STATS,
+				       ISLSM_ALLOC_FREE_ON_RESPONSE);
+	if (!stats_packet)
+		return -ENOMEM;
+
+	/* leave room for the device to write */
+	skb_push(stats_packet, ISLSM_SIZE_STATS);
+	err = islsm_make_prism_header_skb(stats_packet,
+					  ISLSM_ID_EEPROM_READBACK,
+					  ISLSM_TX_CONTROL_TYPE_STAT_READBACK,
+					  0, 0);
+	if (err)
+		islsm_skb_free(islsm,stats_packet);
+
+	return err;
+}
+
+int
+islsm_freq_change(struct islsm *islsm,
+		  uint16_t channel, uint16_t freq,
+		  uint16_t magic1, uint16_t magic2)
+{
+	struct sk_buff *channel_packet;
+	size_t mysize;
+	int err;
+
+	mysize =
+	    islsm->device_version ==
+	    ISLSM_DEVICE_USB_VER1 ? FULL_TX_CONTROL_CHANNEL :
+	    FULL_TX_CONTROL_CHANNEL_VER2;
+
+	/* to be checked, actually */
+	channel_packet = islsm_skb_alloc(islsm, mysize,
+					 ISLSM_ALLOC_FREE_WHEN_SUBMITTED);
+
+	if (!channel_packet)
+		return -ENOMEM;
+
+	err = islsm_make_tx_control_channel_skb(channel_packet,
+						channel, freq, magic1, magic2);
+	if (err)
+		islsm_skb_free(islsm,channel_packet);
+
+	return err;
+}
+
+int
+islsm_data_tx(struct islsm *islsm, struct sm_tx_p *txp,
+	      struct sk_buff *skb)
+{
+	struct net_device *netdev = NETDEV_OF_ISLSM(islsm);
+	int err = 0;
+	uint8_t padding = 0;
+	size_t headroom_needed = FULL_TX_CONTROL_ALLOCDATA + TX_MAX_PADDING +
+		islsm->device_tx_header_space;
+
+	/* FIXME: maybe this should be done beforehand */
+	skb->dev = netdev;
+
+	/* at this step we make use of the padding to realign
+	   beginning of the packet to a multiple of 32 bits */
+	padding = (uint8_t)((long) skb->data - FULL_TX_CONTROL_ALLOCDATA) & 3;
+	islog(L_SM_OUTPUT, "data length %i, padding %i\n", skb->len, padding);
+
+	/* TODO: once everything is sorted out, get rid of this check --
+	   skb_cow already does it */
+	if (skb_headroom(skb) < headroom_needed) {
+		/* This should not be triggered once we correctly set hard_header_len */
+		islog(L_DEBUG, "tx skb: headroom too small\n");
+	}
+	
+	/* skb_cow changes the skb state. Can we still return an error
+	   after this ? -- actually we never do this, but just in
+	   case, i'd like to know */
+	err = skb_cow(skb, headroom_needed);
+	if (err) {
+		islog(L_DEBUG, "dropped tx skb do to error on cow\n");
+		goto bad;
+	}
+
+	/* If the txqueue if full, then we should return an error, so
+	 * that the skb is freed, and free the lmac tx queue */
+	return islsm_make_tx_datapkt_skb(skb, padding, txp);
+
+      bad:
+	/* we propagate the error, therefore the upper layers
+	   are responsible for freeing the skb */
+	return err;
+}
+
+int
+islsm_empty_queue(struct islsm *islsm, uint8_t queue_id)
+{
+	struct sk_buff *free_packet;
+	int err;
+	/* to be checked */
+	free_packet = islsm_skb_alloc(islsm, FULL_TX_CONTROL_FREEQUEUE,
+				      ISLSM_ALLOC_FREE_WHEN_SUBMITTED);
+	err = islsm_make_freequeue_skb(free_packet, queue_id);
+	if (err)
+		islsm_skb_free(islsm,free_packet);
+	return err;
+}
+
+/* transmit a ping frame to the device -- freemac-testing purpose */
+int
+islsm_ping_device(struct islsm *islsm, unsigned length)
+{
+	struct sk_buff *ping_packet;
+	char *payload;
+	int err;
+
+	ping_packet = islsm_skb_alloc(islsm, SIZE_TX_CONTROL + length,
+				      ISLSM_ALLOC_FREE_ON_RESPONSE);
+	/* fill in the payload */
+	payload = (char *) skb_push(ping_packet, length);
+	memset(payload,0x69,length);
+	err = islsm_make_prism_header_skb(ping_packet, ISLSM_ID_EEPROM_READBACK,
+					  ISLSM_TX_CONTROL_TYPE_PING, 0, 0);
+	if (err)
+		islsm_skb_free(islsm,ping_packet);
+
+	return err;
+}
+EXPORT_SYMBOL(islsm_ping_device);
+
+/* transmits a raw frame to the device */
+int
+islsm_outofband_msg(struct islsm *islsm, void *buf, size_t size)
+{
+	struct sk_buff *skb = islsm_skb_alloc(islsm, 0,
+					      ISLSM_ALLOC_FREE_WHEN_SUBMITTED);
+	int err;
+
+	if (!skb)
+		return -ENOMEM;
+
+	memcpy(skb->data, buf, size);
+	skb_put(skb, size);
+
+	err = islsm_alloc(&islsm->memory, skb);
+	if (err)
+		return err;
+
+	err = islsm->isl_tx(skb);
+	if (err)
+		islsm_free(&islsm->memory, LMAC_ADDR_OF_SKB(skb));
+
+	return err;
+}
+
+static void
+timeout_complete(unsigned long data)
+{
+	struct islsm *islsm = (struct islsm *) data;
+	islsm->wait_flag = -ETIMEDOUT;
+	islog(L_DEBUG, "islsm: timeout waiting\n");
+	complete(&islsm->dev_init_comp);
+	return;
+}
+
+int
+islsm_wait_timeout(struct islsm *islsm, unsigned int delay)
+{
+	struct timer_list timer;
+
+	init_timer(&timer);
+	timer.expires = jiffies + delay;
+	timer.data = (unsigned long) (islsm);
+	timer.function = timeout_complete;
+
+	islsm->wait_flag = 0;
+
+	add_timer(&timer);
+	wait_for_completion(&islsm->dev_init_comp);
+	del_timer_sync(&timer);
+
+	return islsm->wait_flag;
+}
+
+EXPORT_SYMBOL(islsm_wait_timeout);
+
+/* this function reads back the serial eeprom contents via the feature
+ * built in intersil firmwares
+ */
+
+int
+islsm_eeprom_readback(struct islsm *islsm)
+{
+	const size_t eeprom_size = ISLSM_EEPROM_SIZE;
+	unsigned len = 0;
+	int remains;
+	int err = 0;
+
+	FN_ENTER;
+
+	/* We don't redo download if the eeprom has
+	   already been loaded */
+	if (islsm->eeprom)
+		goto out_noerr;
+
+	/* This allocate 8K, the size of the eeprom */
+	islsm->eeprom = vmalloc(eeprom_size);
+	if (!islsm->eeprom) {
+		err = -ENOMEM;
+		goto out_err;
+	}
+	islsm->eeprom_size = eeprom_size;
+
+	/* EEPROM seems to be always 8Kb */
+	remains = eeprom_size;
+
+	/* Each iteration will trigger a pipe response */
+	/* We got a problem here, Olivier's computer is too fast ! --
+	 * either we wait for the block to be returned, or we allocate
+	 * other pipes to make the requests */
+	while (remains > 0) {
+		/* try to read as much as possible, not exceeding
+		 * remains */
+		err = islsm_config_readback(islsm, eeprom_size - remains, &len, remains);
+		if (err)
+			goto out_err;
+
+		/* Wait for the device's response before returning :
+		 * we reuse the dev_init_comp semaphore */
+		err = islsm_wait_timeout(islsm, 2 * HZ);
+		if (err)
+			goto out_err;
+
+		remains -= len;
+	}
+
+	err = islsm_parse_eeprom(islsm);
+	if (!err) {
+		goto out_noerr;
+	}
+
+	printk(KERN_ERR "unable to parse the eeprom contents\n");
+ out_err:
+	vfree(islsm->eeprom);
+	islsm->eeprom = 0;
+ out_noerr:
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+islsm_conf_leds(struct islsm *islsm, 
+		uint16_t mode, uint16_t perm_setting,
+		uint16_t temp_setting, uint16_t duration) {
+	struct sk_buff *ledskb;
+	int err;
+
+	FN_ENTER;
+
+	ledskb = islsm_skb_alloc(islsm, FULL_TX_CONTROL_LED,
+				 ISLSM_ALLOC_FREE_WHEN_SUBMITTED);
+	if (!ledskb)
+		return -ENOMEM;
+
+	err = islsm_make_control_led_skb(ledskb, mode, perm_setting,
+					 temp_setting, duration);
+	if (err)
+		islsm_skb_free(islsm,ledskb);
+
+	FN_EXIT1(err);
+	return err;
+}
+
+/* make a temporary setting */
+int islsm_led_temp(struct islsm *islsm,
+		   uint16_t temp_setting, unsigned ms) {
+	unsigned setting = islsm->led_setting;
+	return islsm_conf_leds(islsm,
+			       islsm->led_mode, setting,
+			       setting ^ temp_setting, ms);
+}
+
+int islsm_led_perm(struct islsm *islsm,
+		   uint16_t mode, uint16_t perm_setting) {
+	islsm->led_mode = mode;
+	islsm->led_setting = perm_setting;
+	/* don't care if it does not succeed, this is non-critical
+	   and will be set right on the next call */
+	return islsm_conf_leds(islsm, mode, perm_setting, 0, 0);
+}
+
+static void __attribute__ ((unused))
+islsm_params_print(struct sm_tx_p *params)
+{
+#define PRINT_FIELD(name,type) printk(# name " is %" # type "\n", params->name )
+	PRINT_FIELD(ack_timer, i);
+	PRINT_FIELD(id_magic1, i);
+	PRINT_FIELD(req_type, i);
+	PRINT_FIELD(retry1, i);
+	PRINT_FIELD(retry2, i);
+/* 	PRINT_FIELD(rateset[8],i); */
+	PRINT_FIELD(magic4, i);
+	PRINT_FIELD(magic5, i);
+	PRINT_FIELD(frame_type, i);
+}
+
+/* fill default protocol values */
+void
+islsm_params_init(struct islsm *islsm)
+{
+#define FILL_TXP(txp,ack,id,r_type,w_r1,w_r2,m4,m5,f_type) \
+	{ \
+	(txp)->ack_timer = ack; \
+	(txp)->id_magic1 = id; \
+	(txp)->req_type = r_type; \
+	(txp)->retry1 = w_r1; \
+	(txp)->retry2 = w_r2; \
+	(txp)->magic4 = m4; \
+	(txp)->magic5 = m5; \
+	(txp)->frame_type = f_type; }
+
+	/* sending of data packets */
+	FILL_TXP(&(islsm->smpar.data),
+		 ISLSM_ACK_TIMER, ISLSM_TX_DATA_ID,
+		 ISLSM_TX_CONTROL_TYPE_DATAACK,
+		 7, 7,
+		 ISLSM_TX_FRAME_MAGIC4_MGMT, ISLSM_TX_FRAME_MAGIC5_MGMT,
+		 ISLSM_FRAME_DATA);
+
+	/* sending of probe packets */
+	FILL_TXP(&(islsm->smpar.probe),
+		 0, ISLSM_TX_MGMT_ID,
+		 ISLSM_TX_CONTROL_TYPE_DATANOACK,
+		 1, 1, 0, 0, ISLSM_FRAME_PROBE);
+
+	/* sending of beacon packets */
+	FILL_TXP(&(islsm->smpar.beacon),
+		 0, ISLSM_TX_BEACON_ID,
+		 ISLSM_TX_CONTROL_TYPE_DATANOACK,
+		 1, 1, 0, 0, ISLSM_FRAME_BEACON);
+
+	/* generic mgmt frame */
+	FILL_TXP(&(islsm->smpar.mgmt),
+		 ISLSM_ACK_TIMER, ISLSM_TX_MGMT_ID,
+		 ISLSM_TX_CONTROL_TYPE_DATAACK,
+		 7, 7,
+		 ISLSM_TX_FRAME_MAGIC4_MGMT, ISLSM_TX_FRAME_MAGIC5_MGMT,
+		 ISLSM_FRAME_MGMT);
+
+	/* other values ? */
+
+#undef FILL_TXP
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_pda.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_pda.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_pda.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_pda.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,433 @@
+/*
+  Production Data Area API for Conexant CX3110x chipset.
+
+  Copyright (C) 2004, 2005, 2006 Jean-Baptiste Note <jean-baptiste.note@m4x.org>
+
+  This file written with information gathered from code written for the
+  Nokia 770 and released at maemo.org, which is
+
+  Copyright (C) 2005 Nokia Corporation
+  Author: Samuel Ortiz <samuel.ortiz@nokia.com>
+
+  This file is part of islsm.
+
+  islsm is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your
+  option) any later version.
+
+  islsm is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with islsm; if not, write to the Free Software Foundation, Inc.,
+  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/types.h>
+#include <linux/unistd.h>
+#include <linux/string.h>
+#include <asm/errno.h>
+
+#include <linux/crc-ccitt.h>
+
+#include "isl_sm.h"
+#include "islsm_pda.h"
+#include "islsm_log.h"
+
+#define isl_pda_dump_bytes(d,l) if (isl_debug & L_PDA) { isl_dump_bytes((d),(l)); }
+
+static int pa_cal_output_pwr_option(struct islsm *islsm,
+				    struct wlan_pda_output_limit_rev0_s *dat,
+				    unsigned str_length);
+static int pa_cal_curve_data_option(struct islsm *islsm,
+				    struct wlan_pda_pa_curve_data_old_s *dat,
+				    unsigned str_length);
+static int tx_iq_cal_option(struct islsm *islsm,
+			    struct wlan_pda_iq_autocal_s *dat,
+			    unsigned str_length);
+
+static void pda_print_country(struct wlan_pda_country_s *country) {
+	islog(L_PDA, "Country %.2s, regdomain %02x\n",
+	      country->code, country->regulatory_domain);
+}
+
+static inline size_t pda_size(pda_entry_t *pda_rec) {
+	unsigned length = le16_to_cpu(pda_rec->size);
+	return (length + 1) * sizeof(uint16_t);
+}
+
+static inline pda_entry_t* next_pda(pda_entry_t *pda_rec) {
+	unsigned length = le16_to_cpu(pda_rec->size);
+	return (pda_entry_t*) (((uint16_t *) pda_rec) + length + 1);
+}
+
+static void pda_dump(pda_entry_t *pda_rec) {
+	uint16_t code = le16_to_cpu(pda_rec->code);
+	uint16_t size = le16_to_cpu(pda_rec->size);
+	islog(L_PDA, "Dump of option magic %04x\n", code);
+	isl_pda_dump_bytes(&pda_rec->code, size * sizeof (uint16_t));
+}
+
+static pda_entry_t *
+find_pda_start(eeprom_pda_wrap_t *mgmt_h) {
+	unsigned int pda_offset = le16_to_cpu(mgmt_h->data_length);
+	pda_entry_t *pda_e;
+	islog(L_PDA, "eeprom pda wrapper of %zd bytes\n", pda_offset + sizeof(*mgmt_h));
+	pda_e = (pda_entry_t *) &mgmt_h->data[pda_offset];
+	return pda_e;
+}
+
+static int pda_entry_end(pda_entry_t *pda_e) {
+	unsigned int code = le16_to_cpu(pda_e->code);
+	return (code == PDR_END);
+}
+
+static int pda_process_entry(struct islsm *islsm, pda_entry_t *pda_e) {
+#ifdef MADWIFI
+	struct ieee80211com *ic = &islsm->sc_ic;
+#endif
+	struct net_device *netdev = NETDEV_OF_ISLSM(islsm);
+	unsigned int size = le16_to_cpu(pda_e->size);
+	unsigned int code = le16_to_cpu(pda_e->code);
+	void *payload = pda_e->data;
+	unsigned str_length = (size - 1) * sizeof(uint16_t);
+
+	switch (code) {
+	case PDR_MANUFACTURING_PART_NUMBER:
+		islog(L_PDA, "Manufacturing part number: %.*s\n",
+		      str_length, (char *)payload);
+		break;
+	case PDR_PDA_VERSION:
+		islog(L_PDA, "PDA VERSION, never seen, please report\n");
+		pda_dump(pda_e);
+		break;
+	case PDR_NIC_SERIAL_NUMBER:
+		islog(L_PDA, "NIC S/N: %.*s\n",
+		      str_length, (char *)payload);
+		break;
+	case PDR_MAC_ADDRESS:
+		islog(L_PDA, "Device reported its MAC address\n");
+#ifdef MADWIFI
+		IEEE80211_ADDR_COPY(ic->ic_myaddr, payload);
+		IEEE80211_ADDR_COPY(netdev->dev_addr, payload);
+#else
+		memcpy(netdev->dev_addr, payload, ETH_ALEN);
+#endif				/* MADWIFI */
+		break;
+	case PDR_REGULATORY_DOMAIN_LIST:
+		islog(L_PDA, "Regulatory domain list, please report\n");
+		pda_dump(pda_e);
+		break;
+	case PDR_TEMPERATURE_TYPE:
+		islog(L_PDA, "Temperature type, please report\n");
+		pda_dump(pda_e);
+		break;
+	case PDR_PRISM_PCI_IDENTIFIER:
+		islog(L_PDA, "Prism PCI identifier, please report\n");
+		pda_dump(pda_e);
+		break;
+	case PDR_INTERFACE_LIST:
+	{
+		struct s_bootrec_exp_if *exp_if = payload;
+		int i;
+		int no = str_length / sizeof(struct s_bootrec_exp_if);
+
+		/* loop through, and display, the interfaces */
+		for(i = 0; i < no; i++) {
+			uint16_t if_id = le16_to_cpu(exp_if->if_id);
+			uint16_t if_variant = le16_to_cpu(exp_if->variant);
+#define IF_ID_F 0xf
+			if (if_id == IF_ID_F) {
+				/* I'm really at a loss to understand
+				   what's in there -- but it seems to
+				   work */
+				islsm->smpar.rxhw = (if_variant & 0x7);
+				islog(L_PDA,
+				      "Hardware rx informations:\n"
+				      "RX filter field %08x\n",
+				      islsm->smpar.rxhw);
+			}
+			islsm_print_exp_if(exp_if++,L_PDA);
+		}
+		break;
+	}
+	case PDR_HARDWARE_PLATFORM_COMPONENT_ID:
+	{
+		union wlan_pda_hw_platform *option = payload;
+
+		if (isl_debug & L_PDA) {
+			unsigned int hwtype = le32_to_cpu(option->hw);
+			islog(L_PDA,
+			      "Device reports hardware type: %08x\n",
+			      hwtype);
+			islog(L_PDA, "Device is an isl38%02x\n",
+			      option->split.isl);
+		}
+
+		break;
+	}
+	case PDR_COUNTRY_LIST:
+	{
+		int i;
+		struct wlan_pda_country_s *country = payload;
+		/* once we have this facilty in the stack, print actual
+		   country names */
+		islog(L_PDA,"List of domains for the device:\n");
+		for(i = 0; i < str_length / sizeof(uint32_t); i++)
+			pda_print_country(&country[i]);
+		break;
+	}
+	case PDR_DEFAULT_COUNTRY:
+	{
+		islog(L_PDA,"Default domain for the device:\n");
+		pda_print_country(payload);
+		break;
+	}
+	case PDR_ANTENNA_GAIN:
+	{
+		islog(L_PDA,"Antenna gain option for the device:\n");
+		pda_dump(pda_e);
+		break;
+	}
+	case PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS:
+		return pa_cal_output_pwr_option(islsm, payload, str_length);
+	case PDR_PRISM_PA_CAL_CURVE_DATA:
+		return pa_cal_curve_data_option(islsm, payload, str_length);
+	case PDR_RSSI_LINEAR_APPROXIMATION_DUAL_BAND:
+	{
+		islog(L_PDA,"RSSI linear approximation dual band:\n");
+		/* 8 bytes, I don't understand them -- certainly 4 * 16
+		 * bits, two scales, linear interpolation from the
+		 * custom value on 8 bits to Db. The first value is for
+		 * 0, the last for 255 (maybe rather the reverse).
+		 */
+		pda_dump(pda_e);
+		break;
+	}
+	case PDR_PRISM_ZIF_TX_IQ_CALIBRATION:
+		return tx_iq_cal_option(islsm, payload, str_length);
+	case PDR_RSSI_LINEAR_APPROXIMATION_EXTENDED:
+		/* do something */
+		pda_dump(pda_e);
+		break;
+	case PDR_END:
+	{
+		u16 crc = le16_to_cpu(*(u16 *)payload);
+		islog(L_PDA, "End of options, CRC is %04x\n", crc);
+		break;
+	}
+	default:
+		islog(L_PDA, "unknown option, please report your PDA\n");
+		pda_dump(pda_e);
+	}
+
+	return 0;
+}
+
+/*
+ * pda parsing function
+ */
+
+/* This slow function should be called when the pda, containing
+ * (among other things) calibration data for the RF stage, has been
+ * properly readback. On the N770, this is from flash in the main
+ * memory, for USB / PCI cards, this is in an eeprom chip located next
+ * to the ARM chip, and conneted to it on an i2c bus. See freemac for
+ * more information.
+ */
+
+static int islsm_parse_raw_pda(struct islsm *const islsm,
+			       pda_entry_t * const pda_e, const size_t length) {
+	int err;
+	pda_entry_t *current_pda = pda_e;
+	size_t pda_length = pda_size(current_pda);
+	uint16_t crc;
+
+	/* allow room for the next size lookup */
+	while (pda_length + sizeof(pda_entry_t) < length) {
+		err = pda_process_entry(islsm,current_pda);
+		if (err) {
+			printk(KERN_ERR "islsm: error parsing the pda; your device may be too recent. "
+			       "Please contact the developers.\n");
+			return err;
+		}
+		if (pda_entry_end(current_pda))
+			break;
+		current_pda = next_pda(current_pda);
+		pda_length += pda_size(current_pda);
+	}
+
+	/* Calculate CRC for the PDA -- on all but the crc field itself */
+	crc = ~crc_ccitt(0xffff, (char *)pda_e, pda_length - sizeof(uint16_t));
+
+	/* check it */
+	islog(L_PDA, "Computed CRC is %02x\n", crc);
+	if (crc != le16_to_cpu(*(uint16_t *)current_pda->data)) {
+		printk(KERN_ERR "PDA CRC Check failed\n");
+		return -EINVAL;
+	}
+
+	islsm->pda_length = pda_length;
+
+	return 0;
+}
+
+int
+islsm_parse_eeprom(struct islsm *islsm)
+{
+	eeprom_pda_wrap_t *eeprom = (void *) islsm->eeprom;
+	size_t length = islsm->eeprom_size;
+	pda_entry_t *pda_e;
+	size_t offset;
+	/* FIXME : should pass length, so that the function does not go
+	   too far */
+	pda_e = find_pda_start(eeprom);
+	offset = (uint8_t *) pda_e - (uint8_t *) eeprom;
+	islsm->pda_offset = offset;
+	return islsm_parse_raw_pda(islsm, pda_e, length - offset);
+}
+
+/* option-specific parsing functions */
+
+static int pa_cal_output_pwr_option(struct islsm *islsm,
+				    struct wlan_pda_output_limit_rev0_s *dat,
+				    unsigned str_length) {
+	uint8_t pdr_revision = dat->pdr_revision;
+	unsigned int nfreqs = dat->n_channels;
+	int i;
+
+	/* TODO: we have the information to use with the  */
+	if (pdr_revision != ORIGINAL_PDR1903_REV) {
+		printk(KERN_ERR "Unknown PDR1903 revision %i, please report your PDA\n",pdr_revision);
+		return -EINVAL;
+	}
+
+	islog(L_PDA, "PA calibration power limit option\n");
+	if (nfreqs > str_length / sizeof(struct wlan_pda_output_limits_channel_rev0_s)) {
+		printk(KERN_ERR "too many channels %i for %i bytes\n", nfreqs, str_length);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < nfreqs ; i++) {
+		unsigned frequency = le16_to_cpu(dat->power[i].frequency);
+		unsigned channel = islsm_ref_to_chan(frequency);
+
+		islog(L_PDA, "power limit for %iMHz, channel %i\n", frequency, channel);
+
+		if (channel >= ARRAY_SIZE(islsm->output_pwr_limits)) {
+			printk(KERN_ERR "channel %i out of range!\n", channel);
+			return -EINVAL;
+		}
+
+		islsm->output_pwr_limits[channel] = dat->power[i];
+	}
+	return 0;
+}
+
+static int tx_iq_cal_option(struct islsm *islsm,
+			    struct wlan_pda_iq_autocal_s *dat, unsigned str_length) {
+	unsigned int nfreqs = str_length / sizeof (struct wlan_pda_iq_autocal_s);
+	unsigned int j;
+	islog(L_PDA, "IQ calibration data has %i elements, for an option length of %i\n",
+	      nfreqs, str_length);
+	for (j = 0; j < nfreqs; j++) {
+		unsigned frequency = le16_to_cpu(dat[j].frequency);
+		unsigned channel = islsm_ref_to_chan(frequency);
+
+		islog(L_PDA, "calibration data for %iMHz, channel %i\n", frequency, channel);
+
+		if (channel >= ARRAY_SIZE(islsm->finfo6)) {
+			printk(KERN_ERR "channel %i out of range!\n", channel);
+			return -EIO;
+		}
+		islsm->finfo6[channel] = dat[j];
+	}
+	return 0;
+}
+
+static void pa_cal_rev0_to_rev1(struct wlan_pda_pa_curve_data_sample_rev1_s *to,
+				struct wlan_pda_pa_curve_data_sample_rev0_s *from)
+{
+	to->rf_power = from->rf_power;
+	to->pa_detector = from->pa_detector;
+	to->data_64qam = from->pcv;
+	/* "invent" the points for the other modulations */
+#define SUB(x,y) (uint8_t)((x) - (y)) > (x) ? 0 : (x) - (y)
+	to->data_16qam = SUB(from->pcv, 12);
+	to->data_qpsk  = SUB(to->data_16qam, 12);
+	to->data_bpsk  = SUB(to->data_qpsk, 12);
+	to->data_barker= SUB(to->data_bpsk, 14);
+#undef SUB
+}
+
+static int pa_cal_curve_data_option(struct islsm *islsm,
+				    struct wlan_pda_pa_curve_data_old_s *dat, unsigned str_length) {
+	struct wlan_pda_pa_curve_data_channel_old_s *entry = dat->curve_data;
+	unsigned int nfreqs = dat->n_channels;
+	unsigned int ppcurve = dat->points_per_channel;
+	unsigned cal_method = dat->cal_method_revision;
+	unsigned int i,j;
+
+	islog(L_PDA, "PA calibration curve data\n");
+	islog(L_PDA, "%i channels, %i points per curve per channel\n",
+	      nfreqs, ppcurve);
+
+	if (cal_method != ORIGINAL_PA_CAL_METHOD &&
+	    cal_method != GW_3887_PA_CAL_METHOD) {
+		printk(KERN_ERR "Unknown calibration method %i, please report your PDA\n",cal_method);
+		return -EINVAL;
+	}
+
+	/* FIXME : move to a dynamic point per curve, rather than our
+	 * fixed thing */
+	BUG_ON(ppcurve > ISLSM_POINTS_PER_CURVE);
+	islsm->pa_points_per_curve = ppcurve;
+
+	/* loop over all channels */
+	for (j = 0; j < nfreqs; j++) {
+		/* FIXME: depends on */
+		unsigned frequency   = le16_to_cpu(entry->frequency);
+		unsigned channel = islsm_ref_to_chan(frequency);
+
+		/* TODO: simply filter out unknown channels -- some
+		 * devices report 49 channels ! -- a,b,g are 30 channels
+		 */
+
+		if (channel >= ARRAY_SIZE(islsm->finfo4)) {
+			printk(KERN_ERR "channel %i out of range\n", channel);
+			return -EINVAL;
+		}
+
+		islog(L_PDA, "curve data for freq %iMHz, channel %i\n", frequency, channel);
+
+		if (cal_method == ORIGINAL_PA_CAL_METHOD) {
+			struct wlan_pda_pa_curve_data_sample_rev0_s *samples = &entry->curve_samples[0].rev0;
+			/* loop over all samples */
+			for (i = 0; i < ppcurve; i++) {
+				/* Invent some points for calibration curves */
+				pa_cal_rev0_to_rev1(&islsm->finfo4[channel][i].sample, &samples[i]);
+				islsm->finfo4[channel][i].padding = 0;
+			}
+			entry = (struct wlan_pda_pa_curve_data_channel_old_s *) &samples[ppcurve];
+		} else {
+			char *data;
+			struct wlan_pda_pa_curve_data_sample_rev1_s *samples = &entry->curve_samples[0].rev1;
+			for (i = 0; i < ppcurve; i++) {
+				islsm->finfo4[channel][i].sample = samples[i];
+				islsm->finfo4[channel][i].padding = 0;
+			}
+			/* get to the next frequency entry */
+			/* this will work with my device, but is this
+			 * solid ? -- skip one padding byte */
+			data = (char *) &samples[ppcurve];
+			data++;
+			entry = (struct wlan_pda_pa_curve_data_channel_old_s *) data;
+		}
+	}
+	return 0;
+}
+
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_pda.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_pda.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_pda.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_pda.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,294 @@
+/*
+ * Production Data Area API for Conexant CX3110x chipset.
+ *
+ * Copyright (C) 2005 Nokia Corporation
+ * Author: Samuel Ortiz <samuel.ortiz@nokia.com>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+#ifndef _ISLSM_PDA_H
+#define _ISLSM_PDA_H
+
+#include <linux/types.h>
+#include <linux/if_ether.h> /* for ETH_ALEN */
+
+#define UINT16_GET(p) (*(uint16_t *)(p))
+
+
+/*
+ * this files defines the PDR codes used to build PDAs as defined in document
+ * number 553155. The current implementation mirrors version 1.1 of the
+ * document and lists only PDRs supported by the ARM platform.
+ */
+
+/* common and choice range (0x0000 - 0x0fff) */
+#define PDR_END					0x0000
+#define PDR_MANUFACTURING_PART_NUMBER		0x0001
+#define PDR_PDA_VERSION				0x0002
+#define PDR_NIC_SERIAL_NUMBER			0x0003
+
+#define PDR_MAC_ADDRESS				0x0101
+#define PDR_REGULATORY_DOMAIN_LIST		0x0103
+#define PDR_TEMPERATURE_TYPE			0x0107
+
+#define PDR_PRISM_PCI_IDENTIFIER		0x0402
+
+/* ARM range (0x1000 - 0x1fff) */
+#define PDR_COUNTRY_INFORMATION			0x1000
+#define PDR_INTERFACE_LIST			0x1001
+#define PDR_HARDWARE_PLATFORM_COMPONENT_ID	0x1002
+#define PDR_OEM_NAME				0x1003
+#define PDR_PRODUCT_NAME			0x1004
+#define PDR_UTF8_OEM_NAME			0x1005
+#define PDR_UTF8_PRODUCT_NAME			0x1006
+#define PDR_COUNTRY_LIST			0x1007
+#define PDR_DEFAULT_COUNTRY			0x1008
+
+#define PDR_ANTENNA_GAIN			0x1100
+
+#define PDR_PRISM_INDIGO_PA_CALIBRATION_DATA	0x1901
+#define PDR_RSSI_LINEAR_APPROXIMATION		0x1902
+#define PDR_PRISM_PA_CAL_OUTPUT_POWER_LIMITS	0x1903
+#define PDR_PRISM_PA_CAL_CURVE_DATA		0x1904
+#define PDR_RSSI_LINEAR_APPROXIMATION_DUAL_BAND	0x1905
+#define PDR_PRISM_ZIF_TX_IQ_CALIBRATION     	0x1906
+#define PDR_REGULATORY_POWER_LIMITS             0x1907
+#define PDR_RSSI_LINEAR_APPROXIMATION_EXTENDED  0x1908
+#define PDR_RADIATED_TRANSMISSION_CORRECTION    0x1909
+#define PDR_PRISM_TX_IQ_CALIBRATION             0x190a
+
+/* reserved range (0x2000 - 0x7fff) */
+
+/* customer range (0x8000 - 0xffff) */
+#define PDR_BASEBAND_REGISTERS			0x8000
+#define PDR_PER_CHANNEL_BASEBAND_REGISTERS	0x8001
+
+/*
+ * regulatory domain codes as defined in IEEE 802.11
+ */
+#define REGDOMAIN_FCC		0x10
+#define REGDOMAIN_IC		0x20
+#define REGDOMAIN_ETSI		0x30
+#define REGDOMAIN_SPAIN		0x31
+#define REGDOMAIN_FRANCE	0x32
+#define REGDOMAIN_MKK		0x40    /* channel 14 only */
+#define REGDOMAIN_MKK13         0x41    /* channel 1 to 13 */
+
+#define MAX_ARM_PDR             32
+#define PDR_SIZE_LENGTH         2
+#define PDR_CODE_LENGTH         2
+
+
+/* In most of the chips, the pda is in an eeprom. There's a small
+   wrapper around the pda proper, which can be used to store init
+   data for the ROM */
+typedef struct eeprom_pda_wrap {
+	/* magic1 is always the same thing */
+#define EEPROM_START_MAGIC 0xaa554d47
+	uint32_t                magic1;
+	uint16_t                pad;
+	uint16_t                data_length;
+	uint32_t                arm_opcode;
+	uint8_t                 data[];
+} __attribute__ ((packed))
+eeprom_pda_wrap_t;
+
+typedef struct pda_entry_t_ {
+	uint16_t size;
+	uint16_t code;
+	char     data[];
+} __attribute__((packed)) pda_entry_t;
+
+/*
+ * PDR structures
+ */
+#define NUM_CHANNELS 13
+#define POINTS_PER_CHANNEL 6
+
+/* MAC address PDR 0x0101*/
+struct wlan_pda_mac_addr_s {
+	uint8_t	mac_addr[ETH_ALEN];
+};
+
+/* 1908, revision 08, seen on the Dell 1450 usb */
+/* Two of them, for the two bands, I guess */
+#define PERBAND_PDR1908_REV   0x08
+struct wlan_pda_rssi_cal_band_s {
+	/* three points, don't know what they really mean */
+	uint16_t rssi_A;
+	uint16_t rssi_B;
+	uint16_t rssi_LNA;
+} __attribute__ ((packed));
+
+/* RSSI PDR 0x1908, unknown revision */
+struct wlan_pda_rssi_cal_channel_s {
+	uint16_t frequency;
+	uint16_t rssi_A;
+	uint16_t rssi_B;
+	/* low noise amplifier */
+	uint16_t rssi_LNA;
+} __attribute__ ((packed));
+
+struct wlan_pda_rssi_cal_s {
+	uint8_t  pdr_revision;
+	uint8_t  xcvr_bmp;
+	struct wlan_pda_rssi_cal_channel_s rssi_data[];
+} __attribute__ ((packed));
+
+/* IQ calibration PDR 0x1906*/
+struct wlan_pda_iq_autocal_s {
+	uint16_t  frequency;
+	uint16_t  iq_param_1;
+	uint16_t  iq_param_2;
+	uint16_t  iq_param_3;
+	uint16_t  iq_param_4;
+} __attribute__ ((packed));
+
+
+/* Output limits PDR 0x1903 */
+struct wlan_pda_output_limits_channel_s {
+	uint16_t  frequency;
+	uint8_t   rate_set_mask;
+	uint8_t   rate_set_size;
+	unsigned short   limit_barker;
+	unsigned short   limit_bpsk;
+	unsigned short   limit_qpsk;
+	unsigned short   limit_16qam;
+	unsigned short   limit_64qam;
+} __attribute__ ((packed));
+
+#define PHASER_PDR1903_REV   0x01
+struct wlan_pda_output_limit_s {
+	uint8_t  pdr_revision;
+	uint8_t  xcvr_bmp;
+	uint8_t  n_pa_levels;
+	uint8_t  padding;
+	struct wlan_pda_output_limits_channel_s  power[];
+} __attribute__ ((packed));
+
+#define ORIGINAL_PDR1903_REV   0x00
+struct wlan_pda_output_limits_channel_rev0_s {
+	uint16_t  frequency;
+	uint8_t   val_bpsk;
+	uint8_t   val_qpsk;
+	uint8_t   val_16qam;
+	uint8_t   val_64qam;
+	/* don't really know what they are used for */
+	uint8_t   rate_set_mask;
+	uint8_t   rate_set_size;
+} __attribute__ ((packed));
+
+struct wlan_pda_output_limit_rev0_s {
+	uint8_t  pdr_revision;
+	uint8_t  n_channels;
+	struct wlan_pda_output_limits_channel_rev0_s  power[];
+} __attribute__ ((packed));
+
+
+/* PA Curve data PDR 0x1904 */
+struct wlan_pda_pa_curve_data_sample_s {
+	uint16_t  rf_power;
+	/* power amplifier detector */
+	uint16_t  pa_detector;
+	/* phase center variation */
+	uint16_t  pcv;
+} __attribute__ ((packed));
+
+struct wlan_pda_pa_curve_data_channel_s {
+	uint16_t frequency;
+	uint16_t ladder;
+	uint8_t  rate_set_mask;
+	uint8_t  rate_set_size;
+	struct wlan_pda_pa_curve_data_sample_s curve_samples [];
+} __attribute__ ((packed));
+
+#define PHASER_PA_CAL_METHOD   0x03
+struct wlan_pda_pa_curve_data_s {
+	uint8_t  cal_method_revision;
+	/* transciever */
+	uint8_t  xcvr_bmp;
+	uint8_t  points_per_channel;
+	uint8_t  padding;
+	struct wlan_pda_pa_curve_data_channel_s curve_data[];
+} __attribute__ ((packed));
+
+#define ORIGINAL_PA_CAL_METHOD   0x00
+#define GW_3887_PA_CAL_METHOD    0x01
+
+struct wlan_pda_pa_curve_data_sample_rev1_s {
+	uint8_t   rf_power;
+	uint8_t   pa_detector;
+	/* maybe pcv, maybe something else */
+	uint8_t   data_barker;
+	uint8_t   data_bpsk;
+	uint8_t   data_qpsk;
+	uint8_t   data_16qam;
+	uint8_t   data_64qam;
+} __attribute__ ((packed));
+
+struct wlan_pda_pa_curve_data_sample_rev0_s {
+	/* comparing with the N770 structures yields these meanings for
+	 * the data samples -- but i'm unsure -- the rev1 sample has
+	 * another interpretation */
+	uint8_t                 rf_power;
+	uint8_t                 pa_detector;
+	uint8_t                 pcv;
+} __attribute__ ((packed));
+
+union wlan_pda_pa_curve_data_sample_old_s {
+	struct wlan_pda_pa_curve_data_sample_rev0_s rev0;
+	struct wlan_pda_pa_curve_data_sample_rev1_s rev1;
+};
+
+struct wlan_pda_pa_curve_data_channel_old_s {
+	uint16_t frequency;
+	union wlan_pda_pa_curve_data_sample_old_s curve_samples[];
+} __attribute__ ((packed));
+
+struct wlan_pda_pa_curve_data_old_s {
+	uint8_t  cal_method_revision;
+	uint8_t  n_channels;
+	uint8_t  points_per_channel;
+	uint8_t  padding;
+	struct wlan_pda_pa_curve_data_channel_old_s curve_data[];
+} __attribute__ ((packed));
+
+/* entries in PDR 0x1007 and PDR 0x1008 for the Dell 1450.  I don't
+   really know yet how to discriminate these from the entries of the
+   type below -- probably on the first byte */
+struct wlan_pda_country_s {
+	uint8_t something;
+	uint8_t code[2];
+	uint8_t regulatory_domain;
+} __attribute__ ((packed));
+
+/* Default country PDR 0x1008 */
+struct wlan_pda_default_country_s {
+	uint8_t regulatory_domain;
+	uint8_t country_code[3];
+} __attribute__ ((packed));
+
+/* PDR 0x1002 */
+struct wlan_pda_hw_platform_split {
+	uint8_t                 unk1;
+#define HW_UNK1 0x03
+	uint8_t                 isl;
+#define HW_3887 0x87
+#define HW_3880 0x86
+#define HW_3886 0x80
+#define HW_3890 0x90
+#define HW_3892 0x92
+	uint16_t                unk2;
+#define HW_UNK2 0x5501
+} __attribute__ ((packed));
+
+union wlan_pda_hw_platform {
+	uint32_t hw;
+	struct wlan_pda_hw_platform_split split;
+};
+
+#endif /* _ISLSM_PDA_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_protocol.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_protocol.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_protocol.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,700 @@
+/*
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAVE_PROTOCOL_H
+#define _HAVE_PROTOCOL_H
+
+#ifdef __linux__
+#include <linux/types.h>
+#include <linux/if_ether.h>
+#endif				/* __linux__ */
+
+#include "islsm_pda.h"
+
+/**** protocol parameters ****/
+/* hardware versions */
+enum islsm_versions {
+	ISLSM_DEVICE_USB_VER1 = 0,
+	ISLSM_DEVICE_USB_VER2,
+	ISLSM_DEVICE_PCI_VER1,
+};
+
+/* firmware versions */
+enum islsm_fw_type {
+	ISLSM_FW_LM86 = 0,
+	ISLSM_FW_LM87,
+	ISLSM_FW_FMAC,
+};
+
+#define ISLSM_TX_TIMEOUT		(HZ/10)
+#define ISLSM_ACK_TIMEOUT               (HZ*512/1000)
+
+#define ISLSM_ACK_TIMER         0x1
+
+/* softmac management for isl 802.11g devices. For now this softmac
+ * relies on the madwifi stack. Plan is to port is to the hostap API.
+ * If you would like to do this, please contact me */
+
+/* Control frames are at maximum 0x400 + header space */
+#define ISLSM_MAX_FRAME_SIZE	2048
+#define ISLSM_MAX_CONTROL       0x400
+/* we need 3 bytes more for alignment purposes */
+#define ISLSM_ALIGN_SPACE       3
+#define ISLSM_RXSPACE           0x3500
+
+/*
+   The sm_tx_p structure contains the values used to fill the header of
+   a 802.11 packet sent to the device.  We maintain for now four sets of
+   such parameters for data, mgmt, beacon and probe packets.
+*/
+
+struct sm_tx_p {
+	/* flag : are we expecting an ack ? */
+	int                     ack_timer;
+	/* type of packet */
+	uint32_t                id_magic1;
+	/* value filled in the first byte of a tx data packet */
+	/* maybe this one is only the rts/cts rate */
+	uint16_t                req_type;
+	u8                      retry1;
+	u8                      retry2;
+//	uint16_t                flags;
+	uint8_t                 rateset[8];
+	/* value filled in the rateset parameter */
+	uint32_t                magic4;
+	uint32_t                magic5;
+	/* value filled in the type parameter */
+	uint8_t                 frame_type;
+};
+
+/*
+   The sm_filter_p structure contains the values used to fill the rx_tx
+   filter sent to the device.  We maintain for now three sets of such
+   parameters for different states of the 802.11 stack: assoc, scan,
+   master.
+*/
+
+struct sm_filter_p {
+	/* these are expected to be timeouts, but no idea really */
+	uint16_t                rxtx_timeout1;
+	uint16_t                rxtx_timeout2;
+};
+
+/*
+   The sm_p structure summarizes all unknown or half-guessed values used
+   in the driver for all kinds of packets.
+ */
+
+struct sm_p {
+	/*** rx/tx filter parameters ***/
+	/* some rx/tx filter value common to all packets */
+	uint16_t                rxhw;
+	struct sm_filter_p      assoc;
+	struct sm_filter_p      scan;
+	struct sm_filter_p      master;
+
+	/*** data tx packets parameters ***/
+	struct sm_tx_p          data;
+	struct sm_tx_p          mgmt;
+	struct sm_tx_p          beacon;
+	struct sm_tx_p          probe;
+};
+
+/* These should be read from the mgmt frame
+   I don't really know where they are located...
+*/
+#define ISLSM_NR_CHANNELS 14
+#define ISLSM_NR_RATES 12	/* from what i can read in the packets */
+
+/* rate information */
+/* this rate table is actually present in the firmware header.
+   Learn how to exctract it precisely */
+#define ISLSM_TX_CTSONLY  0x20	/* set this flag and the device will CTS */
+#define ISLSM_TX_RTSCTS   0x10	/* set this flag and the device will RTS */
+
+#define ISLSM_TX_UNK1 0x10	/* i don't know what this means actually */
+
+/* this seems to be present
+   in all kinds of frames
+   received on data and mgmt pipes */
+struct islsm_rx {
+	uint16_t                length;
+	uint8_t                 padding[14];
+	char                    data[];
+} __attribute__ ((packed));
+
+#define SIZE_RX sizeof(struct islsm_rx)
+
+/* the tx'd packets start with a destination on 32 bits, we'll call that
+   their "queue" hereafter */
+struct islsm_tx {
+	uint32_t                arm_addr;
+/* until i sort out what this means... */
+/* #define ISLSM_TX_QUEUE_CONFIG     0x00020200 */
+/* #define ISLSM_TX_QUEUE_ZERO       0x0002006c */
+/* #define ISLSM_TX_QUEUE_ZERO_VER2  0x00020070 */
+
+//#define ISLSM_TX_CONTROL_FILTER_MAGIC6_VER1 0x02480c
+//#define ISLSM_TX_CONTROL_FILTER_MAGIC6_VER2 0x024214
+//#define ISLSM_TX_CONTROL_FILTER_MAGIC6_PCI  0x024790
+
+/*
+The variable part is at the same location in v2 devices
+0x00020670
+0x00020770
+*/
+	uint16_t                length;
+#define ISLSM_MGMT_FOLLOWUP    0x2
+	uint16_t                follower;
+	uint8_t                 padding[8];
+} __attribute__ ((packed));
+
+#define SIZE_NET2280_H sizeof(struct islsm_tx)
+
+/* newer header, seen in DELL 1450 a/b/g usb dongle -- for lm87
+ * firmwares.
+ *
+ * The hardware encapsulation also has changes for the 3887
+ * with these newer firmwares -- the address is put right into the
+ * packet, instead of having one packet for itself.
+ *
+ * All of this is to be checked for PCI and USB + net2280
+ */
+typedef struct islsm_lm87_hdr {
+	/* the following checksum seems computed on the data payload,
+	   including any padding that may have been added (ie, raw
+	   packet size minus 4 bytes, not the size present in the
+	   following fields) */
+	u32      checksum;
+	char     data[];
+} islsm_lm87_hdr_t;
+
+/* custom Intersil CRC routine, used for all packets in very recent
+   firmwares (still have to sort out how to distinguish them from the
+   ones evoked below). Probably standard CRC32. Yes, connexant has
+   better things to do than to make reverse-engeneering difficult. */
+static inline u32
+islsm_crc(const u32 *data, size_t length) {
+	size_t i;
+	u32 crc = 0;
+	for(i = 0; i < length; i+=4) {
+		crc ^= *data++;
+		crc = (crc >> 5) ^ (crc << 3);
+	}
+	return crc;
+}
+
+/*
+ * This version of the checksum is used for instance in the 2.6.X.X,
+ * lm86 series, where it is used to checksum only the data packets.
+ * Unfortunately I can't seem to be able to put my hands on such a
+ * firmware image...
+ */
+static inline u32
+islsm_crc_data(const u8 *data, size_t length) {
+	size_t i;
+	u32 crc = 0;
+	for(i = 0; i < length; i+=4) {
+		crc ^= *data++;
+		crc = (crc >> 5) ^ (crc << 3);
+	}
+	return crc;
+}
+
+/*
+ * structure accounting for the different queues a prio queue would
+ * probably be better. Must be able to link between queue and packet, so
+ * that a tx timeout can reclaim a tx'd packet asynchronously (does the
+ * 802.11 stack allow this ?)
+ */
+#define ISLSM_TX_QUEUE_MASK       0xF
+#define ISLSM_TX_QUEUE_TX(x) (((x & ISLSM_TX_QUEUE_MASK) << 8) | islsm->smpar.datatx_reg)
+#define ISLSM_TX_QUEUE_ID(x) (((x) >> 8) & ISLSM_TX_QUEUE_MASK)
+/* this is observed maximum, i really don't know */
+#define ISLSM_NR_TX_QUEUES 4
+
+/* pimfor from the main driver. */
+/* Guess what : same size, 12 bytes */
+/*
+typedef struct {
+	uint8_t  version;
+	uint8_t  operation;
+	uint32_t oid;
+	uint8_t  device_id;
+	uint8_t  flags;
+	uint32_t length;
+} __attribute__ ((packed))
+pimfor_header_t;
+*/
+
+/* the length should be the length of data *after* the header we're in */
+struct islsm_id {
+/* actually 2*uint8_t, channel + flags */
+	uint16_t                magic1;
+/* TX magic numbers */
+#define ISLSM_TX_MGMT_ID   0x0000
+#define ISLSM_TX_BEACON_ID 0x0002
+/* sometimes data packets begin like this */
+#define ISLSM_TX_DATA_ID   0x0010
+#define ISLSM_TX_PAD_FLAG  0x4000
+
+/* Actually i think all bits in the first byte are meaningless and are
+ * copied indiscriminately in the response packet. But looking at data
+ * transactions, i'm not so confident... */
+#define ISLSM_IC_FLAG_FREE              0x01
+#define ISLSM_IC_TYPE_CTRL              0x80
+
+#define ISLSM_TX_CONTROL_NORESPONSE_ID  0x8001
+#define ISLSM_ID_EEPROM_READBACK        0x8000
+#define ISLSM_ID_FAULT                  0x4d00
+
+#define ISLSM_MGMT_FRAME              (1<<15)
+#define ISLSM_DATA_FRAME              (1<<14)
+/*
+ * Set this bit if you don't want any response on the mgmt pipe. Usually
+ * this is OK for settings only echoing their result (rx/tx filter
+ * packets, frequency change packets
+ */
+/* get = 0 / set = 1
+   must try get with zeroed buffer (i didn't try this !) !!!  */
+#define ISLSM_ID_NO_MGMT_RESPONSE     (1 << 0)
+/* this flag is an unknown quantity for me.
+   seems usefull only for sending data  */
+#define ISLSM_ID_UNKNOWN              (1 << 4)
+
+/* The following magic numbers are coming along with data packets.
+   We need to understand better what they mean so we get rid of this
+   list */
+
+// maybe means trap response too ?
+#define ISLSM_ID_FCS_OK   (1 << 0)
+#define ISLSM_ID_MASK     (0xff00)
+#define ISLSM_ID_MGMT_PKT               0x0100
+#define ISLSM_ID_DATA_PKT               0x0000
+
+/* provide an example capture */
+/* seen in non-monitor mode : 0x4c,0x54,0x5c,0x52 */
+/* seen in real monitor mode : 0xb0,0xa0,0x84,0x80,0x70,
+   0x74,0x60,0x64,0x4c,0x48,0x44,0x40,0x04,0x00 */
+#define ISLSM_DATA_PKT_ACK  (1<<7)
+	uint16_t                length;
+} __attribute__ ((packed));
+
+/* this is from the main driver. Guess what. 20 bytes. */
+struct rfmon_header {
+	uint16_t                unk0;	/* = 0x0000 */
+	uint16_t                length;	/* = 0x1400 */
+	uint32_t                clock;	/* 1MHz clock */
+	uint8_t                 flags;
+	uint8_t                 unk1;
+	uint8_t                 rate;
+	uint8_t                 unk2;
+	uint16_t                freq;
+	uint16_t                unk3;
+	uint8_t                 rssi;
+	uint8_t                 padding[3];
+} __attribute__ ((packed));
+
+/* packets wrapping a received 802.11 packet */
+struct islsm_rx_packet_header {
+	/* This first field to be put above */
+	struct islsm_id         id;
+	uint16_t                freq;	/* frequency, in MHz, le */
+	uint8_t                 unknown1;
+	uint8_t                 rate;	/* rate, same as specified for rateset on tx  */
+	uint8_t                 signal_strength;	/* , in ?, le. Not sure about the meaning of the first byte, really */
+	uint8_t                 padding2;
+	uint16_t                unknown2;	/* this should not be hard -- noise ? Seems to
+						 * be timestamp in master mode */
+	uint64_t                timestamp;	/* timestamp, in microsec, le */
+} __attribute__ ((packed));
+
+#define SIZE_RX_HEADER sizeof(struct islsm_rx_packet_header)
+
+/* the above islsm_tx and islsm_rx headers often wrap this kind of packets */
+struct islsm_tx_control {
+	struct islsm_id         id;
+	/* req_d precision : The device doesn't like them to be
+	 * mangled. Be sure that they are _unique in the device_ ! it's
+	 * used internally too, so sending two packets with the same
+	 * req_id will confuse the device. Beware ! */
+	/* small addition : in the driver, as a control packet is
+	 * reserved, most control frames, using the bottom
+	 * lmac address have this set to 0 */
+	uint32_t                req_id;
+	/* actually this is 2 16-bit fields */
+	uint16_t                type;
+	/* types of control frames */
+#define ISLSM_TX_CONTROL_TYPE_FILTER_SET        0x0
+#define ISLSM_TX_CONTROL_TYPE_CHANNEL_CHANGE    0x1
+#define ISLSM_TX_CONTROL_TYPE_FREQDONE          0x2
+#define ISLSM_TX_CONTROL_TYPE_FREEQUEUE         0x7
+#define ISLSM_TX_CONTROL_TYPE_TXDONE            0x8
+#define ISLSM_TX_CONTROL_TYPE_PING              0x9
+#define ISLSM_TX_CONTROL_TYPE_STAT_READBACK     0xa
+#define ISLSM_TX_CONTROL_TYPE_EEPROM_READBACK   0xc
+#define ISLSM_TX_CONTROL_TYPE_LED               0xd
+
+	/* types of data frames -- I still don't know what they mean */
+#define ISLSM_TX_CONTROL_TYPE_DATANOACK	       0x0
+#define ISLSM_TX_CONTROL_TYPE_DATAACK	       0x1
+#define ISLSM_TX_CONTROL_TYPE_TXVER2           0x8000
+
+/*
+  Firmware has an auto-retry mechanism. Each of these bytes is a retry
+  counter. When a TX fails (for various reasons, and at various
+  points), its tx retry counter is increased and compared to the values
+  below (there are two reasons for TX fails, each yielding an increase
+  in two different counters). When the retry count exceeds the maximum
+  allowed, the packet is dismissed.
+  The retry count is used as an offset into the rate table which follows
+  (field rateset of struct islsm_tx_control_allocdata below). Thus, the
+  retry mechanism allows to lower the rate of the retry, which is
+  supposed to be nice (lower rate = greater chance of successful TX).
+*/
+/*
+  FIXME: this should move this to the structure below. Would cut on data
+  passed to islsm_make_prism_header_skb, and be more logical. Maybe.
+*/
+	u8                      retry1;
+	u8                      retry2;
+#define ISLSM_TX_CONTROL_FLAGS_ACK              0x0707
+#define ISLSM_TX_CONTROL_FLAGS_NOACK	       0x0101
+	char                    data[];
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL sizeof(struct islsm_tx_control)
+
+/*
+ * Frequency setting packet
+ */
+
+#define ISLSM_POINTS_PER_CURVE 8
+
+struct fw_out_levels {
+	uint8_t                 val_barker;
+	uint8_t                 val_bpsk;
+	uint8_t                 val_qpsk;
+	uint8_t                 val_16qam;
+	uint8_t                 val_64qam;
+} __attribute__ ((packed));
+
+struct fw_cal_data_sample {
+	struct wlan_pda_pa_curve_data_sample_rev1_s sample;
+	/* zero-padded */
+	uint8_t                 padding;
+} __attribute__ ((packed));
+
+struct islsm_tx_control_channel {
+	/* This is a bitfield */
+	uint16_t                magic1;
+	/* this is a timing -- maybe CIFS, beacon interval, dwell time ? */
+	uint16_t                magic2;
+/* Setting when passive-scanning */
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN          0x2
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC2_SCAN          0x78
+// OR with default scan values when reaching channel 14
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SCAN_WRAP     0x8
+
+/* Setting when active-scanning.
+ * Such a frequency change packet triggers
+ * the emission of the packet in slot ISLSM_FRAME_PROBE
+ */
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC1_EMIT_TXSLOT    0x6
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC2_EMIT_TXSLOT    0x28
+
+/* TX mode. When in this mode, subsequent TX packets with mode
+ * ISLSM_FRAME_DATA, ISLSM_FRAME_MGMT, ISLSM_FRAME_BEACON are directly
+ * emitted. A correct tx/rx filter is needed for BEACON type.
+ */
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC1_TX            0x1
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC2_TX              0
+
+/* This mode is used in ad-hoc mode, when you want to emit a packet
+ * (null data in dabe's log) while still scanning. Is this possible ?
+ * See for instance Dabe's log.
+ */
+#define ISLSM_TX_CONTROL_CHANNEL_MAGIC1_SET2          0x3
+	uint8_t                 padding1[20];
+	/* These are the IQ autocalibration parameters, whatever
+	   this means */
+	struct wlan_pda_iq_autocal_s freq;
+	/* number of points on the PA calibration curves */
+	uint8_t                 pa_points_per_curve;
+	/* PA levels for the various modulations */
+	struct fw_out_levels    output_pwr_levels;
+	/* The curve data, for interpolation to the above PA level */
+	/* FIXME : move to dynamic number of elements */
+	struct fw_cal_data_sample curve_data[ISLSM_POINTS_PER_CURVE];
+	uint32_t                padding;	/* filled with 0 in old firmware, repeat of output_power_limit
+						 * from the PDA in newer devices */
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_CHANNEL sizeof(struct islsm_tx_control_channel)
+#define FULL_TX_CONTROL_CHANNEL SIZE_TX_CONTROL + SIZE_TX_CONTROL_CHANNEL
+
+struct islsm_tx_control_channel_ver2 {
+	struct islsm_tx_control_channel basic_packet;
+	uint32_t                padding;
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_CHANNEL_VER2 sizeof(struct islsm_tx_control_channel_ver2)
+#define FULL_TX_CONTROL_CHANNEL_VER2 SIZE_TX_CONTROL + SIZE_TX_CONTROL_CHANNEL_VER2
+
+/*
+ * packet which sets the rx/tx filter
+ */
+struct islsm_tx_control_filter {
+	/* This is a bitfield rather than a unique filter type. We
+	   should understand in the firmware what is the effect of each
+	   one of these */
+	uint16_t                filter_type;
+#define ISLSM_TX_CONTROL_FILTER_NOTYPE    0
+#define ISLSM_TX_CONTROL_FILTER_STA       (1<<0)
+#define ISLSM_TX_CONTROL_FILTER_ADHOC     (1<<1)
+#define ISLSM_TX_CONTROL_FILTER_HOSTAP    (1<<2)
+#define ISLSM_TX_CONTROL_FILTER_MONITOR   (1<<4)
+// Seen in many snoops : 1<<5. means reset ?
+#define ISLSM_TX_CONTROL_FILTER_RESET     (1<<5)
+	uint8_t                 destination[ETH_ALEN];
+	uint8_t                 source[ETH_ALEN];
+// 2x uint8_t
+	uint16_t                magic2;
+// FIXME / TODO : understand what those fucking fields mean. If not
+// zeroed, version2 devices are goind completely askew.
+// Do cache-coloring in order to understand if their value is
+// meaningfull in version1 devices.
+// needs active testing in monitor more, i *think* that we have
+// a filter bitfield here. But not sure.
+#define ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM1 0	//xde02
+#define ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM2 0	//xbd02
+#define ISLSM_TX_CONTROL_FILTER_MAGIC2_FORM3 0	//xbd00
+#define ISLSM_TX_CONTROL_FILTER_MAGIC2_STA     0	//xbd02
+#define ISLSM_TX_CONTROL_FILTER_MAGIC2_MONITOR 0x0000
+	uint32_t                magic3;
+#define ISLSM_TX_CONTROL_FILTER_MAGIC3_FORM1   0
+#define ISLSM_TX_CONTROL_FILTER_MAGIC3_STA     0x15f
+#define ISLSM_TX_CONTROL_FILTER_MAGIC3_MONITOR 0x0
+	/* array of rates. Only problem, I don't know what rate they
+	   control. Certainly rx rates ? */
+	uint8_t                 rates[8];
+	/* leave about 0x3500 bytes from the top of the
+	   device's frame space */
+	uint32_t                rx_addr;
+
+	/* Those two fields are still to be understood. There are
+	   certain hints in the firmware though. Somebody should take
+	   on this */
+	/* this is maximal (raw 802.11) rx packet size. Frames longer
+	 * than this are discarded by the firmware, and a counter in the
+	   stats increased accordingly */
+	uint16_t                mru;
+#define ISLSM_TX_CONTROL_FILTER_MAGIC7_VER1 0x0610
+#define ISLSM_TX_CONTROL_FILTER_MAGIC7_VER2 0x0620
+#define ISLSM_TX_CONTROL_FILTER_MAGIC7_PCI  0x0620
+	uint16_t                rxhw;
+	/* again see in firmware */
+	uint16_t                magic8;
+#define ISLSM_TX_CONTROL_FILTER_MAGIC8_STA   0x1f4
+	uint16_t                magic9;
+/* this is a time i think. Find out what it controls */
+#define ISLSM_TX_CONTROL_FILTER_MAGIC9_FORM1 0xf642
+#define ISLSM_TX_CONTROL_FILTER_MAGIC9_PCI   0xf642
+	/* pfui ! */
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_FILTER sizeof(struct islsm_tx_control_filter)
+#define FULL_TX_CONTROL_FILTER SIZE_TX_CONTROL + SIZE_TX_CONTROL_FILTER
+
+/*
+ * packet which controls the leds
+ */
+struct islsm_tx_control_led {
+/* The workings of the mode is not really clear. Basically,
+   a value of 1 will set the green led to blink on packet rx,
+   all other values will go out of this mode */
+	uint16_t                mode;
+#define LED_MODE_SET       2
+#define LED_MODE_RXBLINK   1
+
+/* the leds will be under control of led_setting_temporary
+   for temporary_setting_duration time, in msec, then they
+   are set according to led_setting_permanent.
+   This is for both leds.
+   For instance, if you want the green led to blink while the
+   red led is still on, be sure to set it to LED_GREEN | LED_RED
+   otherwise the red led will be off during the blink */
+	uint16_t                led_setting_temporary;
+	uint16_t                led_setting_permanent;
+#define LED_RED   1
+#define LED_GREEN 2
+
+	/* duration of the temporary settings, in ms */
+	uint16_t                temporary_setting_duration;
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_LED sizeof(struct islsm_tx_control_led)
+#define FULL_TX_CONTROL_LED SIZE_TX_CONTROL + SIZE_TX_CONTROL_LED
+
+/*
+ * packet which is sent to free a
+ * queue where a frame has been alloc'd
+ */
+
+struct islsm_tx_control_freequeue {
+	uint32_t                queue;
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_FREEQUEUE sizeof(struct islsm_tx_control_freequeue)
+#define FULL_TX_CONTROL_FREEQUEUE SIZE_TX_CONTROL + SIZE_TX_CONTROL_FREEQUEUE
+
+/*
+ * Data sending packet
+ */
+
+struct islsm_wepkey {
+	uint8_t                 key_present;
+#define ISLSM_WEPKEY_PRESENT 0x1
+	uint8_t                 key_length;
+	uint8_t                 key[16];
+} __attribute__ ((packed));
+
+struct islsm_tx_control_allocdata {
+	/* index [0-c] into the ratetable ORd with a 
+	   bitmask 40 / 20 / 10, still to be understood */
+	uint8_t                 rateset[8];
+	/* maybe offload type */
+	uint16_t                padding;
+	struct islsm_wepkey     wepkey;
+	uint32_t                frame_type;
+	/* packets are queued in-firmware. This frametype is an
+	 * index into the queue array. In short, the queue it ends up
+	 * in. Additionally, the queue sets a specific TX callback, so
+	 * it does affect the way the packet is sent in an unspecified
+	 * way as-of-yet */
+#define ISLSM_FRAME_DATA		 0x4
+/* frame type that will be emitted at once. difference with above ? */
+#define ISLSM_FRAME_MGMT            	 0x2
+/* frame type that will be emitted once upon a certain frequency change
+   (see code). Queue will be freed by a free queue request or by an
+   allocation of a frame of the same type */
+#define ISLSM_FRAME_PROBE                0x1
+/* frame type that will be emitted at regular intervals upon loading of
+   the right rx/tx filter. Queue will be freed by a free queue or by an
+   allocation of a frame of the same type. */
+#define ISLSM_FRAME_BEACON               0x0
+	uint32_t                padding2;
+	uint32_t                magic4;
+	uint32_t                magic5;
+/* 02 7f 23 with 00 40 magic seems okay for id purposes */
+/* 02 is for some kind of mode ? */
+#define ISLSM_TX_FRAME_MAGIC4_MGMT	0x7f020000	/* 0x7f000000, other
+							 * form with 00 40 as
+							 * magic, and 0x23
+							 * below (dabe's device) */
+#define ISLSM_TX_FRAME_MAGIC5_MGMT	0x23	/* 0x33, other form with 10
+						 * 40 as magic, and 7f02 above */
+#define ISLSM_TX_FRAME_MAGIC4_PROBE	0x0
+#define ISLSM_TX_FRAME_MAGIC5_PROBE	0x0
+	/* 4 is the max padding seen */
+	uint8_t                 frame_align[];
+} __attribute__ ((packed));
+
+#define SIZE_TX_CONTROL_ALLOCDATA sizeof(struct islsm_tx_control_allocdata)
+#define FULL_TX_CONTROL_ALLOCDATA SIZE_TX_CONTROL + SIZE_TX_CONTROL_ALLOCDATA
+#define TX_MAX_PADDING (4 - 1)
+
+#define ISLSM_SIZE_STATS 0x24
+
+/*
+ * eeprom readback packet
+ */
+struct islsm_control_eeprom_lm86 {
+	uint16_t                offset;
+	uint16_t                len;
+	char                    data[];
+} __attribute__ ((packed));
+
+/* same, for lm87 */
+/* I think the maximum framesize is 0x400 -- this includes
+   the frame plus crc for lm87 */
+#define ISLSM_EEPROM_SIZE       0x2000
+#define SIZE_CONTROL_EEPROM     sizeof(struct islsm_control_eeprom_lm86)
+
+struct islsm_control_eeprom_lm87 {
+	u32                     address;
+	u16                     len;
+	/* always 0xf */
+	u16                     unknown;
+	/* magic is LOCK */
+#define ISLSM_LOCK 0x4c4f434b
+	u32                     magic;
+	char                    data[];
+} __attribute__ ((packed));
+
+union islsm_control_eeprom {
+	struct islsm_control_eeprom_lm86 lm86;
+	struct islsm_control_eeprom_lm87 lm87;
+};
+
+/*
+ * packet reporting successfull frequency setting
+ */
+struct islsm_control_freqchange {
+	uint16_t                padding;
+	uint16_t                frequency;
+} __attribute__ ((packed));
+
+/*
+ * packet sent when a data packet is freed
+ */
+struct islsm_control_queueemptied {
+	uint16_t                status;
+/* i'll have to make sure of this */
+#define PKT_STATUS_OK        0x100
+#define PKT_STATUS_NOTACKED  0x1
+	uint16_t                ack_strength;
+	/* the device takes care of the sequence control field
+	   in the packet. Here is what it filled it with */
+	uint16_t                sequence;
+	/* this is, i think another field filled in by the device.
+	   duration / ID field, maybe ? Seems to be field 0x22-0x23
+	   repeated */
+	uint16_t                unknown;
+} __attribute__ ((packed));
+
+/*
+ * packet received, statistics
+ */
+
+struct islsm_control_stats {
+	uint32_t                rx_pkt;
+	uint32_t                stat1;	/* counter */
+	uint32_t                stat2;	/* counter */
+	uint32_t                stat3;	/* counter */
+	uint32_t                stat4;
+	uint32_t                stat5;
+	uint32_t                timestamp;	/* in microseconds, see rx packet */
+	uint32_t                stat6;
+	uint32_t                noise;	/* noise ? -- i'm not sure, anyone checks this ? */
+} __attribute__ ((packed));
+
+#endif				/* _HAVE_PROTOCOL_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_rom.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_rom.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_rom.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_rom.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,92 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+/* this file contains definitions for protocol communication with the
+ * ROM of the ISL devices */
+
+#ifndef _HAVE_ISL_ROM_H_
+#define _HAVE_ISL_ROM_H_
+
+#define X2_SIGNATURE "x2  "
+#define X2_SIGNATURE_SIZE 4
+#define X2_LEN (sizeof(struct x2_header))
+
+#include <linux/firmware.h>
+#include <linux/types.h>
+#include <linux/crc32.h>
+
+/* Rom communication primitives */
+int islrom_send_data(char* data, unsigned data_len);
+
+struct x2_cmd {
+	uint32_t                fw_load_addr;
+	uint32_t                fw_length;
+} __attribute__((packed));
+
+struct x2_header {
+	char                    signature[X2_SIGNATURE_SIZE];
+	struct x2_cmd           cmd;
+	uint32_t                crc;
+} __attribute__((packed));
+
+/* X2 header, used to send the firmware to the 3887 rom */
+
+#define islrom_crc32(data, length) ~crc32_le(~0, (unsigned char const *)(data), (length));
+
+
+/* int                     islrom_build_x2(struct x2_header *header, */
+/* 					uint32_t fw_load_addr, */
+/* 					uint32_t fw_length); */
+/* Firmware checksum */
+void islrom_build_fwtail(uint32_t *tail, char *fw, unsigned fw_len);
+
+/******
+ * DATA SENDING COMMANDS
+ ******/
+
+/* you can readily load the data without x2 header as outlined in the
+ * help. You have no checksum on length and desination address, though,
+ * but you need to provide a checksum on data at the end of the payload
+ */
+int                     islrom_load_fw(struct islsm *device,
+				       unsigned dest_addr,
+				       char *fw, unsigned length);
+
+/* when you send the load command without arguments,
+ * the firmware expects a x2 header to describe the load in the 3887
+ * case.
+ *
+ * In the PCI case, i guess the length is an implied
+ * parameter. Triggering error is not easy by just playing on the
+ * keyboard: the length of the default firmware must be quite long
+ */
+int                     islrom_load_fw_x2(struct islsm *device,
+					  unsigned dest_addr,
+					  char *fw, unsigned length);
+
+/* the firmware responds with (ERROR or OK) + prompt once these commands
+ * have been completed (or aborted by a checksum error, as may be the
+ * case) */
+
+/* once done, jump. implied address is ? */
+int                     islrom_boot_fw(struct islsm *device, int addr);
+
+#endif				/* _HAVE_ISL_ROM_H_ */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_smioctl.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_smioctl.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_smioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_smioctl.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+  Copyright 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _ISLSM_SMIOCTL_H
+#define _ISLSM_SMIOCTL_H
+
+#include <linux/ioctl.h>
+#include <linux/types.h>
+
+/* user-space include */
+#ifndef __KERNEL__
+#include <inttypes.h>
+#endif
+
+typedef struct islsm_reg {
+	uint32_t                addr;
+	uint32_t                val;
+} islsm_reg_t;
+
+typedef islsm_reg_t     islsm_mem_t;
+
+#define ISLSM_FW_NAME_LEN 33
+
+typedef char            islsm_firmware_name_t[ISLSM_FW_NAME_LEN];
+
+#define ISLSM_IOC_MAGIC 'k'
+#define ISLSM_IOC_STATE_CTRL  (1 << (_IOC_NRBITS - 1) )
+#define ISLSM_IOC_ARGTYPE_REG  (1 << (_IOC_NRBITS - 2) )
+
+/* access to pci registers */
+#define ISLSM_IOCGREG _IOWR(ISLSM_IOC_MAGIC,0 | ISLSM_IOC_ARGTYPE_REG,islsm_reg_t)
+#define ISLSM_IOCSREG _IOW(ISLSM_IOC_MAGIC,1 | ISLSM_IOC_ARGTYPE_REG,islsm_reg_t)
+
+/* access to device memory */
+#define ISLSM_IOCGMEM _IOWR(ISLSM_IOC_MAGIC,2 | ISLSM_IOC_ARGTYPE_REG,islsm_mem_t)
+#define ISLSM_IOCSMEM _IOW(ISLSM_IOC_MAGIC,3 | ISLSM_IOC_ARGTYPE_REG,islsm_mem_t)
+
+/* boots the rom */
+#define ISLSM_IOCBOOTROM _IO(ISLSM_IOC_MAGIC, 0)
+/* upload and boot firmware */
+#define ISLSM_IOCLOADFW _IO(ISLSM_IOC_MAGIC, 1)
+/* send the firmware a ping message */
+#define ISLSM_IOCSENDPING _IO(ISLSM_IOC_MAGIC, 2)
+
+/* set protocol constants */
+//#define ISLSM_IOCSPROTO  _IOW(ISLSM_IOC_MAGIC, 1 | ISLSM_IOC_STATE_CTRL)
+
+#endif				/* _ISLSM_SMIOCTL_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_sysfs.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_sysfs.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_sysfs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_sysfs.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+  Copyright 2006 Jean-Baptiste Note
+  Greatly inspired by Samuel Ortiz <samuel.ortiz@nokia.com>
+
+  This file is part of islsm.
+
+  islsm is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your
+  option) any later version.
+
+  islsm is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with islsm; if not, write to the Free Software Foundation, Inc.,
+  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+
+#include "islsm_sysfs.h"
+#include "isl_sm.h"
+#include "islsm_log.h"
+#include "islsm_protocol.h" /* only for eeprom length */
+
+#ifdef CONFIG_SYSFS
+
+/* firmware name */
+static ssize_t islsm_show_fw_name(struct class_device *dev, char *buf)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	return sprintf(buf, "%.*s\n", ISLSM_FW_NAME_LEN, islsm->firmware_name);
+}
+
+static ssize_t islsm_store_fw_name(struct class_device *dev, const char *buf, size_t count)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	size_t min_len = min( (size_t)ISLSM_FW_NAME_LEN, count);
+	char *firmware = islsm->firmware_name;
+	/* we're not sure the input buf is zero-padded */
+	strncpy(firmware, buf, min_len);
+	firmware[min_len] = 0;
+	return count;
+}
+
+/* FCS filtering option in monitor mode. probably the softmac should
+ * handle this parameter */
+static ssize_t islsm_show_rxfilter(struct class_device *dev, char *buf)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	return sprintf(buf, "%04x\n", islsm->soft_rxfilter);
+}
+
+static ssize_t islsm_store_rxfilter(struct class_device *dev, const char *buf, size_t count)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	short rxfilter;
+	int matched;
+	/* we're not sure the input buf is zero-ended ? Some drivers
+	 * seem to assume so */
+	/* buf[count-1] = 0; */
+	matched = sscanf(buf, "%hx", &rxfilter);
+	if (matched != 1)
+		return -EINVAL;
+
+	islsm->soft_rxfilter = rxfilter;
+	return strlen(buf);
+}
+
+/*
+ * EEPROM raw data
+ */
+
+static ssize_t
+islsm_read_eeprom(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct class_device *dev = container_of(kobj,struct class_device,kobj);
+	const struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	size_t eeprom_len = islsm->eeprom_size;
+	u8 *eeprom = islsm->eeprom;
+
+	if (!eeprom)
+		return 0;
+
+	if (off > eeprom_len)
+		return 0;
+
+	if (off + count > eeprom_len)
+		count = eeprom_len - off;
+
+	memcpy(buf, &eeprom[off], count);
+	return count;
+}
+
+static struct bin_attribute sysfs_eeprom_dump_attr = {
+	.attr = {
+		.name = "eeprom",
+		.mode = S_IRUSR,
+		.owner = THIS_MODULE,
+	},
+	.size = 0,
+	.read = islsm_read_eeprom,
+};
+
+/*
+ * In-firmware tx retry count setting for outgoing data packets
+ */
+
+static ssize_t
+islsm_store_data_txretry(struct class_device *dev,
+			 const char *buf, size_t count) {
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	int value1, value2;
+	int matched;
+	matched = sscanf(buf, "%x %x", &value1, &value2);
+	if (matched != 2 ||
+	    value1 < 0 || value1 > 7 ||
+	    value2 < 0 || value2 > 7)
+		return -EINVAL;
+	islsm->smpar.data.retry1 = value1;
+	islsm->smpar.data.retry2 = value2;
+	return strlen(buf);
+}
+
+static ssize_t
+islsm_show_data_txretry(struct class_device *dev, char *buf) {
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	ssize_t count = 0;
+	u8 retries1 = islsm->smpar.data.retry1 & 0xff;
+	u8 retries2 = islsm->smpar.data.retry2 & 0xff;
+	return sprintf(buf + count, "%02x %02x\n", retries1, retries2);
+}
+
+/*
+ * Rate setting
+ * FIXME: do this properly in ieee80211softmac
+ */
+#define TX_RATE_SIZE 8
+
+static ssize_t
+islsm_store_rateset(char dst[], const char *buf, size_t count) {
+	int matched;
+	/* would there be a way to write this with
+	   a loop, more cleverly with simple_strtoul */
+	matched = sscanf(buf, "%hhx %hhx %hhx %hhx %hhx %hhx %hhx %hhx",
+			 &dst[0], &dst[1], &dst[2], &dst[3],
+			 &dst[4], &dst[5], &dst[6], &dst[7]);
+	if (matched == 0)
+		return -EINVAL;
+	return strlen(buf);
+}
+
+static ssize_t
+islsm_print_rateset(char *buf, const char rate_table[]) {
+	ssize_t count = 0;
+	int i;
+	for(i = 0; i < TX_RATE_SIZE; i++) {
+		count += sprintf(buf + count, "%02x ", rate_table[i]);
+	}
+	count += sprintf(buf + count, "\n");
+	return count;
+}
+
+static ssize_t islsm_store_data_rateset(struct class_device *dev,
+					const char *buf, size_t count)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	char *rate_table = islsm->smpar.data.rateset;
+	return islsm_store_rateset(rate_table, buf, count);
+}
+
+static ssize_t islsm_dump_data_rateset(struct class_device *dev, char *buf)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	char *rate_table = islsm->smpar.data.rateset;
+	return islsm_print_rateset(buf, rate_table);
+}
+
+static ssize_t islsm_store_ctrl_rateset(struct class_device *dev,
+					const char *buf, size_t count)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	char *rate_table = islsm->filter_rateset;
+	/* Maybe also trigger the emission of the packet */
+	return islsm_store_rateset(rate_table, buf, count);
+}
+
+static ssize_t islsm_dump_ctrl_rateset(struct class_device *dev, char *buf)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	char *rate_table = islsm->filter_rateset;
+	/* FIXME: should trigger the resend of the rxfilter -- for now
+	 * you need to set this before interface launch */
+	return islsm_print_rateset(buf, rate_table);
+}
+
+/*
+ * Export state of the allocator. Allows for simple tracking of the
+ * allocator state.
+ */
+static ssize_t islsm_dump_allocstate(struct class_device *dev, char *buf)
+{
+	struct islsm *islsm = ISLSM_OF_CLASSDEV(dev);
+	return islsm_alloc_dump(&islsm->memory, buf);
+}
+
+/* TODO: get back chopped pda information */
+
+/* read-write parameters */
+static CLASS_DEVICE_ATTR(fw_name, S_IRUGO | S_IWUSR, islsm_show_fw_name, islsm_store_fw_name);
+static CLASS_DEVICE_ATTR(rxfilter, S_IRUGO | S_IWUSR, islsm_show_rxfilter, islsm_store_rxfilter);
+static CLASS_DEVICE_ATTR(txretry, S_IRUGO | S_IWUSR, islsm_show_data_txretry, islsm_store_data_txretry);
+static CLASS_DEVICE_ATTR(datarateset, S_IRUGO | S_IWUSR, islsm_dump_data_rateset, islsm_store_data_rateset);
+static CLASS_DEVICE_ATTR(ctrlrateset, S_IRUGO | S_IWUSR, islsm_dump_ctrl_rateset, islsm_store_ctrl_rateset);
+
+/* read-only data */
+static CLASS_DEVICE_ATTR(allocator, S_IRUGO, islsm_dump_allocstate, NULL);
+
+static struct class_device_attribute *islsm_attrs[] = {
+	&class_device_attr_fw_name,
+	&class_device_attr_rxfilter,
+	&class_device_attr_txretry,
+	&class_device_attr_datarateset,
+ 	&class_device_attr_ctrlrateset,
+	&class_device_attr_allocator,
+	NULL,
+};
+
+static int
+islsm_device_create_files(struct class_device *dev) {
+	int i = 0;
+	int err = 0;
+	while(!err && islsm_attrs[i])
+		err = class_device_create_file(dev,islsm_attrs[i++]);
+	return err;
+}
+
+static void
+islsm_device_remove_files(struct class_device *dev) {
+	int i = 0;
+	while(islsm_attrs[i])
+		class_device_remove_file(dev,islsm_attrs[i++]);
+}
+
+int islsm_sysfs_create_files(struct class_device *dev) {
+	int err;
+
+	islog(L_DEBUG, "Creating islsm sysfs\n");
+	err = class_device_create_bin_file(dev, &sysfs_eeprom_dump_attr);
+	if (err)
+		goto out;
+	err = islsm_device_create_files(dev);
+ out:
+	return err;
+}
+
+/* check whether cleanup is automatic or not */
+void islsm_sysfs_remove_files(struct class_device *dev)
+{
+	islog(L_DEBUG, "Removing islsm sysfs\n");
+	class_device_remove_bin_file(dev, &sysfs_eeprom_dump_attr);
+	islsm_device_remove_files(dev);
+}
+
+#endif /* CONFIG_SYSFS */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_sysfs.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_sysfs.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_sysfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_sysfs.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+  Greatly inspired by Samuel Ortiz <samuel.ortiz@nokia.com>
+
+  This file is part of islsm.
+
+  islsm is free software; you can redistribute it and/or modify it under
+  the terms of the GNU General Public License as published by the Free
+  Software Foundation; either version 2 of the License, or (at your
+  option) any later version.
+
+  islsm is distributed in the hope that it will be useful, but WITHOUT
+  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with islsm; if not, write to the Free Software Foundation, Inc.,
+  59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include "isl_sm.h"
+
+#define ISLSM_OF_CLASSDEV(x) (struct islsm *) class_get_devdata(x)
+
+int islsm_sysfs_create_files(struct class_device *);
+void islsm_sysfs_remove_files(struct class_device *dev);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uart.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uart.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uart.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uart.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,589 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+  Copyright (C) 2003 Conexant Americas Inc.
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+
+/* for register / unregister device */
+#include <linux/types.h>
+#include <linux/kdev_t.h>
+#include <linux/cdev.h>
+/* for class_simple usage */
+#include <linux/device.h>
+
+#include <linux/isl_38xx.h>
+#include <linux/ioctl.h>
+#include <linux/poll.h>
+#include <asm/uaccess.h>
+
+#include "isl_sm.h"
+#include "islsm_uart.h"
+#include "islsm_smioctl.h"
+#include "islsm_log.h"
+/* will allow to get rid of some ioctls easily */
+#include "islsm_sysfs.h"
+
+// MODULE_DESCRIPTION("Prism54 UART-over-softmac driver");
+// MODULE_AUTHOR("Jean-Baptiste Note <jean-baptiste.note@m4x.org>");
+// MODULE_LICENSE("GPL");
+
+/*******
+ *   UART over SoftMac Instance Character driver
+ *******/
+
+/* The name for our device, as it will appear in /proc/devices */
+#define DEVICE_NAME        "islsm"
+#define DRV_NAME           "isluart"
+#define ISLSM_OF_FILE(f)    ((struct islsm *)(f)->private_data)
+#define UART_OF_FILE(f)     (&((struct islsm *)(f)->private_data)->uart)
+
+/* module state */
+static unsigned major;
+static struct class *islsm_class;
+
+static void uart_prot_reinit(struct islsm *device);
+
+static int uart_init(uart_instance_t *uart_ref);
+static void uart_cleanup(uart_instance_t *uart_ref);
+static int uart_initq(uart_instance_t *, struct queue_s *queue, int size);
+static void uart_cleanupq(struct queue_s *queue);
+
+/* interface with userspace */
+static int uart_open(struct inode *inode, struct file *filp);
+static int uart_release(struct inode *inode, struct file *filp);
+static ssize_t uart_read(struct file *filp, char *buffer,
+			 size_t length, loff_t *offset);
+static ssize_t uart_write(struct file *filp, const char *buffer,
+			  size_t length, loff_t *offset);
+
+void
+uart_prot_reinit(struct islsm *device)
+{
+	uart_instance_t *uart = &device->uart;
+
+	if (!uart->is_open)
+		return;
+
+	device->uart_prot_init(device);
+}
+
+static int
+uart_initq(uart_instance_t *uart, struct queue_s *queue, int size)
+{
+	unsigned long flags;
+
+	queue->q = kmalloc(size, GFP_ATOMIC);
+	if (!queue->q) {
+		printk(KERN_ERR "%s: Could not allocate queue\n", DRV_NAME);
+		return -ENOMEM;
+	}
+
+	spin_lock_irqsave(&uart->lock, flags);
+	queue->p = queue->c = 0;
+	queue->s = size;
+	spin_unlock_irqrestore(&uart->lock, flags);
+
+	return 0;
+}
+
+static void
+uart_cleanupq(struct queue_s *queue)
+{
+	kfree(queue->q);
+}
+
+static int
+uart_open(struct inode *inode, struct file *filp)
+{
+	struct islsm *device;
+	uart_instance_t *uart;
+	struct cdev *dev = inode->i_cdev;
+
+	islog(L_FUNC, "uart_open(%p,%p)\n", inode, filp);
+
+	/* fetch the associated islsm device */
+	uart = container_of(dev, uart_instance_t, dev);
+	device = container_of(uart, struct islsm, uart);
+
+	islog(L_DEBUG, "uart device is %p\n", device);
+
+	filp->private_data = device;
+
+	if (!uart->is_open)
+		/* Initialize the UART over PCI protocol on first open */
+		device->uart_prot_init(device);
+
+	uart->is_open++;
+	return 0;
+}
+
+static int
+uart_release(struct inode *inode, struct file *filp)
+{
+	struct islsm *device = ISLSM_OF_FILE(filp);
+	uart_instance_t *uart = UART_OF_FILE(filp);
+
+	islog(L_FUNC, "uart_release(%p,%p)\n", inode, filp);
+
+	uart->is_open--;
+
+	/* last open restores the state */
+	if (!uart->is_open)
+		device->uart_prot_exit(device);
+
+	return 0;
+}
+
+static unsigned int
+uart_poll(struct file *filp, poll_table * wait)
+{
+	uart_instance_t *uart = UART_OF_FILE(filp);
+
+	poll_wait(filp, &uart->wait, wait);
+
+	if (uart_inq(uart, &uart->rxq) > 0)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static ssize_t
+uart_read(struct file *filp, char *buffer, size_t length, loff_t *offset)
+{
+	uart_instance_t *uart = UART_OF_FILE(filp);
+	unsigned long flags;
+	int bytes_read, uart_size, err;
+	DECLARE_WAITQUEUE(wait, current);
+
+	islog(L_FUNC, "uart_read(%p,%p, %zd)\n", filp, buffer, length);
+
+	err = 0;
+
+	add_wait_queue(&uart->wait, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+
+	spin_lock_irqsave(&uart->lock, flags);
+	uart_size = uart_inq(uart, &uart->rxq);
+	spin_unlock_irqrestore(&uart->lock, flags);
+
+	while (uart_size <= 0) {
+		if (filp->f_flags & O_NONBLOCK) {
+			err = -EAGAIN;
+			break;
+		}
+		schedule();
+		if (signal_pending(current)) {
+			err = -ERESTARTSYS;
+			break;
+		}
+
+		spin_lock_irqsave(&uart->lock, flags);
+		uart_size = uart_inq(uart, &uart->rxq);
+		spin_unlock_irqrestore(&uart->lock, flags);
+	}
+
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&uart->wait, &wait);
+
+	if (err)
+		return err;
+
+	bytes_read = 0;
+
+	/* Note that we may well be returning without any read bytes,
+	   in case some other process has stolen all available from us.
+	 */
+	while (bytes_read < length) {
+		spin_lock_irqsave(&uart->lock, flags);
+		if (uart_inq(uart, &uart->rxq) > 0) {
+			int ret;
+			uint8_t data;
+			data = uart_qconsume(uart, &uart->rxq);
+			spin_unlock_irqrestore(&uart->lock, flags);
+			ret = put_user(data, buffer);
+			/* we loose a character in this case */
+			if (ret < 0)
+				return ret;
+			buffer++;
+			bytes_read++;
+		} else {
+			spin_unlock_irqrestore(&uart->lock, flags);
+			break;
+		}
+	}
+
+	return bytes_read;
+}
+
+static ssize_t
+uart_write(struct file *filp, const char *buffer, size_t length, loff_t *offset)
+{
+	struct islsm *device = ISLSM_OF_FILE(filp);
+	uart_instance_t *uart = UART_OF_FILE(filp);
+	unsigned long flags;
+
+	int written = 0;
+	char c;
+	int tries = 0;
+
+	islog(L_FUNC, "uart_write(%p,%p, %zd)\n", filp, buffer, length);
+
+	/* while there are still bytes to be written */
+	/* the idea there is that the data TX will happen
+	   asynchronously in the interrupt handler. The current code has
+	   a problem in case we miss an interrupt. */
+	while (written < length && tries < 10) {
+		/* fill it with one more character */
+		if (get_user(c, buffer))
+			return -EFAULT;
+
+		/* if queue is not full */
+		spin_lock_irqsave(&uart->lock, flags);
+		if (uart_inq(uart, &uart->txq) < UARTPCI_TXQSIZE) {
+			uart_qproduce(uart, &uart->txq, c);
+			written++;
+			buffer++;
+			spin_unlock_irqrestore(&uart->lock, flags);
+		} else {
+			/* better yet, go to sleep, with timeout, until
+			   buffer is somewhat emptied */
+			/* else (queue is full),
+			   see if we're not hogging the cpu */
+			spin_unlock_irqrestore(&uart->lock, flags);
+			schedule();
+			tries++;
+		}
+
+		/* cts is raised when device gave us CTS without us
+		   having more data to transmit. In this case, we need
+		   to call uart_cts ourselves (the irq handler never
+		   will do it) */
+		if (uart->cts) {
+			uart->cts = 0;
+			device->uart_cts(device);
+		}
+	}
+
+	if (tries >= 10)
+		islog(L_DEBUG, "UPCI: Write Q full, giving up\n");
+
+	return written;
+}
+
+/*
+ * ioctl implementation
+ */
+
+static int
+check_ioc_args(unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	/* do the checks */
+	if (_IOC_TYPE(cmd) != ISLSM_IOC_MAGIC)
+		return -ENOTTY;
+
+	if (_IOC_DIR(cmd) & _IOC_READ)
+		err = !access_ok(VERIFY_WRITE, (void *) arg, _IOC_SIZE(cmd));
+	else if (_IOC_DIR(cmd) & _IOC_WRITE)
+		err = !access_ok(VERIFY_READ, (void *) arg, _IOC_SIZE(cmd));
+
+	if (err)
+		return -EFAULT;
+	return 0;
+}
+
+static int
+uart_ioctl(struct inode *inode, struct file *filp,
+	   unsigned int cmd, unsigned long arg)
+{
+	/* if we can issue ioctls without opening the device, then this
+	   will segfault */
+	int err;
+	struct islsm *device;
+	islsm_reg_t reg_arg;
+
+	device = ISLSM_OF_FILE(filp);
+	err = check_ioc_args(cmd, arg);
+
+	if (err)
+		return err;
+
+	if (_IOC_NR(cmd) & ISLSM_IOC_ARGTYPE_REG) {
+		/* argument is a reg */
+		err = copy_from_user(&reg_arg, (void *) arg, sizeof (reg_arg));
+		if (err)
+			return -EFAULT;
+	}
+
+	switch (cmd) {
+	case ISLSM_IOCGREG:
+		{
+			/* check that we are not out to lunch wrt pci addressing
+			   space */
+			if (!device->isl_read_pcireg)
+				return -ENOTTY;
+			if (reg_arg.addr >= ISL38XX_PCI_MEM_SIZE)
+				return -EFAULT;
+			reg_arg.val =
+			    device->isl_read_pcireg(device, reg_arg.addr);
+			break;
+		}
+	case ISLSM_IOCSREG:
+		{
+			/* check that we are not out to lunch wrt pci addressing
+			   space */
+			if (!device->isl_write_pcireg)
+				return -ENOTTY;
+			if (reg_arg.addr >= ISL38XX_PCI_MEM_SIZE)
+				return -EFAULT;
+			device->isl_write_pcireg(device, reg_arg.val,
+						 reg_arg.addr);
+			return 0;
+		}
+	case ISLSM_IOCGMEM:
+		if (!device->isl_read_devmem)
+			return -ENOTTY;
+		reg_arg.val = device->isl_read_devmem(device, reg_arg.addr);
+		break;
+	case ISLSM_IOCSMEM:
+		if (!device->isl_write_devmem)
+			return -ENOTTY;
+		device->isl_write_devmem(device, reg_arg.val, reg_arg.addr);
+		return 0;
+	case ISLSM_IOCBOOTROM:
+		{
+			/* only OK for PCI and PCI+USB */
+			/* lacks implementation for 3887 */
+			if (!device->isl_romboot)
+				return -ENOTTY;
+			(void) device->isl_romboot(device);
+			uart_prot_reinit(device);
+			return 0;
+		}
+	case ISLSM_IOCLOADFW:
+		{
+			struct net_device *netdev = NETDEV_OF_ISLSM(device);
+			const char *fw_name = device->firmware_name;
+			const struct firmware *fw_entry;
+			int err = 0;
+			/* load the firmware via the device-preferred
+			   method. This is one of
+			   - rom loading (3887, possibly others)
+			   - dma loading (PCI+USB, possibly others)
+			   - write in io space loading (PCI)
+			 */
+			/* should restart the uart protocol.
+			   Don't do this yet, as this allows freemac to work
+			   alright */
+			if (!device->isl_load_fw)
+				return -ENOTTY;
+			err = request_firmware(&fw_entry, fw_name, &netdev->dev);
+			if (err) {
+				printk(KERN_ERR "%s: Request firmware for '%s' failed: %i\n",
+				       DRV_NAME, fw_name, err);
+				return err;
+			}
+			err = device->isl_load_fw(device,fw_entry);
+			uart_prot_reinit(device);
+			release_firmware(fw_entry);
+			return err;
+		}
+	case ISLSM_IOCSENDPING:
+	{
+		islsm_ping_device(device, 0x30);
+		/* should wait for the response */
+		return 0;
+	}
+		/* should add an ioctl to reset the protocol, so that i don't
+		   need to do it in the loadfw and bootrom case */
+	default:
+		return -ENOTTY;
+	}
+
+	if (_IOC_NR(cmd) & ISLSM_IOC_ARGTYPE_REG) {
+		/* argument is a reg */
+		err = copy_to_user((void *) arg, &reg_arg, sizeof (reg_arg));
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static struct file_operations uart_fops = {
+	.owner = THIS_MODULE,
+	.read = uart_read,
+	.write = uart_write,
+	.open = uart_open,
+	.release = uart_release,
+	.poll = uart_poll,
+	.ioctl = uart_ioctl,
+};
+
+/*****
+ * Allocation functions
+ *****/
+
+static int
+uart_init(uart_instance_t *uart)
+{
+
+	memset(uart, 0, sizeof (uart_instance_t));
+
+	init_waitqueue_head(&uart->wait);
+	spin_lock_init(&uart->lock);
+
+	if (uart_initq(uart, &uart->txq, UARTPCI_TXQSIZE))
+		goto failed;
+
+	if (uart_initq(uart, &uart->rxq, UARTPCI_RXQSIZE))
+		goto failed_txq;
+
+	return 0;
+
+      failed_txq:
+	uart_cleanupq(&uart->txq);
+      failed:
+	return -ENOMEM;
+}
+
+int
+uart_init_dev(struct islsm *islsm)
+{
+	uart_instance_t *uart = &islsm->uart;
+	unsigned minor;
+	dev_t dev;
+	struct class_device *c;
+	int err;
+
+	FN_ENTER;
+	err = uart_init(uart);
+
+	if (err)
+		goto failed;
+
+	minor = islsm->minor;
+	dev = MKDEV(major, minor);
+
+	cdev_init(&uart->dev, &uart_fops);
+	err = cdev_add(&uart->dev, dev, 1);
+	if (err)
+		goto failed_uart;
+
+	c = class_device_create(islsm_class,
+				NULL, dev, NULL,
+				"islsm%d", minor);
+
+	if (IS_ERR(c)) {
+		/* Not fatal */
+		printk(KERN_WARNING
+		       "%s: Unable to add device to class for islsm %d, error %ld\n",
+		       DRV_NAME, minor, PTR_ERR(c));
+		goto failed;
+	}
+
+	/* create the sysfs entries */
+	class_set_devdata(c, islsm);
+	err = islsm_sysfs_create_files(c);
+	if (err)
+		goto failed_uart;
+
+	FN_EXIT1(0);
+	return 0;
+
+ failed_uart:
+	uart_cleanup(uart);
+ failed:
+	FN_EXIT1(err);
+	return err;
+}
+
+EXPORT_SYMBOL(uart_init_dev);
+
+static void
+uart_cleanup(uart_instance_t *uart)
+{
+	unsigned long flags;
+	/* maybe make sure no-one is waiting on the wait queue */
+	spin_lock_irqsave(&uart->lock, flags);
+	uart_cleanupq(&uart->txq);
+	uart_cleanupq(&uart->rxq);
+	spin_unlock_irqrestore(&uart->lock, flags);
+}
+
+void
+uart_release_dev(struct islsm *islsm)
+{
+	FN_ENTER;
+	class_device_destroy(islsm_class,MKDEV(major, islsm->minor));
+	cdev_del(&islsm->uart.dev);
+	uart_cleanup(&islsm->uart);
+	FN_EXIT0;
+}
+
+EXPORT_SYMBOL(uart_release_dev);
+
+/* Initialize the module - Register the character device */
+#define DEVICE_RANGE 32
+int
+uart_init_module(void)
+{
+	int err = 0;
+	dev_t dev;
+
+	islsm_class = class_create(THIS_MODULE, "islsm");
+	if (IS_ERR(islsm_class)) {
+		printk(KERN_ERR "%s: error creating islsm class", DRV_NAME);
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* register our range of character device */
+	err = alloc_chrdev_region(&dev, 0, DEVICE_RANGE, DEVICE_NAME);
+	if (err) {
+		printk(KERN_ERR "%s: cannot allocate dev region", DRV_NAME);
+		goto out_free_class;
+	}
+
+	major = MAJOR(dev);
+	islog(L_DEBUG, "islsm_uart: registered device major %d\n", major);
+
+	goto out;
+
+ out_free_class:
+	class_destroy(islsm_class);
+ out:
+	return err;
+}
+
+/* Cleanup - unregister the appropriate file from /proc */
+void
+uart_cleanup_module(void)
+{
+	FN_ENTER;
+	unregister_chrdev_region(MKDEV(major, 0), DEVICE_RANGE);
+	class_destroy(islsm_class);
+	FN_EXIT0;
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uart.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uart.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uart.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,125 @@
+/*
+  Copyright 2004, 2005 Jean-Baptiste Note
+  Copyright (C) 2003 Conexant Americas Inc.
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAVE_ISL_UART_H_
+#define _HAVE_ISL_UART_H_
+
+#include <linux/fs.h>
+#include <linux/kdev_t.h>
+#include <linux/cdev.h>
+#include <linux/wait.h>
+
+struct islsm;
+
+/* queue note :
+
+   on the uart rx queue,
+
+   - the p (producer end) is manipulated by the irq handler, and write
+   access must be under spinlock, taking care that the data write
+   happens *before* the pointer update. Under those conditions, read
+   from userspace should be coherent.
+
+   - the c (consumer) end is manipulated by the user-space interface
+   functions. Access should be done under a lightweight semaphore, as
+   concurrency only exists within userspace.
+
+   on the uart tx queue, the reverse happens :
+
+   - the p (producer) end is written by user-space under semaphore, and
+   read by the irq handler => use atomic value.
+
+   - the c (consumer) end is written by irq handlers, under spinlock,
+   taking care that the data write happens *before* the pointer update,
+   and read by userspace.
+
+   There's a problem whereby a process goes to sleep waiting for some
+   data to be available : we want to ensure this process will not "miss"
+   a "data available" signal from the DR irq.
+
+*/
+
+struct queue_s {
+	uint32_t                s;
+	uint32_t                p;
+	uint32_t                c;
+	uint8_t                *q;
+};
+
+/* this structure describes an uart instance */
+/* it is used as reference to the uart device
+   in the sm device */
+
+typedef struct {
+	struct cdev             dev;
+	int                     is_open;
+
+	uint32_t                cts;	/* CTS pending */
+	wait_queue_head_t       wait;	/* read wait queue */
+	spinlock_t              lock;
+	uint32_t                major;
+
+	struct queue_s          txq;
+	struct queue_s          rxq;
+} uart_instance_t;
+
+/* queue management exported and used in the irq handler */
+#define UARTPCI_TXQSIZE     (4 * 1024)
+#define UARTPCI_RXQSIZE     (4 * 1024)
+
+/* interface functions */
+void                    uart_release_dev(struct islsm *islsm);
+int                     uart_init_dev(struct islsm *islsm);
+
+/* low-level queue access functions */
+static inline int uart_inq(uart_instance_t *uart, struct queue_s *queue)
+{
+	uint32_t                inq;
+
+	inq = queue->p - queue->c;
+	return inq;
+}
+
+static inline uint8_t
+uart_qconsume(uart_instance_t *uart, struct queue_s *queue)
+{
+	uint8_t                 ret;
+
+	ret = queue->q[queue->c % queue->s];
+	(queue->c)++;
+
+	return ret;
+}
+
+static inline void
+uart_qproduce(uart_instance_t *uart, struct queue_s *queue, uint8_t val)
+{
+	queue->q[queue->p % queue->s] = val;
+	(queue->p)++;
+}
+
+#ifndef MADWIFI
+int uart_init_module(void);
+void uart_cleanup_module(void);
+#endif
+
+#endif				/* _HAVE_ISL_UART_H_ */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uartpci.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uartpci.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islsm_uartpci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islsm_uartpci.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,332 @@
+/*
+  Copyright 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+/* This file contains definitions for some functions which are common to
+ * PCI and PCI+net2280 for uart.
+ */
+
+#include <linux/pci.h> /* for PCI_COMMAND_XXX */
+#include <linux/isl_38xx.h>
+#include "islsm_log.h"
+#include "islsm_uart.h"
+#include "isl_sm.h"
+
+#if defined(ISL_PCI)
+
+static inline uint32_t
+islpci_read_pcireg(islpci_private *priv, uint32_t address)
+{
+	void __iomem           *device_base = priv->device_base;
+	uint32_t                reg;
+	unsigned long           flags;
+
+	spin_lock_irqsave(&priv->pcireg_lock, flags);
+	reg = readl(device_base + address);
+	udelay(ISL38XX_WRITEIO_DELAY);
+	spin_unlock_irqrestore(&priv->pcireg_lock, flags);
+	return reg;
+}
+
+static inline uint32_t isl_read_pcireg(struct islsm *islsm, uint32_t address)
+{
+	islpci_private         *priv = ISLPCI_OF_ISLSM(islsm);
+	return islpci_read_pcireg(priv, address);
+}
+
+static inline void
+islpci_write_pcireg(islpci_private *priv, uint32_t value, uint32_t address)
+{
+	void __iomem           *device_base = priv->device_base;
+	unsigned long           flags;
+
+	spin_lock_irqsave(&priv->pcireg_lock, flags);
+	writel(value, device_base + address);
+	udelay(ISL38XX_WRITEIO_DELAY);
+	spin_unlock_irqrestore(&priv->pcireg_lock, flags);
+}
+
+static inline void
+isl_write_pcireg(struct islsm *islsm, uint32_t value, uint32_t address)
+{
+	islpci_private         *priv = ISLPCI_OF_ISLSM(islsm);
+	islpci_write_pcireg(priv, value, address);
+}
+#elif defined(ISL_USBPCI)
+
+#include "islusb_net2280.h"
+
+static inline uint32_t isl_read_pcireg(struct islsm *islsm, uint32_t address)
+{
+	uint32_t                reg;
+	struct p54u            *p54u = P54U_OF_ISLSM(islsm);
+	(void) p54u_dev_readl(p54u, &reg, address);
+	return reg;
+}
+
+static inline void
+isl_write_pcireg(struct islsm *islsm, uint32_t value, uint32_t address)
+{
+	struct p54u            *p54u = P54U_OF_ISLSM(islsm);
+	p54u_dev_writel(p54u, value, address);
+	udelay(ISL38XX_WRITEIO_DELAY);
+}
+
+#endif
+
+static void __attribute__ ((unused))
+uart_prot_init(struct islsm *device)
+{
+	const uint32_t          uart_magic = 0x12345678;
+	uint32_t                reg;
+
+	/* Disable CTS/DR interrupts */
+	reg = isl_read_pcireg(device, ISL38XX_INT_EN_REG);
+	reg &= ~(ISL38XX_DEV_INT_PCIUART_CTS | ISL38XX_DEV_INT_PCIUART_DR);
+	isl_write_pcireg(device, reg, ISL38XX_INT_EN_REG);
+	udelay(ISL38XX_WRITEIO_DELAY);
+
+	/* write magic to activate UART via PCI protocol */
+	/* we don't send DR with this magic number */
+
+	isl_write_pcireg(device, uart_magic, ISL38XX_GEN_PURP_COM_REG_1);
+
+	/* give time to the device to raise CTS */
+	mdelay(50);
+
+	/* Check if the protocol is initialized */
+	reg = isl_read_pcireg(device, ISL38XX_INT_IDENT_REG);
+	reg &= ISL38XX_DEV_INT_PCIUART_CTS;
+
+	if (reg) {
+		/* ACK the interrupt */
+		isl_write_pcireg(device, reg, ISL38XX_INT_ACK_REG);
+		udelay(ISL38XX_WRITEIO_DELAY);
+		islog(L_DEBUG, "UART PCI protocol initialized\n");
+
+		/* Enable CTS/DR interrupts */
+		reg = isl_read_pcireg(device, ISL38XX_INT_EN_REG);
+		reg |=
+		    (ISL38XX_DEV_INT_PCIUART_CTS | ISL38XX_DEV_INT_PCIUART_DR);
+		isl_write_pcireg(device, reg, ISL38XX_INT_EN_REG);
+		udelay(ISL38XX_WRITEIO_DELAY);
+
+		/* And give CTS to the device */
+		isl_write_pcireg(device,
+				 ISL38XX_DEV_INT_PCIUART_CTS,
+				 ISL38XX_DEV_INT_REG);
+		udelay(ISL38XX_WRITEIO_DELAY);
+
+		/* give ourselves CTS. This is needed for freemac, and
+		 * should happen anyways for other protocols, albeit in
+		 * IRQ handler. This will work okay if writing to the
+		 * device does not happen too fast after init.
+		 */
+
+		//device->uart->cts = 1;
+	} else {
+		islog(L_DEBUG, "UART PCI protocol not operational\n");
+	}
+}
+
+static void __attribute__ ((unused))
+uart_prot_exit(struct islsm *device)
+{
+	uint32_t                reg;
+
+	/* remove magic */
+	isl_write_pcireg(device, 0, ISL38XX_GEN_PURP_COM_REG_1);
+	udelay(ISL38XX_WRITEIO_DELAY);
+
+	/* Disable CTS/DR interrupts */
+	reg = isl_read_pcireg(device, ISL38XX_INT_EN_REG);
+	reg &= ~(ISL38XX_DEV_INT_PCIUART_CTS | ISL38XX_DEV_INT_PCIUART_DR);
+	isl_write_pcireg(device, reg, ISL38XX_INT_EN_REG);
+	udelay(ISL38XX_WRITEIO_DELAY);
+}
+
+static void uart_cts(struct islsm *device)
+{
+	uart_instance_t        *uart = &device->uart;
+	unsigned long           flags;
+	uint32_t                data;
+
+	if (!uart) {
+		/* stray CTS signals can happen when we're opening then
+		 * closing the device very fast. We should wait for this
+		 * first CTS before returning from uart_prot_init */
+		islog(L_IRQ, "stray CTS signal\n");
+		return;
+	}
+
+	spin_lock_irqsave(&uart->lock, flags);
+	if (uart_inq(uart, &uart->txq) > 0) {
+		data = uart_qconsume(uart, &uart->txq);
+
+		spin_unlock_irqrestore(&uart->lock, flags);
+
+		isl_write_pcireg(device, data, ISL38XX_GEN_PURP_COM_REG_1);
+		udelay(ISL38XX_WRITEIO_DELAY);
+
+		/* Give DR */
+		isl_write_pcireg(device,
+				 ISL38XX_DEV_INT_PCIUART_DR,
+				 ISL38XX_DEV_INT_REG);
+		udelay(ISL38XX_WRITEIO_DELAY);
+
+	} else {
+		spin_unlock_irqrestore(&uart->lock, flags);
+		/* Device gives us CTS without any data to transmit */
+
+		/* yeah, right, make sure magic is removed -- we need
+		 * this when the first CTS is incoming, in response to
+		 * our own CTS. We should even wait for this event
+		 * (second CTS) to happen in order to leave
+		 * uart_prot_init */
+		isl_write_pcireg(device, 0, ISL38XX_GEN_PURP_COM_REG_1);
+		udelay(ISL38XX_WRITEIO_DELAY);
+		uart->cts = 1;
+	}
+}
+
+static void __attribute__ ((unused))
+uart_dr(struct islsm *device)
+{
+	uart_instance_t        *uart = &device->uart;
+	unsigned long           flags;
+	uint32_t                reg;
+
+	FN_ENTER;
+
+	if (!uart) {
+		islog(L_IRQ, "stray DR signal\n");
+		return;
+	}
+
+	reg = isl_read_pcireg(device, ISL38XX_GEN_PURP_COM_REG_2);
+	udelay(ISL38XX_WRITEIO_DELAY);
+
+	spin_lock_irqsave(&uart->lock, flags);
+	if (uart_inq(uart, &uart->rxq) < UARTPCI_RXQSIZE) {
+		uint8_t                 data = (uint8_t) (reg & 0xff);
+		uart_qproduce(uart, &uart->rxq, data);
+	}
+	spin_unlock_irqrestore(&uart->lock, flags);
+
+	/* Give CTS */
+	isl_write_pcireg(device, ISL38XX_DEV_INT_PCIUART_CTS,
+			 ISL38XX_DEV_INT_REG);
+	udelay(ISL38XX_WRITEIO_DELAY);
+
+	/* Activate the bottom halve */
+	wake_up_interruptible(&uart->wait);
+
+	FN_EXIT0;
+}
+
+/* reboot the device into rom (address 0xe0000000)
+ * or ram (address 0x00000000)
+ */
+static                  inline
+    void isl_reboot(struct islsm *device, const int ram)
+{
+	u32                     reg;
+
+	FN_ENTER;
+
+	/* Disable irqs in case they were not */
+	isl_write_pcireg(device, ISL38XX_INT_EN_REG, 0);
+
+	/* Reset the device */
+	/* clear the RAMBoot, the CLKRUN and the Reset bit */
+	reg = isl_read_pcireg(device, ISL38XX_CTRL_STAT_REG);
+	reg &= ~ISL38XX_CTRL_STAT_RESET;
+	if (!ram)
+		reg &= ~ISL38XX_CTRL_STAT_RAMBOOT;
+	else
+		reg |= ISL38XX_CTRL_STAT_RAMBOOT;
+	reg &= ~ISL38XX_CTRL_STAT_CLKRUN;
+	isl_write_pcireg(device, ISL38XX_CTRL_STAT_REG, reg);
+	wmb();
+
+	/* set the Reset bit without reading the register */
+	isl_write_pcireg(device, ISL38XX_CTRL_STAT_REG,
+			 reg | ISL38XX_CTRL_STAT_RESET);
+	wmb();
+
+	/* clear the Reset bit */
+	isl_write_pcireg(device, ISL38XX_CTRL_STAT_REG, reg);
+	wmb();
+
+	/* wait for the device to reboot */
+	mdelay(100);
+
+	FN_EXIT0;
+}
+
+/* Memory window management function */
+/* adjust the memory window of device for IO at address ptr.
+   we return the offset in the memory window.
+*/
+static unsigned adjust_memory_window(struct islsm *device, uint32_t addr)
+{
+	uint32_t                cur_mem_base, mem_base;
+
+	/* read from device the current memory window location */
+	/* we could also cache the result */
+	cur_mem_base = isl_read_pcireg(device, ISL38XX_DIR_MEM_BASE_REG);
+	udelay(ISL38XX_WRITEIO_DELAY);
+
+	/* check we're rounded to ISL38XX_PCI_MEM_SIZE */
+	mem_base =
+	    (addr / ISL38XX_MEMORY_WINDOW_SIZE) * ISL38XX_MEMORY_WINDOW_SIZE;
+
+	if (mem_base != cur_mem_base) {
+		islog(L_DEBUG, "Adjusting memory window to %x\n", mem_base);
+		isl_write_pcireg(device, mem_base, ISL38XX_DIR_MEM_BASE_REG);
+		udelay(ISL38XX_WRITEIO_DELAY);
+	}
+
+	return (addr - mem_base);
+}
+
+static uint32_t __attribute__ ((unused))
+isl_read_devmem(struct islsm *device, uint32_t addr)
+{
+	unsigned                offset;
+	uint32_t                reg;
+	offset = adjust_memory_window(device, addr);
+	reg = isl_read_pcireg(device, ISL38XX_DIRECT_MEM_WIN + offset);
+	udelay(ISL38XX_WRITEIO_DELAY);
+	return reg;
+}
+
+static void __attribute__ ((unused))
+isl_write_devmem(struct islsm *device, uint32_t value, uint32_t addr)
+{
+	unsigned                offset;
+	offset = adjust_memory_window(device, addr);
+	isl_write_pcireg(device, value, ISL38XX_DIRECT_MEM_WIN + offset);
+	udelay(ISL38XX_WRITEIO_DELAY);
+}
+
+/* Other common functions :
+ * i2c, dma, etc.
+ */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_3887.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_3887.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_3887.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_3887.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,509 @@
+/*
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/smp_lock.h>
+#include <linux/delay.h>
+#include <linux/usb.h>
+#include <linux/isl_38xx.h> /* just for ISL38XX_DEV_FIRMWARE_ADDRES */
+
+#include "islsm_uart.h"
+#include "islsm_log.h"
+#include "islsm_rom.h"
+#include "islusb_dev.h"
+#include "islusb_3887.h"
+
+/*
+ * UART-over-USB routines
+ */
+static void             uart_cts_cb(struct urb *urb);
+static void             uart_dr_cb(struct urb *urb);
+
+static int
+alloc_uart_urb(struct urb **urb_ref)
+{
+	void                   *buffer;
+	*urb_ref = usb_alloc_urb(0, GFP_KERNEL);
+	if (!*urb_ref)
+		return -ENOMEM;
+
+	buffer = kmalloc(P54U_MAX_FRAME_SIZE, GFP_KERNEL);
+	if (!buffer) {
+		usb_free_urb(*urb_ref);
+		return -ENOMEM;
+	}
+	(*urb_ref)->transfer_buffer = buffer;
+	(*urb_ref)->transfer_buffer_length = P54U_MAX_FRAME_SIZE;
+	return 0;
+}
+
+static void
+free_uart_urb(struct urb **urb_ref)
+{
+	kfree((*urb_ref)->transfer_buffer);
+	usb_free_urb(*urb_ref);
+	*urb_ref = 0;
+}
+
+static void
+uartusb_prot_init(struct islsm *islsm)
+{
+	struct p54u            *p54u = P54U_OF_ISLSM(islsm);
+	static char            *interrupt_string = "~";
+	void                   *init_buf;
+	int                     err;
+
+	FN_ENTER;
+
+	/* FIXME: Empty the standard queues for sending / receiving data
+	 * (drain_queue of some sort)
+	 */
+
+	init_buf = kmalloc(strlen(interrupt_string), GFP_KERNEL);
+
+	if (!init_buf)
+		return;
+
+	/* allocate the urb and buffer structures needed */
+	err = alloc_uart_urb(&p54u->cts);
+	if (err) {
+		FN_EXIT0;
+		return;
+	}
+
+	err = alloc_uart_urb(&p54u->dr);
+	if (err) {
+		free_uart_urb(&p54u->cts);
+		FN_EXIT0;
+		return;
+	}
+
+	/* fill the urbs */
+	usb_fill_bulk_urb(p54u->cts, p54u->usbdev, p54u->data_tx.endp,
+			  p54u->cts->transfer_buffer,
+			  p54u->cts->transfer_buffer_length,
+			  uart_cts_cb, islsm);
+
+	usb_fill_bulk_urb(p54u->dr, p54u->usbdev, p54u->data_rx.endp,
+			  p54u->dr->transfer_buffer,
+			  p54u->dr->transfer_buffer_length, uart_dr_cb, islsm);
+
+	/* really simple : start the urbs on data pipe,
+	   send reinit sequence, and you're all set */
+	/* submitting the DR urb *after* yields a series of ZZZZ;
+	   probably to indicate that the endpoint is sleeping ? */
+
+	/* give cts to device by submitting the DR urb */
+	usb_submit_urb(p54u->dr, GFP_KERNEL);
+	memcpy(init_buf, interrupt_string, strlen(interrupt_string));
+	p54u_bulk_msg(p54u, P54U_PIPE_DATA, init_buf, strlen(interrupt_string));
+	msleep(100);
+
+	/* The device should reply to this. */
+	kfree(init_buf);
+
+	/* give ourselves CTS */
+	islsm->uart.cts = 1;
+
+	FN_EXIT0;
+	return;
+}
+
+static void
+uartusb_prot_exit(struct islsm *device)
+{
+	struct p54u            *p54u = P54U_OF_ISLSM(device);
+	/* remove the submitted urbs from the endpoints (CTS and DR) */
+	usb_kill_urb(p54u->cts);
+	usb_kill_urb(p54u->dr);
+}
+
+static void
+uart_cts_cb(struct urb *urb)
+{
+	struct islsm           *device = (struct islsm *) urb->context;
+	uart_instance_t        *uart = &device->uart;
+	unsigned long           flags;
+	char                    data;
+
+	islog(L_DEBUG, "CTS urb returning\n");
+
+	/* check the urb status */
+	if (urb->status) {
+		/* bad status */
+		islog(L_DEBUG, "Bad CTS urb status\n");
+		return;
+	}
+
+	if (!uart) {
+		/* stray CTS signals can happen when we're opening then
+		 * closing the device very fast. We should wait for this
+		 * first CTS before returning from uart_prot_init */
+		islog(L_DEBUG, "stray CTS signal\n");
+		return;
+	}
+
+	spin_lock_irqsave(&uart->lock, flags);
+	/* copy data to the urb */
+	if (uart_inq(uart, &uart->txq) > 0) {
+		data = uart_qconsume(uart, &uart->txq);
+		spin_unlock_irqrestore(&uart->lock, flags);
+
+		/* escape some special protocol characters */
+		/* there may be more, but these seem sufficient
+		   per se */
+
+		switch (data) {
+		case '~':
+			memcpy(urb->transfer_buffer, "}^", 2);
+			urb->transfer_buffer_length = 2;
+			break;
+		case '}':
+			memcpy(urb->transfer_buffer, "}]", 2);
+			urb->transfer_buffer_length = 2;
+			break;
+		default:
+			memcpy(urb->transfer_buffer, &data, 1);
+			urb->transfer_buffer_length = 1;
+		}
+
+		/* Give DR <=> resubmit an urb */
+		/* what if this fails ? */
+		if (usb_submit_urb(urb, GFP_ATOMIC))
+			printk(KERN_ERR "islsm: sending CTS urb failed\n");
+	} else {
+		spin_unlock_irqrestore(&uart->lock, flags);
+		/* Device gives us CTS without any data to transmit */
+		uart->cts = 1;
+	}
+}
+
+static void
+uartusb_cts(struct islsm *device)
+{
+	struct p54u            *p54u = P54U_OF_ISLSM(device);
+	uart_cts_cb(p54u->cts);
+}
+
+static void
+uart_dr_cb(struct urb *urb)
+{
+	struct islsm           *device = (struct islsm *) urb->context;
+	uart_instance_t        *uart = &device->uart;
+	unsigned long           flags;
+	uint8_t                *data;
+	int                     i;
+
+	islog(L_DEBUG, "DR urb returning\n");
+
+	/* check the urb status */
+	if (urb->status) {
+		/* bad status. Should only happend on protocol exit */
+		islog(L_DEBUG, "Bad DR urb status\n");
+		return;
+	}
+
+	if (!uart) {
+		islog(L_DEBUG, "stray DR signal\n");
+		return;
+	}
+
+	data = (uint8_t *) urb->transfer_buffer;
+
+	spin_lock_irqsave(&uart->lock, flags);
+	/* copy the data from the urb */
+	islog(L_DATA, "received %i bytes\n", urb->actual_length);
+	for (i = 0; i < urb->actual_length; i++) {
+		if (uart_inq(uart, &uart->rxq) < UARTPCI_RXQSIZE)
+			uart_qproduce(uart, &uart->rxq, data[i]);
+		else {		/* ENOMEM, too bad, we drop data */
+			islog(L_DATA, "Dropping data in DR\n");
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&uart->lock, flags);
+
+	/* Give CTS == resubmit urb */
+	if (usb_submit_urb(urb, GFP_ATOMIC))
+		printk(KERN_ERR "islsm: sending DR urb failed\n");
+
+	/* Activate the bottom halve */
+	wake_up_interruptible(&uart->wait);
+}
+
+/*
+ * Firmware-loading routines
+ */
+
+static int
+p54u_send_abort_sequence(struct islsm *islsm) {
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	static char *init_string = "~~~~";
+	void *init_buf;
+	int err;
+
+	init_buf = kmalloc(strlen(init_string), GFP_KERNEL);
+	if (!init_buf)
+		return -ENOMEM;
+
+	memcpy(init_buf, init_string, strlen(init_string));
+	err =
+	    p54u_bulk_msg(p54u, P54U_PIPE_DATA, init_buf, strlen(init_string));
+	kfree(init_buf);
+	return err;
+}
+
+static int
+p54u_reset_dev2(struct islsm *islsm)
+{
+	int err;
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+
+	FN_ENTER;
+
+	/* really simple : start the urbs on data pipe,
+	   send reinit sequence, and you're all set */
+	err = rx_queue_refill(p54u, &p54u->data_rx);
+	if (err)
+		goto out;
+
+	err = p54u_send_abort_sequence(islsm);
+	if (err)
+		goto out;
+
+	msleep(100);
+
+out:
+	FN_EXIT1(err);
+	return err;
+}
+
+/* the data needs some formatting :
+ * escape 0x7e to 0x7d 0x5e
+ * escape 0x7d to 0x7d 0x5d
+ */
+static unsigned
+firmware_escape_write_buffer(char *buf, char *data, unsigned write)
+{
+	static char carry = 0;
+	unsigned int i = 0, j = 0;
+	char val;
+
+	if (carry) {
+		buf[j++] = carry;
+		carry = 0;
+	}
+
+	while (j < write) {
+		switch (val = data[i++]) {
+		case '~':
+			buf[j++] = '}';
+			if (j == write)
+				carry =  '^';
+			else
+				buf[j++] = '^';
+			break;
+		case '}':
+			buf[j++] = '}';
+			if (j == write)
+				carry = ']';
+			else
+				buf[j++] = ']';
+			break;
+		default:
+			buf[j++] = val;
+		}
+	}
+	return i;
+}
+
+static int
+p54u_boot_fw2(struct islsm *islsm)
+{
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	static char *go_string = "g\r";
+	int err;
+	void *fw_buf;
+	/* The bootrom has control */
+
+	FN_ENTER;
+
+	fw_buf = kmalloc(P54U_FW_BLOCK, GFP_KERNEL);
+	if (!fw_buf) {
+		FN_EXIT1(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	/* send GO */
+	strcpy(fw_buf, go_string);
+
+	err = p54u_bulk_msg(p54u, P54U_PIPE_DATA,
+			    fw_buf, strlen(go_string));
+
+	/* The firmware should respond with g. Then we're on our own. */
+	err = islsm_wait_timeout(islsm, HZ);
+
+	kfree(fw_buf);
+	/* The lm87 firmware need 350ms to boot */
+	msleep(350);
+
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+islrom_build_x2(struct x2_header *header,
+		uint32_t fw_load_addr, uint32_t fw_length)
+{
+	uint32_t crc;
+	memcpy(header->signature, X2_SIGNATURE, X2_SIGNATURE_SIZE);
+	header->cmd.fw_load_addr = cpu_to_le32(fw_load_addr);
+	header->cmd.fw_length = cpu_to_le32(fw_length);
+	crc = islrom_crc32(&header->cmd, sizeof (header->cmd));
+	header->crc = cpu_to_le32(crc);
+	return 0;
+}
+
+static int
+p54u_load_firmware2(struct islsm *islsm, const struct firmware *fw_entry)
+{
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	struct usb_device *usbdev = p54u->usbdev;
+	static char *start_string = "~~~~<\r";
+	void *data, *fw_buf;
+	unsigned int length, read, written, remains;
+	uint32_t crc;
+	int alen;
+	int err = 0;
+
+	FN_ENTER;
+
+	fw_buf = kmalloc(P54U_FW_BLOCK, GFP_KERNEL);
+	if (!fw_buf) {
+		FN_EXIT1(-ENOMEM);
+		return -ENOMEM;
+	}
+	/* this is awfully simple */
+	data = fw_entry->data;
+	remains = fw_entry->size;
+
+	/* copy the command */
+	strcpy(fw_buf, start_string);
+	length = strlen(start_string);
+
+	/* build the X2 header */
+	islrom_build_x2(fw_buf + length,
+			ISL38XX_DEV_FIRMWARE_ADDRES, fw_entry->size);
+	length += sizeof(struct x2_header);
+
+	while (remains > 0 && !err) {
+		int pipe;
+		written =
+		    remains >
+		    (P54U_FW_BLOCK - length) ? (P54U_FW_BLOCK -
+						length) : remains;
+		read =
+		    firmware_escape_write_buffer(fw_buf + length, data,
+						 written);
+
+		/* directly transfert the data -- no debug, it causes
+		 * kmalloc errors */
+		pipe = usb_sndbulkpipe(usbdev, P54U_PIPE_DATA);
+		err = usb_bulk_msg(usbdev, pipe, fw_buf,
+				   length + written, &alen, 2*HZ);
+
+		if (err) {
+			printk(KERN_ERR
+			       "%s: error writing firmware block:"
+			       "remains %i of %zd.\n",
+			       DRV_NAME, remains, fw_entry->size);
+		}
+
+		data += read;
+		remains -= read;
+		length = 0;
+	}
+
+	/* now send the checksum of the firmware */
+	crc = islrom_crc32(fw_entry->data, fw_entry->size);
+	*((uint32_t *)fw_buf) = cpu_to_le32(crc);
+	err = p54u_bulk_msg(p54u, P54U_PIPE_DATA, fw_buf, sizeof(uint32_t));
+
+	kfree(fw_buf);
+
+	/* At this point the firmware sends back an "OK" string */
+	err = islsm_wait_timeout(islsm,HZ);
+	islog(L_DEBUG, "%s: send firmware done\n", DRV_NAME);
+
+	/* Now we send the go command */
+
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+isl_load_fw2(struct islsm *device, const struct firmware *fw)
+{
+	int err;
+	err = p54u_reset_dev2(device);
+	if (err)
+		goto exit;
+	err = p54u_load_firmware2(device, fw);
+	if (err)
+		goto exit;
+	err = p54u_boot_fw2(device);
+ exit:
+	return err;
+}
+
+/*
+ * Packet transport functions
+ */
+static int
+tx_submit_ver2(struct sk_buff *skb)
+{
+	struct p54u *p54u = P54U_OF_NETDEV(skb->dev);
+	int err;
+	err = tx_queue_submit(&p54u->data_tx, skb);
+	return err;
+}
+
+void
+islusb_fill_3887(struct islsm *islsm) {
+	/* some if not all of these should be filled
+	   automatically when parsing the firmware */
+	islsm->isl_tx = tx_submit_ver2;
+	islsm->device_tx_header_space = 0;
+	islsm->device_version = ISLSM_DEVICE_USB_VER2;
+	/* possibly maybe */
+	islsm->isl_romboot = p54u_send_abort_sequence;
+	islsm->isl_load_fw = isl_load_fw2;
+
+	/* unknown and probably unavailable */
+	islsm->isl_read_pcireg = 0;
+	islsm->isl_write_pcireg = 0;
+	islsm->isl_write_devmem = 0;
+	islsm->isl_read_devmem = 0;
+
+	/* uart procotol initialization */
+	islsm->uart_prot_init = uartusb_prot_init;
+	islsm->uart_prot_exit = uartusb_prot_exit;
+	islsm->uart_cts = uartusb_cts;
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_3887.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_3887.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_3887.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_3887.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,24 @@
+/*
+  Copyright 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include "isl_sm.h"
+
+void islusb_fill_3887(struct islsm *islsm);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_dev.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_dev.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_dev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_dev.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,270 @@
+/*
+  Copyright 2004 Feyd
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAS_ISLUSB_DEV_H
+#define _HAS_ISLUSB_DEV_H
+
+#include <linux/usb.h>
+#include <linux/netdevice.h>	/* net_device */
+
+#define DRV_NAME "prism54usb"
+
+#define P54U_IMAGE_FILE		"isl3890usb"
+#define P54U_IMAGE_FILE_X2	"isl3887usb"
+#define IMAGE_FILE_3887		"isl3887usb_bare"
+
+/* Should be reduced as 
+   max(0x400, mru + rx_headers) */
+#define P54U_MAX_FRAME_SIZE	4096
+#define P54U_QUEUE_LEN          16
+#define P54U_FW_BLOCK		512
+
+/* pipes 3 and 4 are not used by the driver */
+#define P54U_PIPE_NUMBER 9
+
+enum p54u_pipe_addr {
+	P54U_PIPE_DATA = 0x01,
+	P54U_PIPE_MGMT = 0x02,
+	P54U_PIPE_3 = 0x03,
+	P54U_PIPE_4 = 0x04,
+	P54U_PIPE_BRG = 0x0d,
+	P54U_PIPE_DEV = 0x0e,
+	P54U_PIPE_INT = 0x0f,
+};
+
+enum p54u_pipe_index {
+	P54U_TX_DATA,
+	P54U_TX_MGMT,
+	P54U_TX_BRG,
+	P54U_TX_DEV,
+	P54U_RX_DATA,
+	P54U_RX_MGMT,
+	P54U_RX_3,
+	P54U_RX_4,
+	P54U_RX_BRG,
+	P54U_RX_DEV,
+	P54U_RX_INT,
+	P54U_PIPES,
+};
+
+enum p54u_state {
+	P54U_BOOT,
+	P54U_RUN,
+	P54U_SHUTDOWN,
+	P54U_STOPPED,
+};
+
+enum p54u_versions {
+	P54U_DEVICE_VER1,
+	P54U_DEVICE_VER2,
+};
+
+/* net2280.h ? */
+struct net2280_reg_write {
+	u16                     port;
+	u32                     addr;
+	u32                     val;
+} __attribute__ ((packed));
+
+struct net2280_reg_read {
+	u16                     port;
+	u32                     addr;
+} __attribute__ ((packed));
+
+struct p54u_mgmt_tx {
+	u32                     magic1;
+	u32                     magic2;
+	u32                     magic3;
+	u16                     pos;
+	u16                     len;
+} __attribute__ ((packed));
+
+struct p54u_pipe_desc {
+	u8                      addr;	/* the address of the endpoint */
+	u8                      type;	/* the transfer type of the endpoint */
+	size_t                  p_size;	/* the size of the packet */
+	void                    (*callback) (struct urb * urb,
+					     struct pt_regs * regs);
+};
+
+/* RX QUEUES DESCRIPTION
+
+DATA ORGANIZATION:
+   for rx queue we maintain 3 ever-increasing indexes to be interpreted
+   modulo the size of the queue, which serves as a ring buffer : f,c,p
+
+   - f points to the next frame to be processed by the softmac
+     layer. It's modified in driver bottom half => needs locking ?
+
+   - c points to the next submitted frame pending usb callback (meaning
+     the data it contains will have been written by the device). It's
+     modified during the urb callback, in interrupt context.
+
+   - p points to the next free frame. It's modified during frame
+     resubmission, after processing the rx'd frames in the bottom half
+     => needs locking ?
+
+Initially, a frame is free in the [p,f[ range; its receive buffer is
+alloc'd. It is then submitted to the usb layer an goes to the [c,p[
+range of submitted but not filled in frames.  Upon urb callback, it
+falls into the [f,c[ interval : this frame has been received but its
+contents have not yet been processed by the softmac layer. This allows
+the callback to return quickly, as it does minimal work. Later, in a
+bottom half, the frame will be processed (then its buffer is freed), its
+buffer alloc'd, and it will return into the [p,f[ range of free
+frames. And resubmitted immediately.
+
+DATA CONTENTS: an element in a rx queue is composed of an urb and an skb
+whose data pointer is the receive buffer of the urb.
+
+BUFFER ALLOCATION:
+
+    - the urb are recycled, and allocated once and for all.
+
+    - the softmac layer is in charge of freeing the transfer buffers.
+the rx queue mechanism is in charge of allocating the transfer buffers
+(on frame free). We could refine this allocation mechanism by allowing
+the softmac not to free the transfert buffer.
+*/
+
+/* associated functions
+
+   XXX
+*/
+
+/* TX QUEUES DESCRIPTION
+
+DATA ORGANIZATION
+   for tx queue we maintain 3 ever-increasing indexes to be interpreted
+   modulo the size of the queue, which serves as a ring buffer : f,c,p
+
+   - f points to the next frame to be processed by the softmac
+     layer.
+
+   - c points to the next submitted frame pending usb callback (meaning
+     the data it contains will have been received and acknowledged by
+     the device). It's modified during the urb callback, in interrupt
+     context.
+
+   - p points to the next free frame. It's modified during frame
+     submission, after processing, in the bottom half => needs locking ?
+
+Basically f is not really needed here, because the softmac layer does
+not process the tx'd frames. We can have only two indexes, f being
+always equal to c, for instance ; or always equal to p.
+
+DATA CONTENTS: an element in a rx queue is composed of two urbs, one
+with a fixed size, either 32 bits (version 1) or 16 bytes (version 2),
+for the announcement message, and a data urb proper, whose transfert
+buffer needs to be provided by the upper layer (softmac).
+
+BUFFER ALLOCATION:
+
+   - the urbs are recycled. The announcement urbs's buffer are recycled
+     too.
+
+   - the tx skb are freed by us upon callback completion.
+
+*/
+
+/* associated functions :
+   XXX
+*/
+
+typedef struct {
+	struct urb             *descr_urb;	/* urbs used to send the announced message */
+	struct urb             *data_urb;	/* actual data to send */
+	struct sk_buff         *skb;	/* data buffer */
+} usb_command_t;
+
+struct p54u;
+
+struct p54u_pipe {
+	/* these three should go into a struct */
+	usb_command_t          *ringbuf;
+	int                     len;	/* the length of the ringbufer */
+
+	/* queue management */
+	unsigned int            f;
+	unsigned int            c;
+	unsigned int            p;
+
+	/* bottom half to be run on data rx/tx */
+	spinlock_t              lock;
+	struct tasklet_struct   task;
+
+	/* usb characteristics :replace with endp descrptor ? */
+	u8                      addr;	/* the address of the endpoint */
+	u8                      type;	/* the transfer type of the endpoint */
+	size_t                  buffer_size;	/* the size of the buffer to allocate */
+	int                     interval;
+	int                     endp;
+
+	/* our container p54u instance */
+	struct p54u            *p54u;
+};
+
+/* Structure to hold all of our device specific stuff */
+struct p54u {
+	struct usb_device      *usbdev;	/* save off the usb device pointer */
+	struct usb_interface   *interface;	/* save off the usb device pointer */
+
+	int                     state;
+	/* version-specific handling */
+	int                     device_version;
+
+	/* Bulk data pipes */
+	struct p54u_pipe        data_tx;
+	struct p54u_pipe        data_rx;
+	struct p54u_pipe        mgmt_tx;
+	struct p54u_pipe        mgmt_rx;
+
+	/* net2280-specific variables */
+	struct semaphore        reg_sem;
+	struct work_struct      int_bh;
+	struct urb             *int_urb;
+
+	/* 3887-specific URBs for uart-over-usb */
+	struct urb             *dr;
+	struct urb             *cts;
+};
+
+extern int              load_fw;
+
+#define P54U_OF_ISLSM(x) ((struct p54u *)(x)->priv)
+#define P54U_OF_NETDEV(x) ((struct p54u *) islsm_priv(x))
+
+/* device hardware queue management */
+void                    p54u_queue_destroy(struct p54u_pipe *queue);
+int                     p54u_queue_init(struct p54u *device, struct usb_endpoint_descriptor
+					*desc, struct p54u_pipe *queue);
+int                     rx_queue_refill(struct p54u *p54u,
+					struct p54u_pipe *queue);
+
+/* usb transport functions */
+int                     p54u_bulk_msg(struct p54u *device,
+				      unsigned int ep, void *data, int len);
+
+/* tx callbacks for usb devices */
+int                     tx_queue_submit(struct p54u_pipe *queue, struct sk_buff *skb);
+
+#endif /* _HAS_ISLUSB_DEV_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_init.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_init.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_init.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_init.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,428 @@
+/*
+  Copyright 2004 Feyd
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <linux/usb.h>
+#include <linux/pci.h>
+#include <linux/firmware.h>
+#include <linux/isl_38xx.h>
+#include <asm/uaccess.h>
+
+#include "islusb_dev.h"
+#include "isl_sm.h"
+#include "islsm_log.h"
+
+
+#include "islusb_net2280.h"
+#include "islusb_3887.h"
+
+static const struct usb_device_id p54u_table[] = {
+	/* Version 1 devices (pci chip + net2280) */
+	{USB_DEVICE(0x0506, 0x0a11)},	/* 3COM 3CRWE254G72 */
+	{USB_DEVICE(0x0707, 0xee06)},	/* SMC 2862W-G */
+	{USB_DEVICE(0x083a, 0x4501)},	/* Accton 802.11g WN4501 USB */
+	{USB_DEVICE(0x083a, 0x4502)},	/* Siemens Gigaset USB Adapter */
+	{USB_DEVICE(0x083a, 0x5501)},	/* Phillips CPWUA054*/
+	{USB_DEVICE(0x0846, 0x4200)},	/* Netgear WG121 */
+	{USB_DEVICE(0x0846, 0x4210)},	/* Netgear WG121 the second ? */
+	{USB_DEVICE(0x0846, 0x4220)},	/* Netgear WG111 */
+	{USB_DEVICE(0x0cde, 0x0006)},	/* Medion 40900, Roper Europe */
+	{USB_DEVICE(0x124a, 0x4023)},	/* Shuttle PN15, Airvast WM168g, IOGear GWU513 */
+	{USB_DEVICE(0x1915, 0x2234)},	/* Linksys WUSB54G OEM */
+	{USB_DEVICE(0x1915, 0x2235)},	/* Linksys WUSB54G Portable OEM */
+	{USB_DEVICE(0x2001, 0x3701)},	/* DLink DWL-G120 Spinnaker */
+	{USB_DEVICE(0x2001, 0x3703)},	/* DLink DWL-G122 */
+	{USB_DEVICE(0x5041, 0x2234)},	/* Linksys WUSB54G */
+	{USB_DEVICE(0x5041, 0x2235)},	/* Linksys WUSB54G Portable */
+
+	/* Version 2 devices (3887) */
+	{USB_DEVICE(0x050D, 0x7050)},	/* Belkin F5D7050 ver 1000 */
+	{USB_DEVICE(0x0572, 0x2000)},	/* Cohiba Proto board */
+	{USB_DEVICE(0x0572, 0x2002)},	/* Cohiba Proto board */
+	{USB_DEVICE(0x0707, 0xee13)},   /* SMC 2862W-G version 2 */
+	{USB_DEVICE(0x083a, 0x4521)},   /* Siemens Gigaset USB Adapter 54 version 2 */
+	{USB_DEVICE(0x0846, 0x4240)},	/* Netgear WG111 */
+	{USB_DEVICE(0x0915, 0x2000)},	/* Cohiba Proto board */
+	{USB_DEVICE(0x0915, 0x2002)},	/* Cohiba Proto board */
+	{USB_DEVICE(0x0baf, 0x0118)},   /* U.S. Robotics U5 802.11g Adapter*/
+	{USB_DEVICE(0x0BF8, 0x1009)},   /* FUJITSU E-5400 USB D1700*/
+	{USB_DEVICE(0x0cde, 0x0008)},	/* Sagem XG703A */
+	{USB_DEVICE(0x0D8E, 0x3762)},	/* DLink DWL-G120 Cohiba */
+	{USB_DEVICE(0x09AA, 0x1000)},	/* Spinnaker Proto board */
+	{USB_DEVICE(0x2001, 0x3704)},	/* DLink DWL-G122 rev A2 */
+	{USB_DEVICE(0x1435, 0x0427)},	/* Inventel UR054G */
+	{USB_DEVICE(0x413C, 0x8102)},	/* Spinnaker DUT */
+	{USB_DEVICE(0x413C, 0x8104)},	/* Cohiba Proto board */
+	{}
+};
+
+MODULE_DESCRIPTION("Prism54 USB Driver");
+MODULE_AUTHOR
+    ("Feyd <feyd@seznam.cz>, Jean-Baptiste Note <jean-baptiste.note@m4x.org>");
+MODULE_LICENSE("GPL");
+MODULE_DEVICE_TABLE(usb, p54u_table);
+
+static int
+p54u_alloc_buffers(struct p54u *p54u)
+{
+	struct usb_interface *interface = p54u->interface;
+	struct usb_host_interface *iface_desc = &interface->altsetting[0];
+	struct usb_endpoint_descriptor *desc;
+	int err = 0, i;
+
+	FN_ENTER;
+
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		desc = &iface_desc->endpoint[i].desc;
+		switch (desc->bEndpointAddress) {
+		case P54U_PIPE_DATA:
+			err = p54u_queue_init(p54u, desc, &p54u->data_tx);
+			break;
+		case P54U_PIPE_MGMT:
+			err = p54u_queue_init(p54u, desc, &p54u->mgmt_tx);
+			break;
+		case P54U_PIPE_DATA | USB_DIR_IN:
+			err = p54u_queue_init(p54u, desc, &p54u->data_rx);
+			break;
+		case P54U_PIPE_MGMT | USB_DIR_IN:
+			err = p54u_queue_init(p54u, desc, &p54u->mgmt_rx);
+			break;
+		case P54U_PIPE_INT | USB_DIR_IN:
+			err = p54u_int_queue_init(p54u, desc);
+			break;
+		default:
+			islog(L_DEBUG, "unknown %02x endpoint left alone\n",
+			      desc->bEndpointAddress);
+			break;
+		}
+		if (err)
+			goto do_err;
+	}
+	FN_EXIT1(0);
+	return 0;
+
+      do_err:
+	/* FIXME : free buffers */
+	FN_EXIT1(err);
+	return err;
+}
+
+/* kicks the hardware state machine on */
+static int
+p54u_boot(struct net_device *netdev)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(netdev);
+	struct p54u *p54u = P54U_OF_NETDEV(netdev);
+	const struct firmware *fw_entry;
+	int err = 0;
+	int try = 0;
+
+	FN_ENTER;
+
+	/* do nothing if we're already up */
+	if (p54u->state == P54U_RUN) {
+		FN_EXIT1(0);
+		return 0;
+	}
+
+	/* Allocations. Here only software can fault */
+	p54u->state = P54U_BOOT;
+
+	err = islsm_request_firmware(&fw_entry, islsm);
+	if (err)
+		goto exit;
+
+	do {
+		err = islsm->isl_load_fw(islsm, fw_entry);
+		try++;
+	} while(err && try < 3);
+
+	if (err) {
+		printk(KERN_ERR "%s: Boot the device failed: %i\n",
+		       DRV_NAME, err);
+		goto exit_release_firmware;
+	}
+
+	p54u->state = P54U_RUN;
+
+ exit_release_firmware:
+	release_firmware(fw_entry);
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+/* TODO: Devices only have one setting, and it is fixed. Separate
+ * version 1 and version 2 validation
+ */
+static int
+p54u_validate_device(struct usb_interface *interface,
+		     const struct usb_device_id *id)
+{
+	/* We'll check that the device has the required endpoints in at
+	 * least one of its alternate configurations. returns -1 in case there's
+	 * not, otherwise, the index of the first alternate
+	 * configuration which matches what we need */
+
+	struct usb_endpoint_descriptor *epdesc;
+	struct usb_host_interface *curint = interface->altsetting;
+	unsigned int i, j;
+	islog(L_DEBUG, "%s: %i alternate settings for device\n",
+	      DRV_NAME, interface->num_altsetting);
+	for (i = 0; i < interface->num_altsetting; i++) {
+		unsigned int recognized_pipes = 0;
+
+		for (j = 0; j < curint->desc.bNumEndpoints; j++) {
+			epdesc = &curint->endpoint[j].desc;
+			switch (epdesc->bEndpointAddress) {
+			case P54U_PIPE_DATA:
+			case P54U_PIPE_MGMT:
+			case P54U_PIPE_BRG:
+			case P54U_PIPE_DEV:
+			case P54U_PIPE_DATA | USB_DIR_IN:
+			case P54U_PIPE_MGMT | USB_DIR_IN:
+			case P54U_PIPE_BRG | USB_DIR_IN:
+			case P54U_PIPE_DEV | USB_DIR_IN:
+			case P54U_PIPE_INT | USB_DIR_IN:
+				recognized_pipes++;
+				islog(L_DEBUG, "%s: recognized endpoint %02x\n",
+				      DRV_NAME, epdesc->bEndpointAddress);
+				break;
+			default:
+				islog(L_DEBUG,
+				      "%s: unrecognized endpoint %02x\n",
+				      DRV_NAME, epdesc->bEndpointAddress);
+			}
+		}
+		if (recognized_pipes >= P54U_PIPE_NUMBER) {
+			islog(L_DEBUG,
+			      "%s: Alternate setting %i ok for driver\n",
+			      DRV_NAME, i);
+			return i;
+		}
+		curint++;
+	}
+	return -1;
+}
+
+/* manages allocation of the netdev and 802.11 resources */
+static int
+p54u_probe(struct usb_interface *interface, const struct usb_device_id *id)
+{
+	struct usb_device *usbdev = interface_to_usbdev(interface);
+	struct net_device *netdev;
+	struct p54u *p54u;
+	struct islsm *islsm;
+	int error;
+	int conf_index;
+
+	usb_get_dev(usbdev);
+
+	islog(L_DEBUG,
+	      "%s: Prism54 USB Device Probe (Device number:%d): "
+	      "0x%4.4x:0x%4.4x:0x%4.4x\n", DRV_NAME,
+	      usbdev->devnum, (int) usbdev->descriptor.idVendor,
+	      (int) usbdev->descriptor.idProduct,
+	      (int) usbdev->descriptor.bcdDevice);
+	islog(L_DEBUG, "%s: Device at %p\n", DRV_NAME, usbdev);
+	islog(L_DEBUG, "%s: Descriptor length: %x type: %x\n", DRV_NAME,
+	      (int) usbdev->descriptor.bLength,
+	      (int) usbdev->descriptor.bDescriptorType);
+
+	conf_index = p54u_validate_device(interface, id);
+
+	// do this allocation elsewhere ?
+	netdev = alloc_islsm(sizeof (struct p54u));
+	if (!netdev) {
+		printk(KERN_ERR "%s: failed to allocate netdevice\n", DRV_NAME);
+		return -ENOMEM;
+	}
+
+	islsm = ISLSM_OF_NETDEV(netdev);
+	p54u = P54U_OF_NETDEV(netdev);
+
+	p54u->interface = interface;
+	p54u->usbdev = usbdev;
+
+	SET_MODULE_OWNER(netdev);
+
+	// FIXME
+	usb_set_intfdata(interface, islsm);
+
+	/* version-dependent initialization */
+	/* we take the hardware up to the point where it is ready to
+	   talk to us via the ROM */
+	if (conf_index == 0) {
+		printk(KERN_INFO
+		       "%s: suitable configuration found for net2280 + PCI device\n",
+		       DRV_NAME);
+		p54u->device_version = P54U_DEVICE_VER1;
+		init_MUTEX(&p54u->reg_sem);
+		islusb_fill_net2280(islsm);
+		strcpy(islsm->firmware_name, P54U_IMAGE_FILE);
+	} else {
+		printk(KERN_INFO
+		       "%s: No suitable configuration found, trying 3887 support\n",
+		       DRV_NAME);
+		p54u->device_version = P54U_DEVICE_VER2;
+		islusb_fill_3887(islsm);
+		strcpy(islsm->firmware_name, IMAGE_FILE_3887);
+	}
+
+	islsm->isl_boot = p54u_boot;
+	error = p54u_alloc_buffers(p54u);
+
+	if (error) {
+		printk(KERN_ERR "%s: Failed to allocate buffers", DRV_NAME);
+		goto do_cleanup_buf;
+	}
+	// usb_put_dev(usbdev);
+	// I don't know what this means, if this is needed at all...
+	SET_NETDEV_DEV(netdev, &interface->dev);
+
+	error = register_islsm(netdev);
+	if (error) {
+		printk(KERN_ERR "%s: Failed to register islsm\n", DRV_NAME);
+		goto do_cleanup_setup;
+	}
+#ifdef PCIUART
+	error = uart_init_dev(islsm);
+	if (error)
+		goto do_cleanup_uart;
+#endif				/* PCIUART */
+
+	/* in case of a version 1 device, we want to setup the net2280
+	 * right away and activate the bootrom */
+	if (p54u->device_version == P54U_DEVICE_VER1)
+		p54u_setup_rom(p54u);
+
+	return 0;
+
+#ifdef PCIUART
+	uart_release_dev(islsm);
+      do_cleanup_uart:
+#endif				/* PCIUART */
+	unregister_islsm(netdev);
+	/* FIXME */
+      do_cleanup_setup:
+	//p54u_free_buffers()
+      do_cleanup_buf:
+	usb_set_intfdata(interface, NULL);
+	free_islsm(netdev);
+	usb_put_dev(usbdev);
+	return -EIO;
+}
+
+static void
+p54u_disconnect(struct usb_interface *interface)
+{
+	struct usb_device *usbdev = interface_to_usbdev(interface);
+	struct islsm *islsm = usb_get_intfdata(interface);
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	struct net_device *netdev = NETDEV_OF_ISLSM(islsm);
+
+	islog(L_DEBUG, "prism54 USB device %i disconnecting\n", islsm->minor);
+
+	unregister_islsm(netdev);
+	islog(L_DEBUG, "Stopped software state machines\n");
+
+	// Once the madwifi is detached, there is no bh problem any more
+	// so this is okay. Previously there were heavy problems with
+	// RUN->INIT transition that left bh disabled when running this.
+
+	if (p54u->state == P54U_RUN) {
+		p54u->state = P54U_SHUTDOWN;
+		p54u_queue_destroy(&p54u->data_rx);
+		p54u_queue_destroy(&p54u->mgmt_rx);
+		p54u_queue_destroy(&p54u->data_tx);
+		p54u_queue_destroy(&p54u->mgmt_tx);
+		if (p54u->device_version == P54U_DEVICE_VER1)
+			p54u_int_queue_destroy(p54u);
+		islog(L_DEBUG, "All queues destroyed\n");
+	}
+#ifdef PCIUART
+	uart_release_dev(islsm);
+#endif				/* PCIUART */
+
+	usb_set_intfdata(interface, NULL);
+	islog(L_DEBUG, "Cleared interface data\n");
+
+	free_islsm(netdev);
+	islog(L_DEBUG, "Freed netdevice\n");
+
+	// could be done earlier
+	usb_put_dev(usbdev);
+
+	islog(L_DEBUG, "Disconnect complete\n");
+}
+
+static struct usb_driver p54u_driver = {
+	.name = DRV_NAME,
+	.probe = p54u_probe,
+	.disconnect = p54u_disconnect,
+	.id_table = p54u_table,
+};
+
+static int __init
+p54u_init(void)
+{
+	int err;
+
+#ifdef PCIUART
+	err = uart_init_module();
+	if (err) {
+		return err;
+	}
+#endif
+
+	/* register this driver with the USB subsystem */
+	err = usb_register(&p54u_driver);
+	if (err) {
+		printk(KERN_ERR "%s: usb_register failed, %d\n",
+		       DRV_NAME, err);
+#ifdef PCIUART
+		uart_cleanup_module();
+#endif
+		return err;
+	}
+
+	return 0;
+}
+
+static void __exit
+p54u_exit(void)
+{
+	/* deregister this driver with the USB subsystem */
+	usb_deregister(&p54u_driver);
+#ifdef PCIUART
+	uart_cleanup_module();
+#endif
+}
+
+module_init(p54u_init);
+module_exit(p54u_exit);
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_net2280.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_net2280.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_net2280.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_net2280.c	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,1040 @@
+/*
+  Copyright 2004 Feyd
+  Copyright 2004, 2005, 2006 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/version.h>
+#include "islusb_net2280.h"
+#include "islusb_dev.h"
+#include "islsm_log.h"
+
+/*
+ * PCI registers access functions
+ */
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+#define RW_TIMEOUT     1000
+#else
+#define RW_TIMEOUT     1 * HZ
+#endif
+
+static inline void
+islusb_lock_reg(struct p54u *p54u)
+{
+	down(&p54u->reg_sem);
+}
+
+static inline void
+islusb_unlock_reg(struct p54u *p54u)
+{
+	up(&p54u->reg_sem);
+}
+
+#define IS_U32_PORT(port) ((port & P54U_PORT_U32) == P54U_PORT_U32)
+
+static int 
+_net2280_write_reg(struct usb_device *usbdev, int ep, int port,
+			  u32 val, u32 addr) {
+	/* structures & defs should be in net2280.h -- this is not at all islusb-specific */
+	struct net2280_reg_write wreg;
+	unsigned pipe, retlen;
+	int err;
+
+	wreg.port = cpu_to_le16(port);
+	wreg.addr = cpu_to_le32(addr);
+	if (!IS_U32_PORT(port))
+		val &= 0xffff;
+	wreg.val  = cpu_to_le32(val);
+
+	pipe = usb_sndbulkpipe(usbdev, ep & USB_ENDPOINT_NUMBER_MASK);
+	/* passing a stack'd address to bulk_msg is OKay for many
+	   architecture.  We may have some problems on some, though */
+	err = usb_bulk_msg(usbdev, pipe, &wreg, sizeof(wreg), &retlen, RW_TIMEOUT);
+
+	if (err)
+		usb_clear_halt(usbdev, pipe);
+
+	if (!err)
+		islsm_txdata_debug(ep, &wreg, retlen);
+
+	return err;
+}
+
+static int
+_net2280_send_read_reg(struct usb_device *usbdev, int ep, int port,
+		       u32 addr) {
+	struct net2280_reg_read rreg;
+	unsigned pipe, retlen;
+	int err;
+
+	rreg.port = cpu_to_le16(port);
+	rreg.addr = cpu_to_le32(addr);
+
+	pipe = usb_sndbulkpipe(usbdev, ep & USB_ENDPOINT_NUMBER_MASK);
+	/* passing a stack'd address to bulk_msg is OKay for many
+	   architecture.  We may have some problems on some, though */
+	err = usb_bulk_msg(usbdev, pipe, &rreg, sizeof(rreg), &retlen, RW_TIMEOUT);
+	if (!err)
+		islsm_txdata_debug(ep, &rreg, retlen);
+
+	return err;
+}
+
+static int 
+_net2280_rx_read_reg(struct usb_device *usbdev, int ep, int port,
+		     u32 *retval) {
+	u32 reg;
+	unsigned pipe, retlen;
+	int err;
+
+	pipe = usb_rcvbulkpipe(usbdev, ep & USB_ENDPOINT_NUMBER_MASK);
+
+	/* passing a stack'd address to bulk_msg is OKay for many
+	   architecture.  We may have some problems on some, though */
+	err = usb_bulk_msg(usbdev, pipe, &reg, sizeof(reg), &retlen, RW_TIMEOUT);
+
+	reg = le32_to_cpu(reg);
+
+	if (!IS_U32_PORT(port))
+		reg &= 0xffff;
+
+	if (!err) {
+		islsm_rxdata_debug(ep | USB_DIR_IN, &reg, retlen);
+		*retval = reg;
+	}
+
+	return err;
+}
+
+#define NET2280_WRITE_RETRY 2
+
+int islusb_net2280_write_reg(struct p54u *p54u, int ep, int port,
+			     u32 val, u32 addr) {
+	struct usb_device *usbdev = p54u->usbdev;
+	int tries = 0, err;
+
+	islusb_lock_reg(p54u);
+
+	do {
+		err = _net2280_write_reg(usbdev, ep, port, val, addr);
+		tries++;
+	} while (err && tries < NET2280_WRITE_RETRY);
+
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Register write %02x %04x %08x %08x failed: %i\n",
+		       DRV_NAME, ep, port, addr, val, err);
+		goto exit_unlock;
+	}
+
+ exit_unlock:
+	islusb_unlock_reg(p54u);
+	return err;
+}
+
+int islusb_net2280_read_reg(struct p54u *p54u, int ep, int port,
+			    u32 *retval, u32 addr) {
+	struct usb_device *usbdev = p54u->usbdev;
+	int err;
+
+	islusb_lock_reg(p54u);
+
+	err = _net2280_send_read_reg(usbdev, ep, port, addr);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Register read tx %02x %04x %08x failed: %i\n",
+		       DRV_NAME, ep, port, addr, err);
+		goto exit_unlock;
+	}
+
+	err = _net2280_rx_read_reg(usbdev, ep, port, retval);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Register read rx %02x %04x %08x failed: %i\n",
+		       DRV_NAME, ep, port, addr, err);
+	}
+
+ exit_unlock:
+	islusb_unlock_reg(p54u);
+	return err;
+}
+
+/*
+ * UART-over-net2280 functions
+ */
+#define ISL_USBPCI 1
+#include "islsm_uartpci.h"
+
+/*
+ * Interrup-handling function
+ */
+
+static inline void
+p54u_free_int_urb(struct urb *urb) {
+	usb_buffer_free(urb->dev, 4,
+			urb->transfer_buffer,
+			urb->transfer_dma);
+	usb_free_urb(urb);
+}
+
+static void
+p54u_int_urb_callback(struct urb *urb)
+{
+	struct p54u *p54u = (struct p54u *) urb->context;
+	int status = urb->status;
+	unsigned urb_len = urb->actual_length;
+
+	if (status || urb_len < 4) {
+		p54u_free_int_urb(urb);
+		p54u->int_urb = 0;
+		/* this is the end */
+	} else {
+		/* the bh will resend the urb */
+		printk(KERN_ERR "scheduling int bh\n");
+		schedule_work(&p54u->int_bh);
+	}
+
+	return;
+}
+
+static struct urb*
+p54u_alloc_int_urb(struct p54u *p54u,
+		   const struct usb_endpoint_descriptor *desc) {
+	struct usb_device *usbdev = p54u->usbdev;
+	const unsigned size = sizeof(u32);
+	unsigned endp;
+	struct urb *urb;
+	void *buf;
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return 0;
+
+	buf = usb_buffer_alloc(usbdev, size, GFP_KERNEL, &urb->transfer_dma);
+	if (!buf)
+		return 0;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,14)
+#define URB_ASYNC_UNLINK 0
+#endif
+
+	endp = usb_rcvintpipe(usbdev, desc->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
+	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP | URB_ASYNC_UNLINK;
+	usb_fill_int_urb(urb, usbdev, endp, buf, size,
+			 p54u_int_urb_callback, p54u, 6);
+
+	return urb;
+}
+
+static int isl_process_interrupt(struct islsm *islsm);
+
+static void
+p54u_new_int_bh(struct work_struct *work)
+{
+	struct p54u *p54u = container_of(work, struct p54u, int_bh);
+	struct islsm *islsm = usb_get_intfdata(p54u->interface);
+	struct urb *urb = p54u->int_urb;
+	int pending = *(u32*)urb->transfer_buffer;
+	int err = 0;
+
+	FN_ENTER;
+
+	if (pending & NET2280_PCI_INTA_INTERRUPT)
+		err = isl_process_interrupt(islsm);
+	
+	if (!err && p54u->state != P54U_SHUTDOWN)
+		err = usb_submit_urb(urb, GFP_KERNEL);
+
+	if (err)
+		printk(KERN_ERR "%s: error processing interrupts (%i)",
+		       DRV_NAME, err);
+
+	FN_EXIT0;
+	return;
+}
+
+int
+p54u_int_queue_init(struct p54u * p54u,
+		    const struct usb_endpoint_descriptor *desc) {
+	/* FIXME: fix this mess, use the standard hierarchy */
+	struct urb *urb;
+	urb = p54u_alloc_int_urb(p54u,desc);
+	if (!urb)
+		return -ENOMEM;
+
+	p54u->int_urb = urb;
+	INIT_WORK(&p54u->int_bh, p54u_new_int_bh);
+	return 0;
+}
+
+void
+p54u_int_queue_destroy(struct p54u *p54u) {
+	FN_ENTER;
+	if (p54u->int_urb) {
+		//usb_kill_urb(p54u->int_urb);
+		usb_unlink_urb(p54u->int_urb);
+		printk(KERN_ERR "URB unlinked\n");
+	}
+	flush_scheduled_work();
+	FN_EXIT0;
+}
+
+static int
+isl_process_interrupt(struct islsm *islsm)
+{
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	u32 reg;
+	int err;
+
+	p54u_dev_writel(p54u, 0, ISL38XX_INT_EN_REG);
+
+	do {
+		/* read the raised interrupts */
+		err = p54u_dev_readl(p54u, &reg, ISL38XX_INT_IDENT_REG);
+		if (err)
+			break;
+		islog(L_IRQ, "isl int vector: %08x\n", reg);
+
+		/* mask interrupts that we are not concerned with */
+#ifdef PCIUART
+		reg &= (ISL38XX_INT_IDENT_INIT |
+			ISL38XX_DEV_INT_PCIUART_CTS |
+			ISL38XX_DEV_INT_PCIUART_DR);
+#else
+		reg &= ISL38XX_INT_IDENT_INIT;
+#endif
+
+		if (!reg)
+			break;
+
+		/* ack interrupts */
+		err = p54u_dev_writel(p54u, reg, ISL38XX_INT_ACK_REG);
+		if (err)
+			break;
+
+		if (reg & ISL38XX_INT_IDENT_INIT) {
+			islog(L_DEBUG,
+			      "isl init flag set, firmware has booted !\n");
+			complete(&islsm->dev_init_comp);
+		}
+#ifdef PCIUART
+		if (reg & ISL38XX_DEV_INT_PCIUART_CTS) {
+			islog(L_IRQ, "IRQ: UARTPCI CTS\n");
+			uart_cts(islsm);
+		}
+
+		if (reg & ISL38XX_DEV_INT_PCIUART_DR) {
+			islog(L_IRQ, "IRQ: UARTPCI DR\n");
+			uart_dr(islsm);
+		}
+#endif
+		/* ack the interrupts */
+	} while (reg != 0);
+
+	/* clear the interrupt at net2280 level
+	   the net2280 is in host mode */
+	err = p54u_brg_writel(p54u, NET2280_PCI_INTA_INTERRUPT, NET2280_IRQSTAT1);
+
+	/* reenable interrupts in ISL -- note that we should really have
+	 * a cache of the enable mask */
+#ifdef PCIUART
+	err = p54u_dev_writel(p54u,
+			      ISL38XX_INT_IDENT_PCIUART_CTS |
+			      ISL38XX_INT_IDENT_PCIUART_DR,
+			      ISL38XX_INT_EN_REG);
+#endif
+	return err;
+}
+
+/*
+ * Device setup functions
+ */
+
+#define ISLUSB_REBOOT_DELAY 100
+#define ISLUSB_LATCH_DELAY   20
+
+static void
+islusb_mdelay(int ms)
+{
+	msleep(ms);
+}
+
+static int
+p54u_reset_pipe(struct usb_device *usbdev, int addr)
+{
+	int err = 0;
+
+	FN_ENTER;
+	islog(L_FUNC, "resetting pipe %02x\n", addr);
+
+	switch (addr) {
+	case P54U_PIPE_DATA:
+	case P54U_PIPE_MGMT:
+	case P54U_PIPE_BRG:
+		err = usb_clear_halt(usbdev, usb_sndbulkpipe(usbdev, addr));
+		break;
+	case P54U_PIPE_BRG | USB_DIR_IN:
+	case P54U_PIPE_DATA | USB_DIR_IN:
+	case P54U_PIPE_MGMT | USB_DIR_IN:
+		err = usb_clear_halt(usbdev, usb_rcvbulkpipe(usbdev, addr));
+		break;
+	case P54U_PIPE_INT | USB_DIR_IN:
+		err = usb_clear_halt(usbdev, usb_rcvintpipe(usbdev, addr));
+		break;
+	default:
+		break;
+	}
+	FN_EXIT1(err);
+	return err;
+}
+
+static int __attribute__ ((unused))
+p54u_reset_pipes(struct p54u *p54u)
+{
+	struct usb_device *usbdev = p54u->usbdev;
+
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_DEV | USB_DIR_IN);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_DEV);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_BRG | USB_DIR_IN);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_BRG);
+
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_INT | USB_DIR_IN);
+
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_DATA | USB_DIR_IN);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_DATA);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_MGMT | USB_DIR_IN);
+	(void) p54u_reset_pipe(usbdev, P54U_PIPE_MGMT);
+
+	return 0;
+}
+
+/* Setup of the PCI interface of the isl chip  */
+static int
+p54u_islpci_setup(struct p54u *p54u)
+{
+	int err;
+
+	FN_ENTER;
+
+	/* Enable mmio and busmaster on the device */
+	/* the | 0x10000 selects a bus number in type1 cfg
+	 * transactions. Here we're selecting bus number one.
+	 * However, we're NOT in the case of a type one transaction
+	 * whose address's LSB must be one. Is the net2280 interering
+	 * here ?
+	 */
+	err = p54u_pcicfg_dev_writew(p54u, PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,
+				     0x10000 | PCI_COMMAND);
+	if (err)
+		goto exit;
+
+	/* to try */
+//      p54u_pcicfg_dev_writew(netdev, PCI_COMMAND << 2, (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+//      p54u_pcicfg_dev_writew(netdev, PCI_COMMAND, (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER));
+
+/*
+  in original islsm code :
+#define PCI_TRDY_TIMEOUT                        0x40
+#define PCI_RETRY_TIMEOUT                       0x41
+*/
+	/* Set TRDY_TIMEOUT and RETRY_TIMEOUT to 0 */
+	err = p54u_pcicfg_dev_writew(p54u, 0, P54U_TRDY_TIMEOUT | 0x10000);
+	if (err)
+		goto exit;
+//      p54u_pcicfg_dev_writew(netdev, P54U_TRDY_TIMEOUT, 0);
+//      p54u_pcicfg_dev_writew(netdev, P54U_TRDY_TIMEOUT << 2, 0);
+
+	/* Set base address 0 */
+	err = p54u_pcicfg_dev_writel(p54u, P54U_DEV_BASE,
+				      PCI_BASE_ADDRESS_0 | 0x10000);
+//      p54u_pcicfg_dev_writel(netdev, PCI_BASE_ADDRESS_0, P54U_DEV_BASE);
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+/* this function brings down a possibly running lmac firmware. It also
+   brings down a possibly running rom ; for rom communication we should
+   take care not to call this. */
+static void
+p54u_islpci_assert(struct p54u *p54u)
+{
+	/* Assert wakeup */
+	FN_ENTER;
+	p54u_dev_writel(p54u, ISL38XX_DEV_INT_WAKEUP, ISL38XX_DEV_INT_REG);
+	islusb_mdelay(20);
+	/* (see old driver for INT_ABORT definition) */
+	p54u_dev_writel(p54u, ISL38XX_DEV_INT_ABORT, ISL38XX_DEV_INT_REG);
+	islusb_mdelay(20);
+	FN_EXIT0;
+}
+
+static int
+p54u_romboot(struct p54u *p54u)
+{
+	u32 reg;
+	int err;
+
+	FN_ENTER;
+
+	/* Disable irqs in case they were not */
+	/* not sure which way is okay : net2280_irqdisable or this */
+	err = p54u_dev_writel(p54u, 0, ISL38XX_INT_EN_REG);
+	if (err)
+		goto exit;
+
+	/* Reset the device */
+	/* clear the RAMBoot, the CLKRUN and the Reset bit */
+	/* we're booting into rom */
+	err = p54u_dev_readl(p54u, &reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+
+	reg &= ~(ISL38XX_CTRL_STAT_RESET |
+		 ISL38XX_CTRL_STAT_RAMBOOT |
+		 ISL38XX_CTRL_STAT_CLKRUN);
+
+	err = p54u_dev_writel(p54u, reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+	islusb_mdelay(ISLUSB_LATCH_DELAY);
+
+	/* set the Reset bit without reading the register */
+	err = p54u_dev_writel(p54u, reg | ISL38XX_CTRL_STAT_RESET,
+			      ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+	islusb_mdelay(ISLUSB_LATCH_DELAY);
+
+	/* clear the Reset bit */
+	err = p54u_dev_writel(p54u, reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+
+	islusb_mdelay(ISLUSB_REBOOT_DELAY);
+
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+isl_net2280_romboot(struct islsm *islsm) {
+	return p54u_romboot(P54U_OF_ISLSM(islsm));
+}
+
+static int
+p54u_ramboot(struct p54u *p54u)
+{
+	u32 reg;
+	int err;
+
+	FN_ENTER;
+
+	/* Reset the device */
+	/* clear the RAMBoot, the CLKRUN and the Reset bit */
+	/* we're booting into rom */
+	err = p54u_dev_readl(p54u, &reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+
+	reg &= ~(ISL38XX_CTRL_STAT_RESET | ISL38XX_CTRL_STAT_CLKRUN);
+	reg |= ISL38XX_CTRL_STAT_RAMBOOT;
+	err = p54u_dev_writel(p54u, reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+	islusb_mdelay(ISLUSB_LATCH_DELAY);
+
+	/* set the Reset bit without reading the register */
+	err = p54u_dev_writel(p54u, reg | ISL38XX_CTRL_STAT_RESET,
+			      ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+	islusb_mdelay(ISLUSB_LATCH_DELAY);
+
+	/* clear the Reset bit */
+	err = p54u_dev_writel(p54u, reg, ISL38XX_CTRL_STAT_REG);
+	if (err)
+		goto exit;
+
+	/* wait for the device to reboot */
+	islusb_mdelay(ISLUSB_REBOOT_DELAY);
+
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+/* enables routing of the interrupts to its dedicated endpoint */
+static int
+p54u_net2280_irqdisable(struct p54u *p54u)
+{
+	int err;
+
+	FN_ENTER;
+
+	/* See 7.6.5.5 and chapter 9 of net2280 doc */
+	/* tell the net2280 that we don't want it to send us interrupts
+	   via the interrupt endpoing at all */
+	err = p54u_brg_writel(p54u, 0, NET2280_USBIRQENB1);
+
+	/* clear the INTA# interrupt bit in the net2280 */
+	err = p54u_brg_writel(p54u, NET2280_PCI_INTA_INTERRUPT, NET2280_IRQSTAT1);
+
+	FN_EXIT1(err);
+
+	return err;
+}
+
+static int
+p54u_net2280_irqenable(struct p54u *p54u)
+{
+	int err;
+
+	FN_ENTER;
+	/* clear the INTA# interrupt bit in the net2280 */
+	err = p54u_brg_writel(p54u, NET2280_PCI_INTA_INTERRUPT, NET2280_IRQSTAT1);
+	/* activate routing of the interrupts to int_rx */
+	err = p54u_brg_writel(p54u,
+			      NET2280_PCI_INTA_INTERRUPT_ENABLE |
+			      NET2280_USB_INTERRUPT_ENABLE,
+			      NET2280_USBIRQENB1);
+	FN_EXIT1(err);
+	return err;
+}
+
+#if 0
+/* XXX This used to be used ! why has it changed ? */
+/* flush the (data) endpoints of the net2280 */
+static void
+p54u_net2280_flushep(struct p54u *p54u)
+{
+	FN_ENTER;
+	/* Magic */
+	p54u_brg_writel(p54u, NET2280_FIFO_FLUSH, NET2280_EPA_STAT);
+	p54u_brg_writel(p54u, NET2280_FIFO_FLUSH, NET2280_EPB_STAT);
+	p54u_brg_writel(p54u, NET2280_FIFO_FLUSH, NET2280_EPC_STAT);
+	p54u_brg_writel(p54u, NET2280_FIFO_FLUSH, NET2280_EPD_STAT);
+	/* why this again ? */
+	p54u_brg_writel(p54u, NET2280_FIFO_FLUSH, NET2280_EPA_STAT);
+	FN_EXIT0;
+}
+#endif
+
+/* This function only does the initialization needed to communicate
+   with the PCI device behind the bridge */
+static int
+p54u_net2280_init(struct p54u *p54u)
+{
+	u32 reg, revision;
+	u16 reg16;
+	int err;
+
+	FN_ENTER;
+	/* Bridge */
+	/* Reset the usb<->pci bridge */
+	err = p54u_brg_readl(p54u, &reg, NET2280_GPIOCTL);
+	if (err)
+		goto exit;
+
+	if (reg & P54U_BRG_POWER_UP)
+		printk(KERN_WARNING "%s: bridge already up, expect problems\n",
+		       DRV_NAME);
+
+	/* power down the bridge */
+	reg |= P54U_BRG_POWER_DOWN;
+	reg &= ~P54U_BRG_POWER_UP;
+	err = p54u_brg_writel(p54u, reg, NET2280_GPIOCTL);
+	if (err)
+		goto exit;
+
+	islusb_mdelay(100);
+
+	/* power up the bridge */
+	reg |= P54U_BRG_POWER_UP;
+	reg &= ~P54U_BRG_POWER_DOWN;
+	err = p54u_brg_writel(p54u, reg, NET2280_GPIOCTL);
+	if (err)
+		goto exit;
+
+	islusb_mdelay(100);
+	islog(L_DEBUG, "%s: Reset bridge done\n", DRV_NAME);
+
+	/* See 11.5.1 on net2280 doc */
+	islog(L_DEBUG, "%s: Magic 1\n", DRV_NAME);
+	err = p54u_brg_writel(p54u,
+			      NET2280_CLK_30Mhz |
+			      NET2280_PCI_ENABLE |
+			      NET2280_PCI_SOFT_RESET,
+			      NET2280_DEVINIT);
+	if (err)
+		goto exit;
+	islusb_mdelay(20);
+	islog(L_DEBUG, "%s: Magic 1 done\n", DRV_NAME);
+
+	/* Enable mmio and busmaster on the bridge */
+	islog(L_DEBUG, "%s: setup bridge pci resources\n", DRV_NAME);
+	err = p54u_pcicfg_brg_writew(p54u, PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER,
+				     PCI_COMMAND);
+	if (err)
+		goto exit;
+
+	/* Set base address 0 */
+	err = p54u_pcicfg_brg_writel(p54u, NET2280_BASE, PCI_BASE_ADDRESS_0);
+	if (err)
+		goto exit;
+
+	/* Set PCI_STATUS_REC_MASTER_ABORT (why?) */
+	err = p54u_pcicfg_brg_readw(p54u, &reg16, PCI_STATUS);
+	if (err)
+		goto exit;
+
+	err = p54u_pcicfg_brg_writew(p54u, reg16 | PCI_STATUS_REC_MASTER_ABORT,
+				     PCI_STATUS);
+
+	/* Read revision? */
+	err = p54u_brg_readl(p54u, &revision, NET2280_RELNUM);
+	if (err)
+		goto exit;
+
+	islog(L_DEBUG, "%s: Setup bridge pci resources done\n", DRV_NAME);
+
+	/* Magic */
+	islog(L_DEBUG, "%s: Magic 2\n", DRV_NAME);
+	err = p54u_brg_writel(p54u, NET2280_CLEAR_NAK_OUT_PACKETS_MODE,
+			      NET2280_EPA_RSP);
+	if (err)
+		goto exit;
+
+	err = p54u_brg_writel(p54u, NET2280_CLEAR_NAK_OUT_PACKETS_MODE,
+			      NET2280_EPC_RSP);
+	if (err)
+		goto exit;
+
+	islog(L_DEBUG, "%s: Magic 2 done\n", DRV_NAME);
+
+	/* Set base address 2 for bridge : where the endpoint fifos are */
+	islog(L_DEBUG, "%s: Setup bridge base addr 2\n", DRV_NAME);
+	err = p54u_pcicfg_brg_writel(p54u, NET2280_BASE2, PCI_BASE_ADDRESS_2);
+	if (err)
+		goto exit;
+	islog(L_DEBUG, "%s: Setup bridge base addr 2 done\n", DRV_NAME);
+
+ exit:
+	FN_EXIT1(err);
+	return err;
+}
+
+int
+p54u_setup_rom(struct p54u *p54u)
+{
+	int err;
+	FN_ENTER;
+
+	/* setup pci communications */
+	err = p54u_net2280_init(p54u);
+	err = p54u_islpci_setup(p54u);
+	err = p54u_net2280_irqdisable(p54u);
+
+	/* maybe the ROM already is booted there */
+
+	/* bring down a possibly running lmac firmware */
+	p54u_islpci_assert(p54u);
+
+	err = p54u_romboot(p54u);
+
+	/* submit the urb for the interrupt endpoint */
+	//rx_queue_refill(p54u, &p54u->int_rx);
+	err = usb_submit_urb(p54u->int_urb, GFP_KERNEL);
+
+	/* reenable irqs */
+	err = p54u_net2280_irqenable(p54u);
+
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+p54u_reset_dev(struct p54u *p54u)
+{
+	u32 reg;
+	int err;
+
+	FN_ENTER;
+
+	err = p54u_net2280_irqdisable(p54u);
+	if (err)
+		goto do_err;
+
+	/* resets the device. The rom should have control
+	 * there. This will raise the CTS irq, which we will not receive
+	 * due to the above irqdisable.
+	 */
+	err = p54u_romboot(p54u);
+	if (err)
+		goto do_err;
+
+	/* at this point we could already do some things with the rom.
+	 * I'd like to be able to launch the irq circus right there already.
+	 */
+	err = p54u_dev_writel(p54u, 0, ISL38XX_INT_EN_REG);
+	if (err)
+		goto do_err;
+
+	/* Ack the irqs ourselves. When have they been generated ? --
+	 * Could we have disabled them earlier ? *
+	 * Basically the irq pending is the CTS. */
+	islog(L_DEBUG, "%s: ack irq\n", DRV_NAME);
+	err = p54u_dev_readl(p54u, &reg, ISL38XX_INT_IDENT_REG);
+	if (err)
+		goto do_err;
+
+	islog(L_DEBUG, "irq register is %x\n", reg);
+	err = p54u_dev_writel(p54u, reg, ISL38XX_INT_ACK_REG);
+	if (err)
+		goto do_err;
+
+	FN_EXIT1(0);
+	return 0;
+
+      do_err:
+	printk(KERN_ERR "%s: reset error: %i\n", DRV_NAME, err);
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+p54u_load_firmware(struct p54u *p54u, const struct firmware *fw_entry)
+{
+	void *data, *fw_buf;
+	int err, remains;
+	unsigned offset = 0;
+
+	FN_ENTER;
+
+	fw_buf = kmalloc(P54U_FW_BLOCK, GFP_KERNEL);
+	if (!fw_buf)
+		return -ENOMEM;
+
+	/* Firmware */
+	data = fw_entry->data;
+	remains = fw_entry->size;
+
+	if ((remains & 3) != 0)
+		printk(KERN_ERR "%s: error, firmware length must be 32-bits aligned",
+		       DRV_NAME);
+
+	/* past this point we guarantee that len will always be
+	   a multiple of 4, which is necessary for the DMA engine
+	   to work properly */
+	while (remains > 0) {
+		u32 reg;
+		int len;
+		len = min(remains, P54U_FW_BLOCK);
+
+		memcpy(fw_buf, data, len);
+
+		/* we upload a chunk of the firmware into the Net2280's
+		   endpoint fifos */
+		err = p54u_bulk_msg(p54u, P54U_PIPE_DATA, fw_buf, len);
+
+		if (err) {
+			printk(KERN_ERR "%s: error writing firmware block", DRV_NAME);
+			goto do_release;
+		}
+
+		data += len;
+		remains -= len;
+
+		/* Now we control the ISL chip so that it reads back the
+		 * chunk of firmware from the Net2280's fifos */
+
+		/* Set the window to the base of the slave DMA RX engine
+		 * of the chip */
+		p54u_dev_writel(p54u, 0xc0000f00, ISL38XX_DIR_MEM_BASE_REG);
+		/* Do a reset of the pci slave RX dma engine */
+		p54u_dev_writel(p54u, 0, 0x0020 | ISL38XX_DIRECT_MEM_WIN);
+		p54u_dev_writel(p54u, 1, 0x0020 | ISL38XX_DIRECT_MEM_WIN);
+		/* Setup the slave RX engine */
+		p54u_dev_writel(p54u, len, 0x0024 | ISL38XX_DIRECT_MEM_WIN);
+		p54u_dev_writel(p54u, ISL38XX_DEV_FIRMWARE_ADDRES + offset,
+				0x0028 | ISL38XX_DIRECT_MEM_WIN);
+		/* Then setup the master dma register. This is accessed
+		 * not through the memory window, but through the
+		 * standard mapping. The in-arm address is around
+		 * 0xc0000960 */
+		/* Please have a look at net2280_dma.c in the freemac
+		   project for more details */
+		/* set the PCI address we DMA from */
+		p54u_dev_writel(p54u, NET2280_EPA_FIFO_PCI_ADDR, 0x0060);
+		/* length of the DMA, in 32-bits words */
+		p54u_dev_writel(p54u, len >> 2, 0x0064);
+		/* actually start the _read_ DMA */
+		p54u_dev_writel(p54u, ISL38XX_DMA_MASTER_CONTROL_TRIGGER, 0x0068);
+
+		/* readback the slave DMA RX engine state */
+		/* wait for the dma to complete -- we could also
+		 * busy-wait on the register */
+
+		islusb_mdelay(10);
+		err = p54u_dev_readl(p54u, &reg, 0x002c | ISL38XX_DIRECT_MEM_WIN);
+		if (err)
+			goto do_release;
+
+		if (reg != (reg | ISL38XX_DMA_STATUS_DONE | ISL38XX_DMA_STATUS_READY)) {
+			err = -EBUSY;
+			printk(KERN_ERR DRV_NAME ": firmware dma engine error\n");
+			goto do_release;
+		}
+
+
+		if (remains > 0)
+			err = p54u_brg_writel(p54u, NET2280_FIFO_FLUSH,
+					      NET2280_EPA_STAT);
+		if (err) {
+			printk(KERN_ERR DRV_NAME ": error flushing net2280 fifos\n");
+			goto do_release;
+		}
+
+		offset += len;
+	}
+
+	err = p54u_ramboot(p54u);
+
+      do_release:
+	kfree(fw_buf);
+	FN_EXIT1(err);
+	return err;
+}
+
+static int
+p54u_boot_fw(struct islsm *islsm)
+{
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	int err;
+	/* The bootrom has control */
+
+	/* now use the new RX queue mechanism */
+	rx_queue_refill(p54u, &p54u->data_rx);
+	rx_queue_refill(p54u, &p54u->mgmt_rx);
+
+	/* enable interrupts at the isl level */
+#ifdef PCIUART
+	p54u_dev_writel(p54u, ISL38XX_INT_IDENT_INIT |
+			ISL38XX_INT_IDENT_PCIUART_CTS |
+			ISL38XX_INT_IDENT_PCIUART_DR,
+			ISL38XX_INT_EN_REG);
+#else
+	p54u_dev_writel(p54u, ISL38XX_INT_IDENT_INIT,
+			ISL38XX_INT_EN_REG);
+#endif
+
+	err = p54u_net2280_irqenable(p54u);
+	if (err)
+		return err;
+
+	/* The ramboot has been done just after firmware load */
+	/* now we're ready. reset the firmware (which has already booted). */
+	err = p54u_dev_writel(p54u, ISL38XX_DEV_INT_RESET, ISL38XX_DEV_INT_REG);
+	if (err)
+		return err;
+
+	err = islsm_wait_timeout(islsm, HZ);
+	return err;
+}
+
+static int
+isl_load_fw(struct islsm *device, const struct firmware *fw)
+{
+	struct p54u *p54u = P54U_OF_ISLSM(device);
+	int err;
+	err = p54u_reset_dev(p54u);
+	if (err)
+		goto exit;
+	err = p54u_load_firmware(p54u, fw);
+	if (err)
+		goto exit;
+	err = p54u_boot_fw(device);
+ exit:
+	return err;
+}
+
+/*
+ * Transport functions
+ */
+static int
+tx_submit_ver1(struct sk_buff *skb)
+{
+	struct p54u *p54u = P54U_OF_NETDEV(skb->dev);
+	u32 lmac_addr = LMAC_ADDR_OF_SKB(skb);
+	int len = skb->len;
+	int err = 0;
+	struct islsm_tx *islsm_tx;
+
+	islsm_tx = (void *) skb_push(skb, SIZE_NET2280_H);
+	memset(skb->data, 0, SIZE_NET2280_H);
+	islsm_tx->arm_addr = cpu_to_le32(lmac_addr);
+	islsm_tx->length = cpu_to_le16(len);
+
+	islsm_tx->follower = cpu_to_le16(0);
+	err = tx_queue_submit(&p54u->data_tx, skb);
+
+	/* FIXME -- we should do fragmentation of the frames sent on the
+	 * control pipe for frames larget than 0x400 -- for now we don't
+	 * even use it */
+	/* this is the limit payload that will trigger a
+	   split on the control pipe */
+/* #define LIMIT 0x400 */
+/* 	if (len + SIZE_NET2280_H < LIMIT) { */
+/* 		/\* we overflow the max size, we must split the frame *\/ */
+/* 		islsm_tx->follower = cpu_to_le16(ISLSM_MGMT_FOLLOWUP); */
+/* 		// This one is not announced ! f* ! */
+/* 		// Should take care of this in the lower */
+/* 		// functions ? */
+/* 		err = p54u_bulk_msg(p54u, P54U_PIPE_MGMT, */
+/* 				    skb->data, SIZE_NET2280_H); */
+/* 		//tx_queue_submit (netdev, &p54u->mgmt_tx, skb, queue); */
+/* 		if (!err) { */
+/* 			skb_pull(skb, SIZE_NET2280_H); */
+/* 			err = tx_queue_submit(&p54u->mgmt_tx, skb); */
+/* 		} */
+/* 	} */
+	return err;
+}
+
+void
+islusb_fill_net2280(struct islsm *islsm) {
+	islsm->isl_tx = tx_submit_ver1;
+	islsm->device_tx_header_space = SIZE_NET2280_H;
+	islsm->device_version = ISLSM_DEVICE_USB_VER1;
+
+	/* (pci-specific) device callbacks */
+	islsm->isl_read_pcireg = isl_read_pcireg;
+	islsm->isl_write_pcireg = isl_write_pcireg;
+	islsm->isl_write_devmem = isl_write_devmem;
+	islsm->isl_read_devmem = isl_read_devmem;
+	islsm->isl_romboot = isl_net2280_romboot;
+	islsm->isl_load_fw = isl_load_fw;
+
+	/* uart callbacks */
+	islsm->uart_prot_init = uart_prot_init;
+	islsm->uart_prot_exit = uart_prot_exit;
+	islsm->uart_cts = uart_cts;
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_net2280.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_net2280.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_net2280.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_net2280.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,222 @@
+/*
+  Copyright 2004 Feyd
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#ifndef _HAS_ISLUSB_NET2280_H
+#define _HAS_ISLUSB_NET2280_H
+
+#include <linux/firmware.h>
+#include <linux/usb/net2280.h>
+#include "islusb_dev.h"
+
+struct islsm;
+
+/* read/write transactions are initiated according
+   to the size of the packet sent to the endpoint.
+*/
+#define P54U_REG_WSIZE		(sizeof(struct p54u_reg))
+#define P54U_REG_RSIZE		(P54U_REG_WSIZE - (sizeof(u32)))
+
+/* Access through CFGOUT (DEP_CFG register :
+   P54U_PIPE_BRG =		0x0d) */
+/* access to memory mapped config registers */
+#define P54U_PORT_BRG		0x0010
+/* access to PCI configuration registers */
+#define P54U_PORT_BRG_CFG	0x0000
+
+/* Access through PCIOUT ( DEP_CFG register :
+   P54U_PIPE_DEV =		0x0e) */
+/* p54u-specific configuration (reserved bits used) */
+/* 7.6.5.3 in net2280 doc */
+/* 11.7.1 for bit signification */
+/* read/writes to the device pci address space */
+/* 0x8000 means : DMA_READ_LINE_ENABLE */
+/* 0x0000 means : memory space read/write */
+#define P54U_PORT_DEV		0x0800
+/* read/writes to the device pci
+   0x0080 means : read / write in CFG space space */
+#define P54U_PORT_DEV_CFG	0x0880
+
+/* this is actually a byte enable mask */
+/* first 4 bits, byte enable mask */
+/* bit 4 0x10, means read/write -- unused here, as well as
+ * master_start */
+#define P54U_PORT_U16		0x0003
+#define P54U_PORT_U32		0x000f
+
+#define P54U_PORT_BRG_U32	(P54U_PORT_BRG | P54U_PORT_U32)
+#define P54U_PORT_BRG_CFG_U32	(P54U_PORT_BRG_CFG | P54U_PORT_U32)
+#define P54U_PORT_BRG_CFG_U16	(P54U_PORT_BRG_CFG | P54U_PORT_U16)
+
+#define P54U_PORT_DEV_U32	(P54U_PORT_DEV | P54U_PORT_U32)
+#define P54U_PORT_DEV_CFG_U32	(P54U_PORT_DEV_CFG | P54U_PORT_U32)
+#define P54U_PORT_DEV_CFG_U16	(P54U_PORT_DEV_CFG | P54U_PORT_U16)
+
+/* pci */
+#define NET2280_BASE		0x10000000
+#define NET2280_BASE2		0x20000000
+
+/* gpio */
+#define P54U_BRG_POWER_UP	(1 << GPIO0_DATA)
+#define P54U_BRG_POWER_DOWN	(1 << GPIO1_DATA)
+
+/* devinit */
+#define NET2280_CLK_4Mhz	(15 << LOCAL_CLOCK_FREQUENCY)
+#define NET2280_CLK_30Mhz	(2 << LOCAL_CLOCK_FREQUENCY)
+#define NET2280_CLK_60Mhz	(1 << LOCAL_CLOCK_FREQUENCY)
+#define NET2280_CLK_STOP	(0 << LOCAL_CLOCK_FREQUENCY)
+#define NET2280_PCI_ENABLE	(1 << PCI_ENABLE)
+#define NET2280_PCI_SOFT_RESET	(1 << PCI_SOFT_RESET)
+
+/* enpoints */
+#define NET2280_CLEAR_NAK_OUT_PACKETS_MODE	(1 << CLEAR_NAK_OUT_PACKETS_MODE)
+#define NET2280_FIFO_FLUSH			(1 << FIFO_FLUSH)
+
+/* irq */
+#define NET2280_USB_INTERRUPT_ENABLE		(1 << USB_INTERRUPT_ENABLE)
+#define NET2280_PCI_INTA_INTERRUPT		(1 << PCI_INTA_INTERRUPT)
+#define NET2280_PCI_INTA_INTERRUPT_ENABLE	(1 << PCI_INTA_INTERRUPT_ENABLE)
+
+/* registers */
+#define NET2280_DEVINIT		0x00
+#define NET2280_USBIRQENB1	0x24
+#define NET2280_IRQSTAT1	0x2c
+#define NET2280_FIFOCTL         0x38
+#define NET2280_GPIOCTL		0x50
+#define NET2280_RELNUM		0x88
+#define NET2280_EPA_RSP		0x324
+#define NET2280_EPA_STAT	0x32c
+#define NET2280_EPB_STAT	0x34c
+#define NET2280_EPC_RSP		0x364
+#define NET2280_EPC_STAT	0x36c
+#define NET2280_EPD_STAT	0x38c
+
+#define NET2280_EPA_CFG     0x320
+#define NET2280_EPB_CFG     0x340
+#define NET2280_EPC_CFG     0x360
+#define NET2280_EPD_CFG     0x380
+#define NET2280_EPE_CFG     0x3A0
+#define NET2280_EPF_CFG     0x3C0
+
+#define P54U_DEV_BASE		0x40000000
+
+#define P54U_TRDY_TIMEOUT	0x40
+#define P54U_RETRY_TIMEOUTG	0x41
+
+int                     islusb_net2280_write_reg(struct p54u *p54u,
+						 int ep, int port,
+						 u32 val, u32 addr);
+int                     islusb_net2280_read_reg(struct p54u *p54u,
+						int ep, int port,
+						u32 *retval, u32 addr);
+
+/* helper functions for accessing net2280 and pci-behind-net2280
+   registers */
+
+static inline int
+p54u_brg_writel(struct p54u *dev, u32 val, u32 addr) {
+	return islusb_net2280_write_reg(dev, P54U_PIPE_BRG,
+					P54U_PORT_BRG_U32,
+					val, addr);
+}
+
+static inline int
+p54u_pcicfg_brg_writel(struct p54u *dev, u32 val, u32 addr) {
+	return islusb_net2280_write_reg(dev, P54U_PIPE_BRG,
+					P54U_PORT_BRG_CFG_U32,
+					val, addr);
+}
+
+static inline int
+p54u_pcicfg_brg_writew(struct p54u *dev, u16 val, u32 addr) {
+	return p54u_pcicfg_brg_writel(dev, val, addr);
+}
+
+static inline int
+p54u_dev_writel(struct p54u *dev, u32 val, u32 addr) {
+	return islusb_net2280_write_reg(dev, P54U_PIPE_DEV,
+					P54U_PORT_DEV_U32,
+					val, P54U_DEV_BASE | addr);
+}
+
+static inline int
+p54u_pcicfg_dev_writel(struct p54u *dev, u32 val, u32 addr) {
+	return islusb_net2280_write_reg(dev, P54U_PIPE_DEV,
+					P54U_PORT_DEV_CFG_U32,
+					val, addr);
+}
+
+static inline int
+p54u_pcicfg_dev_writew(struct p54u *dev, u16 val, u32 addr) {
+	return p54u_pcicfg_dev_writel(dev, val, addr);
+}
+
+static inline int
+p54u_brg_readl(struct p54u *dev, u32 *val, u32 addr) {
+	return islusb_net2280_read_reg(dev, P54U_PIPE_BRG,
+				       P54U_PORT_BRG_U32, val, addr);
+}
+
+static inline int
+p54u_pcicfg_brg_readl(struct p54u *dev, u32 *val, u32 addr) {
+	return islusb_net2280_read_reg(dev, P54U_PIPE_BRG,
+				       P54U_PORT_BRG_CFG_U32, val, addr);
+}
+
+static inline int
+p54u_pcicfg_brg_readw(struct p54u *dev, u16 *val, u32 addr) {
+	int err;
+	u32 relay;
+	err = islusb_net2280_read_reg(dev, P54U_PIPE_BRG,
+				      P54U_PORT_BRG_CFG_U16, &relay, addr);
+	*val = (u16)relay;
+	return err;
+}
+
+static inline int
+p54u_dev_readl(struct p54u *dev, u32 *val, u32 reg) {
+	return islusb_net2280_read_reg(dev, P54U_PIPE_DEV, P54U_PORT_DEV_U32,
+				       val, P54U_DEV_BASE | reg);
+}
+
+static inline int
+p54u_pcicfg_dev_readl(struct p54u *dev, u32 *val, u32 addr) {
+	return islusb_net2280_read_reg(dev, P54U_PIPE_DEV,
+				       P54U_PORT_DEV_CFG_U32, val, addr);
+}
+
+static inline int
+p54u_pcicfg_dev_readw(struct p54u *dev, u32 *val, u32 addr) {
+	u32 relay;
+	int err;
+	err = islusb_net2280_read_reg(dev, P54U_PIPE_DEV,
+				      P54U_PORT_DEV_CFG_U16, &relay, addr);
+	*val = (u16)relay;
+	return err;
+}
+
+void islusb_fill_net2280(struct islsm *islsm);
+int  p54u_setup_rom(struct p54u *);
+int  p54u_int_queue_init(struct p54u * p54u,
+			 const struct usb_endpoint_descriptor *desc);
+void p54u_int_queue_destroy(struct p54u *p54u);
+
+#endif /* _HAS_ISLUSB_NET2280_H */
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_transport.c linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_transport.c
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/islusb_transport.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/islusb_transport.c	2007-04-12 16:57:03.000000000 +0200
@@ -0,0 +1,732 @@
+/*
+  Copyright 2004 Feyd
+  Copyright 2004, 2005 Jean-Baptiste Note
+
+  This file is part of prism54usb.
+
+  prism54usb is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  prism54usb is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with prism54usb; if not, write to the Free Software Foundation,
+  Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+
+*/
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/smp_lock.h>
+#include <linux/completion.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/usb.h>
+#include <linux/pci.h>
+#include <linux/skbuff.h>
+#include <linux/isl_38xx.h>
+#include <linux/version.h>
+#include <asm/uaccess.h>
+
+#include "islusb_dev.h"
+#include "isl_sm.h"
+#include "islsm_log.h"
+#include "islusb_net2280.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12)
+#define BULK_TIMEOUT   2000
+#else
+#define BULK_TIMEOUT   2 * HZ
+#endif
+
+static inline void
+p54u_mdelay(int ms)
+{
+	/*
+	 * XXX OK, this is ugly somewhat. In Linux, "sleep" sleeps,
+	 * "delay" busy-waits. But in BSD, apparently, "delay" sleeps.
+	 * Replace p54u_mdelay. We do not sync with p54u these days.
+	 */
+	msleep(ms);
+}
+
+int
+p54u_bulk_msg(struct p54u *p54u, unsigned int ep, void *_data, int len)
+{
+	struct usb_device *usbdev = p54u->usbdev;
+	unsigned char *data = _data;
+	int alen;
+	int pipe, err;
+
+	islsm_txdata_debug(ep, data, len);
+
+	pipe = usb_sndbulkpipe(usbdev, ep);
+	err = usb_bulk_msg(usbdev, pipe, data, len, &alen, BULK_TIMEOUT);
+	if (err)
+		printk(KERN_ERR "%s: bulk submit failed: %i\n", DRV_NAME, err);
+
+	return err;
+}
+
+int
+p54u_submit_urb(struct urb *urb, int flags)
+{
+	int err;
+
+	islsm_txdata_debug(urb->pipe, urb->transfer_buffer,
+			   urb->transfer_buffer_length);
+
+	urb->actual_length = 0;
+	err = usb_submit_urb(urb, flags);
+
+	if (err)
+		islog(L_DEBUG, "%s: urb submit failed: %i\n", DRV_NAME, err);
+
+	return err;
+}
+
+/* RX QUEUE MANAGEMENT */
+
+/* callback common to all bulk endpoints */
+static
+void p54u_bulk_urb_callback(struct urb *urb);
+static
+void p54u_nil_urb_callback(struct urb *urb);
+static struct urb *
+p54u_alloc_urb(struct usb_device *usbdev, struct p54u_pipe *queue);
+
+/* a bit dirty, but, hey... */
+#define NETDEV_OF_P54U(x) (NETDEV_OF_ISLSM(container_of((void *)x, struct islsm, priv)))
+
+/* Should be called under lock ? */
+static int
+rx_queue_add(struct p54u_pipe *queue, usb_command_t *cmd)
+{
+	struct p54u *p54u = queue->p54u;
+	struct sk_buff *skb;
+	int err;
+	size_t buffer_size;
+	struct urb *urb;
+
+	/* realloc urb if needed */
+	if (!cmd->data_urb)
+		cmd->data_urb = p54u_alloc_urb(p54u->usbdev, queue);
+	urb = cmd->data_urb;
+	if (!urb)
+		return -ENOMEM;
+
+	WARN_ON(cmd->skb);
+	buffer_size = queue->buffer_size;
+	skb = dev_alloc_skb(buffer_size);
+
+	if (!skb)
+		return -ENOMEM;
+
+	skb->iif = NETDEV_OF_P54U(p54u)->ifindex;
+
+	/* realign buffer */
+	skb_push(skb, skb_headroom(skb));
+	skb_trim(skb, 0);
+
+	cmd->skb = skb;
+
+	urb->transfer_buffer = skb->data;
+	urb->transfer_buffer_length = buffer_size;
+
+	err = usb_submit_urb(urb, GFP_ATOMIC);
+	if (err) {
+		islog(L_DEBUG, "could not submit rx urb : %i\n", err);
+		dev_kfree_skb(skb);
+		cmd->skb = 0;
+	}
+
+	return err;
+}
+
+/* needed for ver1 devices */
+
+static inline void
+remove_net2280_header(struct sk_buff *skb)
+{
+	(void) skb_pull(skb, SIZE_RX);
+	return;
+}
+
+static void
+rx_cmd(struct p54u *p54u, struct sk_buff *skb) {
+	if (p54u->state == P54U_RUN) {
+		/* switch according to hardware type */
+		if (p54u->device_version == P54U_DEVICE_VER1)
+			remove_net2280_header(skb);
+		islsm_data_input(skb);
+	} else {
+		if ((p54u->device_version == P54U_DEVICE_VER2) &&
+		    (p54u->state == P54U_BOOT))
+				islsm_bootup_input(skb);
+		else {
+			islog(L_DEBUG,
+			      "dropping packet received while not running\n");
+			dev_kfree_skb(skb);
+		}
+	}
+}
+
+/* This could to be replaced by skb_dequeue at some point */
+static struct sk_buff *
+rx_queue_skb_dequeue(struct p54u_pipe *queue, int *err) {
+	unsigned len = queue->len;
+	usb_command_t *cmd;
+	struct sk_buff *skb = 0;
+	struct urb *urb;
+	unsigned long flags;
+
+	/* after queue->f increase and spinlock release, the packet is
+	   in another range and can be refilled at any moment by a
+	   concurrent process -- so we need more work than just
+	   returning it -- this will be sufficient when doing 
+	   fully-dynamic allocation of urbs  */
+
+	spin_lock_irqsave(&queue->lock,flags);
+
+	if (queue->f >= queue->c)
+		goto out;
+
+	cmd = &queue->ringbuf[queue->f++ % len];
+
+	skb = cmd->skb;
+	cmd->skb = 0;
+
+	urb = cmd->data_urb;
+	if (urb->status) {
+		/* urb was fucked up */
+		islog(L_DEBUG, "rx urb bad status : %i\n",
+		      urb->status);
+		dev_kfree_skb(skb);
+		*err = -EIO;
+	} else {
+		(void) skb_put(skb, urb->actual_length);
+	}
+
+ out:
+	spin_unlock_irqrestore(&queue->lock,flags);
+
+	return skb;
+}
+
+static int
+rx_queue_process(struct p54u *p54u, struct p54u_pipe *queue)
+{
+	int err = 0;
+	struct sk_buff *skb;
+
+	/* for all acked packets in the queue */
+	while ( (skb = rx_queue_skb_dequeue(queue, &err)) ) {
+		if (err)
+			break;
+		rx_cmd(p54u, skb);
+	}
+
+	return err;
+}
+
+static usb_command_t *
+_rx_queue_cmd_refill(struct p54u_pipe *queue) {
+	usb_command_t *cmd = 0;
+	unsigned len = queue->len;
+
+ 	if (queue->p < queue->f + len)
+		cmd = &queue->ringbuf[queue->p++ % len];
+
+	return cmd;
+}
+
+int
+rx_queue_refill(struct p54u *p54u, struct p54u_pipe *queue)
+{
+	usb_command_t *cmd;
+	int err = 0;
+	unsigned long flags;
+
+	if (p54u->state == P54U_SHUTDOWN) {
+		islog(L_DEBUG, "not refilling queue %02x in shutdown state\n",
+		      queue->addr);
+		return 0;
+	}
+
+	spin_lock_irqsave(&queue->lock,flags);
+	while ( (cmd = _rx_queue_cmd_refill(queue)) ) {
+		err = rx_queue_add(queue, cmd);
+		if (err)
+			break;
+	}
+	spin_unlock_irqrestore(&queue->lock,flags);
+
+	return err;
+}
+
+static void
+p54u_rx_bh(unsigned long data)
+{
+	struct p54u_pipe *pipe = (void *)data;
+	struct p54u *p54u = pipe->p54u;
+	int err;
+
+	err = rx_queue_process(p54u, pipe);
+	if (!err)
+		rx_queue_refill(p54u, pipe);
+
+	return;
+}
+
+static inline void
+rx_queue_cancel(struct p54u_pipe *queue, unsigned int index)
+{
+	usb_command_t *cmd = &queue->ringbuf[index % queue->len];
+	struct urb *descr = cmd->descr_urb;
+	if (descr)
+		usb_unlink_urb(descr);
+	usb_unlink_urb(cmd->data_urb);
+}
+
+static void
+rx_queue_empty(struct p54u_pipe *queue)
+{	
+	unsigned int start;
+	unsigned int end;
+	unsigned long flags;
+
+	spin_lock_irqsave(&queue->lock,flags);
+	start = queue->c;
+	end = queue->p;
+	while (start < end)
+		rx_queue_cancel(queue, start++);
+	spin_unlock_irqrestore(&queue->lock,flags);
+}
+
+/* TODO : queue unalloc function */
+
+/* TX QUEUE MANAGEMENT */
+
+/* called in non-atomic context */
+static struct urb *
+p54u_alloc_urb(struct usb_device *usbdev, struct p54u_pipe *queue)
+{
+	struct urb *urb;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (!urb)
+		return 0;
+
+	usb_fill_bulk_urb(urb, usbdev, queue->endp, 0,
+			  queue->buffer_size,
+			  p54u_bulk_urb_callback, queue);
+
+	return urb;
+}
+
+static struct urb *
+p54u_alloc_descr_urb(struct p54u *p54u, struct p54u_pipe *queue)
+{
+	/* TODO : fix size for version 2 devices */
+	struct usb_device *usbdev = p54u->usbdev;
+	unsigned int size = 16;
+	struct urb *urb;
+	void *buf;
+
+	urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!urb)
+		return 0;
+
+	urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+	/* fill in the urb when in version 1 device ? */
+	buf = usb_buffer_alloc(usbdev, size, GFP_KERNEL, &urb->transfer_dma);
+	if (!buf) {
+		islog(L_DEBUG, "could not allocate tx descr buf\n");
+		usb_free_urb(urb);
+		return 0;
+	}
+
+	/* the descr urb is very different from one device to the
+	 * other */
+	if (p54u->device_version == P54U_DEVICE_VER1) {
+		int endp = usb_sndbulkpipe(usbdev,
+					   P54U_PIPE_DEV &
+					   USB_ENDPOINT_NUMBER_MASK);
+		usb_fill_bulk_urb(urb, usbdev, endp, buf, 16,
+				  p54u_nil_urb_callback, 0);
+	} else {
+		usb_fill_bulk_urb(urb, usbdev, queue->endp,
+				  buf, 4, p54u_nil_urb_callback, 0);
+	}
+
+	return urb;
+}
+
+/* This function is only called during initialization of the queue */
+static int
+tx_queue_add(struct p54u *p54u, struct p54u_pipe *queue, unsigned int index)
+{
+	struct usb_device *usbdev = p54u->usbdev;
+	usb_command_t *command;
+	struct urb *urb;
+
+	command = &queue->ringbuf[index];
+
+	/* alloc needed urbs */
+	urb = p54u_alloc_descr_urb(p54u, queue);
+	if (!urb)
+		goto fail;
+	command->descr_urb = urb;
+
+
+	urb = p54u_alloc_urb(usbdev, queue);
+	if (!urb)
+		goto fail_urb;
+	command->data_urb = urb;
+
+	return 0;
+
+      fail_urb:
+	/* FIXME we're leaking the buffer descr urb */
+      fail:
+	return -ENOMEM;
+}
+
+static void
+tx_queue_process(struct p54u_pipe *queue)
+{
+	unsigned long final = queue->c;
+
+	/* for all acked packets in the queue */
+	BUG_ON(queue->f > final);
+	while (queue->f < final) {
+		unsigned int index = queue->f % queue->len;
+		struct sk_buff *skb = queue->ringbuf[index].skb;
+		queue->ringbuf[index].skb = (struct sk_buff *) 0;
+		/* FIXME : the skb must be successfull for this to be
+		   called */
+		islsm_txskb_free(skb);
+		queue->f++;
+	}
+}
+
+/* This is only a stub now -- get rid of it */
+static void
+p54u_tx_bh(unsigned long data)
+{
+	struct p54u_pipe *pipe = (void *)data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pipe->lock,flags);
+	tx_queue_process(pipe);
+	spin_unlock_irqrestore(&pipe->lock,flags);
+
+	return;
+}
+
+/* QUEUE MANAGEMENT */
+/* Agnostic functions */
+static void
+p54u_bulk_urb_callback(struct urb *urb)
+{
+	struct p54u_pipe *queue = (struct p54u_pipe *) urb->context;
+	/* TODO : spin lock for c, or atomic. Check in what context the
+	 * callback is called. Is it serialized against callbacks on the
+	 * same endpoint ? */
+	queue->c++;
+	tasklet_schedule(&queue->task);
+
+	return;
+}
+
+static void
+p54u_nil_urb_callback(struct urb *urb)
+{
+	return;
+}
+
+/* only these are exported */
+int
+p54u_queue_init(struct p54u *p54u,
+		struct usb_endpoint_descriptor *desc, struct p54u_pipe *queue)
+{
+	struct usb_device *usbdev = p54u->usbdev;
+
+	/* some needed fields init. Maybe I should just have the desc
+	 * saved instead of copying all its fields. */
+	/* please note : investigate what this wMaxPacketSize is worth
+	 * and _use_it_ instead of a P54U_MAX_bidule
+	 * -- it's worth nothing
+	 *
+	 */
+	queue->addr = desc->bEndpointAddress;
+	queue->interval = desc->bInterval;
+
+	queue->p54u = p54u;
+	queue->len = P54U_QUEUE_LEN;
+	queue->buffer_size = P54U_MAX_FRAME_SIZE;
+
+	if (queue->addr & USB_DIR_IN) {
+		queue->endp =
+			usb_rcvbulkpipe(usbdev,
+					queue->
+					addr & USB_ENDPOINT_NUMBER_MASK);
+		tasklet_init(&queue->task, p54u_rx_bh,
+			     (unsigned long)queue);
+	} else {
+		queue->endp =
+			usb_sndbulkpipe(usbdev,
+					queue->
+					addr & USB_ENDPOINT_NUMBER_MASK);
+		tasklet_init(&queue->task, p54u_tx_bh,
+			     (unsigned long)queue);
+	}
+	
+	spin_lock_init(&queue->lock);
+
+	/* queue proper init */
+	queue->f = queue->c = queue->p = 0;
+
+	/* initialize arrays */
+	queue->ringbuf =
+	    kmalloc(sizeof (*queue->ringbuf) * queue->len, GFP_KERNEL);
+
+	if (queue->ringbuf == 0)
+		return -ENOMEM;
+
+	/* zero out the thing */
+	memset(queue->ringbuf, 0, sizeof (*queue->ringbuf) * queue->len);
+
+	/* In case of an OUT endpoint, we allocate the data, because
+	 * we'd better do this in interruptible context, whereas
+	 * submission will be done in atomic context */
+	if (!(queue->addr & USB_DIR_IN)) {
+		unsigned int i;
+		for (i = 0; i < queue->len; i++)
+			tx_queue_add(p54u, queue, i);
+	}
+
+	return 0;
+}
+
+void
+p54u_queue_destroy(struct p54u_pipe *queue)
+{
+	unsigned int i;
+
+	if (!queue || !(queue->ringbuf))
+		return;
+
+	/* actually works for tx queues */
+	rx_queue_empty(queue);
+
+	/* wait for the urb to become free. Maybe i shouldn't set the
+	 * async unlink flag ? */
+	BUG_ON(queue->c > queue->p);
+	while (queue->c < queue->p) {
+		islog(L_DEBUG,
+		      "waiting for urbs in [%i %i[, queue %02x to return\n",
+		      queue->c, queue->p, queue->addr);
+		// schedule ?
+		p54u_mdelay(10);
+	}
+
+	/* wait for the last bh to do its job */
+	/* upping f will happen in the bh */
+	BUG_ON(queue->f > queue->c);
+	while (queue->f < queue->c) {
+		islog(L_DEBUG,
+		      "waiting for urbs in [%i %i[, queue %02x to be bh'd\n",
+		      queue->f, queue->c, queue->addr);
+		tasklet_schedule(&queue->task);
+	}
+
+	tasklet_kill(&queue->task);
+
+	/* free the alloc'd urbs. This is simple,
+	   usb_free_urb and dev_kfree_skb can be called on nulls. */
+	for (i = 0; i < queue->len; i++) {
+		usb_command_t *cmd = &queue->ringbuf[i];
+		usb_free_urb(cmd->data_urb);
+		usb_free_urb(cmd->descr_urb);
+		if (cmd->skb)
+			dev_kfree_skb(cmd->skb);
+	}
+
+	kfree(queue->ringbuf);
+	queue->ringbuf = 0;
+
+	return;
+}
+
+/* TODO: move the usb_command_t into the control block -- and only queue
+   skbs */
+static int
+tx_queue_submit_lm87_3887(usb_command_t *command, struct sk_buff *skb)
+{
+	u32 address = LMAC_ADDR_OF_SKB(skb);
+	struct urb *data_urb = command->data_urb;
+
+	/* for LM87 transport on the G3887, the
+	   address is not a separate packet */
+	*(u32 *)skb_push(skb, sizeof(u32)) = cpu_to_le32(address);
+
+	/* prepare the data urb */
+	data_urb->transfer_buffer = skb->data;
+	data_urb->transfer_buffer_length = skb->len;
+
+	/* submit the urbs, for now with debug */
+	return p54u_submit_urb(data_urb, GFP_ATOMIC);
+}
+
+static int
+tx_queue_submit_lm86_3887(usb_command_t *command, struct sk_buff *skb)
+{
+	u32 address = LMAC_ADDR_OF_SKB(skb);
+	struct urb *data_urb = command->data_urb;
+	struct urb *descr_urb = command->descr_urb;
+	int err;
+
+	/* for LM86 transport on the G3887, the address is a separate
+	   packet */
+
+	/* prepare the address URB */
+	*((u32 *) descr_urb->transfer_buffer) = cpu_to_le32(address);
+	/* should be taken care of during allocation */
+	descr_urb->transfer_buffer_length = 4;
+
+	data_urb->transfer_buffer = skb->data;
+	data_urb->transfer_buffer_length = skb->len;
+
+	/* submit the urbs, for now with debug */
+	err = p54u_submit_urb(descr_urb, GFP_ATOMIC);
+
+	if (!err)
+		err = p54u_submit_urb(data_urb, GFP_ATOMIC);
+
+	return err;
+}
+
+static int
+tx_queue_submit_lm86_3886(usb_command_t *command, struct sk_buff *skb)
+{
+	int err;
+	struct net2280_reg_write reg;
+	unsigned int pipe;
+	int val;
+	struct urb *data_urb = command->data_urb;
+	struct urb *descr_urb = command->descr_urb;
+	/* for LM86 transport on the 3886 + net2280, the
+	   data packet is announced by an interrupt request */
+
+	/* prepare the interrupt URB */
+	pipe = data_urb->pipe;
+	switch (usb_pipeendpoint(pipe)) {
+	case P54U_PIPE_DATA:
+		val = ISL38XX_DEV_INT_DATA;
+		break;
+	case P54U_PIPE_MGMT:
+		val = ISL38XX_DEV_INT_MGMT;
+		break;
+	default:
+		return -EIO;
+	}
+
+	reg.port = cpu_to_le16(P54U_PORT_DEV_U32);
+	reg.addr = cpu_to_le32(P54U_DEV_BASE | ISL38XX_DEV_INT_REG);
+	reg.val = cpu_to_le32(val);
+
+	memcpy(descr_urb->transfer_buffer, &reg, sizeof (reg));
+	descr_urb->transfer_buffer_length = sizeof (reg);
+
+	/* Additionally, the USB needs to be padded to 32-bits width. I
+	   don't know what happens for the CRC in lm87 mode -- must it
+	   be changed ?	*/
+
+	if (skb->len % 4) {
+		/* FIXME : is there enough room ? */
+		unsigned int padding = 4 - (skb->len & 3);
+		void *ref = skb_put(skb, padding);
+		memset(ref, 0, padding);
+	}
+
+	data_urb->transfer_buffer = skb->data;
+	data_urb->transfer_buffer_length = skb->len;
+
+	err = p54u_submit_urb(descr_urb, GFP_ATOMIC);
+	if (!err)
+		err = p54u_submit_urb(data_urb, GFP_ATOMIC);
+
+	return err;
+}
+
+/* TODO: when tx path has been simplified, this function will be
+   duplicated into the chip-specific files, so that we don't have to
+   case here against the device version -- which is completely useless,
+   as this is called from device-specific callbacks... */
+int
+tx_queue_submit(struct p54u_pipe *queue, struct sk_buff *skb)
+{
+	struct islsm *islsm = ISLSM_OF_NETDEV(skb->dev);
+	struct p54u *p54u = P54U_OF_ISLSM(islsm);
+	usb_command_t *command;
+	unsigned long flags;
+	int err;
+
+	if (p54u->state != P54U_RUN) {
+		islog(L_DEBUG, "dismissed packet sending attempt while not running\n");
+		return -EIO;
+	}
+
+	/* Lock until submitted, to make sure urb submit is in correct
+	 * order wrt the queue */
+	spin_lock_irqsave(&queue->lock, flags);
+
+	BUG_ON(queue->p > queue->f + queue->len);
+	if (queue->p == queue->f + queue->len) {
+		err = -ENOSPC;
+		goto err_unlock;
+	}
+
+	command = &queue->ringbuf[queue->p % queue->len];
+
+	switch (p54u->device_version) {
+	case P54U_DEVICE_VER2 :
+	{
+		switch (islsm->fw_type) {
+		case ISLSM_FW_LM87:
+			err = tx_queue_submit_lm87_3887(command, skb);
+			break;
+		case ISLSM_FW_LM86:
+			err = tx_queue_submit_lm86_3887(command, skb);
+			break;
+		default:
+			err = -EINVAL;
+		}
+	}
+	break;
+	case P54U_DEVICE_VER1 :
+		err = tx_queue_submit_lm86_3886(command, skb);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	if (!err) {
+		command->skb = skb;
+		queue->p++;
+	}
+
+ err_unlock:
+	spin_unlock_irqrestore(&queue->lock, flags);
+	return err;
+}
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/Makefile linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/Makefile
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/Makefile	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,6 @@
+prism54usb-objs := islusb_init.o islusb_transport.o \
+	islsm_input.o islsm_output.o islsm_netdev.o islsm_ioctl.o \
+	islsm_uart.o islsm_bra.o islsm_pda.o islusb_3887.o islusb_net2280.o \
+	islsm_log.o islsm_alloc_skb.o islsm_sysfs.o
+
+obj-$(CONFIG_PRISM54_USB) += prism54usb.o
diff -Nurp linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/sent_data_ok.h linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/sent_data_ok.h
--- linux-2.6.21-sabayon-r1.orig/drivers/net/wireless/prism54usb/sent_data_ok.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.21-sabayon-r1/drivers/net/wireless/prism54usb/sent_data_ok.h	2007-04-04 09:22:31.000000000 +0200
@@ -0,0 +1,231 @@
+#include "isl_sm.h"
+/* usb version 1 packet */
+static char             islsm_data_packet1[86] = {	//0x00, 0x02, 0x02, 0x00, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x01, 0x80, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	0x00,
+	0x00, 0x14, 0x0a, 0x06,
+	0x02, 0x00, 0x1f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x1f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x1f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x1f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x1f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+/* usb version 2 packet */
+static char             islsm_data_packet2[86] =
+    { 0x01, 0x80, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	0x00,
+	0x00, 0x14, 0x0a, 0x06,
+	0x02, 0x00, 0x03, 0x00, 0x07, 0x00, 0x5e, 0x00, 0x02, 0x00, 0x07,
+	0x00,
+	0x0f, 0x00, 0x2f, 0x00,
+	0x03, 0x00, 0x0f, 0x00, 0xff, 0x03, 0x2b, 0x00, 0x07, 0x00, 0x0f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x78, 0x05
+};
+
+/* pci packet. 5a values are "don't care" values. */
+static char             islsm_data_packet3[88] =
+    { 0x01, 0x80, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	0x00,
+	0x00, 0x14, 0x0a, 0x06,
+	0x02, 0x5a, 0x03, 0x00, 0x07, 0x00, 0x2f, 0x00, 0x02, 0x5a, 0x07,
+	0x00,
+	0x0f, 0x00, 0x5e, 0x00,
+	0x03, 0x5a, 0x0f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x07, 0x5a, 0x0f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+/* ap mode, my device */
+/*
+0x01 0x80 0x4a 0x00 0x00 0x00 0x00 0x00 0x03 0x00 0x00 0x00 0x00 0x14 0x0a 0x06
+0x02 0x5a 0x03 0x00 0x07 0x00 0x2f 0x00 0x02 0x5a 0x07 0x00 0x0f 0x00 0x5e 0x00
+0x03 0x5a 0x0f 0x00 0xff 0x03 0x00 0x00 0x07 0x5a 0x0f 0x00 0xff 0x03 0x00 0x00
+0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a
+0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a 0x5a
+0x00 0x00 0x00 0x00 0x00 0x00
+*/
+
+/* My device, client mode */
+static char             islsm_data_UNK1[88]  __attribute__ ((unused)) =
+    { 0x01, 0x80, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	0x00,
+	0x00, 0x14, 0x0a, 0x06,
+	0x02, 0x5a, 0x03, 0x00, 0x07, 0x00, 0x2f, 0x00, 0x02, 0x5a, 0x07,
+	0x00,
+	0x0f, 0x00, 0x5e, 0x00,
+	0x03, 0x5a, 0x0f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x07, 0x5a, 0x0f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+/* from david */
+static char             islsm_data_UNK1_2[88]  __attribute__ ((unused)) =
+    { 0x01, 0x80, 0x4a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
+	0x00,
+	0x00, 0x14, 0x0a, 0x06,
+	0x02, 0x01, 0x03, 0x00, 0x07, 0x00, 0x2f, 0x00, 0x02, 0x00, 0x07,
+	0x00,
+	0x0f, 0x00, 0x5e, 0x00,
+	0x03, 0x00, 0x0f, 0x00, 0xff, 0x03, 0x00, 0x00, 0x07, 0x00, 0x0f,
+	0x00,
+	0xff, 0x03, 0x00, 0x00,
+	0x00, 0x16, 0x0e, 0x35, 0xbd, 0x34, 0xda, 0x56, 0x01, 0x4e, 0xb3,
+	0xe5,
+	0x50, 0x10, 0x29, 0xe0,
+	0xa9, 0x91, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+};
+
+/*
+May 11 11:50:42 niobium kernel: frag :  01 80 08 00 00 00 00 00 0d 00 00 00 03 00 03 00 03 00 00 00
+May 11 11:50:42 niobium kernel: driver_time time 0x396b6b6a us
+May 11 11:50:42 niobium kernel: prism_interconnect_message_query(1, 1, 52, 20200, c75c47b8)
+*/
+
+/* Which mode was david on ? hostap mode ? */
+static char             islsm_data_UNK2_2[52]  __attribute__ ((unused)) = {
+	0x01, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x50,
+	0xbf, 0xa8, 0xa4, 0xe6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x47, 0x02,
+	0x00,
+	0x20, 0x06, 0x03, 0x00,
+	0x00, 0x00, 0x3f, 0xc7,
+};
+
+/* end */
+
+/* client mode, my device. Try to understand AP mode, my device. See how
+ * it fares. */
+static char             islsm_data_UNK2[52]  __attribute__ ((unused)) = {
+	0x01, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x04,
+	0xe2, 0x63, 0x97, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x47, 0x02,
+	0x00,
+	0x20, 0x06, 0x01, 0x00,
+	0x00, 0x00, 0xc5, 0xf7,
+};
+
+/* ap mode, my device */
+static char             islsm_data_UNK2_3[52]  __attribute__ ((unused)) = {
+	0x01, 0x80, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00,
+	0x00, 0x00, 0x00, 0x04,
+	0xe2, 0x63, 0x97, 0x34, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
+	0x00,
+	0x01, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x47, 0x02,
+	0x00,
+	0x20, 0x06, 0x01, 0x00,
+	0x00, 0x00, 0xc5, 0xf7,
+};
+
+/* client mode, my device */
+static char             islsm_data_UNK3[]  __attribute__ ((unused)) = {
+	0x01, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00,
+	0x02, 0x00, 0x78, 0x00,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x6c, 0x09, 0xf5, 0x03, 0x10, 0x00, 0x00,
+	0x00,
+	0x06, 0x01, 0x08, 0x38,
+	0x38, 0x38, 0x38, 0x38, 0x57, 0x75, 0x8b, 0x99, 0xa5, 0xb1, 0xbd,
+	0x5a,
+	0x4f, 0x40, 0x69, 0x77,
+	0x83, 0x8f, 0x9b, 0x5a, 0x47, 0x18, 0x54, 0x62, 0x6e, 0x7a, 0x86,
+	0x5a,
+	0x3b, 0xea, 0x3e, 0x4c,
+	0x58, 0x64, 0x70, 0x5a, 0x2f, 0xcb, 0x2b, 0x39, 0x45, 0x51, 0x5d,
+	0x5a,
+	0x23, 0xb5, 0x19, 0x27,
+	0x33, 0x3f, 0x4b, 0x5a, 0x17, 0xa5, 0x07, 0x15, 0x21, 0x2d, 0x39,
+	0x5a,
+	0x00, 0x94, 0x00, 0x00,
+	0x00, 0x0b, 0x17, 0x5a, 0x4d, 0x48, 0x44, 0x39, 0x7c, 0x00, 0x69,
+	0xfe,
+};
+
+static char             islsm_data_UNK4[]  __attribute__ ((unused)) = {
+	0x01, 0x80, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
+	0x00,
+	0x02, 0x00, 0x78, 0x00,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a,
+	0x5a, 0x5a, 0x5a, 0x5a, 0x71, 0x09, 0xf4, 0x03, 0x10, 0x00, 0x00,
+	0x00,
+	0x06, 0x01, 0x08, 0x48,
+	0x48, 0x48, 0x43, 0x38, 0x57, 0x76, 0x8b, 0x99, 0xa5, 0xb1, 0xbd,
+	0x5a,
+	0x4f, 0x42, 0x69, 0x77,
+	0x83, 0x8f, 0x9b, 0x5a, 0x47, 0x19, 0x54, 0x62, 0x6e, 0x7a, 0x86,
+	0x5a,
+	0x3b, 0xeb, 0x3e, 0x4c,
+	0x58, 0x64, 0x70, 0x5a, 0x2f, 0xcb, 0x2b, 0x39, 0x45, 0x51, 0x5d,
+	0x5a,
+	0x23, 0xb5, 0x19, 0x27,
+	0x33, 0x3f, 0x4b, 0x5a, 0x17, 0xa6, 0x07, 0x15, 0x21, 0x2d, 0x39,
+	0x5a,
+	0x00, 0x94, 0x00, 0x00,
+	0x00, 0x0b, 0x17, 0x5a, 0x4d, 0x48, 0x43, 0x38, 0x7c, 0x00, 0x69,
+	0xfe,
+};
+
+struct magicpkt {
+	int                     len;
+	char                   *data;
+};
+
+static struct magicpkt  magicpkt_table[3] = {
+	[ISLSM_DEVICE_USB_VER1] {.len = sizeof (islsm_data_packet1),.data =
+				 islsm_data_packet1}
+	,
+	[ISLSM_DEVICE_USB_VER2] {.len = sizeof (islsm_data_packet2),.data =
+				 islsm_data_packet2}
+	,
+	[ISLSM_DEVICE_PCI_VER1] {.len = sizeof (islsm_data_packet3),.data =
+				 islsm_data_packet3}
+	,
+};
