diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/Kconfig linux-2.6.20-sabayon-r1/fs/Kconfig
--- linux-2.6.20-sabayon-r1.orig/fs/Kconfig	2007-02-12 12:49:03.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/Kconfig	2007-02-12 12:52:10.000000000 +0100
@@ -1619,6 +1619,16 @@ config UFS_DEBUG
 	  Y here.  This will result in _many_ additional debugging messages to be
 	  written to the system log.
 
+config UNION_FS
+	tristate "Union fs support"
+	depends on EXPERIMENTAL
+	help
+	  Unionfs is a stackable unification file system, which can
+	  appear to merge the contents of several directories (branches),
+	  while keeping their physical content separate.
+
+	  see <http://www.fsl.cs.sunysb.edu/project-unionfs.html> for details
+
 endmenu
 
 menu "Network File Systems"
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/Makefile linux-2.6.20-sabayon-r1/fs/Makefile
--- linux-2.6.20-sabayon-r1.orig/fs/Makefile	2007-02-12 12:49:03.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/Makefile	2007-02-12 12:52:28.000000000 +0100
@@ -116,3 +116,4 @@ obj-$(CONFIG_HPPFS)		+= hppfs/
 obj-$(CONFIG_DEBUG_FS)		+= debugfs/
 obj-$(CONFIG_OCFS2_FS)		+= ocfs2/
 obj-$(CONFIG_GFS2_FS)           += gfs2/
+obj-$(CONFIG_UNION_FS)          += unionfs/
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/AUTHORS linux-2.6.20-sabayon-r1/fs/unionfs/AUTHORS
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/AUTHORS	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/AUTHORS	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,180 @@
+PRIMARY AUTHORS AND MAJOR CONTRIBUTORS TO UNIONFS:
+The primary authors work at the Filesystems and Storage Lab at Stony Brook
+University.   They also currently maintain the package.
+
+* Erez Zadok  <ezk@cs.sunysb.edu>
+- Primary Investigator
+
+* Charles P. Wright  <cwright@cs.sunysb.edu>
+- Primary maintainer (12/2004-Present)
+- Snapshotting support
+- Initial development
+
+* Dave Quigley  <dquigley@fsl.cs.sunysb.edu>
+- 2.6 Port
+- Maintenance (1/2005-Present)
+
+* Arun Krishna Kumar <arunmk@fsl.cs.sunysb.edu>
+- Maintenance (6/2005-12/2005)
+
+* Mohammad Nayyer Zubair
+- Initial development
+- Regression Suite
+
+* Puja Gupta
+- Initial development
+
+* Harikesavan Krishnan
+- Initial development
+
+* Josef "Jeff" Sipek
+- Maintenance (12/2005-Present)
+
+Other contributors:
+* Sai Suman  <suman@pantasys.com>
+January 10, 2005: NFS Export patch
+January 10, 2005: Copyup bug fix.
+
+* Alex de Landgraaf <alex@delandgraaf.com>
+January 10, 2005: Fixes for gcc 2.9.5
+
+* Anton Farygin <rider@altlinux.com>
+February 2, 2005:  Fixes for non-privileged copyup.
+March 2, 2005: vfs_readdir bug in dirhelper.c
+March 2, 2005: Fix copyup on symlinks
+March 2, 2005: Fix handling of failed whiteout lookup
+August 15, 2005: Fix possible deadlock in incgen when memory allocaiton fails.
+
+* Jaspreet Singh  <jsingh@ensim.com>
+February 8, 2005: Use security functions for xattr copyup.
+May 11, 2005: Fix for Xattr copyup on Selinux
+May 12, 2005: Selinux requires valid i_mode before d_instantiate.
+
+* Fabian Franz <fs-bugs@fabian-franz.de>
+February 22, 2005: Hardlinks should have the same inode number.
+February 22, 2005: Device copyup fix.
+February 22, 2005: Identified d_delete problem over tmpfs
+March 2, 2005: vfs_readdir bug in dirhelper.c
+
+* Terry Barnaby <terry1@beam.ltd.uk>
+March 3, 2005: Copy attributes on d_revalidate
+March 2, 2005: Fix for readdir over NFS
+March 16, 2005: Fix for unionfs_dir_llseek
+April 20, 2005: Submitted opaque directory patch, wich the current code
+is inspired by.
+
+* Lucas Correia Villa Real <lucasvr@gobolinux.org>
+March 7, 2005: Makefile uses MODDIR.
+
+* Eduard Bloch <blade@debian.org>
+March 7, 2005: Fix man page sections, improve Makefile
+
+* Fernando Freiregomez <fernando.freiregomez@telefonica.es>
+March 7, 2005: Have snapmerge fix times on created files.
+
+* Markus F.X.J. Oberhumer <markus@oberhumer.com>
+April 18, 2005: Fixes for compilation on AMD64
+
+* Tomas Matejicek
+May 10, 2005: I used his linuxrc as the basis for the Unionfs as a root
+file system instructions.
+March 22, 2006: Little updates and corrections to INSTALL
+
+* Shaya Potter
+July 19, 2005: Symbolic links should not be renamed to whiteout files, as
+that confuses Unionfs later.
+September 2, 2005: Fix copyup checking for mmap.
+October 11, 2005: Deadlock fix.
+October 20, 2005: Improved locking for branch manipulation
+October 20, 2005: Fix for removing opaque directories.
+November 18, 2005: NULL check in lookup_whiteout.
+March 5, 2006: Implemented true mmap
+
+* Jan Engelhardt <jengelh@linux01.gwdg.de>
+July 22, 2005: Support for realpath in unionctl.
+August 1, 2005: Use vprintk instead of vsnprintf/printk combo.
+August 9, 2005: Fix unionctl so that it doesn't truncate "/" to "".
+February 21, 2006: Make unionfs work with the new mutex subsystem
+
+* Malcom Lashley <malc@gentoo.org>
+August 9, 2005: AMD64 compile fixes.
+
+* Eduard Bloch <blade@debian.org>
+August 9, 2005: Debian packaging files.
+
+* Klaus Knopper <unionfs@knopper.net>
+August 22, 2005: Fix from lookup_one_len in unionfs_create.
+September 23, 2005: Fix for unionfs_permission pertaining to
+read only file systems
+
+* Junjiro Okajima <hooanon05@yahoo.co.jp>
+September 21, 2005: Fix for of by one error in KMALLOC.
+September 26, 2005: Fix for d_revalidate.
+September 28, 2005: rmdir fix.
+October 13, 2005: rename fix (Bug #425).
+October 19, 2005: NFS security hole fix.
+November 5, 2005: Fix for race b/t lookup and new_dentry_private_data.
+November 8, 2005: Fix error checking in lookup_backend.
+December 27, 2005: Fixed create whiteout bug, forgotten dput()
+December 27, 2005: Fixed unlink bug, forgotten dput()s
+December 27, 2005: Fixed create bug, forgotten dput(), extra GET_PARENT
+December 27, 2005: Fixed permission bug, creat/open truncates the running
+executable
+December 27, 2005: Properly copyup atime, mtime, and ctime.
+December 28, 2005: Fixed missing DPUT()s in unionfs_lookup_backend
+December 28, 2005: Fixed privileges-related bug in is_opaque_dir
+December 29, 2005: Fixed missing/misplaced DPUT()sg DPUT()
+January 20, 2006: Introduced per-branch nfsro flag (unionctl.c)
+January 22, 2006: Fixed persistant inode code: link, rmdir, shrinking of
+dcache, map validation
+January 24, 2006: Fixed hidden inode not being iput() since ibstart and
+ibend is not updated.
+January 31, 2006: Fixes "pseudo hardlink" via persistent inode
+February 2, 2006: Fixed minor bug in unionfs_create regarding stale atime and
+mtime
+February 5, 2006: Changed get_uin() to read_uid()
+February 10, 2006: Fixed stale inode problem of regression/bug418.sh
+February 21, 2006: Fixed some problems around permission bits of a dir
+March 4, 2006: Fixed bug - broken inode when the target entry is hard-linked
+March 4, 2006: Fixed unionfs_permission on reiserfs and xfs
+March 8, 2006: Fixed xattr "not supported" check in copyup
+April 17, 2006: Fixed link-unlink issue (i_nlink going to 0)
+
+* Bill Nottingham <notting@redhat.com>
+Match 3, 2006: Fixed tmpfs xattrs
+
+* Robert Glowczynski <roglo@op.pl>
+October 6, 2005: Fix for fsync over squashfs.
+
+* Charles Duffy <cduffy@spamcop.net
+October 21, 2005: Compile fix for x86_64
+
+* Tom Young <twyun@twyoung.com>
+October 22, 2005: readdir.sh regression script
+
+* Alessio Curri <alessio.curri@elettra.trieste.it>
+November 11, 2005: Fix for RPM spec file.
+
+* Martin Walter <mawa@uni-freiburg.de>
+November 16, 2005: Fix a thinko in NFS_SECURITY_HOLE.
+
+* Martin Kreiner <m.kreiner@levigo.de>
+January 13, 2006: Introduced mount option nfsperms, and removed NFS_SECURITY_HOLE
+January 20, 2006: Introduced per-branch nfsro flag, and removed nfsperms
+
+* Peeka J. Enberg <penberg@cs.helsinki.fi>
+January 14, 2006: Removed the use of GFP_UNIONFS and replaced it with GFP_KERNEL
+
+* Amnon Aaronsohn <bla@cs.huji.ac.il>
+January 25, 2006: Fixed patch-kernel.sh error msg
+
+* Konstantin Olchanski <olchansk@triumf.ca>
+February 8, 2006: Fixed inode_permission (check for nameidata being null)
+
+* Ed Swierk <eswierk@gmail.com>
+March 4, 2006: Install the unionimap man page along with all the other man pages
+
+* Gregory Haskins <ghaskins@novell.com>
+June 14, 2006: Updated RPM specfile, fixed up Makefiles
+
+* And many more ...
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/branchman.c linux-2.6.20-sabayon-r1/fs/unionfs/branchman.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/branchman.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/branchman.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,579 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: branchman.c,v 1.66 2006/10/31 00:05:22 yiannos Exp $
+ */
+
+#include "unionfs.h"
+
+struct dentry **alloc_new_dentries(int objs)
+{
+	if (!objs)
+		return NULL;
+
+	return KZALLOC(sizeof(struct dentry *) * objs, GFP_KERNEL);
+}
+
+struct unionfs_usi_data *alloc_new_data(int objs)
+{
+	if (!objs)
+		return NULL;
+
+	return KZALLOC(sizeof(struct unionfs_usi_data) * objs, GFP_KERNEL);
+}
+
+static void fixputmaps(struct super_block *sb)
+{
+	struct unionfs_sb_info *spd;
+	struct putmap *cur;
+	int gen;
+	int i;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	cur = spd->usi_putmaps[spd->usi_lastputmap - spd->usi_firstputmap];
+
+	for (gen = 0; gen < spd->usi_lastputmap - spd->usi_firstputmap; gen++) {
+		if (!spd->usi_putmaps[gen])
+			continue;
+		for (i = 0; i <= spd->usi_putmaps[gen]->bend; i++)
+			spd->usi_putmaps[gen]->map[i] =
+			    cur->map[spd->usi_putmaps[gen]->map[i]];
+	}
+
+	print_exit_location();
+}
+
+static int newputmap(struct super_block *sb)
+{
+	struct unionfs_sb_info *spd;
+	struct putmap *newmap;
+	int count = 0;
+	int i;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	i = sizeof(int) * (sbend(sb) + 1);
+	newmap = KMALLOC(sizeof(struct putmap) + i, GFP_KERNEL);
+	if (!newmap) {
+		print_exit_status(-ENOMEM);
+		return -ENOMEM;
+	}
+
+	if (!spd->usi_firstputmap) {
+		spd->usi_firstputmap = 1;
+		spd->usi_lastputmap = 1;
+
+		spd->usi_putmaps = KMALLOC(sizeof(struct putmap *), GFP_KERNEL);
+		if (!spd->usi_putmaps) {
+			KFREE(newmap);
+			print_exit_status(-ENOMEM);
+			return -ENOMEM;
+		}
+	} else {
+		struct putmap **newlist;
+		int newfirst = spd->usi_firstputmap;
+
+		while (!spd->usi_putmaps[newfirst - spd->usi_firstputmap] &&
+		       newfirst <= spd->usi_lastputmap) {
+			newfirst++;
+		}
+
+		newlist =
+		    KMALLOC(sizeof(struct putmap *) *
+			    (1 + spd->usi_lastputmap - newfirst), GFP_KERNEL);
+		if (!newlist) {
+			KFREE(newmap);
+			print_exit_status(-ENOMEM);
+			return -ENOMEM;
+		}
+
+		for (i = newfirst; i <= spd->usi_lastputmap; i++) {
+			newlist[i - newfirst] =
+			    spd->usi_putmaps[i - spd->usi_firstputmap];
+		}
+
+		KFREE(spd->usi_putmaps);
+		spd->usi_putmaps = newlist;
+		spd->usi_firstputmap = newfirst;
+		spd->usi_lastputmap++;
+	}
+
+	newmap->bend = sbend(sb);
+	for (i = 0; i <= sbend(sb); i++) {
+		count += branch_count(sb, i);
+		newmap->map[i] = i;
+	}
+	for (i = spd->usi_firstputmap; i < spd->usi_lastputmap; i++) {
+		struct putmap *cur;
+		cur = spd->usi_putmaps[i - spd->usi_firstputmap];
+		if (!cur)
+			continue;
+		count -= atomic_read(&cur->count);
+	}
+	atomic_set(&newmap->count, count);
+	spd->usi_putmaps[spd->usi_lastputmap - spd->usi_firstputmap] = newmap;
+
+	print_exit_status(0);
+	return 0;
+}
+
+/* XXX: this function needs to go. There is no reason for this to be here */
+int unionfs_ioctl_branchcount(struct file *file, unsigned int cmd,
+			      unsigned long arg)
+{
+	int err = 0;
+	int bstart, bend;
+	int i;
+	struct super_block *sb = file->f_dentry->d_sb;
+
+	print_entry_location();
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	err = bend + 1;
+	if (!arg)
+		goto out;
+
+	for (i = bstart; i <= bend; i++) {
+		if (put_user(branch_count(sb, i), ((int __user *)arg) + i)) {
+			err = -EFAULT;
+			goto out;
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_ioctl_incgen(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int err = 0;
+	struct super_block *sb;
+
+	print_entry_location();
+
+	sb = file->f_dentry->d_sb;
+
+	unionfs_write_lock(sb);
+	if ((err = newputmap(sb)))
+		goto out;
+
+	atomic_inc(&stopd(sb)->usi_generation);
+	err = atomic_read(&stopd(sb)->usi_generation);
+
+	atomic_set(&dtopd(sb->s_root)->udi_generation, err);
+	atomic_set(&itopd(sb->s_root->d_inode)->uii_generation, err);
+
+      out:
+	unionfs_write_unlock(sb);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_ioctl_addbranch(struct inode *inode, unsigned int cmd,
+			    unsigned long arg)
+{
+	int err;
+	struct unionfs_addbranch_args *addargs = NULL;
+	struct nameidata nd;
+	char *path = NULL;
+	int gen;
+	int i;
+
+	int pobjects;
+
+	struct unionfs_usi_data *new_data = NULL;
+	struct dentry **new_udi_dentry = NULL;
+	struct inode **new_uii_inode = NULL;
+
+	struct dentry *root = NULL;
+	struct dentry *hidden_root = NULL;
+
+	print_entry_location();
+
+#ifdef UNIONFS_IMAP
+	if (stopd(sb)->usi_persistent) {
+		printk(KERN_ERR "Cannot manipulate branches if imap is used\n");
+		err = -EPERM;
+		goto out;
+	}
+#endif
+
+	err = -ENOMEM;
+	addargs = KMALLOC(sizeof(struct unionfs_addbranch_args), GFP_KERNEL);
+	if (!addargs)
+		goto out;
+
+	err = -EFAULT;
+	if (copy_from_user
+	    (addargs, (const void __user *)arg,
+	     sizeof(struct unionfs_addbranch_args)))
+		goto out;
+
+	err = -EINVAL;
+	if (addargs->ab_perms & ~(MAY_READ | MAY_WRITE | MAY_NFSRO))
+		goto out;
+	if (!(addargs->ab_perms & MAY_READ))
+		goto out;
+
+	err = -E2BIG;
+	if (sbend(inode->i_sb) > FD_SETSIZE)
+		goto out;
+
+	err = -ENOMEM;
+	if (!(path = getname((const char __user *)addargs->ab_path)))
+		goto out;
+
+	err = path_lookup(path, LOOKUP_FOLLOW, &nd);
+
+	RECORD_PATH_LOOKUP(&nd);
+	if (err)
+		goto out;
+	if ((err = check_branch(&nd))) {
+		path_release(&nd);
+		RECORD_PATH_RELEASE(&nd);
+		goto out;
+	}
+
+	unionfs_write_lock(inode->i_sb);
+	lock_dentry(inode->i_sb->s_root);
+
+	root = inode->i_sb->s_root;
+	for (i = dbstart(inode->i_sb->s_root); i <= dbend(inode->i_sb->s_root);
+	     i++) {
+		hidden_root = dtohd_index(root, i);
+		if (is_branch_overlap(hidden_root, nd.dentry)) {
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+	err = -EINVAL;
+	if (addargs->ab_branch < 0
+	    || (addargs->ab_branch > (sbend(inode->i_sb) + 1)))
+		goto out;
+
+	if ((err = newputmap(inode->i_sb)))
+		goto out;
+
+	stopd(inode->i_sb)->b_end++;
+	dtopd(inode->i_sb->s_root)->udi_bcount++;
+	set_dbend(inode->i_sb->s_root, dbend(inode->i_sb->s_root) + 1);
+	itopd(inode->i_sb->s_root->d_inode)->b_end++;
+
+	atomic_inc(&stopd(inode->i_sb)->usi_generation);
+	gen = atomic_read(&stopd(inode->i_sb)->usi_generation);
+
+	pobjects = sbend(inode->i_sb) + 1;
+
+	/* Reallocate the dynamic structures. */
+	new_data = alloc_new_data(pobjects);
+	new_udi_dentry = alloc_new_dentries(pobjects);
+	new_uii_inode = KZALLOC(sizeof(struct inode *) * pobjects, GFP_KERNEL);
+
+	if (!new_udi_dentry || !new_uii_inode || !new_data) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Copy the in-place values to our new structure. */
+	for (i = 0; i < addargs->ab_branch; i++) {
+		atomic_set(&(new_data[i].sbcount),
+			   branch_count(inode->i_sb, i));
+
+		new_data[i].branchperms = branchperms(inode->i_sb, i);
+		new_data[i].hidden_mnt = stohiddenmnt_index(inode->i_sb, i);
+		new_data[i].sb = stohs_index(inode->i_sb, i);
+
+		new_udi_dentry[i] = dtohd_index(inode->i_sb->s_root, i);
+		new_uii_inode[i] = itohi_index(inode->i_sb->s_root->d_inode, i);
+	}
+
+	/* Shift the ends to the right (only handle reallocated bits). */
+	for (i = sbend(inode->i_sb) - 1; i >= (int)addargs->ab_branch; i--) {
+		int j = i + 1;
+		int pmindex;
+
+		atomic_set(&new_data[j].sbcount, branch_count(inode->i_sb, i));
+
+		new_data[j].branchperms = branchperms(inode->i_sb, i);
+		new_data[j].hidden_mnt = stohiddenmnt_index(inode->i_sb, i);
+		new_data[j].sb = stohs_index(inode->i_sb, i);
+		new_udi_dentry[j] = dtohd_index(inode->i_sb->s_root, i);
+		new_uii_inode[j] = itohi_index(inode->i_sb->s_root->d_inode, i);
+
+		/* Update the newest putmap, so it is correct for later. */
+		pmindex = stopd(inode->i_sb)->usi_lastputmap;
+		pmindex -= stopd(inode->i_sb)->usi_firstputmap;
+		stopd(inode->i_sb)->usi_putmaps[pmindex]->map[i] = j;
+
+	}
+
+	/* Now we can free the old ones. */
+	KFREE(dtopd(inode->i_sb->s_root)->udi_dentry);
+	KFREE(itopd(inode->i_sb->s_root->d_inode)->uii_inode);
+	KFREE(stopd(inode->i_sb)->usi_data);
+
+	/* Update the real pointers. */
+	dtohd_ptr(inode->i_sb->s_root) = new_udi_dentry;
+	itohi_ptr(inode->i_sb->s_root->d_inode) = new_uii_inode;
+	stopd(inode->i_sb)->usi_data = new_data;
+
+	/* Re-NULL the new ones so we don't try to free them. */
+	new_data = NULL;
+	new_udi_dentry = NULL;
+	new_uii_inode = NULL;
+
+	/* Put the new dentry information into it's slot. */
+	set_dtohd_index(inode->i_sb->s_root, addargs->ab_branch, nd.dentry);
+	set_itohi_index(inode->i_sb->s_root->d_inode, addargs->ab_branch,
+			IGRAB(nd.dentry->d_inode));
+	set_branchperms(inode->i_sb, addargs->ab_branch, addargs->ab_perms);
+	set_branch_count(inode->i_sb, addargs->ab_branch, 0);
+	set_stohiddenmnt_index(inode->i_sb, addargs->ab_branch, nd.mnt);
+	set_stohs_index(inode->i_sb, addargs->ab_branch, nd.dentry->d_sb);
+
+	atomic_set(&dtopd(inode->i_sb->s_root)->udi_generation, gen);
+	atomic_set(&itopd(inode->i_sb->s_root->d_inode)->uii_generation, gen);
+
+	fixputmaps(inode->i_sb);
+
+      out:
+	unlock_dentry(inode->i_sb->s_root);
+	unionfs_write_unlock(inode->i_sb);
+
+	KFREE(new_udi_dentry);
+	KFREE(new_uii_inode);
+	KFREE(new_data);
+	KFREE(addargs);
+	if (path)
+		putname(path);
+
+	print_exit_status(err);
+
+	return err;
+}
+
+/* This must be called with the super block already locked. */
+int unionfs_ioctl_delbranch(struct super_block *sb, unsigned long arg)
+{
+	struct dentry *hidden_dentry;
+	struct inode *hidden_inode;
+	struct vfsmount *hidden_mnt;
+	struct dentry *root_dentry;
+	struct inode *root_inode;
+	int err = 0;
+	int pmindex, i, gen;
+
+	print_entry("branch = %lu ", arg);
+	lock_dentry(sb->s_root);
+
+#ifdef UNIONFS_IMAP
+	if (stopd(sb)->usi_persistent) {
+		printk(KERN_ERR "Cannot manipulate branches if imap is used\n");
+		err = -EPERM;
+		goto out;
+	}
+#endif
+	err = -EBUSY;
+	if (sbmax(sb) == 1)
+		goto out;
+	err = -EINVAL;
+	if (arg < 0 || arg > stopd(sb)->b_end)
+		goto out;
+	err = -EBUSY;
+	if (branch_count(sb, arg))
+		goto out;
+	if ((err = newputmap(sb)))
+		goto out;
+
+	pmindex = stopd(sb)->usi_lastputmap;
+	pmindex -= stopd(sb)->usi_firstputmap;
+
+	atomic_inc(&stopd(sb)->usi_generation);
+	gen = atomic_read(&stopd(sb)->usi_generation);
+
+	root_dentry = sb->s_root;
+	root_inode = sb->s_root->d_inode;
+
+	hidden_dentry = dtohd_index(root_dentry, arg);
+	hidden_mnt = stohiddenmnt_index(sb, arg);
+	hidden_inode = itohi_index(root_inode, arg);
+
+	DPUT(hidden_dentry);
+	IPUT(hidden_inode);
+	mntput(hidden_mnt);
+
+	for (i = arg; i <= (sbend(sb) - 1); i++) {
+		set_branch_count(sb, i, branch_count(sb, i + 1));
+		set_stohiddenmnt_index(sb, i, stohiddenmnt_index(sb, i + 1));
+		set_stohs_index(sb, i, stohs_index(sb, i + 1));
+		set_branchperms(sb, i, branchperms(sb, i + 1));
+		set_dtohd_index(root_dentry, i,
+				dtohd_index(root_dentry, i + 1));
+		set_itohi_index(root_inode, i, itohi_index(root_inode, i + 1));
+		stopd(sb)->usi_putmaps[pmindex]->map[i + 1] = i;
+	}
+
+	set_dtohd_index(root_dentry, sbend(sb), NULL);
+	set_itohi_index(root_inode, sbend(sb), NULL);
+	set_stohiddenmnt_index(sb, sbend(sb), NULL);
+	set_stohs_index(sb, sbend(sb), NULL);
+
+	//XXX: Place check for inode maps and removal of branch here
+
+	stopd(sb)->b_end--;
+	set_dbend(root_dentry, dbend(root_dentry) - 1);
+	dtopd(root_dentry)->udi_bcount--;
+	itopd(root_inode)->b_end--;
+
+	atomic_set(&dtopd(root_dentry)->udi_generation, gen);
+	atomic_set(&itopd(root_inode)->uii_generation, gen);
+
+	fixputmaps(sb);
+
+	/* This doesn't open a file, so we might have to free the map here. */
+	if (atomic_read(&stopd(sb)->usi_putmaps[pmindex]->count) == 0) {
+		KFREE(stopd(sb)->usi_putmaps[pmindex]);
+		stopd(sb)->usi_putmaps[pmindex] = NULL;
+	}
+
+      out:
+	unlock_dentry(sb->s_root);
+	print_exit_status(err);
+
+	return err;
+}
+
+int unionfs_ioctl_rdwrbranch(struct inode *inode, unsigned int cmd,
+			     unsigned long arg)
+{
+	int err;
+	struct unionfs_rdwrbranch_args *rdwrargs = NULL;
+	int gen;
+
+	print_entry_location();
+
+	unionfs_write_lock(inode->i_sb);
+	lock_dentry(inode->i_sb->s_root);
+
+	if ((err = newputmap(inode->i_sb)))
+		goto out;
+
+	err = -ENOMEM;
+	rdwrargs = KMALLOC(sizeof(struct unionfs_rdwrbranch_args), GFP_KERNEL);
+	if (!rdwrargs)
+		goto out;
+
+	err = -EFAULT;
+	if (copy_from_user
+	    (rdwrargs, (const void __user *)arg,
+	     sizeof(struct unionfs_rdwrbranch_args)))
+		goto out;
+
+	err = -EINVAL;
+	if (rdwrargs->rwb_branch < 0
+	    || (rdwrargs->rwb_branch > (sbend(inode->i_sb) + 1)))
+		goto out;
+	if (rdwrargs->rwb_perms & ~(MAY_READ | MAY_WRITE | MAY_NFSRO))
+		goto out;
+	if (!(rdwrargs->rwb_perms & MAY_READ))
+		goto out;
+
+	set_branchperms(inode->i_sb, rdwrargs->rwb_branch, rdwrargs->rwb_perms);
+
+	atomic_inc(&stopd(inode->i_sb)->usi_generation);
+	gen = atomic_read(&stopd(inode->i_sb)->usi_generation);
+	atomic_set(&dtopd(inode->i_sb->s_root)->udi_generation, gen);
+	atomic_set(&itopd(inode->i_sb->s_root->d_inode)->uii_generation, gen);
+
+	err = 0;
+
+      out:
+	unlock_dentry(inode->i_sb->s_root);
+	unionfs_write_unlock(inode->i_sb);
+	KFREE(rdwrargs);
+
+	print_exit_status(err);
+
+	return err;
+}
+
+int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	int err = 0;
+	fd_set branchlist;
+
+	int bstart = 0, bend = 0, bindex = 0;
+	struct dentry *dentry, *hidden_dentry;
+
+	print_entry_location();
+
+	dentry = file->f_dentry;
+	lock_dentry(dentry);
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	FD_ZERO(&branchlist);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (hidden_dentry->d_inode)
+			FD_SET(bindex, &branchlist);
+	}
+
+	err = copy_to_user((void __user *)arg, &branchlist, sizeof(fd_set));
+	if (err) {
+		err = -EFAULT;
+		goto out;
+	}
+
+      out:
+	unlock_dentry(dentry);
+	err = err < 0 ? err : bend;
+	print_exit_status(err);
+	return (err);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/ChangeLog linux-2.6.20-sabayon-r1/fs/unionfs/ChangeLog
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/ChangeLog	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/ChangeLog	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,4092 @@
+2006-11-08  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h, stale_inode.c: Remove config.h include (depricated),
+	struct inode sliming patch fix (removed i_blksize)
+
+2006-11-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile, Makefile.kernel: Up the version to 1.5pre
+
+2006-11-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile, Makefile.kernel, NEWS: Unionfs 1.4
+
+2006-11-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* .cvsignore: ignore .sioq.o.cmd and Module.symvers
+
+2006-11-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_remount_fs): Removed unused variable
+
+2006-11-04 Yiannis Preicleous <yiannnos@gmail.com>
+
+	* super.c: allow remounting, print warning
+
+2006-10-31 Yiannis Pericleous <yiannnos@gmail.com>
+
+	* sioq.c, lookup.c, copyup.c, inode.c: Convert sioq to anonymous unions
+
+2006-10-30 Yiannis Pericleous <yiannnos@gmail.com>
+
+	* branchman.c: Prevent branch manipulations if imap used
+
+2006-10-10  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* copyup.c, inode.c: More fixes related to copyup of files >= 2GB 
+
+2006-10-10  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c: Sioq wasn't being properly initialized
+
+2006-10-10  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* copyup.c: Fixed copyup of files >= 2GB 
+
+2006-09-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* sioq.c: One function was missing a complete and another was not 
+	formatted properly.
+
+2006-09-21  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* ALL: Junjiro's sioq code with some minor modifications
+
+2006-08-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* super.c: Fixed compilation on 64-bit systems
+
+2006-08-05  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* ALL: Copyright header update (fixed my name - added 'Jeff', added
+	  Junjiro, super.c had 2 ezk lines) (a part of LKML-branch)
+
+2006-07-31  David P. Quigley  <dpquigl@fsl.cs.sunysb.edu>
+
+	* main.c: Fixed a printk statement.
+
+2006-07-31  David P. Quigley  <dpquigl@fsl.cs.sunysb.edu>
+
+	* main.c: Added a new mount option to specify the directory 
+	specifier for the dirs= section of the unionfs mount command
+	* man/unionfs.4: Added separator documentation
+
+2006-07-19  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* subr.c: Removed references to tasklist_lock since it will
+	be removed from 2.6.18 and is not needed.
+
+2006-07-13  Erez Zadok  <ezk@cs.sunysb.edu>
+
+	* INSTALL (UNIONFS_IMAP): rephrase.
+
+2006-07-07  David P. Quigley  <dpquigl@tycho.nsa.gov>
+
+	* Makefile: Cleanedup install and uninstall targets.
+
+2006-07-03  David P. Quigley  <dpquigl@tycho.nsa.gov>
+
+	* copyup.c (copyup_xattrs): removed LSM hooks in function. They
+	are not needed since the only time we access xattrs are with the
+	vfs_*xattr functions which already have the checks. In addition
+	replaced makeshift setxattr code with appropriate vfs_setxattr
+	call.
+
+2006-06-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/runtests.sh: Fixed inverted logic condition
+
+	* misc/runtests.sh: If build fails, provide an fallback option
+
+2006-06-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile, Makefile.kernel, commonfops.c, main.c, super.c,
+	unionfs.h: Updated to make 2.6.18-rc happy.
+
+2006-06-26  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* NEWS: Unionfs 1.3, copied over 1.1.5 release news
+
+	* Makefile, Makefile.kernel: Unionfs 1.3, supports 2.6.17 only
+
+2006-06-26  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* main.c, super.c, unionfs.h: use '#ifdef CONFIG_EXPORTFS'
+
+2006-06-22  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* persistent_inode.c: fix tiny bugs in __write_uin() and
+	  read_uin(), use __fread() in get_lin().
+	* super.c: new export functions. un-tested 64 bit environment
+	  (pointer and inode number).
+
+2006-06-14  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* man/uniondbg.8, man/unionimap.8: newline after .IP "-foo" to
+	make man happy
+
+2006-06-14  Gregory Haskins  <ghaskins@novell.com>
+
+	* Makefile, utils/Makefile, rpm/unionfs.spec: Updated RPM specfile,
+	fixed up Makefiles
+
+2006-06-11  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Fixed silly typo
+
+2006-06-10  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h (copy_inode_size): Removed copy_inode_size because it
+	was (1) ugly, and (2) unnecessary; the code can easily be in the two
+	functions that used it
+
+2006-06-09  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile: Up the version number
+
+	* README, NEWS: Sync with the 1.2 branch
+
+	* Makefile, Makefile.kernel, unionfs.h: Define supported version in
+	the Makefile; added kvers make target to display the supported
+	kernel version
+
+	* docs/OO-INDEX, docs/versions.txt: Document describing the new
+	versioning scheme
+
+2006-06-09  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* .cvsignore: ignore cscope.out
+
+2006-06-05  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile: fixed tarball target
+
+2006-06-02  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* docs/00-INDEX, docs/new_locking.txt: Proposed design for new locking
+	mechanism (work-in-progress)
+
+2006-06-01  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* branchman.c: Added comments
+	* commonfops.c: Added comments
+	* docs/locks.txt: Beginnings of a comprehensive file on lock placement
+	in unionfs
+
+2006-06-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* super.c: Remove reference to split-view caches
+
+	* unionfs_debug.h: Small touch ups
+
+2006-06-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs_debug.h: Finished debuging code (print entry/exit)
+
+2006-06-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/runtests.sh: Nicified the output of the script
+
+2006-06-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/runtests.sh: Little cleanup
+
+2006-06-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/nightly-build.sh, misc/runtests.sh: Move unionfs build to after
+	reboot; added code to do test builds with different EXTRACFLAGS
+
+2006-05-31  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* docs/debug.c, docs/debug.txt: Wrong file extension
+
+2006-05-31  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* .cvsignore: ignore vi/vim swap files
+
+	* match-dget.pl, match-iget.pl, match-malloc.pl, misc/match-dget.pl,
+	misc/match-iget.pl, misc/match-malloc.pl: Moved debug scripts to misc/
+
+
+2006-05-31  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* INSTALL, Makefile.kernel, commonfops.c, copyup.c, dentry.c,
+	dirfops.c, file.c, inode.c, lookup.c, main.c, print.c, rdstate.c,
+	rename.c, subr.c, super.c, unionfs.h, unionfs_debug.h,
+	unionfs_macros.h, unlink.c, xattr.c: Simplified & cleaned up debugging
+	support
+
+2006-05-31  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* .cvsignore, utils/.cvsignore: updated ignore files
+
+2006-05-30  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* utils/Makefile: Removed some variable declarations
+	* Makefile: Passed variables down to lower file
+
+2006-05-30  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* utils/: Moved all user mode programs into this directory
+	* usils/Makefile: New Makefile for this directory
+	* Makefile: Changed file to call utils/Makefile for user mode program
+	related operations.
+
+2006-05-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs_macros.h (stohs{,_index}, ftohf{,_index}, itohi{,_index}):
+	make objects passed const - make GCC 4.0 happy
+
+2006-05-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* man/unionctl.2: Branch deletion and file querying
+
+2006-05-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h, unionfs_imap.h, unionfs_macros.h, unionfs_debugmacros.h:
+	simplified the macro files
+
+	* unlink.c, rdstate.c: minor cleanup
+
+2006-05-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* mmap.c (sync_page, unionfs_sync_page): Merged the two functions,
+	since (1) sync_page might be confused with kernel's own sync_page,
+	and (2) our sync_page did not do much beside an if and a function call
+
+2006-05-30  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* regression/rename-501.sh: remove obsoleted debug lines.
+
+2006-05-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* man/unionctl.2: About 70% of the manpage. Still need to describe
+	branch deletion, and file querying.
+
+2006-05-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* inode.c (inode_permission): Ignore EROFS returned by all but the
+	first branch
+
+2006-05-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* inode.c, rename.c, subr.c, unionfs.h: Several rename fixes by
+	Junjiro to comply with the newly established rename semantics (see
+	docs/rename.txt); includes new make_dir_opaque() function
+
+2006-05-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* docs/rename.txt: Enumerated thought all the possible cases of
+	logically/physicaly empty to logically/physicaly empty directories
+
+2006-05-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* docs/rename.txt: Rename "matrix" documented
+
+2006-05-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* copyup.c (copyup_named_dentry): Removed several hard-coded values
+
+	* main.c: same as above
+
+	* mmap.c (unionfs_do_readpage): same as above
+
+	* print.c (fist_print_inode, fist_print_file, __fist_print_dentry):
+	same as above
+
+	* unionimap.c (create_forwardmap, check_if_entry_exists,
+	print_forwardmap): same as above
+
+	* misc/runtests.sh: build torture tests before running them
+
+2006-05-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Bail out if KERNEL_VERSION is less than 2.6.17
+	(EXTRAVERSION happens to be conveniently ignored)
+
+2006-05-24  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/nightly-build.sh: Make /cvs/cvsupdate after we have
+	successfully updated and re-exec-ed the script
+
+2006-05-24  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* misc/nightly-build.sh: Make kernel build on 2 CPUs
+
+2006-05-24  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* rename.c: add new function may_rename_dir() to check the rename src
+	  dir is empty or not. After rename succeeds, decrement its generation
+	  in order to force lookup at next time.
+	* regression/rename-501.sh: add test patterns.
+
+2006-05-23  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_mkdir): __dir_opaque whiteouts' creation mode
+	should not be hardcoded to an octal value
+
+	* mmap.c (unionfs_sync_page): Removed leftover line of code
+
+2006-05-22  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* regression/lookout-opaque.sh: added option to useradd so that userdelete will work
+	* regression/unlink-whiteout.sh: removed bin prefix from touch and
+	unlink
+
+2006-05-20  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* rename.c: fold too long line.
+	* subr.c: remove unused create_whiteout_parent() which was disabled by
+	  '#if 0 ... #endif'
+	* unionfs.h: remove the declaration of the unused function
+
+2006-05-19  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* regression/rename-501.sh: test for Bug #501
+	* rename.c (do_rename, unionfs_rename_whiteout, __rename_all,
+	  __rename_all_revert, __rename_all_clobber, unionfs_rename_all):
+	  create the whiteout for rename_src under the old parent dir.
+	* subr.c (create_whiteout_parent): remove create_whiteout_parent()
+	  temporary.
+
+2006-05-17  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* mmap.c (unionfs_commit_write, unionfs_copy_block): Removed incorrect
+	comment, removed completely useless function (unionfs_copy_block)
+
+2006-05-17  Shaya Potter <spotter@cs.columbia.edu>
+
+	* mmap.c (unionfs_commit_write): Shaya's commit_write fix
+
+2006-05-17  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* mmap.c (sync_page, unionfs_sync_page): Compiles with
+	2.6.17-rc3-git18
+
+2006-05-03  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* subr.c (superio_store): Fixed bizarre printk format
+
+2006-04-23  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_parse_options, parse_dirs_option): Fixed refcounting
+	leak (if a branch dir doesn't exist during mount, the previously
+	lookedup branches were not freed properly)
+
+2006-04-17  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* unlink.c (unionfs_unlink_whiteout): Fixed link-unlink issue (i_nlink
+	going to 0)
+
+2006-04-14  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* BUGS, man/unionfs.4: Added warning of dire consequences (Bug #256)
+
+	* README: Mention latest 2.6 kernel only
+
+2006-04-11  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* file.c (__unionfs_read, unionfs_read): Fixed mtime being incorrectly
+	updated on access
+
+2006-03-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c (parse_dirs_option): On error, NULL the pointers after free
+
+2006-03-22  Tomas Matejicek  <tomas@linux-live.org>
+
+	* INSTALL: Little updates and corrections
+
+2006-03-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c, super.c, main.c, unionfs.h: removed references to
+	COPYUP_CURRENT_USER and copyup mount option since we only have one
+	copyup mode now.
+
+2006-03-21  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* commonfops.c, dirfops.c, inode.c, main.c, stale_inode.c: Remove old
+	checks for kernel version - it's always going to be the latest only
+
+2006-03-11  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* .cvsignore: Ignore generated files *.o.cmd (mmap and malloc)
+
+2006-03-08  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* copyup.c (copyup_xattr): Fixed xattr "not supported" check
+
+2006-03-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* misc/preprocess.pl: added UNIONFS_MMAP to list of symbols.
+
+2006-03-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* file.c: forgot to put an ifndef around __do_mmap
+	* mmap.c: forgot to add this file to cvs
+
+2006-03-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* file.c (__unionfs_read, __unionfs_write): code that was removed
+	by Shaya's patch which we fall back on if the person chooses not to
+	compile with UNIONFS_MMAP
+	* copyup.c, file.c, inode.c, main.c, super.c: Ifdefed around Shaya's
+	code and extracted some code to support not using UNIONFS_MMAP
+	* Makefile: added mmap.c
+	* INSTALL: added comment for UNIONFS_MMAP
+	* Note this code hasn't been fully tested yet and is considered highly
+	experimental.
+
+2006-03-05  Shaya Potter <spotter@cs.columbia.edu>
+
+	* copyup.c, file.c, inode.c, main.c, super.c: Implemented true mmap
+
+2006-03-04  Ed Swierk  <eswierk@gmail.com>
+
+	* Makefile: Install the unionimap man page along with all the other
+	man pages
+
+2006-03-04  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* inode.c (unionfs_permission): Fixed unionfs_permission on reiserfs
+	and xfs
+
+2006-03-04  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* main.c (unionfs_interpose): Fixed bug - when the target entry is
+	hard-linked, the unionfs inode will be broken
+
+2006-03-03  Bill Nottingham <notting@redhat.com>
+
+	* unionfs.h: added extern for temp vfs_listxattr function
+	* copyup.c: removed old style listxattr code and replaced
+	it with vfs_listxattr
+	* xattr.c: removed locks from all xattr functions since kernel
+	documentation says that getxattr and listxattr don't require
+	a lock and since vfs_setxattr and vfs_removexattr take the
+	mutex on the inode we get a deadlock if we lock the inode
+	before hand.
+
+2006-02-21  Jan Engelhardt  <jengelh@linux01.gwdg.de>
+
+	* ALL: Make unionfs work with the new mutex subsystem
+
+2006-02-21  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* dirhelper.c (delete_whiteouts): Use superio_*; small cleanup
+
+	* lookup.c (is_opaque_dir): Use superio_*
+
+	* subr.c (superio_store, superio_revert): Added superio_store and
+	superio_revert
+
+	* unionfs.h: Added struct superio
+
+	* unlink.c (unionfs_rmdir_all): Check return value of delete_whiteouts
+
+2006-02-20  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Increment version number require 2.6.16.
+
+	* Makefile: Increment version number.
+	* INSTALL, NEWS: Add new define options.
+
+2006-02-20  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* man/unionfs.4: removed all references to copyup mount option.
+
+2006-02-20  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* main.c, rename.c, unionfs.h, super.c, unlink.c: Moved
+	DELETE_WHITEOUT to the default mode for delete and wrapped all
+	DELETE_ALL code in ifdefs.
+	* unlink.c (unionfs_unlink_whitout): Rewrote this function to use
+	unlink/create instead of the atomic rename operation we used before.
+	* misc/preprocess.pl: added entry for UNIONFS_DELETE_ALL ifdef.
+
+2006-02-15  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_read_super, unionfs_d_alloc_root): Created a "fake"
+	d_alloc_root
+
+2006-02-15  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs_debugmacros.h: Cleanup; removed unused __FILE__, etc.
+	parameters from inline functions; removed unnecessary macro wrappers
+
+	* commonfops.c (unionfs_file_revalidate, unionfs_open): C99 doesn't
+	allow mixing of code and variable declarations
+
+2006-02-13  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c, unionfs.h: Use simpler cpp directives.
+	* misc/preprocess.pl: Simple preprocessor for stripping #ifdefs and
+	KERNEL_VERSION defines.
+
+2006-02-12  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* branchman.c, commonfops.c, dentry.c, lookup.c, main.c,
+	persistent_inode.c, super.c, unionfs.h, unionfs_debugmacros.h:
+	Removed inline objects from unionfs_inode_info, unionfs_dentry_info,
+	unionfs_sb_info, and unionfs_file_info
+
+	* unionfs_macros.h: Removed inline objects from unionfs_inode_info,
+	unionfs_dentry_info, unionfs_sb_info, and unionfs_file_info; Replaced
+	many macros by inline functions
+
+2006-02-10  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* dentry.c (unionfs_d_revalidate): Merges two auto variables 'err' and
+	'invalid'. And also checks the return value of unionfs_lookup_backend
+	correctly. It solves the stale inode problem of regression/bug418.sh
+
+	* lookup.c (unionfs_partial_lookup): Same as above
+
+2006-02-09  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h: reverted change
+
+2006-02-09  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_show_options): removed reference to mounter.
+
+	* unionfs.h: removed reference to mounter.
+
+2006-02-08  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* dirhelper.c (delete_whiteouts): Use WHLEN instead of 4
+
+	* persisten_inode.c (__fread, __fwrite): Make sparse happy
+
+	* unionfs.h, unionfs_debugmarcros.h (__dtopd): Misc cleanups
+
+2006-02-08  Konstantin Olchanski  <olchansk@triumf.ca>
+
+	* inode.c (inode_permission): nameidata can be null, add checks for it
+
+2006-02-08  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c (copyup_permissions): Removed code referencing the
+	copyup=mounter option.
+	* main.c (unionfs_parse_options): same as above
+	* unionfs.h (unionfs_sb_info): same as above.
+
+2006-02-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* INSTALL: Added fistdev.mk description for UNIONFS_IMAP.
+
+2006-02-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c (copyup_named_dentry,create_parent_named): ifdefed
+	persistent inode code.
+	* dirfops.c (unionfs_filldir): Same as first.
+	* main.c (unionfs_parse_options): Same as first.
+	* persistent_inode.c: ifdefed out entire file.
+	* super.c (unionfs_put_super): Same as two lines up.
+	* unionfs.h: ifdefed persistent inode variables from unionfs_sb_info
+	and the externed functions.
+
+
+2006-02-05  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* copyup.c (copyup_named_dentry): Any error, not only ENOSPC/EDQUOT,
+	should unlink the partial copyup
+
+	* ChangeLog: Clarified the meaning of a changelog entry
+
+2006-02-05  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c (parse_dirs_option): Added a check for people attempting to
+	make the left most branch read-only
+
+2006-02-05  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* copyup.c (copyup_named_dentry): If the copyup failed because of
+	quota or lack of disk space, unlink the partial copyup
+
+	* rename.c (unionfs_rename_all, unionfs_rename_whiteout): Fixed rename
+	which was copying up to all rw branches to the left of the source
+
+2006-02-05  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c: we shouldn't be using such a complex open
+	statement when the creat function is exactly what we are doing
+	with open
+
+2006-02-05  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* dirfops.c (unionfs_filldir): With current get_uin() is hard to
+	distinguish the error from success. Writing persistent ino files
+	may meet the file size limit. Now, users should be careful about
+	filesystem quota.
+
+	* main.c (unionfs_interpose): See above
+
+	* persistent_inode.c (__fread, __fwrite, parse_imap_option, __get_uid,
+	__read_uin, __write_uin, get_uin, read_uin): See above
+
+	* unionfs.h: See above
+
+2006-02-05  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c: Modified open statements to create the files
+	with u+wr instead of u+wrx
+
+2006-02-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* README: Remove reference to 2.4 as we don't support it anymore
+
+2006-02-04  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* debug_malloc.c: Moved all malloc debugging functions to this file.
+
+	* Makefile: added debug_malloc.o to object list.
+
+	* persistent_inode.c (remove_map): removed a decrement that wasent
+	needed.
+
+2006-02-04  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_create): Fixed uid/gid/mode not being reset when
+	file is created by renaming a whiteout
+
+2006-02-02  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* inode.c (unionfs_create): Fixed minor bug regarding stale atime and
+	mtime
+
+2006-02-01  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Removed usi_fsnum_table since its not used and makes
+	no sense to have.
+
+	* persistent_inode.c: Removed usi_fsnum_table code. Added remove_map
+
+	* unionimap.c: Fixed code that prints forward maps since it was always
+	printing 0 for the inode number.
+
+2006-01-31  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* dentry.c (unionfs_d_revalidate): Get the hidden inode, not the
+	hidden dentry's inode; fixes "pseudo hardlink" via persistent inode
+
+2006-01-25  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile, Makefile.kernel: Incremented version
+
+	* NEWS, Makefile, Makefile.kernel: Version 1.1.2
+
+2006-01-25  Amnon Aaronsohn  <bla@cs.huji.ac.il>
+
+	* patch-kernel.sh: Fixed patch-kernel.sh error msg
+
+2006-01-24  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* subr.c (create_whiteout_parent): Hidden inode is not iput() since
+	ibstart and ibend is not updated.
+
+2006-01-22  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* copyup.c (copyup_named_dentry, create_parents_named): Fixed
+	persistant inode code: link, rmdir, shrinking of dcache, map validation
+
+	* main.c (copyup_xattrs): Fixed persistant inode code: link, rmdir,
+	shrinking of dcache, map validation
+
+	* persistent_inode.c (__fread, __fread, verify_forwardmap,
+	verify_reversemap, init_imap_data, parse_imap_option, __get_uin,
+	__write_uin, get_uin, write_uin): Fixed persistant inode code: link,
+	rmdir, shrinking of dcache, map validation
+
+	* unionfs.h: Fixed persistant inode code: link, rmdir, shrinking of
+	dcache, map validation
+
+2006-01-20  Martin Kreiner  <m.kreiner@levigo.de>
+
+	* BUGS, INSTALL, man/unionctl.8, man/unionfs.4: Documentation update
+
+	* branchman.c (unionfs_ioctl_addbranch, unionfs_ioctl_rdwrbranch):
+	Per branch nfsro option
+
+	* inode.c (inode_permission): Per branch nfsro option
+
+	* main.c (parse_dirs_option, unionfs_parse_options): Per branch nfsro
+	option
+
+	* super.c (unionfs_show_options): Per branch nfsro option
+
+	* unionctl.c (__usage, parse_rw, parse_options, dump_branches, main):
+	Per branch nfsro option
+
+	* unionfs.h: Per branch nfsro option
+
+2006-01-20  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_addbranch, unionfs_ioctl_delbranch):
+	Inode refcount debugging tool calls
+
+	* copyup.c (create_parents_named):Inode refcount debugging tool calls
+
+	* dentry.c (unionfs_d_revalidate, unionfs_d_iput):Inode refcount
+	debugging tool calls
+
+	* inode.c (unionfs_link): Inode refcount debugging tool calls
+
+	* main.c (unionfs_interpose, unionfs_reinterpose, unionfs_igrab,
+	unionfs_iput, unionfs_iget): Inode refcount debugging helper code;
+	Fixed init of atomic_t
+
+	* subr.c (create_whiteout_parent, unionfs_refresh_hidden_dentry):
+	Inode refcount debugging tool calls
+
+	* super.c (unionfs_clear_inode): Inode refcount debugging tool calls
+
+	* unionfs.h: Definitions for IGET, IGRAB, and IPUT
+
+	* match-iget.pl: Inode refcount debugging code output "matcher"
+
+2006-01-17  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c, unionfs.h: Added #if'd kzalloc for kernels older than 2.6.14
+
+2006-01-14  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* branchman.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+	* commonfops.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+	* copyup.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+	* main.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+	* persistent_inode.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+	* super.c: Replaced pairs of KMALLOC and memset calls to
+	KZALLOC calls.
+
+
+2006-01-14  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Fixed unionfs_kmalloc prototype
+
+	* main.c (unionfs_kzalloc, unionfs_kmalloc): Use kzalloc, not
+	the non-existent kzmalloc
+
+2006-01-14  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* AUTHORS: added entry for Peeka J. Enberg
+
+2006-01-14  Peeka J. Enberg  <penberg@cs.helsinki.fi>
+
+	* ALL: Changed all use of GFP_UNIONFS to GFP_KERNEL
+
+	* unionfs.h: Removed definition for GFP_UNIONFS
+
+2006-01-14  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h : Included defines for KZMALLOC and extern for
+	unionfs_kzalloc. NOTE: This change makes the minimum kernel
+	version for unionfs 2.6.14.
+
+	* main.c (unionfs_kmalloc): Changed prototype to use the
+	actual type of GFP_KERNEL instead of int and removed a
+	(void *) since the kernel coding conventions say that this
+	is not necessary.
+
+	* main.c (unionfs_kzalloc): New wrapper function to track
+	kzallocs when debugging.
+
+2006-01-13  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* BUGS, INSTALL: Removed all references to NFS_SECURITY_HOLE
+
+2006-01-13  Martin Kreiner  <m.kreiner@levigo.de>
+
+	* inode.c (inode_permission): Introduce nfsperms mount option and
+	remove NFS_SECURITY_HOLE
+
+	* main.c (unionfs_dentry_info): Introduce nfsperms mount option and
+	remove NFS_SECURITY_HOLE
+
+	* super.c (unionfs_show_options): Introduce nfsperms mount option and
+	remove NFS_SECURITY_HOLE
+
+	* unionfs.h:Introduce nfsperms mount option and
+	remove NFS_SECURITY_HOLE
+
+2006-01-12  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* fist.h: Code moved to unionfs.h, unionfs_macros.h, and
+	unionfs_debugmacros.h
+
+	* ALL, misc/*.c: Removed all references to fist.h
+
+2006-01-09  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (__rename_all{,_unlink,_revert,_clobber}): Make functions
+	static
+
+2006-01-08  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (unionfs_rename_all,lookup_whiteout): Split up the
+	nearly 300 line unionfs_rename_all function into several more
+	understandable "double underscore" functions; removed get_whname
+	it used __getname which allocates a whole page, updated
+	lookup_whiteout to use alloc_whname instead
+
+	* lookup.c (unionfs_lookup_backend): Use this should be the last
+	alloc_whname patch
+
+2006-01-07  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* file.c: Use unlocked_ioctl iff the kernel is 2.6.11 or newer
+	(unionfs_main_fops)
+
+	* dirfops.c: Use unlocked_ioctl iff the kernel is 2.6.11 or newer
+	(for unonfs_dir_fops)
+
+	* commonfops.c (unionfs_ioctl): Use unlocked_ioctl iff the kernel
+	is 2.6.11 or newer, the prototype for unionfs_ioctl is also different
+	on 2.6.11 or newer
+
+	* inode.c (inode_permission): If kernel is older than 2.6.10, use
+	vfs_permission otherwise generic_permission
+
+2006-01-03  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* ChangeLog : fixed two gramatical errors in the changelog.
+
+2006-01-03  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Added a define for the first valid inode number so we
+	aren't using magic numbers in the persistent inode code.
+
+	* super.c: added a call to cleanup_imap_data to properly free
+	resources on unmount.
+
+	* persistent_inode.c: (imap_parse_options): cleanedup code,
+	(init_imap_data): new function (cleanup_imap_data): new
+	function.
+
+	* unionimap.c : cleaned up some brackets from single line if
+	statements.
+
+2006-01-03  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Renamed make_whname to alloc_whname, use strlcat instead
+	of strncat (the strcpy is safe since WHPFX will always be NULL
+	terminated), the NULL termination is dony by strlcat
+
+	* inode.c (unionfs_create, unionfs_link, unionfs_symlink,
+	unionfs_mkdir, unionfs_mknod): Renamed make_whname to alloc_whname
+
+	* rename.c (do_rename): Renamed make_whname to alloc_whname
+
+	* subr.c (create_whiteout, create_whiteout_parent): Renamed
+	make_whname to alloc_whname
+
+	* unlink.c (unionfs_unlink_whiteout): Renamed make_whname to
+	alloc_whname
+
+2006-01-03  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_branchcount, unionfs_ioctl_addbranch,
+	unionfs_ioctl_rdwrbranch, unionfs_ioctl_queryfile): Make sparse happy
+
+	* commonfops.c (unionfs_ioctl): Make sparse happy
+
+	* copyup.c (copyup_named_dentry): Make sparse happy
+
+	* file.c (unionfs_read, unionfs_write): Make sparse happy
+
+	* inode.c (unionfs_readlink, unionfs_follow_link): Make sparse happy
+
+	* main.c (unionfs_read_super): Make sparse happy
+
+	* persistent_inode.c (verify_forwardmap, verify_reversemap, get_uin,
+	get_lin): Make sparse happy
+
+2006-01-02  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* unionfs.h: added make_whname to replace scattered and duplicate
+	code that allocates memory, copies into it WHPFX and the rest of
+	the filename
+
+	* inode.c (unionfs_create, unionfs_link, unionfs_symlink,
+	unionfs_mkdir, unionfs_mknod): Use make_whname instead of manually
+	allocating, and copying data
+
+	* rename.c (do_rename): Use make_whname instead of manually
+	allocating, and copying data
+
+	* subr.c (create_whiteout, create_whiteout_parent): Use make_whname
+	instead of manually allocating, and copying data
+
+	* unlink.c (unionfs_unlink_whiteout): Use make_whname instead of
+	manually allocating, and copying data
+
+2006-01-02  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* ALL: Copyright year updated
+
+	* man/*: Date updated
+
+	* misc/split-views-2.4.26.patch: removed because 2.4 is not supported
+
+2006-01-01  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (do_rename): use WHLEN+1 instead of 5
+
+2005-12-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (do_rename): Added two missing DPUT()s
+
+	* subr.c (create_whiteout_parent): use LOOKUP_ONE_LEN instead of
+	lookup_one_len
+
+2005-12-29  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* commonfops.c, copyup.c, main.c, print.c, super.c: converted FISTBUG
+	commands to printk and BUG pairs.
+	* fist.h: removed definition for FISTBUG
+
+2005-12-29  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend): Use WHLEN+1 instead of 5
+
+	* unionfs_debugmacros.h (__ftohf_index, __set_ftohf_index, __set_itohi_index,
+	__set_dbend, __set_dbstart, __set_dbopaque, __dtohd_index): BUG_ON with a more
+	complex condition is more optimal than "if(partial_condition) BUG_ON(...);"
+
+2005-12-29  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* lookup.c (unionfs_lookup_backend): DPUT() when done with the dentry
+	not before, added missing DPUT()
+
+2005-12-28  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* AUTHORS: Some maintenance dates.
+
+2005-12-28  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* AUTHORS: updated to reflect the patches commited in the last two days
+
+2005-12-28  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* lookup.c (unionfs_lookup_backend): Fixed missing DPUT()s
+
+2005-12-28  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* lookup.c: change the process's privilege temporally when
+	creating/searching/deleting the whiteouts (in is_opaque_dir,) and
+	forgot DPUT() after failing is_opaque_dir() (in unionfs_lookup_backend)
+
+2005-12-27  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* subr.c (create_whiteout): create whiteout bug, forgotten dput()
+
+2005-12-27  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* unlink.c (unionfs_unlink_whiteout): unlink bug, forgotten dput()s
+
+2005-12-27  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* inode.c (unionfs_create): create bug, forgotten dput(), extra GET_PARENT
+
+2005-12-27  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* lookup.c (new_dentry_private_data): Use GFP_ATOMIC instead
+	of GFP_UNIONFS (which currently is same as GFP_KERNEL) to prevent
+	sleeping while atomic bug
+
+2005-12-27  Junjiro Okajima  <hooanon05@yahoo.co.jp>
+
+	* inode.c (unionfs_permission): permission bug, creat/open truncates
+	the running executable
+
+2005-12-27  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionctl.c : Fixed check to see if a branch was already in the union and
+	fixed --before and --after logic.
+
+	* regression/branchman.sh: BUG370 will not work anymore due to code to avoid
+	duplicate branches being added. Need to reevaluate if it should be kept
+	anymore.
+
+2005-12-27  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* *.[ch]: Went through every file and replaced ASSERT and ASSERT2 with
+	BUG_ON calls. The logic for BUG_ON is the opposite of ASSERT but I believe
+	they are all converted properly.
+
+	* fist.h: Removed definitions for ASSERT and ASSERT2
+
+2005-12-27  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* *.[ch]: Went through every file and removed PASSERT and PASSERT2
+	statments. If there was an if that inclosed it then that was removed
+	also.
+
+	* fist.h: Removed definitions for PASSERT and PASSERT2.
+
+2005-12-27  Junjiro Okajima <hooanon05@yahoo.co.jp>
+
+	* copyup.c (copyup_permissions): Properly copyup atime, mtime, and
+	ctime.
+
+2005-12-27  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_lookup): Bugfix for bug #451 is not valid,
+	change reverted
+
+2005-12-20  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* lookup.c (new_dentry_private_data): Use SLAB_ATOMIC instead
+	of SLAB_KERNEL (prevent sleeping while atomic bug)
+
+2005-11-30  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* main.c: Updated module info (now includes unionfs version
+	 number)
+
+2005-11-29  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* branchman.c: Added check for addition of branches with
+	 overlapping paths. Fixes rest of Bug #374.
+
+2005-11-29  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unionctl.c: Fixed branch addition with just branch (and
+	  neither mode nor before/after specified.
+
+2005-11-29  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Fix Coverity flagged errors.
+
+2005-11-29  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* main.c : Corrected a boundary case, so that one cannot
+	 use "/" as a branch if /ro is a branch.
+
+2005-11-28  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* main.c : Ensure that the branches getting added during a
+	 mount operation do not have overlapping branch paths. This
+	 is part of Bug #374.
+
+2005-11-28  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* inode.c: unionfs_lookup was not incrementing the reference
+	 count of the dentry. this was causing the chmod bug. added
+	 this, and fixed bug #451
+
+2005-11-26  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unlink.c: Updated unionfs_unlink_whiteout to fix bug #434
+
+2005-11-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* print.c: Remove unused function.
+
+	* Makefile: Don't duplicate source list.
+
+2005-11-23  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionimap.c: Fix unchecked malloc.
+
+	* usercommon.c: Fix double free.
+
+2005-11-20  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* global : Changes made for "sparse"
+
+2005-11-18  Josef "Jeff" Sipek <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (get_whname): Make constant's type clearer
+
+2005-11-18  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unionctl.c : Changes made for "sparse"
+
+2005-11-18  Josef "Jeff" Sipek <jsipek@fsl.cs.sunysb.edu>
+
+	* rename.c (get_whname): Add NULL termination.
+
+2005-11-18  Shaya Potter <spotter@cs.columbia.edu>
+
+	* rename.c (lookup_whiteout): Add NULL Check.
+
+2005-11-18  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Remove UNIONFS_XATTR define, because 2.6 has consistent prototypes.
+
+2005-11-16  Martin Walter  <mawa@uni-freiburg.de>
+
+	* inode.c: Fix IS_NFS.
+
+2005-11-15  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c: Allow debug= to be passed to the Unionfs module.
+
+2005-11-11  Allessio Curri <alessio.curri@elettra.trieste.it>
+
+	* rpm/unionfs.spec: Update RPM spec file to include unionimap.
+
+2005-11-09  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* commonfops.c (unionfs_open): Slightly rework reader/writer locks.
+
+2005-10-24  Shaya Potter <spotter@cs.columbia.edu>
+
+	* Fix scope of readers/writer locks on branch configuration.
+
+2005-11-09  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unlink.c: Add comment w/ Junjiro's rmdir fix.
+
+2005-09-26  Junjiro Okajima <hooanon05@yahoo.co.jp>
+
+	* dentry.c (unionfs_d_revalidate): Don't copy attributes to nonexistent
+	inodes.
+
+	* lookup.c (new_dentry_private_data): Fix a race b/t lookup and d_free.
+
+2005-11-08  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: use /lib/modules/`uname -r`/kernel/fs/unionfs/unionfs.ko
+	to be consistent with other file systems.
+
+	* patch-kernel.sh: Add more double-patching checks.
+
+	* Use WHPFX and WHLEN instead of ".wh." and 4.
+
+	* dirhelper.c (delete_whiteouts): Remove useless partial lookup.
+	* unlink (unionfs_rmdir_all): Remove useless partial lookup.
+
+	* subr.c (create_whiteout): Silently succeed if the whiteout already
+	exists.
+	* inode.c (unionfs_unlink_all): Fix some coding style.
+
+2005-11-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionctl.c (parse_options): Added a check in to see if a branch
+	already exists in the union and if it does the operation fails.
+
+2005-11-07  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* dentry.c (dentry_revalidate): Remove extra d_deleted check.
+	* commonfops.c (unionfs_open): Undo add debug print of opened dentry.
+
+	* commonfops.c (unionfs_open): Add debug print of opened dentry.
+
+2005-10-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (inode_permission): Fix typo in NFS_SECURITY_HOLE.
+
+2005-11-06  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* fist.h (lock_parent, unlock_dir): moved from now non-existent
+	missing_vfs_funcs.h
+	* inode.c (unionfs_create): use {,un}lock_rename instead of
+	double_{,un}lock
+	* rename.c (do_rename): use {,un}lock_rename instead of double_{,un}lock
+	* unlink.c (unionfs_unlink_whiteout): use {,un}lock_rename instead of
+	double_{,un}lock
+	* missing_vfs_funcs.h: removed
+
+2005-10-25  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Increment version to 1.1.2pre.
+	* regression/readdir.sh: readdir regression script.
+	It doesn't reproduce the bug for us, but extra tests can't hurt.
+
+	* dirfops.c (unionfs_readdir): Properly update uds_dirpos,
+	which fixes directory reading operations.
+
+2005-10-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* compat.[ch]: Remove old files.
+
+2005-10-24  Shaya Potter <spotter@cs.columbia.edu>
+
+	* copyup.c (copyup_file): Don't fput errors.
+	* copyup.c, unionfs.h: Use loff_t for copyup size.
+
+	* copyup.c (copyup_named_dentry): Code cleanup.
+
+2005-10-21  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* AUTHORS: Update AUTHORS.
+
+2005-10-21  Charles Duffy  <cduffy@spamcop.net>
+
+	* xattr.c: Use ssize_t for xattr functions.
+
+2005-10-20  Shaya Potter <spotter@cs.columbia.edu>
+
+	* dirhelper.c (check_empty): Respect opaqueness.
+
+	* Replace lock_super around branch management operations with a
+	Unionfs read/write semaphore.  This will allow branchput/branchget
+	to operate concurrently, but prevent them from racing against
+	branchman operations.
+
+2005-10-19  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_permission): Don't call normal permission before
+	inode_permission (our modified version of permission), because it
+	just duplicates work.
+
+	* commonfops.c (branchput_gen): Lock the super when we read putmaps.
+
+	* inode.c (inode_permission): If NFS_SECURITY_HOLE is defined
+	treat -EACCESS as if we should fall back on inode_permission.
+
+	* branchman.c (unionfs_ioctl_rdwrbranch): Make super/dentry
+	lock/unlock symmetric.
+
+2005-10-18  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* NEWS: Updates NEWS file for release
+
+2005-10-14  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* rename.c : Used the create_whiteout_parent function to
+	create the whiteout in unionfs_rename_all.
+	* subr.c : Brought the create_whiteout_parent back. These
+	squash Bug #442.
+
+2005-10-13  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* rename.c : Fixed rest of Bug #425. Applied the patch
+	sent in by Junjiro Okajima.
+
+2005-10-13  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* rmdir-all.sh: added test for bug 430. Not sure if
+	we are going to patch it yet but if we do the test
+	is there.
+	* regression/Makefile: added rmdircheckinode.c
+	* regression/progs/rmdircheckinode.c: program to check
+	if the inode numbers match after a failed rmdir.
+
+2005-10-13  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* rename.c (unionfs_rename) : Fixed bug #425. The new_dentry
+	affects the unlink called by "mv" after the rename has failed.
+	It makes unlink return with -EISDIR. (partial fix)
+
+2005-10-11  Shaya Potter <spotter@cs.columbia.edu>
+
+	* dentry.c (unionfs_d_revalidate): Fix a deadlock.
+
+2005-10-06  Robert Glowczynski  <roglo@op.pl>
+
+	* file.c (unionfs_fsync): Fix check for NULL lower-level operation.
+
+2005-09-29  Patrik Weiskircher
+
+	* Makefile.kernel: Remove reference to locks.c.
+
+2005-09-28  Junjiro Okajima <hooanon05@yahoo.co.jp>
+
+	* unlink.c (unionfs_rmdir_all): Always create whiteouts on directory
+	removal.
+
+2005-09-28  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* commonfops.c (unionfs_file_revalidate): Properly update
+	generation when we combine copyup and reopening.
+	* Makefile: Remove some 2.4 cruft.
+
+2005-09-27  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_incgen): Fix print indentation bug.
+
+	* unionimap.c: AMD64 fix from Gentoo.
+
+2005-09-27  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* inode.c: Made change to use both inode_permissions and
+	permissions.
+
+2005-09-27  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: Document MODDIR.
+
+2005-09-23  Klaus Knopper  <unionfs@knopper.net>
+
+	* inode.c: added inode_permissions to check for permissions
+	on a file even if its on an ROFS and used it in
+	unionfs_permissions
+
+2005-09-22  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* Makefile: remove 'tags' target dependency from 'all'
+
+2005-09-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* Makefile: forgot to remove locks.c from source list
+
+2005-09-21  Junjiro Okajima <hooanon05@yahoo.co.jp>
+
+	* inode.c: Fixed several off-by-one kmalloc bugs.
+
+2005-09-20  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* removed locking code from codebase since we no longer
+	handle locking (vfs will do it)
+
+2005-09-18  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* removed 2.4 code from fist.h, inode.c, lookup.c,
+	persistent_inode.c, rdstate.c
+
+2005-09-18  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* removed 2.4 code from copyup.c, dentry.c, dirfops.c
+	and file.c
+
+2005-09-18  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* removed 2.4 code from stale_inode.c, subr.c, unionfs.h,
+	unlink.c, xattr.c
+
+2005-09-17  Josef "Jeff" Sipek  <jsipek@fsl.cs.sunysb.edu>
+
+	* removed 2.4 code from main.c, print.c, super.c,
+	xattr.c
+
+2005-09-17  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* removed 2.4 code from branchman.c, commonfops.c
+
+2005-09-16  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile.kernel: Use EXTRA_CFLAGS.
+
+	* Makefile: Use ${LD} instead of ld, for cross compilation.
+
+2005-09-15  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* Makefile: Updated to 1.1.0pre
+	* Makefile.kernel: Updated to 1.1.0pre
+
+2005-09-15  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* NEWS: Updated for release.
+	* Makefile: updated for release.
+	* Makefile.kernel: updated for release
+
+2005-09-12  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* locks.c: Removed locking code since its broken big define 0 around
+	it
+	* file.c: Removed locking references have the vfs handle it.
+	* unionfs.h: fixed bug with 2.4 compilation.
+
+2005-09-08  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c: Remove comment leftover from templates that doesn't make
+	sense in current context.
+
+2005-09-05  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* commonfops.c: Remove lower fput debug printks.
+
+2005-09-02  Shaya Potter <spotter@cs.columbia.edu>
+
+	* file.c (unionfs_mmap): Fix flag checking for mmap.
+
+2005-09-01  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* We shouldn't use d_delete, vfs_unlink already does it.  The only
+	known remaining 2.6.13 issue is the unionfs_lock (flock.sh in the
+	regression suite).
+
+	* inode.c,stale_inode.c: Support for 2.6.13's new follow_link
+	prototype.  However, many of the regression tests fail for
+	unrelated reasons (or at least I think they are unrelated).
+
+	* unionctl.c: Allow --FOO to go before the union specifier (e.g.,
+	unionctl --list /mnt/unionfs now works).
+	* lookup.c: Don't partial lookup the root dentry.
+
+	* copyup.c: Check for permission setting errors.
+
+2005-08-31  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* lookup_one_len never returns NULL.
+
+2005-08-30  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_permission): Simplified code.
+
+	* inode.c (unionfs_link): Copy directory attrs to directory
+	(BUG391).  Unfortunately, regression test doesn't quite catch the
+	bug because of a revalidate for the stat.
+	* commit: Don't complain about .sh file's indentation.
+
+2005-08-29  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: tmpfs doesn't support fsync on directories
+
+	* Makefile: Update release target for new directory structure.
+
+	* patch-kernel.sh: Depend on Experimental, and move configuration
+	option to File Systems -> Miscellaneous file systems at the end,
+	not as the very first file system. Add UNIONFS_VERSION define.
+	Use tail -n +7 instead of tail +7.
+
+	* file.c (unionfs_fsync): Don't use dtohd on unlocked dentries.
+
+2005-08-28  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_link): Don't use unionfs_interpose with
+	INTERPOSE_LINK any more, because only one line of the whole
+	function was being used anyway.  This fixes an inode refcount leak
+	in unionfs_link, so the regression suite now passes with the new
+	locking, without any leaks.
+
+	* commonfops.c (unionfs_file_release): Update rdstate access time when
+	saving it in the inode (so that it won't be so quickly discarded).
+
+2005-08-26  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* dirfops.c (unionfs_readdir) : removed the changes made
+	for the special way in which vfs_llseek was handles for
+	Reiser4, as Reiser4 introduced a patch which made it
+	behave properly.
+
+2005-08-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Passes regression tests.
+
+	* Locking for create_parents.  Regression tests from branchman to
+	open.sh PASS.
+
+	* Basic inode operations pass sniff test with new locking (regression
+	tests not yet tried).
+
+	* Dentries need locking, and there isn't much way around it.This
+	snapshot adds some untested locking, and you won't want to use it
+	yet.  The basic principles are:
+		1. As soon as a VFS operation that touches a dentry is entered,
+		the dentry should be locked.
+		2. The lock ordering is:
+			Children before parents
+			Two children are tie broken with their address
+	There are several functions not done yet, most notably create_parents,
+	because it is going to require more thought (we walk up the parent
+	list and then back down it).  This in part is why children need to go
+	before parents (also revalidate walks up the parent list).
+
+2005-08-25  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* xattr.c: unused label causing a warning and inturn an error.
+
+2005-08-25  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (interpose,reinterpose): Interposition should lock the dentry.
+
+	* file.c: CodingStyle, and we don't need to check ftopd before ftohf.
+	* file.c (unionfs_mmap): We were checking our file instead of the lower
+	-level file for having valid operations.
+	* dirfops.c,dirhelper.c: CodyingStyle
+
+	* copyup.c: There is no need for _len at the end of functions, because
+	other versions don't exist any longer.
+
+	* lookup.c (unionfs_lookup_backend): Lock the dentry private data
+	for the whole lookup routine.
+	* branchman.c: CodingStyle fixes.
+	* rdstate.c, super.c: Use KERN_ERR if we have unfreed objects.
+
+2005-08-25  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: Fix losetup instructions.
+
+2005-08-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* print.c: Avoid kmallocs.
+	* rdstate.c,dirfops.c: Code style cleanups.
+
+2005-08-24  Anton Farygin  <rider@altlinux.com>
+
+	* dentry.c (d_revalidate):  Lock inode when freeing lower level ones.
+
+2005-08-24  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+	* unionfs.h: Updated forwardmap version and added a new data
+	structure bmapent.(Later on these should be unified into one header
+	rather than being in 2 header files).
+	* persistant_inode.c: Updated code to use bmapents now.
+
+2005-08-24  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c: Added code to ensure you dont add a filesystem with
+	the same fsid twice (no duplicate entries in the maps).
+	* unionimap.h: Added a new data structrue bmapent.
+	* The code in the kernel to read the maps hasent been changed so it
+	doesent work yet. Check back soon for that.
+
+2005-08-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_create): Use proper permissions when recreating
+	a deleted file (BUG383).
+
+2005-08-23  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* commonfops.c (copyup_deleted_file): Fix leak of name on subsequent
+	loop iterations.
+
+	* commonfops.c (copyup_deleted_file): Cleanup of major loop.
+
+	* unionfs.h (DPUT,KFREE): Don't try to free errors.
+
+	* main.c (unionfs_reinterpose): Remove d_unhashed assertion.
+	* unionfs.h (d_deleted): Create an inline function to tell
+	if a directory is deleted (i.e., unhashed and not the root).
+
+2005-08-23  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_parse_options): More checking for copyupmode.
+
+2005-08-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionfs.h (get_nlinks): More intelligent link counting.
+
+	* inode.c (unionfs_create): Don't dput an IS_ERR.
+
+	* unionfs.h: sbstart is always zero
+	* main.c (unionfs_read_super): check_branch does existence checking
+
+	* unionfs_debugmacros.h: Fix stray printks.
+
+	The following fixes are so that the regression suite runs without
+	any memory or dentry leaks:
+	* branchman.c (unionfs_ioctl_addbranch): Zero newly allocated
+	arrays.
+	* copyup.c (unionfs_create_named_dirs): Fix leak of path stack.
+	* main.c: Handle get_parent.
+	* lookup.c: Make the logic to put preceding negative dentries a
+	function.
+	* unlink.c (unionfs_unlink_all): Fix dentry reference count leak.
+	* inode.c (unionfs_link): Properly handle lock_ and unlock_dir.
+	* match-dget.pl: Handle DS and DD for set and unset records.
+
+2005-08-20  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: sendfile conflicts w/ Unionfs.
+
+2005-08-19  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* dirfops.c (unionfs_readdir) : changed the way the
+	return value of the repeated vfs_llseek (with origin
+	=1) is used. this is to allow readdir in Reiser4,
+	which returns -ENOENT (!!!) for the llseek in same
+	cases. this is for Bug #358
+
+2005-08-18  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* match-dget.pl: Insert both gets and puts into list of actions
+	for unreleased dentries.
+
+	* match-dget.pl: Dget matching script.
+	* Use DGET, DPUT, DENTRY_OPEN, and LOOKUP_ONE_LEN to
+	record when we dget and dput dentries.
+
+2005-08-17  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* match-malloc.pl: Return number of errors.
+
+	* print.c (fist_print_generic_dentry): Print inode number.
+
+	* copyup.c (unionfs_create_named_dirs): Fix dentry reference leak.
+
+2005-08-15  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* print.c (fist_print_file): Divide into generic and Unionfs halves,
+	ASSERT if we are passed a lower-level file.
+
+	* file.c (unionfs_lock): Handle write locks on r/o branches.
+
+2005-03-03  Anton Farygin  <rider@altlinux.com>
+
+	* dentry.c (unionfs_d_revalidate): Fix possible double unlock.
+
+	* branchman.c (unionfs_ioctl_incgen): Fix possible deadlock when
+	memory allocation fails.
+
+2005-08-12  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* rename.c, commonfops.c : removed the
+	dget/dput functions sandwiching the vfs_unlink as
+	these raise the refcounts and cause the .nfsXYZ
+	files to get created after unlinks. This knocks
+	out Bug#364 for 2.6.
+
+2005-08-11  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_parse_dirs): Prevent recursive Unionfs mounts.
+
+	* branchman.c: Plug a few memory leaks.
+
+2005-08-11  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_release) : fixed a case that would
+	cause a reference to the lower-level nfs inode to be
+	present. This is part of #364.
+
+2005-08-11  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionctl.c: Support --mode ro branch or --mode branch ro
+
+	* branchman.c: Only count putmaps that exist.
+
+2005-08-10  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* man/unionctl.8: No need for warning about root directory anymore.
+	* commonfops.c: Kill branch deletion ioctl.
+
+	* super.c: Magic MS_REMOUNT to remove a branch.
+	* unionctl.c: Use remount instead of ioctl to remove a branch.
+	* branchman.c (unionfs_ioctl_delbranch): Take the super, not an inode.
+
+2005-08-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_revalidate): All exit paths should go through
+	out.
+
+	* main.c (unionfs_parse_options,unionfs_parse_dirs): Simplified
+	option parsing using strsep rather than direct pointer manipulation.
+	Organized the options into types to factor out common code.
+
+2005-08-09  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* debian/*: Use official debian packaging files.
+
+	* Some AMD64 fixes.
+	* vprintk wrapper for 2.4.
+
+2005-08-09  Jan Engelhardt  <jengelh@linux01.gwdg.de>
+
+	* unionctl.c: Do not truncate "/" to "" when stripping the last "/"
+	from directories.
+
+2005-08-05  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main: Use FS_REVAL_DOT so that directories are always revalidated
+	during lookup.
+
+	* Drop err=passup, as it is unmaintained.
+
+2005-08-05  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* commonfops.c (unionfs_flush) : changed the dput to give
+	more symmetry and readability to the code.
+
+2005-08-04  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_revalidate) : return successfully if the
+	dentry is unhashed
+	* commonfops.c (unionfs_flush) : corrected the d_unhashed check
+
+2005-08-04  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c (QUERY): Don't copy FD_SET before ioctl. FD_ZERO the
+	set before the call.
+
+	* branchman.c (newputmap): Subtract the count from old putmaps from
+	the brand new putmap's count.
+
+	* branchman.c (unionfs_ioctl_delbranch): Use putmaps.
+	* lookup.c (new_dentry_private_data): Fix branch removal when
+	transitioning from > UNIONFS_INLINE_OBJECTS to ==
+	UNIONFS_INLINE_OBJECTS.
+
+2005-08-03  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h,main.c,super.c,inode.c: removed all code
+	pertaining SETATTR_ALL since the feature is not necessary
+	and complicates things.
+	* man/unionfs.4: removed text pertaining to the setattr
+	mount option.
+
+2005-08-03  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionfs.h (putmap): We need to keep track of the mapping between
+	branch numbers for older generation numbers and the current
+	generation so that we can properly branchput.
+	* branchman.c: Add functions to manipulate putmaps.
+	* commonfops.c: Use putmaps for revalidation and close.
+
+2005-08-03  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_release) : added a check to take care
+	of the case when the dentry coming into release is from a
+	failed lookup. This knocks bug #303 out.
+
+2005-08-03  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Remove older non-opaque directory mode.
+
+2005-08-01  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend): Skip those hidden
+	dentries that are NULL.
+
+2005-08-01  Jan Engelhardt  <jengelh@linux01.gwdg.de>
+
+	* print.c (fist_dprint_internal): Use vprintk instead of
+	vsnprintf/printk combo.
+
+2005-08-01  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionfs_debugmacros.h (branchget,branchput):
+	ASSERT if a branch's count goes negative.
+	* super.c (unionfs_put_super): ASSERT if the branch
+	counts are not zero on unmount.
+	* commonfops.c (unionfs_file_release): Don't put branches
+	that we didn't get.
+	* commonfops.c (unionfs_open): Don't get a branch until
+	we open it.
+
+	* commonfops.c: Fix generation number increment.
+
+2005-07-26  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* main.c: cleaned up parse_options code for copyup,
+	copyupuid,copyupgid,copyupmode.
+
+2005-07-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unlink.c, main.c, rmdir.c, rename.c: Remove obsolete
+	and unmaintained DELETE_FIRST mode.
+
+2005-07-26  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* man/unionfs.4: Added default behavior into the options
+	section for entries that didnt already have it.
+
+2005-07-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_parse_options): Move directory parsing
+	out of parse options function, so we don't have as many 4+ level
+	indents.
+
+2005-07-25  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Update version number to 1.0.14pre.
+
+2005-07-25  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* man/unionimap.8: Minor editing.
+
+2005-07-24  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* man/unionimap.8 : finished the man page: added a verbose
+	description and examples.
+
+2005-07-22  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* man/unionimap.8 : added descriptions to options in the
+	option section.
+
+2005-07-22  Jan Engelhardt  <jengelh@linux01.gwdg.de>
+
+	* unionctl.c: Use realpath so that relative pathnames are allowed
+	for mountpoints and branches.
+
+2005-07-22  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* subr.c (create_whiteout_parent) : removed this function
+	as it is not called anymore (#258).
+
+2005-07-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Update version to 1.0.13.
+	* Makefile: Include new regression tests in distribution.
+	* man/unionimap.8: An empty placeholder man page.
+
+2005-07-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* missing_vfs_funcs.h: Removed get_parent function since the 2.6
+	kernel has a dget_parent function which is the appropriate one to use
+	also made note that the templates do not use either triple_up or triple_down
+	* unionfs.h: checked to see if we are in 2.6 and if so define get_parent to be
+	dget_parent.
+	* unionimap.c: fixed a typo in the usage example.
+	* man/unionfs.4: added an entry for imap
+
+2005-07-21  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_create_named_dirs) : corrected the
+	function to get rid of problems with the open-unlink
+	regression test.
+
+2005-07-20  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unlink.c (unionfs_rmdir_all) : added checks to ensure
+	that the delete_whiteouts is not called for files. this
+	is a fix for bug 323
+
+	* rename.c (unionfs_rename_all) : changed the whiteout
+	creation call to "create_whiteout" instead of the
+	"create_whiteout_parent". this must solve 332.
+
+	* rename.c (unionfs_rename_whiteout) : change similar
+	to above to correct #336.
+
+2005-07-20  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_file_revalidate): Handle GFS and don't try
+	to reopen files that no longer exist.
+	* subr.c (unionfs_copyup_named_dentry_len): Add a bit of debugging.
+	* Fix comments that are past 80 characters and some other
+	minor style issues.
+
+	* subr.c (unionfs_create_whiteout): Don't set the parent's
+	opaque field when creating a whiteout, set your own.
+
+2005-07-20  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Fix things so that we compile on 2.4 again, and use the
+	older form of ioctl for kernels less than 2.6.11.
+
+	* ChangeLog: 80 character entries.
+
+2005-07-19  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionctl.c: Check if we are trying to remove a branch while
+	this process is causing it to be busy and print an appropriate
+	error message.
+
+	* man/unionctl.8: Minor edits.
+
+2005-07-19  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_queryfile) : changed
+	  function replacing lookup_one_len by partial lookups
+	  (second commit) : changed O_NONBLOCK to O_RDONLY
+
+2005-07-19  Shaya Potter  <spotter@cs.columbia.edu>
+
+	* unlink.c (unionfs_unlink_whiteout): Don't rename a symlink
+	to a whiteout, we need to unlink and create instead.
+
+2005-07-18  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unlink.c (unionfs_unlink_all) : checked if the dbopaque
+	  value is set for the current dentry, as this will
+	  indicate if there is a file to the right of the current
+	  file (Fix BUG #319).
+
+2005-07-18  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* commonfops.c: Use unlocked_ioctl when it is defined.
+	* branchman.c: Change prototypes to be more consistent with
+	unlocked_ioctl.
+
+	* commit: Script for committing files
+	* Lindent: Linux indentation script.
+	* *.[ch]: Add emacs magic.
+
+2005-07-14  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend) : fixed bug #321
+	  (that is, removed the semicolon that was introduced
+	  in the unionfs-042605-1324.tar.gz snapshot.
+
+2005-07-14  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_create_named_dirs) : corrected the usage of
+	  the name and namelen arguments sent into the function. This
+	  should take care of both bugs #299 and #322.
+
+2005-07-13  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_queryfile) : added ioctl definition
+	  that lists those branches where the specified file exists(#253).
+	* commonfops.c (unionfs_ioctl) : added the new ioctl.
+	* fist.h : added an include for the fd_set helper functions
+	* unionfs.h : added a structure unionfs_queryfile_args to
+	  pass variables to the new structure.
+	* unionctl.c : added the user interface
+	* uniondbg.c : rearranged the includes to help compilation
+
+2005-07-08  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* unionfs.h : added variables uii_totalopens and uii_writeopens to
+	  help in keeping filehandles valid after unlinks until closes.
+	* fist.h : included random.h to help get random bytes for file names
+	* commonfops.c (unionfs_file_revalidate) : added functionality to copy
+	  the lower-level file into a file with a randomly generated name
+	  obtained by using the newly added function "get_random_name" in
+	  commonfops.c
+	  (unionfs_open, unionfs_flush) : updated the uii_totalopens and
+	  uii_writeopens to be set and checked during the time of opening and
+	  flushing the file.
+	* copyup.c (unionfs_copyup_dentry_len) : made this into a wrapper
+	  function which now accepts the name of the file
+	  (unionfs_copyup_named_dentry_len).
+	  (unionfs_copyup_file) : similar wrapper to unionfs_copyup_named_file
+	  as above.
+	  (unionfs_create_dirs) : similar wrapper to unionfs_create_named_dirs
+	  as above
+	  (unionfs_copyup_named_file) : added function similar to
+	  unionfs_copyup_file which takes the file name as argument as well.
+	* main.c (unionfs_reinterpose) : ensured that deleted dentries are not
+	  reinterposed.
+	* dentry.c (unionfs_d_revalidate) : changed the check for deleted
+	  dentries to use the d_unhashed function also.
+
+2005-07-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+	* main.c: Ohh my god the inodes are persistent. Ohh and changed
+	interpose to use get_uin if we are using persistent inode maps.
+
+2005-07-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+	* super.c: fixed problem with kernel version number in an ifdef
+
+2005-07-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* dirfops.c: removed some debugging printk statments.
+	* persistent_inode.c: finished debugging and cleanedup get_uin.
+
+2005-06-30  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h  added extern decls for get_uin and get_lin
+	* persistent_inode.c: more work on the loading code and get_uin and
+	 get_lin
+	* dirfops.c: changed to make use of the persistent inode code only
+	if maps are loaded.
+
+2005-06-28  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* persistent_inode.c: changed how files are loaded in should be
+	done still need to test
+	* unionfs.h: added a new variable into unionfs_superblock_info
+	* unionimap.c: changed called to mkfsid
+	* usercommon.c: changed fillfsid and mkfsid. No longer uses the inode
+	since it will always be 2 since we are using the root of the fs.
+
+2005-06-24  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* Makefile: added usercommon.c into the make targets
+	* usercommon.c: Moves find_union to here and fixed it up
+	* unionimap.c: uses mkfsid now if fsid comes back as 0
+	* unionimap.h: added extern for mkfsid
+	* persistent_inode.c: fixed some bugs
+	* unionctl.c: removed find_union from here and updated calls to it.
+
+2005-06-23  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* dentry.c (d_revalidate): We shouldn't re-lookup
+	non-connected dentries.
+
+2005-06-23  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* Makefile: Include Makefile.kernel.
+
+	* subr.c (create_whiteout, create_whiteout_parent): Set the dbopaque
+	value to the branch where the whiteout gets created.  This is to solve
+	bug #294.
+
+2005-06-22  Arun M. Krishnakumar  <arunmk@fsl.cs.sunysb.edu>
+
+	* commonfops.c (unionfs_open): If the highest-priority branch
+	is read-only return -EROFS for opens with O_WRITE.
+
+2005-06-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* persistent_inode.c: parse_imap_options and associated calls are
+	working. maps are loaded in properly. Still need to finish and test
+	calls to use the maps.
+
+2005-06-17  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* persistent_inode.c: it appears that parse_imap_options is working
+	and so is verify_forwardmap. verify_reversemap needs to be fixed.
+
+2005-06-17  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* persistent_inode.c: Fixed some bugs still not working properly
+
+	* unionfs.h: added typedef for uuid_t.
+
+	* doit.sh: added imap entry into script.
+
+2005-06-17  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: If you have Fedora Core 4, then you need kernel-devel.
+
+	* Makefile: Fix the Makefile so that it won't recompile every
+	object every time.
+
+	* unionimap.c: Fix printf formats.
+
+2005-06-16  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c : Fixed a bug that prevented compiling on newer
+	gcc versions
+
+2005-06-16  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c : Tested and working we can now make and print valid
+	unionfs imap files.
+
+2005-06-16  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c : finished coding starting testing and debugging.
+	* unionimap.h : minor changes
+
+2005-06-15  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c : wrote some more code not tested yet
+	* unionimap.h : added a struct that is needed.
+	* Makefile: Cleanedup a conflict.
+
+2005-06-15  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* fist.h,print.c,unionfs.h: Change NODEBUG to UNIONFS_NDEBUG to be
+	more inline with the rest of the kernel.
+	* print.c: Wrap in UNIONFS_NDEBUG, so there is no need for a separate
+	flag to not compile it.
+
+	* unionctl.c: Add Unionfs version to help message
+		(not just unionctl version).
+	* unionimap.c: Add version to help message.
+
+2005-06-12  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c, match-malloc.pl: Handle KFREE(NULL).
+	* commonfops.c (unionfs_file_revalidate): NULL ftohf_ptr after freeing
+	it.
+	* commonfosp.c (unionfs_open): Allocate correctly sized ftohf_ptr.
+
+2005-06-10  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionimap.c: Beginning of a user mode program to create inode map
+	files.
+	* unionimap.h: Header for program.
+	* unionfs.h: added definitions for imap structs
+	* Makefile: added make targets for unionimap.c and .h
+
+2005-05-26  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* persistent_inode.c: Comment out 64-bit division.
+
+2005-05-25  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h : added some variables to the unionfs_sb_info struct to
+	handle persistent inodes.
+	* persistent_inode.c : more work done on the parsing functions almost
+	done but not quite there yet.
+	* main.c : added entry in parse_options to handle persistent inodes.
+
+2005-05-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unlink.c (unionfs_unlink_whiteout): Missing dput in truncating fix.
+
+	* unlink.c (unionfs_unlink_whiteout): Truncate whiteout after it
+	is created.
+
+2005-05-23  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Test commit.
+
+	* inode.c (unionfs_create): Fix ASSERT that had a side-effect.
+	This fixes a dentry reference count bug if you compile with
+	-DNODEBUG.
+
+2005-05-19  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unlink.c: Empty a directory of its whiteouts before deleting it,
+	and refresh the hidden dentry on a failed rmdir.
+
+	* unionfs.h: Always include ufi_file_i, so we can compile with zero
+	inline entries if we want.
+
+	* Test commit.
+
+	* Makefile: Define UNIONFS_VERSION to be the current version.
+	* main.c: Print the version of Unionfs, not main.c.
+
+2005-05-17  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend): Fix partial lookups for
+	three or more branches.
+
+2005-05-16  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend): Change UNIONFS_LOOKUP_PARTIAL
+	to UNIONFS_LOOKUP_REVAL_NEG, when a dentry magically turns positive
+	on us.
+
+2005-05-14  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* lookup.c (new_dentry_private_data): Fix memset'ing logic.
+	* branchman.c (unionfs_ioctl_addbranch): Fix copying logic.
+
+	* inode.c(unionfs_follow_link): Return 0 not the number of bytes
+	in follow_link.
+
+	* Reduce Unionfs module size when NODEBUG is set by not compiling
+	print.c, and using a different set of macros that don't require
+	__FILE__, __FUNCTION__, and __LINE__, and don't do as much checking
+	because we've aleady turned ASSERT off.
+
+	* Support for inline objects, so that we don't need more
+	than one allocation for inodes and only two for dentries (the dentry
+	itself and its private data).
+
+	* Separate directory file operations from normal file operations.
+
+2005-05-13  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Increment version number.
+
+	* Makefile: Release 1.0.12
+
+2005-05-13  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Disable generic_file_sendfile, because it causes nfsd
+	to Oops.
+
+	* lookup.c (unionfs_lookup): Don't ASSERT dentry goodness along
+	the error path.
+	* dentry.c (unionfs_d_release): Handle dentries without dthod_ptrs.
+
+2005-05-11  Jaspreet Singh  <jsingh@ensim.com>
+
+	* main.c (unionfs_interpose): Move fist_copy_attr_all before
+	d_instantiate so Selinux can decide what type of inode it is.
+
+2005-05-13  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* Makefile : fixed spelling mistake
+	* persistent_inode.c : fixed typo for compilation
+
+2005-05-12  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+	* persistent_inode.c : Stupid spelling mistake in the name
+	of the file.
+
+2005-05-12  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* persistant_inode.c : Functions needed to establish and maintain
+	a persistant inode scheme for unionfs.
+	* main.c : modified parse options for persistant inodes. Not done yet
+
+2005-05-11  Jaspreet Singh  <jsingh@ensim.com>
+
+	* copyup.c (unionfs_copyup_xattrs): Don't use XATTR_CREATE,
+	instead use 0 so that it is replaced or created as needed
+	(Selinux automatically creates attributes.
+
+2005-05-11  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* print.c (fist_print_generic_dentry): ASSERT(d_count > 0) so
+	that we find dentries gone bad earlier rather than later.
+
+	* inode.c (unionfs_mkdir): bend should not go past the opaque
+	directory, but stay there.
+
+2005-05-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: Add root file system instructions based on Linux
+	Live's linuxrc.
+
+2005-05-08  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* main.c,super.c,lookup.c: Use alloc_inode in 2.6, so that only
+	two allocations need to be made per inode instead of two.  In
+	both 2.4 and 2.6 use a private kmem_cache for our dentry data,
+	so that we don't need to waste space by having kmalloc round up.
+
+	* lookup.c (new_dentry_private_data): Merge initialization and
+	reinitialization code from lookup and read_super.  Also don't
+	reallocate dentry private data if we already have enough space.
+
+	* INSTALL: Add Jaspreet Singh's selinux instructions.
+
+	* INSTALL: Add EXDEV on ro branch rename as a limitation.
+
+	* inode.c: follow_link and put_link fix for 2.6.
+
+	* lookup.c: Compile fix for 2.4.
+
+	* rename.c: If a directory is moved on a read-only branch return EXDEV,
+	so that mv essentially does a cp -r (recursive copyup in the kernel
+	would be too ugly).
+
+2005-05-06  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* lookup.c: Merge unionfs_lookup_backend and unionfs_partial_lookup,
+	partial lookups will now properly handle whiteouts.
+
+	* print.c: Fix compile error when NODEBUG is defined.
+
+	* lookup.c: Fix BUG 264.
+	* print.c: Separate generic inode printing from itohi printing.
+	Use const for print functions.
+
+2005-05-05  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Code style fixes.
+
+2005-04-27  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* inode.c changed ops vectors to C99 style initialization.
+	* file.c changed ops vectors to C99 style initialization.
+	* dentry.c changed ops vectors to C99 style initialization.
+	* super.c changed ops vectors to C99 style initialization.
+	* stale_inode.c changed ops vectors to C99 style initialization.
+
+2005-04-21  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h: added no check versions ot set_dtohd_index
+	and dtohd_index.
+	* dentry.c: changed a function call to dtohd_index_nocheck
+
+2005-04-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* lookup.c (unionfs_lookup_backend): When a whiteout is encountered,
+	set opauqeness as we do with opaque directories, to prevent partial
+	lookup from seeing past the whiteout.
+
+	* lookup.c: Separate file for lookup code.
+	* subr.c: Move unionfs_partial_lookup to lookup.c.
+	* inode.c: Move unionfs_lookup to lookup.c:
+
+	* rename.c: Don't print lower-level dentries using a Unionfs
+	specific function.
+
+	* print.c: Divide fist_print_dentry into one function for Unionfs
+	specific dentries, and then a generic function.  Also ASSERT that
+	we are really printing a Unionfs dentry (so we don't dereference
+	bad private data).
+
+	* Fix indentation comments.
+
+2005-04-25  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* subr.c: Code style fixes.
+
+2005-04-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* NEWS: Keep NEWS up to date.
+
+2005-04-21  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_filldir): Don't strncmp for .wh., if the
+	name's length is less than 4.  Old cruft can make things
+	go horribly bad (BUG 254).
+
+	* inode.c (unionfs_lookup_backend): Properly handle file
+	transitioning from a negative to a positive dentry. (BUG 215)
+
+2005-04-21  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Sendfile only exists on 2.6.
+	* main.c: Catch UNIONFS_REVAL_NEG specifically, still
+	need to understand/fix.
+
+2005-04-20  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* subr.c (unionfs_partial_lookup) ,unionfs.h
+	(unionfs_dentry_info), inode.c(unionfs_lookup):
+	Correctly mark a directory as opaque and respect that
+	during partial lookups.
+
+	* Exorcise struct typedefs and "fake" STATIC functions.
+
+	* inode.c: Experimental support for opaque directories,
+	not all of the loose ends are tied up, so this snapshot
+	will have some associated oddities.
+
+	* xattr.c: Use EOPNOTSUPP, not ENOTSUPP.
+
+	* Makefile, unionfs.h: Separation of rename/unlink code.
+	* rename.c: Separate rename code from inode.c
+	* unlink.c: Separate unlink code from inode.c
+
+2005-04-20  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* rdstate.c, unionfs.h: DOH, We were checking if
+	uii_rdversion <= MAXRDCOOKIE to decide whether or not
+	to wrap uii_cookie.
+
+2005-04-19  Fabian Franz  <fs-bugs@fabian-franz.de>
+
+	* applied patch to file.c that uses generic_file_sendfile
+	to implement sendfile.
+
+2005-04-18  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* removed a stray printk
+
+2005-04-18  Markus F.X.J. Oberhumer  <markus@oberhumer.com>
+
+	* file.c, locks.c: Use #ifdef for 64-bit locking
+	commands, which are not defined on amd64.
+
+2005-04-18  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c: Extended attributes now copyup properly.
+	This has only been tested in 2.6 but I see no reason
+	that it shouldent work in 2.4
+	* copyup.c: unionfs_create_dirs is now nolonger bound
+	by MAX_DIRS_CREATE. We now use kmalloc to dynamically
+	allocate memory for it and "realloc" the memory when
+	needed.
+
+2005-04-18  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* copyup.c: Use list_size as the argument to xattr_free, not the
+	MAX_LIST_SIZE.
+
+	* file.c: ASSERT was asserting on the dentry, not the i_mode.
+
+2005-04-16  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Delay copyup of read-write files located on read-only
+	branches, until an operation will actually write to them (BUG 225).
+
+	* INSTALL: Cleanup kernel instructions a bit.
+
+2005-04-13  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* inode.c: unionfs_mkdir now spoofes the uid and gid of the owner
+	of the whiteout file for the purpose of removing it.
+
+2005-04-11  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+	* patch-kernel.sh : Script written to move unionfs into the kernel
+	source tree. The original script was submitted by Sven Geggus however
+	the script was cleaned up and modified for various reasons. Check the
+	file for more details.
+	* Makefile: PHONY added to the utils target to aid in building them
+	for the kernel.
+	* INSTALL: Directions added for building unionfs into a monolithic kernel.
+
+2005-04-11  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c : changed comparison from > to >= to be compatable with 2.6.0
+	* fist.h : same as above
+	* unionfs.h : same as above
+	* rdstate.c : same as above
+	* main.c : same as above
+	* inode.c : same as above
+	* super.c : same as above
+	* xattr.c : sme as above
+
+2005-03-24  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* unionfs.h : changed UNIONFS_SUPER_MAGIC. All fist based file systems
+	  will have the first 2 bytes of the MAGIC number be f15f.
+	* super.c : statfs struct is now properly filled.
+
+2005-03-23  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* INSTALL: removed the warning about NFS exports
+	* Makefile: Increases release number.
+	* NEWS: Added release news for 1.0.11
+	* unionfs.h: added a function rdstate2offset
+	* file.c: redid llseek and readdir implementation
+	* rdstate: redid find_rdstate
+
+2005-03-21  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Add big warnings that NFS exports won't work in 1.0.10.
+
+2005-03-17  Terry Barnaby <terry1@beam.ltd.uk>
+
+	* rdstate.c (find_rdstate): Factor out rdstate search.
+	* file.c (unionfs_dir_llseek): Use rdstate if it exists.
+
+2005-03-16  Terry Barnaby <terry1@beam.ltd.uk>
+
+	* Makefile: fix clean target
+
+	* file.c (unionfs_dir_llseek): Fix mistaken use of origin
+	instead of offset.
+
+2005-03-16  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_statfs): Use shifting instead of division.
+
+2005-03-15  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_statfs) : df now reports the proper numbers.
+	duplicate super blocks are not factored into the calculations and
+	all the block sizes are normalized to the first partition.
+
+2005-03-14  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_read_super) : In 2.4 the kernel expects a valid
+	super block or null we were returning an error pointer and this
+	caused an Oops. This has been fixed.
+
+2005-03-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionfs_getlk (unionfs_getlk): Add preprocessor define for
+	2.6.11+, and add a missing case.
+
+2005-03-10  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* locks.c (unionfs_setlk): fixed a typo in the 2.6 function
+
+2005-03-10  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* misc/snapmerge: Explain how to get two snapshots merged into one
+	snapshot.
+
+	* file.c (unionfs_dir_llseek), locks.c (unionfs_setlk): Fix build
+	on 2.6.
+
+2005-03-09  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_lock): function is completely rewritten to actually
+	work.
+	* locks.c (unionfs_setlk,unionfs_getlk): locks.c was added to house
+	locking functions so file.c doesent get overcrowded. unionfs_setlk
+	and unionfs_getlk were added and placed in this file with some
+	helper functions for 2.6
+
+2005-03-08  Terry Barnaby <terry1@beam.ltd.uk>
+
+	* file.c (unionfs_dir_lseek): Allow seek to beginning/end of dirs.
+
+2005-03-07  Fernando Freiregomez <fernado.freiregomez@telefonica.es>
+
+	* misc/snapmerge: Fix permissions/times after copying files.
+
+2005-03-07  Lucas Correia Villa Real <lucasvr@gobolinux.org>
+	* Makefile: Use MODDIR instead of /lib/modules/`uname -r`
+
+2005-03-07  Eduard Bloch <blade@debian.org>
+	* man/*: Fix man page sections
+	* Makefile: Add separate modules target, remove excessive uname -r's
+	so that kernel version can be overridden.
+
+2005-03-03  Anton Farygin  <rider@altlinux.com>
+
+	* Makefile: Can now build utilities without building kernel module.
+
+2005-03-03  Terry Barnaby <terry1@beam.ltd.uk>
+
+	* dentry.c (unionfs_d_revalidate): Use fist_copy_attr_all to
+	make the cache appear more coherent.
+
+2005-03-02  Fabian Franz  <fs-bugs@fabian-franz.de>
+2005-03-02  Anton Farygin  <rider@altlinux.com>
+	* dirhelper.c: Fix BUG 184: vfs_readdir is allowed to return positive
+	results.
+
+2005-03-02  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_readdir): Remove buf.error which was unused.
+
+2005-03-02  Anton Farygin  <rider@altlinux.com>
+
+	* Fix BUG 205: mv on symlinks
+
+	* Fix BUG 203: Kernel oops on creat file with len of name > 252
+
+2005-02-24  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* RPM spec file included in release.  Remove CVS directory from
+	debian directory in release.
+
+	* Add fsid= to interactions, with pointer to exports(5).
+
+2005-02-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* unionctl.c (find_union): Start off w/ a 1K buffer and double it
+	if the lines in /proc/mounts don't fit.  Thanks to J. H. Wilson for
+	finding and patching this bug.
+
+	* main.c (unionfs_interpose): Reorganize if statement.
+
+	* rdstate.c (add_filldir_node,find_filldir_node): Don't print the
+	names in debug mode because they aren't '\0' terminated.
+
+2005-02-22  Fabian Franz  <fs-bugs@fabian-franz.de>
+
+	* Applied patch to bug 193 Fixed the problem with
+	hardlinks not having the same inode number.
+
+2005-02-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_delete): d_delete should not be defined (or
+	call the lower d_delete).  Thanks to Fabian Franz for identifying
+	this issue.
+
+2005-02-22  Fabian Franz  <fs-bugs@fabian-franz.de>
+
+	* copyup.c (unionfs_copyup_dentry_len): Applied patch provided
+	for bug #196. A device was being decoded when it didnt have to be.
+
+2005-02-22  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* README: Article URL.
+
+2005-02-18  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* dirhelper.c (create_dir_whs) : commiting chips change to make
+	sure it creates whiteouts properly.
+
+2005-02-17  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: Squashfs is generally OK, but we do have flock problems.
+
+	* file.c (unionfs_dir_llseek): Untested fix for BUG 187.
+
+2005-02-09  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_link): Fixed linking if the underlying file
+	system is read-only. The fix causes an issue with device being
+	busy on umount.  * rdstate.c (find_filldir_node): Print statement
+	was referencing a bad pointer.
+
+
+2005-02-08  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_copyup_xattrs): Use PASSERT, other compile fixes.
+	* xattr.c (xattr_alloc, xattr_free): Shouldn't be static.
+	* Go back to GFP_KERNEL, because GFP_NOFS causes problems with vserver.
+
+2005-02-08  Jaspreet Singh  <jsingh@ensim.com>
+
+	* copyup.c (unionfs_copyup_xattrs): Use security functions.
+
+2005-02-08  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_copyup_xattrs): Take the inode lock as is done in
+	setxattr.
+	* inode.c (unionfs_link): Reference counting on error paths/compile fix.
+
+2005-02-07  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_link): On copyup path directory was not unlocked.
+
+2005-02-07  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_xattr_copyup): Review of code, not yet tested.
+
+	* inode.c (unionfs_link): Revert to Chip's version of
+	unionfs_link.
+
+2005-02-07  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile: Allow module prefixes to be specified for
+	RPM_BUILD_ROOT
+	* rpm/unionfs.spec: Compiled, tested, and installed.
+
+2005-02-06  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* Makefile added a target for uninstall to accomodate rpm removal
+
+2005-02-02  Anton Farygin  <rider@altlinux.com>
+
+	* copyup.c (unionfs_copyup_permissions): Use ATTR_FORCE to make
+	sure any user can change permissions.
+	* copyup.c (unionfs_create_dirs): Twiddle current->fsuid/fsgid
+	so that any user's copyup will behave properly.
+
+2005-02-02  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_mmap): Don't ASSERT that the lower mmap
+	operation is there, instead return ENODEV, as is done in
+	do_mmap_pgoff.  NTFS (and others) don't support mmap, so
+	neither should we when stacked on top.
+
+2005-02-01  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* dirhelper.c : fixed 2.6 compilation. call to vfs_creat missing
+	last param in 2.6
+
+	* Makefile : namei.c is no longer needed so it was removed from
+	the make file.
+
+2005-01-28  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* subr.c, dirhelper.c: Move mkdir/rmdir helpers into separate
+	file.
+
+	* unionfs.h, fist.h: Remove unused/redundant definitions.
+
+2005-01-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* rdstate.c, unionfs.h: Move finding and adding filldir nodes
+	into rdstate.c.  This reduced the readdir code size, and should
+	also let us reuse the code for the subr.c functions.
+	* subr.c: Use an rdstate instead of a second readdir to remove
+	files in delete_whiteouts.
+	* namei.c: Removed vfs_unlink_nozombie.
+
+2005-01-19  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* INSTALL: Add more CFLAGS options to make things smaller.
+
+	* unionfs.h, file.c, rdstate.c: Change DIREOF from -1 to 2^31-1 to
+	fix readdir.
+
+	* unionctl.c: Don't strip trailing slash for "/" when searching for
+	the Union.
+
+	* Makefile: Include INSTALL.
+
+2005-01-14  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_addbranch): Fix error path resource leak.
+
+2005-01-14  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* copyup.c (unionfs_copyup_permissions): Changed so it actually works now
+	instead of corrupting certian bits.
+	* copyup.c (unionfs_create_dirs): Function actually uses unionfs_copyup_permissions
+	for setting directory permissions instead of setting them explicitly.
+
+2005-01-14  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_dir_llseek): Allow llseek to the current
+	offset in the directory, but nowhere else.
+	* file.c (unionfs_readdir): Save the last offset, so we
+	can lseek to it (for pretend).
+
+	* Remove all occurrences of GFP_KERNEL and replace with GFP_NOFS,
+	so our allocations can't cause file system calls.
+
+2005-01-13  Rakesh N. Iyer  <riyer@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_readdir): Fixed deadlock in rdstate search.
+
+2005-01-13  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Split README into INSTALL as well.
+
+	* Makefile: Spit out a message saying to read install.
+
+	* Don't build xattr functions w/o -DUNIONFS_XATTR
+
+2005-01-11  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* inode.c: Initial implementation of hardlinking a file on a read only branch.
+	  Attributes are not copied properly yet.
+
+2005-01-10  Sai Suman  <suman@pantasys.com>
+
+	* copyup.c: Fix usage of unionfs_copyup_permissions.
+
+2005-01-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* super.c: 2.4 compile fixes
+
+	* fist.h: Updated FISTBUG for gcc 2.9.5
+
+2005-01-10  David P. Quigley  <dquigley@fsl.cs.sunysb.edu>
+
+	* xattr.c: Format changes for size_t.
+
+	* doit.sh: Call optional postdoit script
+
+2005-01-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* AUTHORS file.
+
+	* README updates.
+
+	* Allow NFS exports on 2.6 (Sai Suman)
+	* Fixes to print format in xattr.c (Sai Suman)
+
+	* debian/*: Debian packaging from Alex de Landgraaf.
+
+	* Remove -Wno-unused-label for gcc 2.9.5 (alex@delandgraaf.com).
+	* Allow "EXTRACFLAGS=-DNODEBUG" in fistdev.mk to disable
+	the printing/ASSERT facility, cutting object size in half.
+
+2005-01-09  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* unionfs.h: Warn when compiling on unsupported kernels.
+	* super.c: Compile fix for 2.6.8.
+	* Makefile: Include ChangeLog in the release.
+
+2005-01-07  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Prepare 1.0.6 release.
+
+	* Fix 2.6 compile issues in new code.
+
+	* rdstate.c: Move readdir state away from subr.c.
+	Use a kmem_cache for filldir nodes.
+
+	* copyup.c: Move copyup functions away from subr.c
+
+2005-01-06  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Working NFS readdir.  On close we store left-over
+	readdir state in the inode for up to 5 seconds.  If a readdir
+	has a matching cookie, then we pull the state out of the inode
+	and use it.  We also needed to use our own offsets, otherwise
+	the NFS client got confused.
+
+	* subr.c: Remember the number of entries in our hash table for
+	each inode, and use that as the number for the next readdir.
+
+	* Makefile: Fix dependencies on .h files.
+
+	* print.c: Consistencify printing of files and superblocks
+	and shorten some overly verbose output that added no information,
+	but reduced the effective kernel log size.
+
+	* fist.h: Make gcc check fist_dprint_internal formats.
+
+	* file.c,unionfs.h: Separate readdir state into a separate structure.
+
+	* file.c,unionfs.h,subr.c: Make readdir state use variable sized
+	hash tables based on number of pages in lower-level directories.
+
+	* Makefile: Install unionfs.ko, not unionfs.o if it exists.
+
+	* main.c: Remove MODULE_PARM because it is deprecated.
+
+2005-01-04  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_read): Fix "inifite" cat bug on 2.6
+
+	* Makefile: Auto-select 2.4 vs. 2.6 for build.
+
+	* Unify 2.4 and 2.6 Makefiles
+
+	* Fixes for printing file structures at debug level 18.
+
+	* Fixes for 2.4 compilation.
+
+2004-12-30  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* *.[ch]: Update year.
+
+2004-12-29  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c: Embed rename.txt into comment.
+
+2004-12-29  Charles P. Wright  <cwright@cs.sunysb.edu>
+
+	* inode.c, unionfs.h: Changed directory copyup function back to
+	old prototype.
+
+	* subr.c (unionfs_copyup_dentry_len): Handle directories, devices,
+	and symlinks.
+
+2004-12-27  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c: Only request copyup of parent directories.
+
+	* subr.c (unionfs_copyup_dentry_len): Handle directory copyup
+	(required for chmod).
+
+	* main.c (unionfs_parse_options): Fix along error path.
+
+2004-12-06  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_interpose): Allow mount point crossing.
+
+	* README, Makefile, inode.c: Turn off extended attributes, unless
+	the user specifically turns them back on by defining UNIONFS_XATTR.
+	This prevents us from getting various compile errors depending on
+	vendor-specific patches.
+
+2004-11-10  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* Fix .cvsignore and release.
+
+	* README: Added warning that anything less than 2.4.20 is unsupported.
+
+	* namei.c: Removed inode_dir_notify calls when we are on less than
+	2.4.20, because the symbol is not exported.
+
+	* Fixed lots of bad casts from pointer to int in printks.
+
+	* main.c (unionfs_parse_options): Fix for badly ordered variables.
+
+	* main.c (unionfs_read_super): Remove double free along error path.
+
+	* wrapfs.h (dtopd_lhs): Remove cast from LHS of assignments.
+
+2004-11-09  Erez Zadok  <ezk@cs.sunysb.edu>
+
+	* released unionfs-1.0.2.
+
+	* README (site): fix typo. missing "`".
+
+	* Makefile (clean): remove tarball.
+
+	* README: updated.
+
+2004-11-09  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* released unionfs-1.0.1.
+
+	* Makefile: Include man pages in the release.
+
+2004-11-07  Erez Zadok  <ezk@cs.sunysb.edu>
+
+	* released unionfs-1.0.
+
+	* announce-email.txt: revised announcement text.
+
+2004-09-23  Erez Zadok  <ezk@cs.sunysb.edu>
+
+	* announce-email.txt: draft announcement email.
+
+	* README: revised.
+
+2004-09-15  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Don't allocate directory hash table for files.
+
+	* inode.c (unionfs_setattr): Don't do partial lookup if setattr is not
+	set to all (should improve delete_whiteout).
+
+	* Some grayout code (we don't discuss rename_first anymore, so it
+	actually doesn't matter).
+
+2004-08-24  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* namei.c (vfs_create_nozombie): Whiteout creation needs a version
+	of vfs_create that won't down the i_zombie.
+
+	* subr.c (create_dir_whs_filldir):  Don't ASSERT that the whiteout
+	doesn't already exist, because we can have multiple files with
+	the same name in other branches.
+
+2004-08-23  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_mkdir, unionfs_symlink, unionfs_mknod): lookup
+	whiteout in 'bstart' not 'bindex'. We always looked up on first branch
+	as bindex was set to 0
+
+2004-08-20  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_inode_revalidate): Walk up the tree to revalidate
+	inodes like we do for dentries.
+
+	* inode.c, subr.c, unionfs.h: Use multilocks to protect against
+	unionfs_partial_lookup and revalidate operations racing against
+	each other.
+
+	* unionfs.h: Implementation of "multilocks".
+
+	* Makefile: install target
+
+	* We don't change size, so no sca_*.[ch] files.
+
+	* main.c (unionfs_hidden_dentry_index): This function is unused now
+	that Mohammad took it out, so I removed it.
+
+	* Removed unnecessary files.
+
+	* COPYING: SUNY we can't be blamed for anything notice; and the GPL.
+
+2004-08-19  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_setattr): using dtohd_index() instead of
+	unionfs_hidden_dentry() because an intermediate hidden dentry
+	could be NULL and we dont want PASSERT to oops on us
+
+2004-08-19  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_unlink_all): We shouldn't have negative dentries
+	unless they are the first one.
+
+	* inode.c (unionfs_inode_revalidate): PASSERT(hidden_inode) instead
+	of Oopsing.
+
+	* inode.c (unionfs_rename_all): Typo in the clobbering unlink.
+
+	* inode.c (unionfs_rename_all): No debug printks.
+
+	* unionfs.h (get_nlinks): Don't sum up non-directories.
+
+	* subr.c (unionfs_refresh_hidden_dentry): Re-lookup a dentry, this
+	is needed on rename reverts because vfs_rename trashes the dentry
+	of the target.
+
+	* inode.c (unionfs_rename_all): Working revert.
+
+2004-08-18  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_rename_all): New rename that handles more cases,
+	revert code doesn't work yet.
+
+2004-08-18  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* inode.c (rmdir_all): exit if error is not -EROFS and not -ENOTEMPTY
+
+	* inode.c (rmdir_all): exit from function and dont create whiteout
+	if vfs_rmdir returns error other than -EROFS
+
+
+2004-08-17  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_unlink_all): Unlock the directory on error.
+
+	* inode.c (unionfs_setattr): Lock on all attribute changes, not just
+	some.
+
+	* inode.c (do_rename): Check renames based on index rather than
+	new_dentry which might not exist.
+
+	* Makefile: debugging symbols are very useful for Oops tracing
+
+	* unionfs.h (CUR_MAX_BRANCH): Removed CUR_MAX_BRANCH which was always
+	sbend + 1, and replaced with sbmax (that doesn't require a redundant
+	and possbly inconsistent field within the super-block).
+
+	* unionfs.h (dtopd): Converted from a macro to an inline function
+	so that we can do more checking of the private data that we are
+	returning.
+
+	* unionfs.h (dtohd_index) Added a udi_bcount field to the private data
+	so we would Oops rather than silently overflow array bounds.
+
+	* dentry.c: Recursively revalidate the parent (the ASSERT that was
+	checking this was mis-written).  It turns out that our parent was not
+	always valid.
+
+	* file.c (unionfs_file_revalidate): Always reassign the read-ahead
+	values because the older file might have different values and llseek
+	will cause an assertion failure.
+
+	* inode.c (unionfs_lookup_backend): Treat revalidated negative and
+	positive dentries differently.
+
+2004-08-16  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c: Use an fd_set instead of an integer for tracking successful
+	renames.
+
+	* branchman.c: Don't allow more than FD_SETSIZE (1024) branches.
+
+	* unionctl.c: Specific message for exceeding FD_SETSIZE.
+
+2004-08-11  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c: Return ENAMETOOLONG when looking up ".wh.*"
+
+	* unionctl.c: Add ioctl.
+
+	* branchman.c: Don't allow branches without MAY_READ
+
+	* unionctl.c: Convert branch pathnames into index automatically.
+
+	* unionctl.c: Match the longest prefix of our path inside of
+	/proc/mounts instead of the path itself.  This is required so that
+	remove doesn't need to open the root of the union.
+
+	* unionctl.c: Remove branch ioctl and list branch configuration.
+
+2004-08-10  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* file.c: added CAP_SYS_ADMIN checks before calling unionfs ioctls
+
+	* uniondbg.c: now contains debugging related ioctls
+
+	* unionctl.c: now contains ioctls to add, remove and set branch
+	permissions moved here
+
+	* uniondbg.c: ioctls to add, remove and set branch permissions
+	moved here
+
+	* fist_ioctl.c: remaining ioctls stay here
+
+	* subr.c: making sure copyupuid, copyupgid and copyupmode are all
+	specified when copyup option is set to mounter.
+
+	* inode.c: implemented unionfs_rename_first()
+
+2004-08-09  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* inode.c: more places where we should exit if get an error other than
+	-EROFS in unlink/rmdir and related functions.
+
+	* subr.c: exit if get an error other than -EROFS when
+	creating/deleting whiteouts
+
+	* inode.c: making sure that we create/mkdir/symlink/mknod to the
+	left only if the error returned is -EROFS, otherwise passup
+
+	* subr.c: use notify_change instead of directly modifying the inode
+	fields.
+
+	* subr.c: use notify_change instead of directly modifying the inode
+	fields.
+
+	* main.c: added copyupuid, copyupgid and copyupmode mount options.
+	These options will specify the mode, uid and gid of copied-up files.
+	copyup option should be set to mounter.
+
+	* subr.c: using the above mount time values for copied-up files.
+
+	* unionfs.h added these values in the unionfs super block.
+
+2004-06-17  Charles P. Wright <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_flush): Flush all branches (only makes a
+	difference for directories).
+
+2004-08-03  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* super.c: Implemented unionfs_show_options. Can now view unionfs
+	mount time options in /proc/mounts
+
+	* inode.c: using is_robranch_super instead of is_robranch in
+	create, mkdir, symlink, mknod operations, whenever we try to
+	remove whiteouts if they exist.
+
+	* main.c: while parsing options using strcmp wherever we can,
+	removed all magic numbers, copyup options are now preserve,
+	currentuser, mounter
+
+	* subr.c: when copying up the default mode should be original
+	owner (preserve)
+
+2004-08-02  Mohammad Nayyer Zubair  <zubair@filer.fsl.cs.sunysb.edu>
+
+	* main.c: unionfs mount time flag changed from being an integer
+	flag to several text options that will together make up the flag.
+
+2004-05-17  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c: Fixed off by one error when adding more than 8
+	branches.
+
+2004-05-10  Charles P. Wright  <cwright@polarbear.fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_read_super): Error check to prevent oops on bad
+	mount-time options.
+
+2004-04-21  Charles P. Wright  <cwright@polarbear.fsl.cs.sunysb.edu>
+
+	* file.c: revalidate files when the are passed into our methods,
+	this allows copy-up of open files.  Yeah snapshots.
+
+	* dentry.c: Should not use d_hash and d_compare because Unionfs is
+	in charge of the namespace, not the lower-level file systems.
+
+	* Unionfs now has split-view caches.  If compiled with
+	-DSPLIT_VIEW_CACHES, then Unionfs supports duplicating the super
+	block structure and dynamically selecting the correct structure to
+	use when crossing into the unionfs mountpoint.  Right now the
+	default behavior is that root has one view, and every other user
+	has another view.
+
+	If the super block is not duplicated then everything works as
+	before.
+
+2004-04-20  Charles P. Wright  <cwright@polarbear.fsl.cs.sunysb.edu>
+
+	* branchman.c: Super Duper works!  An ioctl can let you create a
+	super block that is a copy of the original.  When you stat the
+	mountpoint that super block is returned.  Now to fix the reference
+	counting bugs associated with unmount. :)
+
+2004-04-19  Charles P. Wright  <cwright@arcticfox.foo>
+
+	* super.c (unionfs_select_super): return s_root for now
+
+2004-03-15  Charles P. Wright  <cwright@arcticfox.foo>
+
+	* dentry.c (unionfs_d_revalidate): Fix refcounts.
+
+	* inode.c (unionfs_inode_revalidate): Fix reference counting.
+
+	* inode revalidate "works" (e.g., no Oopses or other broken f/s
+	behavior), but has broken reference counting.
+
+2004-03-14  Charles P. Wright  <cwright@arcticfox.foo>
+
+	* main.c (unionfs_interpose): Changed neg_dent_flag to which was
+	true if we did *not* have a negative dentry to is_negative_dentry
+	which *is* true if we have a negative dentry.  Fixed related
+	assert (which was ASSERT(1)).
+
+	* inode.c (unionfs_lookup): Read through and simplified lookup by
+	removing duplicated code or nasty if/else statements when if
+	continue would work(to the tune of 20%).  Clarified comments as
+	well.  Now instead of being a 248 line monster it is a 199 line
+	monster.
+
+	* UNIONFS-TODO: We still need to solve whiteouts (i.e., you can
+	sucessfully stat a whiteout in Unionfs).  Note this is not
+	introduced by my changes.
+
+2004-03-12  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_rdwrbranch): Read/write branch setting.
+
+2004-03-11  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* branchman.c (unionfs_ioctl_addbranch): Refcount fix.
+
+2004-03-04  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (do_rename): Correctly check is_readonly.
+
+	* fist.h (print_exit_pointer): Print out pointer using %p and
+	don't convert using PTR_ERR if it is not IS_ERR.
+
+	* subr.c (unionfs_create_parent_dir): Return error as pointer
+
+	* subr.c (create_whiteout): Check branch before creating whiteouts.
+
+	* unionfs.h (VALID_MOUNT_FLAGS): Define valid mount flags in the
+	header, so main.c doesn't need to know all of them.
+
+	* doit.sh (FLAG): Default mode should be UNLINK_ALL, not
+	UNLINK_WHITEOUT.
+
+	* inode.c (unionfs_unlink): Unlink creates whiteout to the left.
+
+2004-03-03  Charles P. Wright  <cwright@polarbear.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_create): Creation on a robranch will
+	cause the file to be created to the left.
+
+	* unionfs.h: More macros for checking if things are on read-only
+	branches.
+
+	* xattr.c: Separate xattrs from inode.c.
+
+	* ATTACH-TODO.txt: Unionfs doesn't attach.
+
+	* README.attach: Unionfs doesn't attach.
+
+	* mmap.c: Unionfs doesn't filter data.
+
+	* vm_area.c: No data filtering.
+
+2004-03-02  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c: Updated parsing code so that dirs can be specified as
+	b0=rw,b1,b2=ro,b3.  Defaults to rw.  Need to actually integrate
+	the permission checking code elsewhere.
+
+2003-11-10  Harikesavan Pathangi Krishnan  <hari@a-rh72i.fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_readdir): Changed code to fix the NFS related bug.
+
+2003-10-27  Harikesavan Pathangi Krishnan  <hari@mooby.fsl.cs.sunysb.edu>
+
+	* subr.c (unionfs_copyup_dentry_len): This is a modified form of
+	unionfs_copyup_dentry() that takes in the length of file to be
+	copied up. The length is useful when the file size is changed in
+	the setattr.
+
+2003-10-01  Puja Gupta  <puja@t6.fsl.cs.sunysb.edu>, Jay, Mohammad.
+
+	* subr.c (unionfs_copyup_dentry): fixed copyup bug, update bstart, bend
+	on error on vfs_create.
+
+2003-09-27  Puja Gupta  <puja@a-rh8.fsl.cs.sunysb.edu>, Hari, Jay.
+
+	* inode.c (unionfs_rename_all): fixed to call rename and create
+	whiteout for test_rename script.
+
+2003-09-26  Puja Gupta  <puja@a-rh8.fsl.cs.sunysb.edu>, Zubair, Hari.
+
+	* subr.c (create_whiteout): removed unnecessary dput of hidden_dentry.
+
+2003-09-26  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>, Hari
+
+	* subr.c, inode.c, unionfs.h: Better function name and comments.
+
+	* inode.c (unionfs_rename_all): changed to create whiteouts
+	properly on error conditions.
+	(unionfs_rename_whiteout): initilize parent dentry.
+
+2003-09-26  Harikesavan Pathangi Krishnan  <hari@icon.fsl.cs.sunysb.edu>, Puja.
+
+	* print.c (fist_print_dentry): added print for d_parent, aligned.
+
+	* subr.c (create_whiteout_left_parent): Added function for
+	creating whiteout in a parent directory by a char * string.
+	(unionfs_create_parent_dir): initialize dtohd before checking and
+	changing the bstart and bend for new dentry.
+	(unionfs_copyup_dentry): removed extra dput, since fput internally
+	does that.
+
+	* inode.c (unionfs_rename_whiteout): fixed to support copyup for EROFS.
+
+2003-09-24  Puja Gupta  <puja@story.fsl.cs.sunysb.edu>, Hari, Jay.
+
+	* subr.c (unionfs_create_parent_dir): Fixed updating bstart for copyup.
+
+2003-09-23  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>, Hari, Jay.
+
+	* subr.c (unionfs_create_parent_dir): Updates bstart, bend, dputs
+	extra negative dentries.
+
+2003-09-23  Puja Gupta  <puja@story.fsl.cs.sunysb.edu>, Hari, Jay.
+
+	* subr.c (unionfs_create_parent_dir): Dput the previous negative
+	dentry.
+
+	* inode.c (unionfs_create, unionfs_mkdir, unionfs_mknod, unionfs_link)
+	(unionfs_symlink): Removed dgets and dputs to handle errors in
+	vfs functions.  Now handled in unionfs_create_parent_dir.
+	(do_rename): removed dputs and dgets to balance with create_parent.
+
+2003-09-22  Harikesavan Pathangi Krishnan  <hari@t1.fsl.cs.sunysb.edu>, Mohammad.
+
+	* subr.c (unionfs_create_parent_dir): Fixed a bug related to
+	igrabbing lower inode.
+
+2003-09-22  Akshat Aranya  <aaranya@t6.fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_parse_options): Fix some memory leaks in error
+	paths.
+
+2003-09-22  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_read_super): Fixed error path.
+
+2003-09-22  Erez Zadok  <ezk@ulkesh.fsl.cs.sunysb.edu>
+
+	* match-malloc.pl: document this script with a procedure telling
+	how to use malloc debugging.  Use -DFIST_MALLOC_DEBUG from now on.
+
+2003-09-22  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* fist.h, main.c, subr.c: turned off MEMORY_DEBUG.
+
+2003-09-22  Puja Gupta  <puja@t1.fsl.cs.sunysb.edu>
+
+	* main.c (unionfs_read_super): Memory fix.
+
+2003-09-22  Puja Gupta  <puja@mooby.fsl.cs.sunysb.edu>
+
+	* inode.c, dentry.c, super.c: Memory Leak Checks.
+
+2003-09-22  Erez Zadok  <ezk@agora.fsl.cs.sunysb.edu>
+
+	* subr.c: add transcation counter to malloc/free debugging.
+
+	* match-malloc.pl: perl script to parse log output from
+	KMALLOC/KFREE macros, and report leaks etc.
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Puja, Hari, Jay.
+
+	* inode.c (unionfs_lookup): changed the dput location of hidden
+	whiteout dentry in the code.
+
+2003-09-22  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* subr.c (check_empty): added list_del.
+
+	* inode.c (unionfs_lookup): kfree moved at out.
+	(unionfs_unlink_whiteout): added kfree.
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Puja, Hari, Jay
+
+	* subr.c (create_parent_dir()): added support for left to right
+	copy up.  Could be used in unionfs_link()
+
+2003-09-21  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>, Jay, Hari, Mohammad.
+
+	* subr.c (check_whiteout): check for error on kmalloc.
+	(check_empty): moved kfree after 'out' label.
+
+	* main.c (unionfs_read_super): changed to dput superblock dentries on
+	error conditions.
+
+	* file.c (unionfs_filldir): check for error on kmalloc.
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Puja, Hari, Jay.
+
+	* inode.c (unionfs_link()): unlinking .wh.foo (if exists)
+	while creating link called foo
+
+2003-09-21  Puja Gupta <pugupta@cs.sunysb.edu>, Hari, Jay, Mohammad.
+
+	* inode.c (unionfs_mkdir, unionfs_mknod): dget hidden_dentry if not
+	calling create_parent_dir.
+
+	* inode.c (unionfs_mkdir, unionfs_mknod): removed extra dget before
+	removing whiteout.
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Hari, Jay, Puja.
+
+	* inode.c (unionfs_symlink()):  removed extra dget() in symlink
+
+2003-09-21  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* inode.c, dentry.c, unionfs.h: variable declaration re-shuffled to
+        compile on local machine.
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Hari, Jay, Puja
+
+	* subr.c (create_dir_whs()):  removed extra dget on hidden dentry
+
+	* file.c (unionfs_open()): calling branchput if get an error in
+	opening hidden dentry
+
+2003-09-21  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>, Jay, Hari, Mohammad.
+
+	* inode.c: removed extra bstart, and comments.
+
+	* file.c (unionfs_readdir): Added a bindex++ to {un,re}-reverted code.
+	Works now!! ;-)
+
+2003-09-21  Mohammad Nayyer Zubair  <zubair@t1.fsl.cs.sunysb.edu>, Hari, Jay, Puja.
+
+	* subr.c (create_whiteout_left()): synched reference counts for
+	hidden_dentry; added a dget for the hidden_dentry
+
+2003-09-21  Puja Gupta  <puja@t1.fsl.cs.sunysb.edu>, Jay.
+
+	* inode.c (unionfs_create): removed extra dget, dput for vfs_rename.
+	Removed extra dputs, d_drop on error.
+
+2003-09-21  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* subr.c (unionfs_create_parent_dir): removed extra dput on error
+	in lookup.
+	(create_whiteout_left): mode set to create whiteout.
+	(delete_whiteouts): removed dput on NULL hidden_dentry.
+
+2003-09-20  Mohammad Nayyer Zubair  <zubair@mooby.fsl.cs.sunysb.edu> Puja, Jay
+
+	* inode.c:  removed all "dtohd_index(dentry, bindex) = NULL" references and any
+	extra dputs
+
+	* subr.c:  modified code in troublesome create_whiteout_left() function.
+	Removed extra dgets on the parent and dputting the hidden dentry
+
+2003-09-20  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* subr.c: added branchput for branchgets.
+
+	* print.c (fist_checkinode): fixed the count print condition.
+
+	* inode.c (unionfs_unlink_whiteout): changes to dget, notify_change.
+	match dget and dput.
+
+2003-09-20  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Makefile (tags): target for tags
+
+	* inode.c (unionfs_unlink_whiteout): Refcount fix.
+
+2003-09-20  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_readdir): reverting back to file.c before changes
+	related to readdir_called flag.  Was going into an infinite loop due
+	to some condition.  The current version works fine.
+
+	* subr.c (create_dir_whs_filldir): replaced "return err" with
+	"goto out", which was causing an infinite loop.
+	(check_whiteout, delete_whiteouts): replaced 'ret' with err.
+
+2003-09-19  Puja Gupta  <puja@icon.fsl.cs.sunysb.edu>
+
+	* subr.c (create_dir_whs): added filldir_called flag.
+
+2003-09-19  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>, Jay, Hari, Mohammad.
+
+	* subr.c (check_empty): check if filldir is called or not.
+
+2003-09-19  Harikesavan Pathangi Krishnan  <hari@t1.fsl.cs.sunysb.edu>, Jay, Chip, Puja, Mohammad
+
+	* subr.c (check_empty): Added a flag field in the callback
+	structure that makes readdir call once again if all the contents
+	of the directory are not read.
+
+2003-09-19  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_release): free resources on file close.
+
+	* file.c (unionfs_filldir): Print a warning on any duplicate, but
+	don't return -EIO.
+
+	* subr.c (create_whiteout_left): fix a refcount leak
+
+2003-09-19  Mohammad Nayyer Zubair  <zubair@mooby.fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_filldir()): fixed the rm -Rf (-EIO, ENOTEMTPY
+	error) cases.  return -EIO ONLY when get a 'foo' and 'foo' exists
+	in the same directory, which would indicate corruption in the file
+	system. Before were returning -EIO ALSO if filldir gets a
+	'.wh.foo' and 'foo', latter being in the linked list already
+
+2003-09-17  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>, Hari, Mohammed.
+
+	* Makefile: Changing back to old file.
+
+	* subr.c (create_whiteout_left): removed dput, hidden_dentry == NULL.
+
+	* inode.c (do_rename): If error, make hidden_dentry NULL.
+	(unionfs_rename_all): copyup file on err = -EROFS.
+
+	* unionfs.h: added copyup_dentry.
+
+	* subr.c (unionfs_copyup_dentry): added this function, called from
+	setattr.
+	(unionfs_copyup_file): modified, calls copyup_dentry internally. Added
+	checks before kfree.
+
+	* inode.c (unionfs_setattr): calls copyup when trying to setattr for a
+	RO branch.
+
+	* fist.h (FISTBUG): imported from ncryptfs.
+
+2003-09-17  Harikesavan Pathangi Krishnan  <hari@t1.fsl.cs.sunysb.edu>
+
+	* inode.c: Fixed the bug related to creation of whiteouts on the
+	leftmost branch when a directory on that branch is rmdir'ed.
+
+2003-09-16  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* subr.c: fixed indentation for readdir actors
+
+	* inode.c (unionfs_rmdir): create_whiteout can just not do anything
+
+	* unionfs.h (itohi, dtohd): Reference count check before returning
+	to user space.
+
+2003-09-16  Puja Gupta  <puja@a-rh8.fsl.cs.sunysb.edu>, Hari, Mohammad.
+
+	* inode.c (unionfs_create): removed a dget, was giving a seg fault.
+	(unionfs_lookup): error check for lookup_one_len added.
+	(unionfs_rmdir_all): checking if rmdir failed on leftmost, and if it
+	had whiteouts, remove them, and call vfs_rmdir again, to create
+	whiteout.
+
+2003-09-16  Mohammad Nayyer Zubair  <zubair@t6.fsl.cs.sunysb.edu> Hari <hari@fsl.cs.sunysbe.du>
+
+	* main.c (unionfs_interpose()):  removed unnecessary fist_prints()
+
+2003-09-16  Mohammad Nayyer Zubair  <zubair@t6.fsl.cs.sunysb.edu> Hari <hari@fsl.cs.sunysbe.du>
+
+	* print.c (fist_print_dentry() and fist_print_inode()): removed
+	the anding code when printing the mode of the inode. Was printing
+	a negative mode value.
+
+2003-09-15  Puja Gupta  <puja@a-rh8.fsl.cs.sunysb.edu>, Hari, Mohammed.
+
+	* subr.c: fput for copied up file not required.
+
+	* print.c: print level 9 changed to 8.  Level 9 doesn't get printed.
+
+	* unionfs.h (IS_COPYUP_ERR, IS_WRITE_FLAG): Added.
+
+	* subr.c (unionfs_copyup_file): Checks added, replaced variables, fixed.
+
+	* inode.c (unionfs_permission): One code for files and directories.
+	Error bypassed for -EROFS, but not for leftmost branch.
+
+	* file.c (unionfs_open): Check added for RO partition, and call copyup.
+
+2003-09-15  Mohammad Nayyer Zubair  <zubair@t6.fsl.cs.sunysb.edu> Hari <hari@fsl.cs.sunysbe.du>
+
+	* inode.c (unionfs_mknod): done. removes whiteout if
+	present. format similar to unionfs_mkdir(). Tested.
+
+2003-09-14  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* inode.c (do_rename): Fixed parent directory for lookup of whiteout.
+	(unionfs_rename_whiteout): Added case for DELETE_WHITEOUT for rename.
+        (unionfs_rename): Check destination->inode before S_ISDIR.
+
+2003-09-14  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_filldir): Remove a duplicate from the list if
+	filldir fails.
+
+	* dentry.c (unionfs_d_revalidate, unionfs_d_compare, unionfs_d_hash):
+	Turned into utility functions for printing to reduce volume of debug
+	output.
+
+2003-09-14  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_rename_all): fix for bindex counter.
+	(unionfs_rename_all): check if error not occured in bstart of
+	destination.
+	(unionfs_rename_all): whiteout is always create in the bstart of
+	source, not to go to left of it.
+
+2003-09-14  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Detect EIO on single directories by doing duplicate elimination
+	routine.
+
+2003-09-13  Puja Gupta  <puja@t3.fsl.cs.sunysb.edu>, Jay.
+
+	* inode.c: added dput for hidden_dentry, whiteout_dentry that
+	are not used after lookup.
+
+	* subr.c: added dput for hidden_dentry, whiteout_dentry that
+	are not used after lookup.
+
+2003-09-13  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* PASSERT is for pointers.  ASSERT is for non-pointer conditions.
+
+2003-09-12  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* main.c: Sanity checks on flag=.
+
+	* subr.c (create_whiteout_left): Balanced a dput w/ a dget.
+
+	* print.c: exit should be level 5, not 4.  hidden_dentries/inodes
+	are level 9 instead of 8.
+
+	* Changed ASSERT to Oops when the pointer is poisoned.
+
+	* Changed ASSERT(foo != NULL) to ASSERT(foo)
+
+	* Default flag is 0x0.
+
+2003-09-11  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>, Hari, Zubair, Jay.
+
+	* inode.c (unionfs_create, unionfs_symlink): whiteouts truncated
+	to zero and ctime updated.
+
+	* unionfs.h: added flags COPYUP_OWNER, COPYUP_FS_MOUNTER,
+	redefined flags.
+
+	* inode.c: unlock parent added.
+
+	* file.c (unionfs_open): check for error and call copyup on EROFS.
+
+	* inode.c (unionfs_unlink): changed the function like rmdir. Used
+	rename instead of unlink, create for whiteouts.
+	(unionfs_mkdir): restructured code.
+
+	* unionfs.h (GLOBAL_ERR_PASSUP): removed DELETE_ERR_PASSUP.
+	GLOBAL_ERR_PASSUP indicates whether to pass error back or create
+	whiteouts/try again.
+
+	* inode.c (unionfs_create, unionfs_symlink, unionfs_link):
+	restructured changed *_ERR_PASSUP to GLOBAL_ERR_PASSUP.
+
+	* unionfs.h (GLOBAL_ERR_PASSUP): added, for all functions,
+	whether, on error, should passup or try to make up for error
+	encountered.
+
+	* inode.c (unionfs_symlink): updating bstart, bend for symlink
+	create.  Restructured the code.
+
+2003-09-11  Mohammad Nayyer Zubair  <zubair@t6.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_symlink): done. removes whiteout if
+	present. same format as in unionfs_create()
+
+	* inode.c (unionfs_link): creating destination path in source's
+	branch instead of vice versa
+
+	* inode.c (unionfs_rmdir_all): removed unneccessary d_drop()
+	call. unionfs_rmdir() calls it at the end
+
+2003-09-10  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_rmdir): Split into several functions.
+
+	* subr.c (delete_whiteouts): Delete all whiteouts in
+	a given directory in a given branch.
+
+	* subr.c (check_empty): Check if a directory is empty.
+
+2003-09-10  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>, Hari.
+
+	* unionfs.h: unionfs_interpose now returns void.
+
+	* subr.c (unionfs_partial_lookup): removed extra dput.
+	unionfs_reinterpose now returns void.
+
+	* main.c (unionfs_reinterpose): is now a void function and igrab
+	was called twice for already existing hidden inode. Fixed.
+
+	* file.c (single_branch_filldir): removed fist_dprint printed
+	extra newline character on commandline during readdir.
+
+	* unionfs.h (COPYUP_CURRENT): removed multiple definition.
+
+2003-09-09  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* subr.c (unionfs_full_lookup): Removed this function, was similar
+	to unionfs_partial_lookup.
+
+	* inode.c (unionfs_unlink): added if-else for three different
+	options for unlink, and also for error handling (passup or
+	whiteout). Replaced unionfs_full_lookup with
+	unionfs_partial_lookup (Both functions were same, just change in
+	name).  Added dget, dput at appropriate places.
+
+	* unionfs.h (DELETE_FIRST, DELETE_WHITEOUT, DELETE_ERR_PASSUP):
+	added, and removed all other unlink flags.
+
+2003-09-09  Mohammad Nayyer Zubair  <zubair@t6.fsl.cs.sunysb.edu> Hari <hari@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_lookup):  returning EIO for directory whiteout.
+
+2003-09-02 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu> Hari <hari@fsl.cs.sunysb.edu>
+
+	* inode.c: mkdir and create revisted, restructured and tested
+
+2003-09-08  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_write): Fixed positioning code.
+
+2003-09-07  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_create): added dget, get_parent, double_lock
+	and error check for vfs_rename of whiteouts. Added d_drop for any
+	negative dentry at the end of function.
+	(unionfs_mkdir): added error check for vfs_unlink of whiteouts,
+	unionfs_interpose, create_dir_whs.  Removed multiple unlock_dir.
+
+	* subr.c (create_dir_whs_filldir, create_whiteout_left):
+	changed char name[PATH_MAX] to char *name.
+
+	* inode.c (unionfs_create, unionfs_lookup, unionfs_unlink)
+	(unionfs_mkdir): changed char name[PATH_MAX] to char *name.
+	(unionfs_rmdir): removed unused name, wh_name.
+
+2003-09-06  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_create): reverted back to the loop for create
+	from bstart to zeroth branch.
+
+2003-09-02 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c: file to file rename done.
+
+	* major items left: dir to dir rename
+
+	* minor items left: mknod, symlink
+
+2003-09-05  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c (unionfs_filldir, single_branch_filldir): Removed memory
+	leak for debug output in filldirs.
+	(unionfs_readdir): Return -failure from filldir (previously our
+	filldir had no error propagation).
+
+	* ioctls via extended attributes works.
+
+	* branchman.c (unionfs_ioctl_delbranch): Don't let people delete
+	the last remaining branch.  It would be cooler if we could, but
+	probably not worth all the effort to make the root dentry behave
+	properly when there is nothing underneath it.
+
+	* file.c: Removed branch management functions.
+
+	* inode.c): xattr functions.
+
+	* branchman.c: Branch management functions.
+
+2003-09-03  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_clear_inode): Fixed cleanup of stale inodes.
+
+	* fist.h (ASSERT2): Macro to print out caller when we fail.
+
+	* Changed ASSERT2's to ASSERT, since they weren't really being
+	used as an ASSERT2.
+
+	* unionfs.h (itohi, dtohd): Converted to a function, added an
+	ASSERT2 to make sure we don't underflow the array.
+
+2003-09-02 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* subr.c: removed the unnecessary vfs_rename() function call in
+	create_whiteout_left(). Doing vfs_create() directly.
+
+	* inode.c: fixes in lookup(). Started on unionfs_rename().
+
+
+2003-09-01 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* subr.c: added function int remove_whiteouts(dentry_t *dentry,
+	dentry_t *hidden_dentry, int bindex)
+	Called by unionfs_rmdir(). Does vfs_readdir() and then unlinks all
+	whiteouts entries in it.
+
+2003-09-01  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Updated CUR_MAX_BRANCH and MOUNT_FLAG.
+
+	* dentry.c (unionfs_d_revalidate): Make negative dentries that
+	just turned negative stale.
+
+	* inode.c (unionfs_inode_revalidate): Make negative inodes stale.
+
+	* stale_inode.c: Functions to make a magic stale inode.
+
+2003-09-01 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c: unionfs_mkdir() done and works as per updated design.
+	Creating whiteout entries for all entires to the right. Details on
+	this are in the updated function_description.html file
+
+	* file.c: a separate filldir function for single branch directory.
+	Ignoring whiteout entries.
+
+	* subr.c: added a function: int create_whs_right(dentry_t *dentry,
+	int cur_index) Does a vfs_readdir on all directories starting from
+	cur_index + 1 and creates whiteout entries in cur_index (called in
+	unionfs_mkdir()). Details on this are in the updated
+	function_description.html file
+
+	preliminary cases are working as expected
+
+	Left: rename, mknod, symlink.
+
+2003-09-01  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Add branch ioctl and trimmed unionfs_dir_fops.
+
+	* fist.h: Structure for add branch ioctl.
+
+	* fist_ioctl.c: Add branch and cleaner branchcount ioctl.
+
+2003-08-31  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* dentry.c (unionfs_d_revalidate): Do revalidation of dentries,
+	we now can remove the leftmost branch and expose old contents.
+
+2003-08-27 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c: unionfs_unlink() implemented as per new design specs
+	(ignoring intermiate directories for now)
+
+	* subr.c: added create_whiteout_left(dentry, index) function:
+	creates a whiteout in index, on error it proceeds to the left.
+
+	* file.c: in fill_dir() ignoring whiteout entries
+
+	* Left: mkdir, mknod, symlink, rmdir, rename
+
+2003-08-27  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* Branch removal sort of works.
+
+2003-08-27 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c: unionfs_create() implemented as per new design specs.
+	If found a .wh.foo entry, vfs_rename it to foo.
+
+	* inode.c: unionfs_lookup() implemented as per new design specs.
+	If found a whiteout entry, just stop lookup
+
+	* inode.c: unionfs_link() implemented as per new design specs
+
+	* inode.c: unionfs_setattr() implemented as per new design specs
+
+	* inode.c: unionfs_permission() implemented as per new design specs.
+
+	* file.c: calling unionfs_copyup_file() in unionfs_open() if open
+	with specified flags fails with the current underlying file
+
+	* subr.c:  fixes in unionfs_copyup_file()
+
+	* unionfs.h: modified mount time flags
+
+	* Still left (according to new specs): mkdir, symlink, mknod,
+	unlink, rmdir, rename hard.
+
+2003-08-26  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_inode_revalidate): Refresh inode from lower level.
+
+	* fist_ioctl.c: Increment super generation number.
+
+	* file.c (unionfs_ioctl_incgen): Increment super generation number.
+
+2003-08-20  Charles P. Wright  <cwright@fsl.cs.sunysb.edu>
+
+	* file.c: Branch reference counters updated on open/close.  Need
+	to figure out how do to update them when a unionfs directory
+	becomes the cwd of a process.
+
+	* doit.sh: Source doitopts or doitopts.`uname -n` so different
+	developers can have different setups, w/o changing CVS.
+
+	* unionfs.h: Added generation number to super block, inode, and dentries.
+
+	* attach.c: Not used.
+
+2003-08-13  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* subr.c: some fixes in unionfs_copyup_file() (untested yet)
+
+	* file.c: calling unionfs_copyup_file() if write() fails on the
+	leftmost file.  Failure could result because of read-only
+	permissions on the file so probably should do copy up only if
+	branch is mounted RO.
+
+	* unionfs.h: modified definition for unionfs_copyup_file()
+
+2003-08-13  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* subr.c: added function: unionfs_copyup_file(inode_t *dir,
+	dentry_t *dentry, int oldbindex, int newbindex) first does
+	recursive directory creation, then does vfs_create() and then
+	reads PAGE_SIZE bytes from old file to new file
+
+	* subr.c, inode.c: moved useful functions:
+	unionfs_create_parent_dir() and unionfs_partial_lookup() to subr.c
+	from inode.c
+
+	* unionfs.h: definition for unionfs_copyup_file
+
+	* Makefile: added subr.o to the list of OBJS
+
+2003-08-13  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* unionfs.h: added definition for unionfs_create_whiteout.
+
+2003-08-12  Puja Gupta  <puja@mooby.fsl.cs.sunysb.edu>
+
+	* inode.c: reverting back to old copy without changes to rename.
+
+2003-08-04  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* unionfs.h (UNLINK_WHITEOUT, UNLINK_ALL_FIRST, UNLINK_ERR): New flags
+	for handling various unlink options.
+
+	* main.c (unionfs_parse_options): fixed check for getting mount flags.
+
+	* inode.c (unionfs_unlink): added unlink for whiteout. If flag is set
+	for UNLINK_WHITEOUT, try to create whiteout in branches to left, create
+	recursive subdirectories.  Also added check for various flags for
+	unlink_first or unlink_all, and how to handle error on unlink.
+	(unionfs_create_parent_dir): check in for loop fixed.
+
+2003-08-04  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* file.c: readdir is working fine with the hashtable in the private
+	data of unionfs file.
+	diff -ru on gcc tarball is successful
+
+	* inode.c: implemented option 2 of link(), recursively creating source
+	path in destination branch when branches are different
+
+	* unionfs.h: added two mount time flags
+	LINK_EXDEV: just return -EXDEV when dentries are on different branches
+	LINK_RECURSIVE: recursively create source path in target branch
+
+2003-07-31  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* file.c: readdir/filldir's linked list converted into a hashtable
+	of size HASHTABLE_SIZE Duplicate elimation is working. Still to
+	test the gcc tarball.
+
+	* unionfs.h: converted dir_list list head to an array of list
+	heads of size HASHTABLE_SIZE
+
+
+2003-07-30  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* unionfs.h: changed to new flag, CREATE_RW_ERR, UNLINK_WHITEOUT,
+	UNLINK_ERR.  Function definition for unionfs_partial_lookup.
+
+	* inode.c (unionfs_partial_lookup): added, called from
+	unlink. Looks up the remaining files that were not looked up in
+	unionfs_lookup.
+	(unionfs_unlink): code now transferred to unionfs_partial_lookup.
+	(unionfs_create): flag name is CREATE_RW_ERR.
+
+	* inode.c (unionfs_create): changed to new flag values.
+
+	* unionfs.h (IS_SET): changed flags to be exclusive. Also, changed
+	IS_SET to work on place value of bit.
+
+2003-07-27  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* file.c (unionfs_open): removed ftohd_index(file, bindex) = NULL.
+	unionfs_getdents_callback now has file_t *.
+	(unionfs_filldir, unionfs_readdir): changed the global list_head
+	for duplicate elimination to have a list_head in private data of
+	file. So, the list of name, namelen is stored in this new
+	list_head, and compared against this.
+
+	* unionfs.h: added struct filldir_node to private data of file.
+	Thus, every file has unique and seperate list for readdir.
+
+	* doit.sh: "flag=" instead of "flags=".
+
+2003-07-28  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c: unionfs_link's option 1 done. Return -EXDEV if old and
+	new dentries are in different branches / starting option 2: if
+	different branches, creating destination path in the source branch
+
+	* unionfs.h: added a simple function which returns the sum of all
+	the underlying inodes' nlink value
+
+	* inode.c: calling the above function wherever nlinks value was
+	being set
+
+2003-07-24  Puja Gupta  <puja@t2.fsl.cs.sunysb.edu>
+
+	* unionfs.h: #defines for MOUNT_FLAG, CREATE_PASSUP,
+	CREATE_RW_ERR_PASSUP, CREATE_TRY_LEFT and IS_SET.
+
+	* main.c (unionfs_parse_options): parse the mount time flag and
+	initialize it.
+
+	* inode.c (unionfs_create): added handling of partial errors to
+	handle various cases: 1) Try to Left (default), 2) PassUp, 3) If
+	EPERM on RW branch, PassUp.
+
+	* doit.sh: changed mount options to include "flag=".
+
+2003-07-24  Puja Gupta  <pugupta@cs.sunysb.edu>
+
+	* inode.c (unionfs_setattr): added check for NULL hidden dentry.
+	(unionfs_inode_revalidate): added ASSERT2 for inode.
+
+2003-07-24  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* file.c: in unionfs_open, now only opening leftmost file instead
+	of opening all of the hidden files.  Opening all directories
+	though.
+
+	* inode.c: setattr function done. Assigning 'correct' value to the
+	n_links variable in the unionfs inode.  In inode_revalidate
+	function assigning 'correct' value to the n_links variable in the
+	unionfs inode.
+
+	* main.c: just moved sum_nlinks variable to the beginning of the
+	  interpose function. diff -ru on a randomly distributed
+	  (recursive) gcc tarball is failing. Some duplicate files are
+	  being listed.  'ls' on the directory containing above duplicate
+	  files also lists the files twice. Files have same unionfs inode.
+	  Checking out whats happening.
+
+2003-07-22  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* main.c: in interpose() added lines which compute the sum of the
+	nlinks of the underlying inodes and assigns this sum to the
+	unionfs inode.
+
+	* inode.c: in permission() added check for a null hidden inode
+
+2003-07-22  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* unionfs.h: init_file_array is now init_ftohf_ptr,
+	init_inode_array is now init_itohi_ptr, init_sb_array is now
+	init_stohs_ptr, added init_stohiddenmnt_ptr, init_dentry_info,
+	init_dentry_array is now init_dtohd_ptr.  All this makes sure that
+	all allocated memory is initialized to zero before its being used.
+
+	* super.c (unionfs_read_inode): init_inode_array is now init_itohi_ptr.
+
+	* main.c (unionfs_parse_options): init_priv_inode is now
+	init_dentry_info.
+	(unionfs_parse_options): memset, init_stohs_ptr, init_stohiddenmnt_ptr
+	added for initialize memory allocated to NULL.
+	(unionfs_read_super): init_dtohd_ptr added to initialize to NULL.
+
+	* inode.c (unionfs_lookup): init_dentry_array is now init_dtohd_ptr.
+
+	* file.c (unionfs_open): added init_ftohf_ptr, setting underlying
+	file pointer to NULL.
+
+2003-07-21  Puja Gupta <pugupta@cs.sunysb.edu>
+
+	* inode.c (unionfs_create): get rid of the hidden dentry that lead
+	to an unsuccessful attempt to create. Update bstart, bend
+	accordingly.
+	(unionfs_create_parent_dir): added "count--" for proper pointer
+	position. Updated private data, bstart for the dentry and inode of
+	intermediate directories created.  Also, updated bend for the
+	negative dentry returned from this function to create.
+
+	* main.c (unionfs_interpose): removed comments and extra line
+	spaces.
+
+2003-07-20  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* unionfs.h (MAX_DIR_CREATE): added MAX_DIR_CREATE for the number of
+	directories allowed to be created in recursive subdir creation.
+	Should be dynamic.
+
+	* inode.c (unionfs_create): changed to handle partial error by
+	recursively creating directory to left branches.
+	(unionfs_create_parent_dir): added this function, it creates
+	hidden directory path for a given parent inode and dentry in
+	specified branch. (Still to test)
+
+2003-07-15  Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* inode.c <unionfs_lookup>: Found a bug while mounting unionfs on
+	a randomly distributed (recursive) am-utils tarball on 5 branches.
+	Basically we were not memsetting the array of pointers to hidden
+	objects after kmallocing a CUR_MAX_BRANCH number of pointers for
+	dentry, inode, file and sb.  They were assumed to be NULL in
+	lookup and hence were not explicitly set to NULL in the array when
+	requireed.
+
+	* unionfs.h: Added macros which initialize hidden arrays to NULL
+
+2003-07-15  Puja Gupta  <puja@mooby.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_lookup): added few debug statements.
+	(unionfs_unlink): Since lookup for file had just the leftmost
+	entry, unlink now internally calls lookup for all remaining
+	branches.  And the current policy for unlink is, unlink
+	all. (Tested).
+
+	* unionfs.h: added definition for unionfs_reinterpose.
+
+	* main.c (unionfs_reinterpose): This new function takes a dentry
+	with leftmost hidden inode interposed, and reinterposes the newly
+	lookedup hidden inodes in remaining branches.  Called from
+	unionfs_unlink.
+
+	* mount_tarball.sh, mount_tarball_random.sh: These scripts are now
+	moved to ../tools directory.
+
+2003-07-13  Puja Gupta  <puja@mooby.fsl.cs.sunysb.edu>
+
+	* inode.c (unionfs_lookup): fixed initialization of negative dentry.
+
+	* print.c (fist_print_inode), (fist_print_file),(fist_print_dentry),
+	(fist_print_sb): made more readable, pointers now printed with %p.
+
+2003-07-10  Puja Gupta  <puja@idol.fsl.cs.sunysb.edu>
+
+	* super.c (unionfs_statfs): check for duplicate superblock data being
+	added.
+	(unionfs_umount_begin): check for NULL hidden_sb, hidden_sb->s_op.
+
+2003-07-10 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* print.c: fist_print_inode(): prints underlying inodes if any.
+	fist_print_dentry(): prints underlying dentries if any.
+	fist_print_files(): prints underlying files if any.
+	fist_print_superblock(): prints underlying sbs if any.
+
+2003-07-10 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* print.c: improved the formatting of printing inode, dentry and
+	sb
+
+	* main.c, inode.c removed unneccessary lines printing debugging
+	info in interpose()
+
+2003-07-13 Mohammad Nayyer Zubair <mzubair@ic.sunysb.edu>
+
+	* file.c inode.c: removed debugging info lines
+
+	* created mount_tarball.sh.  right now, distributes an equal
+		number of files/dirs among N branches tar-ing am-utils
+		through unionfs mount point gives same package buildall
+		through mount point gives same structure/files
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/commonfops.c linux-2.6.20-sabayon-r1/fs/unionfs/commonfops.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/commonfops.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/commonfops.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,709 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: commonfops.c,v 1.61 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+/* We only need this function here, but it could get promoted to unionfs.h, if
+ * other things need a generation specific branch putting function. */
+static inline void branchput_gen(int generation, struct super_block *sb,
+				 int index)
+{
+	struct putmap *putmap;
+
+	if (generation == atomic_read(&stopd(sb)->usi_generation)) {
+		branchput(sb, index);
+		return;
+	}
+
+	BUG_ON(stopd(sb)->usi_firstputmap > generation);
+	BUG_ON(stopd(sb)->usi_lastputmap < generation);
+
+	putmap =
+	    stopd(sb)->usi_putmaps[generation - stopd(sb)->usi_firstputmap];
+	BUG_ON(index < 0);
+	BUG_ON(index > putmap->bend);
+	BUG_ON(putmap->map[index] < 0);
+	branchput(sb, putmap->map[index]);
+	if (atomic_dec_and_test(&putmap->count)) {
+		stopd(sb)->usi_putmaps[generation - stopd(sb)->usi_firstputmap]
+		    = NULL;
+		dprint(PRINT_DEBUG, "Freeing putmap %d.\n", generation);
+		KFREE(putmap);
+	}
+}
+
+static char *get_random_name(int size, unsigned char *name)
+{
+	int i;
+	int j;
+	unsigned char *tmpbuf = NULL;
+
+	if (size <= WHLEN)
+		return NULL;
+
+	if (!name)
+		name = KMALLOC(size + 1, GFP_KERNEL);
+	if (!name) {
+		name = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	strncpy(name, WHPFX, WHLEN);
+
+	tmpbuf = KMALLOC(size, GFP_KERNEL);
+	if (!tmpbuf) {
+		KFREE(name);
+		name = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+
+	get_random_bytes((void *)tmpbuf, (size - 3) / 2);
+
+	j = WHLEN;
+	i = 0;
+	while ((i < (size - 3) / 2) && (j < size)) {
+		/* get characters in the 0-9, A-F range */
+
+		name[j] =
+		    (tmpbuf[i] % 16) <
+		    10 ? (tmpbuf[i] % 16) + '0' : (tmpbuf[i] % 16) + 'a';
+		j++;
+		if (j == size)
+			break;
+		name[j] =
+		    (tmpbuf[i] >> 4) <
+		    10 ? (tmpbuf[i] >> 4) + '0' : (tmpbuf[i] >> 4) + 'a';
+		j++;
+
+		i++;
+	}
+
+	name[size] = '\0';
+
+      out:
+	KFREE(tmpbuf);
+	return (name);
+
+}
+
+static int copyup_deleted_file(struct file *file, struct dentry *dentry,
+			       int bstart, int bindex)
+{
+	int attempts = 0;
+	int err;
+	int exists = 1;
+	char *name = NULL;
+	struct dentry *tmp_dentry = NULL;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+
+	print_entry_location();
+
+	/* Try five times to get a unique file name, fail after that.  Five is
+	 * simply a magic number, because we shouldn't try forever.  */
+	while (exists) {
+		/* The first call allocates, the subsequent ones reuse. */
+		name = get_random_name(UNIONFS_TMPNAM_LEN, name);
+		err = -ENOMEM;
+		if (!name)
+			goto out;
+		//XXX: Why do we do this every time? bstart never changes?
+		hidden_dentry = dtohd_index(dentry, bstart);
+
+		tmp_dentry = LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+					    UNIONFS_TMPNAM_LEN);
+		err = PTR_ERR(tmp_dentry);
+		if (IS_ERR(tmp_dentry))
+			goto out;
+		exists = tmp_dentry->d_inode ? 1 : 0;
+		DPUT(tmp_dentry);
+
+		err = -EEXIST;
+		if (++attempts > 5)
+			goto out;
+	}
+
+	err = copyup_named_file(dentry->d_parent->d_inode, file, name, bstart,
+				bindex, file->f_dentry->d_inode->i_size);
+	if (err)
+		goto out;
+
+	/* bring it to the same state as an unlinked file */
+	hidden_dentry = dtohd_index(dentry, dbstart(dentry));
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+	err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
+	unlock_dir(hidden_dir_dentry);
+
+      out:
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_file_revalidate(struct file *file, int willwrite)
+{
+	struct super_block *sb;
+	struct dentry *dentry;
+	int sbgen, fgen, dgen;
+	int bindex, bstart, bend;
+	struct file *hidden_file;
+	struct dentry *hidden_dentry;
+	int size;
+
+	int err = 0;
+
+	print_entry(" file = %p", file);
+
+	dentry = file->f_dentry;
+	lock_dentry(dentry);
+	sb = dentry->d_sb;
+	unionfs_read_lock(sb);
+	if (!unionfs_d_revalidate(dentry, NULL) && !d_deleted(dentry)) {
+		err = -ESTALE;
+		goto out;
+	}
+	print_dentry("file revalidate in", dentry);
+
+	sbgen = atomic_read(&stopd(sb)->usi_generation);
+	dgen = atomic_read(&dtopd(dentry)->udi_generation);
+	fgen = atomic_read(&ftopd(file)->ufi_generation);
+
+	BUG_ON(sbgen > dgen);
+
+	/* There are two cases we are interested in.  The first is if the
+	 * generation is lower than the super-block.  The second is if someone
+	 * has copied up this file from underneath us, we also need to refresh
+	 * things. */
+	if (!d_deleted(dentry) &&
+	    ((sbgen > fgen) || (dbstart(dentry) != fbstart(file)))) {
+		/* First we throw out the existing files. */
+		bstart = fbstart(file);
+		bend = fbend(file);
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			if (ftohf_index(file, bindex)) {
+				branchput_gen(fgen, dentry->d_sb, bindex);
+				fput(ftohf_index(file, bindex));
+			}
+		}
+
+		if (ftohf_ptr(file)) {
+			KFREE(ftohf_ptr(file));
+			ftohf_ptr(file) = NULL;
+		}
+
+		/* Now we reopen the file(s) as in unionfs_open. */
+		bstart = fbstart(file) = dbstart(dentry);
+		bend = fbend(file) = dbend(dentry);
+
+		size = sizeof(struct file *) * sbmax(sb);
+		ftohf_ptr(file) = KZALLOC(size, GFP_KERNEL);
+		if (!ftohf_ptr(file)) {
+			err = -ENOMEM;
+			goto out;
+		}
+
+		if (S_ISDIR(dentry->d_inode->i_mode)) {
+			/* We need to open all the files. */
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				hidden_dentry = dtohd_index(dentry, bindex);
+				if (!hidden_dentry)
+					continue;
+
+				DGET(hidden_dentry);
+				mntget(stohiddenmnt_index(sb, bindex));
+				branchget(sb, bindex);
+
+				hidden_file =
+				    DENTRY_OPEN(hidden_dentry,
+						stohiddenmnt_index(sb, bindex),
+						file->f_flags);
+				if (IS_ERR(hidden_file)) {
+					err = PTR_ERR(hidden_file);
+					goto out;
+				} else {
+					set_ftohf_index(file, bindex,
+							hidden_file);
+				}
+			}
+		} else {
+			/* We only open the highest priority branch. */
+			hidden_dentry = dtohd(dentry);
+			if (willwrite && IS_WRITE_FLAG(file->f_flags)
+			    && is_robranch(dentry)) {
+				for (bindex = bstart - 1; bindex >= 0; bindex--) {
+
+					err = copyup_file(dentry->
+							  d_parent->
+							  d_inode,
+							  file,
+							  bstart,
+							  bindex,
+							  file->
+							  f_dentry->
+							  d_inode->i_size);
+
+					if (!err)
+						break;
+					else
+						continue;
+
+				}
+				atomic_set(&ftopd(file)->ufi_generation,
+					   atomic_read(&itopd(dentry->d_inode)->
+						       uii_generation));
+				goto out;
+			}
+
+			DGET(hidden_dentry);
+			mntget(stohiddenmnt_index(sb, bstart));
+			branchget(sb, bstart);
+			hidden_file =
+			    DENTRY_OPEN(hidden_dentry,
+					stohiddenmnt_index(sb, bstart),
+					file->f_flags);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				goto out;
+			}
+			set_ftohf(file, hidden_file);
+			/* Fix up the position. */
+			hidden_file->f_pos = file->f_pos;
+
+			memcpy(&(hidden_file->f_ra), &(file->f_ra),
+			       sizeof(struct file_ra_state));
+		}
+		atomic_set(&ftopd(file)->ufi_generation,
+			   atomic_read(&itopd(dentry->d_inode)->
+				       uii_generation));
+	}
+
+	/* Copyup on the first write to a file on a readonly branch. */
+	if (willwrite && IS_WRITE_FLAG(file->f_flags)
+	    && !IS_WRITE_FLAG(ftohf(file)->f_flags) && is_robranch(dentry)) {
+		dprint(PRINT_DEBUG,
+		       "Doing delayed copyup of a read-write file on a read-only branch.\n");
+		bstart = fbstart(file);
+		bend = fbend(file);
+
+		BUG_ON(!S_ISREG(file->f_dentry->d_inode->i_mode));
+
+		for (bindex = bstart - 1; bindex >= 0; bindex--) {
+			if (!d_deleted(file->f_dentry)) {
+				err =
+				    copyup_file(dentry->d_parent->
+						d_inode, file, bstart,
+						bindex,
+						file->f_dentry->
+						d_inode->i_size);
+			} else {
+				err =
+				    copyup_deleted_file(file, dentry, bstart,
+							bindex);
+			}
+
+			if (!err)
+				break;
+			else
+				continue;
+
+		}
+		if (!err && (bstart > fbstart(file))) {
+			bend = fbend(file);
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				if (ftohf_index(file, bindex)) {
+					branchput(dentry->d_sb, bindex);
+					fput(ftohf_index(file, bindex));
+					set_ftohf_index(file, bindex, NULL);
+				}
+			}
+			fbend(file) = bend;
+		}
+	}
+
+      out:
+	print_dentry("file revalidate out", dentry);
+	unlock_dentry(dentry);
+	unionfs_read_unlock(dentry->d_sb);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_open(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	int hidden_flags;
+	struct file *hidden_file = NULL;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *dentry = NULL;
+	int bindex = 0, bstart = 0, bend = 0;
+	int locked = 0;
+	int size;
+
+	print_entry_location();
+
+	ftopd_lhs(file) = KZALLOC(sizeof(struct unionfs_file_info), GFP_KERNEL);
+	if (!ftopd(file)) {
+		err = -ENOMEM;
+		goto out;
+	}
+	fbstart(file) = -1;
+	fbend(file) = -1;
+	atomic_set(&ftopd(file)->ufi_generation,
+		   atomic_read(&itopd(inode)->uii_generation));
+
+	size = sizeof(struct file *) * sbmax(inode->i_sb);
+	ftohf_ptr(file) = KZALLOC(size, GFP_KERNEL);
+	if (!ftohf_ptr(file)) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	hidden_flags = file->f_flags;
+
+	dentry = file->f_dentry;
+	dprint(PRINT_DEBUG, "dentry to open is %p\n", dentry);
+	lock_dentry(dentry);
+	unionfs_read_lock(inode->i_sb);
+	locked = 1;
+
+	bstart = fbstart(file) = dbstart(dentry);
+	bend = fbend(file) = dbend(dentry);
+
+	/* increment to show the kind of open, so that we can
+	 * flush appropriately
+	 */
+	atomic_inc(&itopd(dentry->d_inode)->uii_totalopens);
+
+	/* open all directories and make the unionfs file struct point to these hidden file structs */
+	if (S_ISDIR(inode->i_mode)) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_dentry = dtohd_index(dentry, bindex);
+			if (!hidden_dentry)
+				continue;
+
+			DGET(hidden_dentry);
+			mntget(stohiddenmnt_index(inode->i_sb, bindex));
+			hidden_file =
+			    DENTRY_OPEN(hidden_dentry,
+					stohiddenmnt_index(inode->i_sb, bindex),
+					hidden_flags);
+			if (IS_ERR(hidden_file)) {
+				err = PTR_ERR(hidden_file);
+				goto out;
+			}
+
+			set_ftohf_index(file, bindex, hidden_file);
+			/* The branchget goes after the open, because otherwise
+			 * we would miss the reference on release. */
+			branchget(inode->i_sb, bindex);
+		}
+	} else {
+		/* open a file */
+		hidden_dentry = dtohd(dentry);
+
+		/* check for the permission for hidden file.  If the error is COPYUP_ERR,
+		 * copyup the file.
+		 */
+		if (hidden_dentry->d_inode && is_robranch(dentry)) {
+			/* if the open will change the file, copy it up otherwise defer it. */
+			if (hidden_flags & O_TRUNC) {
+				int size = 0;
+
+				err = -EROFS;
+				/* copyup the file */
+				for (bindex = bstart - 1; bindex >= 0; bindex--) {
+					err =
+					    copyup_file(dentry->
+							d_parent->
+							d_inode, file,
+							bstart, bindex, size);
+					if (!err) {
+						break;
+					}
+				}
+				goto out;
+			} else {
+				hidden_flags &= ~(OPEN_WRITE_FLAGS);
+			}
+		}
+
+		DGET(hidden_dentry);
+		/* dentry_open will decrement mnt refcnt if err.
+		 * otherwise fput() will do an mntput() for us upon file close.
+		 */
+		mntget(stohiddenmnt_index(inode->i_sb, bstart));
+		hidden_file = DENTRY_OPEN(hidden_dentry,
+					  stohiddenmnt_index(inode->i_sb,
+							     bstart),
+					  hidden_flags);
+		if (IS_ERR(hidden_file)) {
+			err = PTR_ERR(hidden_file);
+			goto out;
+		} else {
+			set_ftohf(file, hidden_file);
+			branchget(inode->i_sb, bstart);
+		}
+	}
+
+      out:
+	/* freeing the allocated resources, and fput the opened files */
+	if (err < 0 && ftopd(file)) {
+		if (!locked)
+			unionfs_read_lock(file->f_dentry->d_sb);
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_file = ftohf_index(file, bindex);
+			if (hidden_file) {
+				branchput(file->f_dentry->d_sb, bindex);
+				/* fput calls dput for hidden_dentry */
+				fput(hidden_file);
+			}
+		}
+		if (!locked)
+			unionfs_read_unlock(file->f_dentry->d_sb);
+		KFREE(ftohf_ptr(file));
+		KFREE(ftopd(file));
+	}
+
+	print_file("OUT: unionfs_open", file);
+
+	if (locked) {
+		unlock_dentry(dentry);
+		unionfs_read_unlock(inode->i_sb);
+	}
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_file_release(struct inode *inode, struct file *file)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+	int bindex, bstart, bend;
+	int fgen;
+
+	print_entry_location();
+
+	checkinode(inode, "unionfs_release");
+
+	/* fput all the hidden files */
+	fgen = atomic_read(&ftopd(file)->ufi_generation);
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_file = ftohf_index(file, bindex);
+
+		if (hidden_file) {
+			fput(hidden_file);
+			unionfs_read_lock(inode->i_sb);
+			branchput_gen(fgen, inode->i_sb, bindex);
+			unionfs_read_unlock(inode->i_sb);
+		}
+	}
+	KFREE(ftohf_ptr(file));
+
+	if (ftopd(file)->rdstate) {
+		ftopd(file)->rdstate->uds_access = jiffies;
+		dprint(PRINT_DEBUG, "Saving rdstate with cookie %u [%d.%lld]\n",
+		       ftopd(file)->rdstate->uds_cookie,
+		       ftopd(file)->rdstate->uds_bindex,
+		       (long long)ftopd(file)->rdstate->uds_dirpos);
+		spin_lock(&itopd(inode)->uii_rdlock);
+		itopd(inode)->uii_rdcount++;
+		list_add_tail(&ftopd(file)->rdstate->uds_cache,
+			      &itopd(inode)->uii_readdircache);
+		mark_inode_dirty(inode);
+		spin_unlock(&itopd(inode)->uii_rdlock);
+		ftopd(file)->rdstate = NULL;
+	}
+	KFREE(ftopd(file));
+
+	checkinode(inode, "post unionfs_release");
+
+	print_exit_status(err);
+	return err;
+}
+
+long unionfs_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long err = 0;		/* don't fail by default */
+	struct file *hidden_file = NULL;
+	int val;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	/* check if asked for local commands */
+	switch (cmd) {
+	case FIST_IOCTL_GET_DEBUG_VALUE:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		val = get_debug_mask();
+		err = put_user(val, (int __user *)arg);
+		break;
+
+	case FIST_IOCTL_SET_DEBUG_VALUE:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = get_user(val, (int __user *)arg);
+		if (err)
+			break;
+		dprint(PRINT_DEBUG, "IOCTL SET: got arg %d\n", val);
+		if (val < 0 || val > PRINT_MAX) {
+			err = -EINVAL;
+			break;
+		}
+		set_debug_mask(val);
+		break;
+
+		/* add non-debugging fist ioctl's here */
+
+	case UNIONFS_IOCTL_BRANCH_COUNT:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = unionfs_ioctl_branchcount(file, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_INCGEN:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err = unionfs_ioctl_incgen(file, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_ADDBRANCH:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err =
+		    unionfs_ioctl_addbranch(file->f_dentry->d_inode, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_RDWRBRANCH:
+		if (!capable(CAP_SYS_ADMIN)) {
+			err = -EACCES;
+			goto out;
+		}
+		err =
+		    unionfs_ioctl_rdwrbranch(file->f_dentry->d_inode, cmd, arg);
+		break;
+
+	case UNIONFS_IOCTL_QUERYFILE:
+		/* XXX: This should take the file. */
+		err = unionfs_ioctl_queryfile(file, cmd, arg);
+		break;
+
+	default:
+		hidden_file = ftohf(file);
+
+		err = security_file_ioctl(hidden_file, cmd, arg);
+		if (err)
+			goto out;
+		err = -ENOTTY;
+		if (!hidden_file || !hidden_file->f_op)
+			goto out;
+		if (hidden_file->f_op->unlocked_ioctl) {
+			err =
+			    hidden_file->f_op->unlocked_ioctl(hidden_file, cmd,
+							      arg);
+		} else if (hidden_file->f_op->ioctl) {
+			lock_kernel();
+			err =
+			    hidden_file->f_op->ioctl(hidden_file->f_dentry->
+						     d_inode, hidden_file, cmd,
+						     arg);
+			unlock_kernel();
+		}
+	}			/* end of outer switch statement */
+
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+
+int unionfs_flush(struct file *file, fl_owner_t id)
+{
+	int err = 0;		/* assume ok (see open.c:close_fp) */
+	struct file *hidden_file = NULL;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+	if (!atomic_dec_and_test
+	    (&itopd(file->f_dentry->d_inode)->uii_totalopens))
+		goto out;
+
+	lock_dentry(file->f_dentry);
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_file = ftohf_index(file, bindex);
+
+		if (hidden_file && hidden_file->f_op
+		    && hidden_file->f_op->flush) {
+			err = hidden_file->f_op->flush(hidden_file, id);
+			if (err)
+				goto out_lock;
+			/* This was earlier done in the unlink_all function in unlink.c */
+			/* if there are no more references to the dentry, dput it */
+			if (d_deleted(file->f_dentry)) {
+				DPUT(dtohd_index(file->f_dentry, bindex));
+				set_dtohd_index(file->f_dentry, bindex, NULL);
+			}
+		}
+
+	}
+
+      out_lock:
+	unlock_dentry(file->f_dentry);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/COPYING linux-2.6.20-sabayon-r1/fs/unionfs/COPYING
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/COPYING	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/COPYING	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,373 @@
+This Unionfs-1.0 release is licensed under the terms of the GNU General
+Public License (GPL).
+
+For information on commercial licensing through the SUNY Research
+Foundation, contact Erez Zadok <ezk@cs.sunysb.edu>.
+
+Copyright (c) 2003-2006 Erez Zadok
+Copyright (c) 2003-2006 Charles P. Wright
+Copyright (c) 2005-2006 Josef Sipek
+Copyright (c) 2005      Arun M. Krishnakumar
+Copyright (c) 2005-2006 David P. Quigley
+Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+Copyright (c) 2003      Puja Gupta
+Copyright (c) 2003      Harikesavan Krishnan
+Copyright (c) 2003-2006 Stony Brook University
+Copyright (c) 2003-2006 The Research Foundation of State University of New York
+
+All rights reserved.
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/copyup.c linux-2.6.20-sabayon-r1/fs/unionfs/copyup.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/copyup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/copyup.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,737 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York*
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: copyup.c,v 1.78 2006/10/31 18:05:33 yiannos Exp $
+ */
+
+#include "unionfs.h"
+
+/*Not Working Yet*/
+static int copyup_xattrs(struct dentry *old_hidden_dentry,
+			 struct dentry *new_hidden_dentry)
+{
+	int err = 0;
+	ssize_t list_size = -1;
+	char *name_list = NULL;
+	char *attr_value = NULL;
+	char *name_list_orig = NULL;
+
+	print_entry_location();
+
+	list_size = vfs_listxattr(old_hidden_dentry, NULL, 0);
+
+	if (list_size <= 0) {
+		err = list_size;
+		goto out;
+	}
+
+	name_list = xattr_alloc(list_size + 1, XATTR_LIST_MAX);
+	if (!name_list || IS_ERR(name_list)) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+	list_size = vfs_listxattr(old_hidden_dentry, name_list, list_size);
+	attr_value = xattr_alloc(XATTR_SIZE_MAX, XATTR_SIZE_MAX);
+	if (!attr_value || IS_ERR(attr_value)) {
+		err = PTR_ERR(name_list);
+		goto out;
+	}
+	name_list_orig = name_list;
+	while (*name_list) {
+		ssize_t size;
+
+		//We need to lock here since vfs_getxattr doesn't lock for us.
+		mutex_lock(&old_hidden_dentry->d_inode->i_mutex);
+		size = vfs_getxattr(old_hidden_dentry, name_list,
+				    attr_value, XATTR_SIZE_MAX);
+		mutex_unlock(&old_hidden_dentry->d_inode->i_mutex);
+		if (size < 0) {
+			err = size;
+			goto out;
+		}
+
+		if (size > XATTR_SIZE_MAX) {
+			err = -E2BIG;
+			goto out;
+		}
+		//We don't need to lock here since vfs_setxattr does it for us.
+		err = vfs_setxattr(new_hidden_dentry, name_list, attr_value,
+				   size, 0);
+
+		if (err < 0)
+			goto out;
+		name_list += strlen(name_list) + 1;
+	}
+      out:
+	name_list = name_list_orig;
+
+	if (name_list)
+		xattr_free(name_list, list_size + 1);
+	if (attr_value)
+		xattr_free(attr_value, XATTR_SIZE_MAX);
+	/* It is no big deal if this fails, we just roll with the punches. */
+	if (err == -ENOTSUPP || err == -EOPNOTSUPP)
+		err = 0;
+	return err;
+}
+
+/* Determine the mode based on the copyup flags, and the existing dentry. */
+static int copyup_permissions(struct super_block *sb,
+			      struct dentry *old_hidden_dentry,
+			      struct dentry *new_hidden_dentry)
+{
+	struct iattr newattrs;
+	int err;
+
+	print_entry_location();
+
+	newattrs.ia_atime = old_hidden_dentry->d_inode->i_atime;
+	newattrs.ia_mtime = old_hidden_dentry->d_inode->i_mtime;
+	newattrs.ia_ctime = old_hidden_dentry->d_inode->i_ctime;
+	newattrs.ia_valid = ATTR_CTIME | ATTR_ATIME | ATTR_MTIME |
+	    ATTR_ATIME_SET | ATTR_MTIME_SET;
+	/* original mode of old file */
+	newattrs.ia_mode = old_hidden_dentry->d_inode->i_mode;
+	newattrs.ia_gid = old_hidden_dentry->d_inode->i_gid;
+	newattrs.ia_uid = old_hidden_dentry->d_inode->i_uid;
+	newattrs.ia_valid |= ATTR_FORCE | ATTR_GID | ATTR_UID | ATTR_MODE;
+	if (newattrs.ia_valid & ATTR_MODE) {
+		newattrs.ia_mode =
+		    (newattrs.ia_mode & S_IALLUGO) | (old_hidden_dentry->
+						      d_inode->
+						      i_mode & ~S_IALLUGO);
+	}
+
+	err = notify_change(new_hidden_dentry, &newattrs);
+
+	print_exit_status(err);
+	return err;
+}
+
+int copyup_dentry(struct inode *dir, struct dentry *dentry,
+		  int bstart, int new_bindex,
+		  struct file **copyup_file, loff_t len)
+{
+	return copyup_named_dentry(dir, dentry, bstart, new_bindex,
+				   dentry->d_name.name,
+				   dentry->d_name.len, copyup_file, len);
+}
+
+int copyup_named_dentry(struct inode *dir, struct dentry *dentry,
+			int bstart, int new_bindex, const char *name,
+			int namelen, struct file **copyup_file, loff_t len)
+{
+	struct dentry *new_hidden_dentry;
+	struct dentry *old_hidden_dentry = NULL;
+	struct super_block *sb;
+	struct file *input_file = NULL;
+	struct file *output_file = NULL;
+	struct sioq_args args;
+	ssize_t read_bytes, write_bytes;
+	mm_segment_t old_fs;
+	int err = 0;
+	char *buf;
+	int old_bindex;
+	int got_branch_input = -1;
+	int got_branch_output = -1;
+	int old_bstart;
+	int old_bend;
+	int old_mode;
+	loff_t size = len;
+	struct dentry *new_hidden_parent_dentry = NULL;
+	mm_segment_t oldfs;
+	char *symbuf = NULL;
+
+	print_entry_location();
+	verify_locked(dentry);
+	print_dentry("IN: copyup_named_dentry", dentry);
+
+	old_bindex = bstart;
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	BUG_ON(new_bindex < 0);
+	BUG_ON(new_bindex >= old_bindex);
+
+	sb = dir->i_sb;
+
+	unionfs_read_lock(sb);
+
+	if ((err = is_robranch_super(sb, new_bindex)))
+		goto out;
+
+	/* Create the directory structure above this dentry. */
+	new_hidden_dentry = create_parents_named(dir, dentry, name, new_bindex);
+	if (IS_ERR(new_hidden_dentry)) {
+		err = PTR_ERR(new_hidden_dentry);
+		goto out;
+	}
+
+	print_dentry("Copyup Object", new_hidden_dentry);
+
+	/* Now we actually create the object. */
+	old_hidden_dentry = dtohd_index(dentry, old_bindex);
+	DGET(old_hidden_dentry);
+	
+	old_mode = old_hidden_dentry->d_inode->i_mode;
+
+	/* For symlinks, we must read the link before we lock the directory. */
+	if (S_ISLNK(old_mode)) {
+
+		symbuf = KMALLOC(PATH_MAX, GFP_KERNEL);
+		if (!symbuf) {
+			err = -ENOMEM;
+			goto copyup_readlink_err;
+		}
+
+		oldfs = get_fs();
+		set_fs(KERNEL_DS);
+		err =
+		    old_hidden_dentry->d_inode->i_op->
+		    readlink(old_hidden_dentry, (char __user *)symbuf,
+			     PATH_MAX);
+		set_fs(oldfs);
+		if (err < 0)
+			goto copyup_readlink_err;
+		symbuf[err] = '\0';
+	}
+
+	/* Now we lock the parent, and create the object in the new branch. */
+	new_hidden_parent_dentry = lock_parent(new_hidden_dentry);
+	if (S_ISDIR(old_mode)) {
+		args.mkdir.parent = new_hidden_parent_dentry->d_inode;
+		args.mkdir.dentry = new_hidden_dentry;
+		args.mkdir.mode = old_mode; /*S_IRWXU*/
+		run_sioq(__unionfs_mkdir, &args);
+		err = args.err;
+	} else if (S_ISLNK(old_mode)) {
+		args.symlink.parent = new_hidden_parent_dentry->d_inode;
+		args.symlink.dentry = new_hidden_dentry;
+		args.symlink.symbuf = symbuf;
+		args.symlink.mode = old_mode;
+		run_sioq(__unionfs_symlink, &args);
+		err = args.err;
+	} else if (S_ISBLK(old_mode)
+		   || S_ISCHR(old_mode)
+		   || S_ISFIFO(old_mode)
+		   || S_ISSOCK(old_mode)) {
+		args.mknod.parent = new_hidden_parent_dentry->d_inode;
+		args.mknod.dentry = new_hidden_dentry;
+		args.mknod.mode = old_mode;
+		args.mknod.dev = old_hidden_dentry->d_inode->i_rdev;
+		run_sioq(__unionfs_mknod, &args);
+		err = args.err;	
+	} else if (S_ISREG(old_mode)) {
+		args.create.parent = new_hidden_parent_dentry->d_inode;
+		args.create.dentry = new_hidden_dentry;
+		args.create.mode = old_mode;
+		args.create.nd = NULL;
+		run_sioq(__unionfs_create, &args);
+		err = args.err;
+	} else {
+		printk(KERN_ERR "Unknown inode type %d\n",
+		       old_hidden_dentry->d_inode->i_mode);
+		BUG();
+	}
+
+      copyup_readlink_err:
+	KFREE(symbuf);
+	if (err) {
+		/* get rid of the hidden dentry and all its traces */
+		DPUT(new_hidden_dentry);
+		set_dtohd_index(dentry, new_bindex, NULL);
+		set_dbstart(dentry, old_bstart);
+		set_dbend(dentry, old_bend);
+		goto out_dir;
+	}
+#ifdef UNIONFS_IMAP
+	if (stopd(sb)->usi_persistent) {
+		err = write_uin(dentry->d_sb, dentry->d_inode->i_ino,
+				new_bindex, new_hidden_dentry->d_inode->i_ino);
+		if (err)
+			goto out_dir;
+	}
+#endif
+	/* We actually copyup the file here. */
+	if (S_ISREG(old_hidden_dentry->d_inode->i_mode)) {
+		mntget(stohiddenmnt_index(sb, old_bindex));
+		branchget(sb, old_bindex);
+		got_branch_input = old_bindex;
+		input_file =
+		    DENTRY_OPEN(old_hidden_dentry,
+				stohiddenmnt_index(sb, old_bindex),
+				O_RDONLY | O_LARGEFILE);
+		if (IS_ERR(input_file)) {
+			err = PTR_ERR(input_file);
+			goto out_dir;
+		}
+		if (!input_file->f_op || !input_file->f_op->read) {
+			err = -EINVAL;
+			goto out_dir;
+		}
+
+		/* copy the new file */
+		DGET(new_hidden_dentry);
+		mntget(stohiddenmnt_index(sb, new_bindex));
+		branchget(sb, new_bindex);
+		got_branch_output = new_bindex;
+		output_file =
+		    DENTRY_OPEN(new_hidden_dentry,
+				stohiddenmnt_index(sb, new_bindex),
+				O_WRONLY | O_LARGEFILE);
+		if (IS_ERR(output_file)) {
+			err = PTR_ERR(output_file);
+			goto out_dir;
+		}
+		if (!output_file->f_op || !output_file->f_op->write) {
+			err = -EINVAL;
+			goto out_dir;
+		}
+
+		/* allocating a buffer */
+		buf = (char *)KMALLOC(PAGE_SIZE, GFP_KERNEL);
+		if (!buf) {
+			err = -ENOMEM;
+			goto out_dir;
+		}
+
+		/* now read PAGE_SIZE bytes from offset 0 in a loop */
+		old_fs = get_fs();
+
+		input_file->f_pos = 0;
+		output_file->f_pos = 0;
+
+		err = 0;	// reset error just in case
+		set_fs(KERNEL_DS);
+		do {
+			if (len >= PAGE_SIZE)
+				size = PAGE_SIZE;
+			else if ((len < PAGE_SIZE) && (len > 0))
+				size = len;
+
+			len -= PAGE_SIZE;
+
+			read_bytes =
+			    input_file->f_op->read(input_file,
+						   (char __user *)buf, size,
+						   &input_file->f_pos);
+			if (read_bytes <= 0) {
+				err = read_bytes;
+				break;
+			}
+
+			write_bytes =
+			    output_file->f_op->write(output_file,
+						     (char __user *)buf,
+						     read_bytes,
+						     &output_file->f_pos);
+			if (write_bytes < 0 || (write_bytes < read_bytes)) {
+				err = write_bytes;
+				break;
+			}
+		} while ((read_bytes > 0) && (len > 0));
+		set_fs(old_fs);
+		KFREE(buf);
+#ifdef UNIONFS_MMAP
+		/* SP: Now that we copied up the file, have to sync its data
+		 * as otherwise when we do a read_cache_page(), we'll possibly
+		 * read crap.
+		 *
+		 * another posisble solution would be in the address op code
+		 * would be to check the "lower" page to see if its dirty,
+		 * and if it's dirty, use it directl
+		 */
+		if (!err) {
+			err =
+			    output_file->f_op->fsync(output_file,
+						     new_hidden_dentry, 0);
+		}
+#endif
+		if (err) {
+			/* copyup failed, because we ran out of space or quota,
+			 * or something else happened so let's unlink; we don't
+			 * really care about the return value of vfs_unlink */
+			vfs_unlink(new_hidden_parent_dentry->d_inode,
+				   new_hidden_dentry);
+
+			goto out_dir;
+		}
+	}
+
+	/* Set permissions. */
+	if ((err =
+	     copyup_permissions(sb, old_hidden_dentry, new_hidden_dentry)))
+		goto out_dir;
+	/* Selinux uses extended attributes for permissions. */
+	if ((err = copyup_xattrs(old_hidden_dentry, new_hidden_dentry)))
+		goto out_dir;
+
+	/* do not allow files getting deleted to be reinterposed */
+	if (!d_deleted(dentry))
+		unionfs_reinterpose(dentry);
+
+      out_dir:
+	if (new_hidden_parent_dentry)
+		unlock_dir(new_hidden_parent_dentry);
+
+      out:
+	if (input_file && !IS_ERR(input_file)) {
+		fput(input_file);
+	} else {
+		/* since input file was not opened, we need to explicitly
+		 * dput the old_hidden_dentry
+		 */
+		DPUT(old_hidden_dentry);
+	}
+
+	/* in any case, we have to branchput */
+	if (got_branch_input >= 0)
+		branchput(sb, got_branch_input);
+
+	if (output_file) {
+		if (copyup_file && !err) {
+			*copyup_file = output_file;
+		} else {
+			/* close the file if there was no error, or if we ran
+			 * out of space in which case we unlinked the file */
+			if (!IS_ERR(output_file))
+				fput(output_file);
+			branchput(sb, got_branch_output);
+		}
+	}
+
+	unionfs_read_unlock(sb);
+
+	print_dentry("OUT: copyup_dentry", dentry);
+	print_inode("OUT: copyup_dentry", dentry->d_inode);
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function creates a copy of a file represented by 'file' which currently
+ * resides in branch 'bstart' to branch 'new_bindex.  The copy will be named
+ * "name".  */
+int copyup_named_file(struct inode *dir, struct file *file, char *name,
+		      int bstart, int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	print_entry_location();
+
+	err = copyup_named_dentry(dir, file->f_dentry, bstart,
+				  new_bindex, name, strlen(name), &output_file,
+				  len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		set_ftohf_index(file, new_bindex, output_file);
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function creates a copy of a file represented by 'file' which currently
+ * resides in branch 'bstart' to branch 'new_bindex.
+ */
+int copyup_file(struct inode *dir, struct file *file, int bstart,
+		int new_bindex, loff_t len)
+{
+	int err = 0;
+	struct file *output_file = NULL;
+
+	print_entry_location();
+
+	err = copyup_dentry(dir, file->f_dentry, bstart, new_bindex,
+			    &output_file, len);
+	if (!err) {
+		fbstart(file) = new_bindex;
+		set_ftohf_index(file, new_bindex, output_file);
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/* This function replicates the directory structure upto given dentry
+ * in the bindex branch. Can create directory structure recursively to the right
+ * also.
+ */
+struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+			      int bindex)
+{
+	struct dentry *hidden_dentry;
+
+	print_entry_location();
+	hidden_dentry =
+	    create_parents_named(dir, dentry, dentry->d_name.name, bindex);
+	print_exit_location();
+
+	return (hidden_dentry);
+}
+
+/* This function replicates the directory structure upto given dentry
+ * in the bindex branch.  */
+struct dentry *create_parents_named(struct inode *dir, struct dentry *dentry,
+				    const char *name, int bindex)
+{
+	int err;
+	struct dentry *child_dentry;
+	struct dentry *parent_dentry;
+	struct dentry *hidden_parent_dentry = NULL;
+	struct dentry *hidden_dentry = NULL;
+	struct sioq_args args;
+	const char *childname;
+	unsigned int childnamelen;
+
+	int old_kmalloc_size;
+	int kmalloc_size;
+	int num_dentry;
+	int count;
+
+	int old_bstart;
+	int old_bend;
+	struct dentry **path = NULL;
+	struct dentry **tmp_path;
+	struct super_block *sb;
+#ifdef UNIONFS_IMAP
+	int persistent;
+#endif
+	print_entry_location();
+
+	verify_locked(dentry);
+
+	/* There is no sense allocating any less than the minimum. */
+	kmalloc_size = malloc_sizes[0].cs_size;
+	num_dentry = kmalloc_size / sizeof(struct dentry *);
+
+	if ((err = is_robranch_super(dir->i_sb, bindex))) {
+		hidden_dentry = ERR_PTR(err);
+		goto out;
+	}
+
+	print_dentry("IN: create_parents_named", dentry);
+	dprint(PRINT_DEBUG, "name = %s\n", name);
+
+	old_bstart = dbstart(dentry);
+	old_bend = dbend(dentry);
+
+	hidden_dentry = ERR_PTR(-ENOMEM);
+	path = (struct dentry **)KZALLOC(kmalloc_size, GFP_KERNEL);
+	if (!path)
+		goto out;
+
+	/* assume the negative dentry of unionfs as the parent dentry */
+	parent_dentry = dentry;
+
+	count = 0;
+	/* This loop finds the first parent that exists in the given branch.
+	 * We start building the directory structure from there.  At the end
+	 * of the loop, the following should hold:
+	 *      child_dentry is the first nonexistent child
+	 *      parent_dentry is the first existent parent
+	 *      path[0] is the = deepest child
+	 *      path[count] is the first child to create
+	 */
+	do {
+		child_dentry = parent_dentry;
+
+		/* find the parent directory dentry in unionfs */
+		parent_dentry = child_dentry->d_parent;
+		lock_dentry(parent_dentry);
+
+		/* find out the hidden_parent_dentry in the given branch */
+		hidden_parent_dentry = dtohd_index(parent_dentry, bindex);
+
+		/* store the child dentry */
+		path[count++] = child_dentry;
+		if (count == num_dentry) {
+			old_kmalloc_size = kmalloc_size;
+			kmalloc_size *= 2;
+			num_dentry = kmalloc_size / sizeof(struct dentry *);
+
+			tmp_path =
+			    (struct dentry **)KZALLOC(kmalloc_size, GFP_KERNEL);
+			if (!tmp_path) {
+				hidden_dentry = ERR_PTR(-ENOMEM);
+				goto out;
+			}
+			memcpy(tmp_path, path, old_kmalloc_size);
+			KFREE(path);
+			path = tmp_path;
+			tmp_path = NULL;
+		}
+
+	} while (!hidden_parent_dentry);
+	count--;
+
+	sb = dentry->d_sb;
+#ifdef UNIONFS_IMAP
+	persistent = stopd(sb)->usi_persistent;
+#endif
+	/* This is basically while(child_dentry != dentry).  This loop is
+	 * horrible to follow and should be replaced with cleaner code. */
+	while (1) {
+		// get hidden parent dir in the current branch
+		hidden_parent_dentry = dtohd_index(parent_dentry, bindex);
+		unlock_dentry(parent_dentry);
+
+		// init the values to lookup
+		childname = child_dentry->d_name.name;
+		childnamelen = child_dentry->d_name.len;
+
+		if (child_dentry != dentry) {
+			// lookup child in the underlying file system
+			hidden_dentry =
+			    LOOKUP_ONE_LEN(childname, hidden_parent_dentry,
+					   childnamelen);
+			if (IS_ERR(hidden_dentry))
+				goto out;
+		} else {
+			int loop_start;
+			int loop_end;
+			int new_bstart = -1;
+			int new_bend = -1;
+			int i;
+
+			/* is the name a whiteout of the childname ? */
+			//lookup the whiteout child in the underlying file system
+			hidden_dentry =
+			    LOOKUP_ONE_LEN(name, hidden_parent_dentry,
+					   strlen(name));
+			if (IS_ERR(hidden_dentry))
+				goto out;
+
+			/* Replace the current dentry (if any) with the new one. */
+			DPUT(dtohd_index(dentry, bindex));
+			set_dtohd_index(dentry, bindex, hidden_dentry);
+
+			loop_start =
+			    (old_bstart < bindex) ? old_bstart : bindex;
+			loop_end = (old_bend > bindex) ? old_bend : bindex;
+
+			/* This loop sets the bstart and bend for the new
+			 * dentry by traversing from left to right.
+			 * It also dputs all negative dentries except
+			 * bindex (the newly looked dentry
+			 */
+			for (i = loop_start; i <= loop_end; i++) {
+				if (!dtohd_index(dentry, i))
+					continue;
+
+				if (i == bindex) {
+					new_bend = i;
+					if (new_bstart < 0)
+						new_bstart = i;
+					continue;
+				}
+
+				if (!dtohd_index(dentry, i)->d_inode) {
+					DPUT(dtohd_index(dentry, i));
+					set_dtohd_index(dentry, i, NULL);
+				} else {
+					if (new_bstart < 0)
+						new_bstart = i;
+					new_bend = i;
+				}
+			}
+
+			if (new_bstart < 0)
+				new_bstart = bindex;
+			if (new_bend < 0)
+				new_bend = bindex;
+			set_dbstart(dentry, new_bstart);
+			set_dbend(dentry, new_bend);
+			break;
+		}
+
+		if (hidden_dentry->d_inode) {
+			/* since this already exists we dput to avoid
+			 * multiple references on the same dentry */
+			DPUT(hidden_dentry);
+		} else {
+
+			/* its a negative dentry, create a new dir */
+			hidden_parent_dentry = lock_parent(hidden_dentry);
+			args.mkdir.parent = hidden_parent_dentry->d_inode;
+			args.mkdir.dentry = hidden_dentry;
+			args.mkdir.mode = child_dentry->d_inode->i_mode;
+			run_sioq(__unionfs_mkdir, &args);
+			err = args.err;
+			if (!err)
+				err = copyup_permissions
+				    (dir->i_sb, child_dentry, hidden_dentry);
+			unlock_dir(hidden_parent_dentry);
+			if (err) {
+				DPUT(hidden_dentry);
+				hidden_dentry = ERR_PTR(err);
+				goto out;
+			}
+#ifdef UNIONFS_IMAP
+			if (persistent) {
+				err = write_uin
+				    (sb, child_dentry->d_inode->i_ino,
+				     bindex, hidden_dentry->d_inode->i_ino);
+				if (err) {
+					DPUT(hidden_dentry);
+					hidden_dentry = ERR_PTR(err);
+					goto out;
+				}
+			}
+#endif
+			set_itohi_index(child_dentry->d_inode, bindex,
+					IGRAB(hidden_dentry->d_inode));
+			if (ibstart(child_dentry->d_inode) > bindex)
+				ibstart(child_dentry->d_inode) = bindex;
+			if (ibend(child_dentry->d_inode) < bindex)
+				ibend(child_dentry->d_inode) = bindex;
+
+			set_dtohd_index(child_dentry, bindex, hidden_dentry);
+			if (dbstart(child_dentry) > bindex)
+				set_dbstart(child_dentry, bindex);
+			if (dbend(child_dentry) < bindex)
+				set_dbend(child_dentry, bindex);
+		}
+
+		parent_dentry = child_dentry;
+		child_dentry = path[--count];
+	}
+      out:
+	KFREE(path);
+	print_dentry("OUT: create_parents_named", dentry);
+	print_exit_pointer(hidden_dentry);
+	return hidden_dentry;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/dentry.c linux-2.6.20-sabayon-r1/fs/unionfs/dentry.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/dentry.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/dentry.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dentry.c,v 1.77 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations added for "sparse" */
+extern int unionfs_d_revalidate_wrap(struct dentry *dentry,
+				     struct nameidata *nd);
+extern void unionfs_d_release(struct dentry *dentry);
+extern void unionfs_d_iput(struct dentry *dentry, struct inode *inode);
+
+/*
+ * THIS IS A BOOLEAN FUNCTION: returns 1 if valid, 0 otherwise.
+ */
+int unionfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)
+{
+	int valid = 1;		/* default is valid (1); invalid is 0. */
+	struct dentry *hidden_dentry;
+	int bindex, bstart, bend;
+	int sbgen, dgen;
+	int positive = 0;
+	int locked = 0;
+	int restart = 0;
+	int interpose_flag;
+
+	print_util_entry_location();
+
+      restart:
+	verify_locked(dentry);
+
+	/* if the dentry is unhashed, do NOT revalidate */
+	if (d_deleted(dentry)) {
+		dprint(PRINT_DEBUG, "unhashed dentry being revalidated: %*s\n",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out;
+	}
+
+	BUG_ON(dbstart(dentry) == -1);
+	if (dentry->d_inode)
+		positive = 1;
+	dgen = atomic_read(&dtopd(dentry)->udi_generation);
+	sbgen = atomic_read(&stopd(dentry->d_sb)->usi_generation);
+	/* If we are working on an unconnected dentry, then there is no
+	 * revalidation to be done, because this file does not exist within the
+	 * namespace, and Unionfs operates on the namespace, not data.
+	 */
+	if (sbgen != dgen) {
+		struct dentry *result;
+		int pdgen;
+
+		unionfs_read_lock(dentry->d_sb);
+		locked = 1;
+
+		/* The root entry should always be valid */
+		BUG_ON(IS_ROOT(dentry));
+
+		/* We can't work correctly if our parent isn't valid. */
+		pdgen = atomic_read(&dtopd(dentry->d_parent)->udi_generation);
+		if (!restart && (pdgen != sbgen)) {
+			unionfs_read_unlock(dentry->d_sb);
+			locked = 0;
+			/* We must be locked before our parent. */
+			if (!
+			    (dentry->d_parent->d_op->
+			     d_revalidate(dentry->d_parent, nd))) {
+				valid = 0;
+				goto out;
+			}
+			restart = 1;
+			goto restart;
+		}
+		BUG_ON(pdgen != sbgen);
+
+		/* Free the pointers for our inodes and this dentry. */
+		bstart = dbstart(dentry);
+		bend = dbend(dentry);
+		if (bstart >= 0) {
+			struct dentry *hidden_dentry;
+			for (bindex = bstart; bindex <= bend; bindex++) {
+				hidden_dentry =
+				    dtohd_index_nocheck(dentry, bindex);
+				if (!hidden_dentry)
+					continue;
+				DPUT(hidden_dentry);
+			}
+		}
+		set_dbstart(dentry, -1);
+		set_dbend(dentry, -1);
+
+		interpose_flag = INTERPOSE_REVAL_NEG;
+		if (positive) {
+			interpose_flag = INTERPOSE_REVAL;
+			mutex_lock(&dentry->d_inode->i_mutex);
+			bstart = ibstart(dentry->d_inode);
+			bend = ibend(dentry->d_inode);
+			if (bstart >= 0) {
+				struct inode *hidden_inode;
+				for (bindex = bstart; bindex <= bend; bindex++) {
+					hidden_inode =
+					    itohi_index(dentry->d_inode,
+							bindex);
+					if (!hidden_inode)
+						continue;
+					IPUT(hidden_inode);
+				}
+			}
+			KFREE(itohi_ptr(dentry->d_inode));
+			itohi_ptr(dentry->d_inode) = NULL;
+			ibstart(dentry->d_inode) = -1;
+			ibend(dentry->d_inode) = -1;
+			mutex_unlock(&dentry->d_inode->i_mutex);
+		}
+
+		result = unionfs_lookup_backend(dentry, interpose_flag);
+		if (result) {
+			if (IS_ERR(result)) {
+				valid = 0;
+				goto out;
+			}
+			/* current unionfs_lookup_backend() doesn't return
+			   a valid dentry */
+			DPUT(dentry);
+			dentry = result;
+		}
+
+		if (positive && itopd(dentry->d_inode)->uii_stale) {
+			make_stale_inode(dentry->d_inode);
+			d_drop(dentry);
+			valid = 0;
+			goto out;
+		}
+		goto out;
+	}
+
+	/* The revalidation must occur across all branches */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	BUG_ON(bstart == -1);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry || !hidden_dentry->d_op
+		    || !hidden_dentry->d_op->d_revalidate)
+			continue;
+
+		if (!hidden_dentry->d_op->d_revalidate(hidden_dentry, nd))
+			valid = 0;
+	}
+
+	if (!dentry->d_inode)
+		valid = 0;
+	if (valid)
+		fist_copy_attr_all(dentry->d_inode, itohi(dentry->d_inode));
+
+      out:
+	if (locked)
+		unionfs_read_unlock(dentry->d_sb);
+	print_dentry("revalidate out", dentry);
+	print_util_exit_status(valid);
+	return valid;
+}
+
+int unionfs_d_revalidate_wrap(struct dentry *dentry, struct nameidata *nd)
+{
+	int err;
+
+	print_entry_location();
+	lock_dentry(dentry);
+
+	err = unionfs_d_revalidate(dentry, nd);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+void unionfs_d_release(struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+	/* There is no reason to lock the dentry, because we have the only
+	 * reference, but the printing functions verify that we have a lock
+	 * on the dentry before calling dbstart, etc. */
+	lock_dentry(dentry);
+	print_dentry_nocheck("unionfs_d_release IN dentry", dentry);
+
+	/* this could be a negative dentry, so check first */
+	if (!dtopd(dentry)) {
+		dprint(PRINT_DEBUG, "dentry without private data: %*s",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out;
+	} else if (dbstart(dentry) < 0) {
+		/* this is due to a failed lookup */
+		/* the failed lookup has a dtohd_ptr set to null,
+		   but this is a better check */
+		dprint(PRINT_DEBUG, "dentry without hidden dentries : %*s",
+			    dentry->d_name.len, dentry->d_name.name);
+		goto out_free;
+	}
+
+	/* Release all the hidden dentries */
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	}
+	/* free private data (unionfs_dentry_info) here */
+	KFREE(dtohd_ptr(dentry));
+	dtohd_ptr(dentry) = NULL;
+      out_free:
+	/* No need to unlock it, because it is disappeared. */
+#ifdef TRACKLOCK
+	printk("DESTROYLOCK:%p\n", dentry);
+#endif
+	free_dentry_private_data(dtopd(dentry));
+	dtopd_lhs(dentry) = NULL;	/* just to be safe */
+      out:
+	print_exit_location();
+}
+
+/*
+ * we don't really need unionfs_d_iput, because dentry_iput will call iput() if
+ * unionfs_d_iput is not defined. We left this implemented for ease of
+ * tracing/debugging.
+ */
+void unionfs_d_iput(struct dentry *dentry, struct inode *inode)
+{
+	print_entry_location();
+	IPUT(inode);
+	print_exit_location();
+}
+
+struct dentry_operations unionfs_dops = {
+	.d_revalidate = unionfs_d_revalidate_wrap,
+	.d_release = unionfs_d_release,
+	.d_iput = unionfs_d_iput,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/dirfops.c linux-2.6.20-sabayon-r1/fs/unionfs/dirfops.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/dirfops.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/dirfops.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dirfops.c,v 1.25 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+/* Make sure our rdstate is playing by the rules. */
+static void verify_rdstate_offset(struct unionfs_dir_state *rdstate)
+{
+	BUG_ON(rdstate->uds_offset >= DIREOF);
+	BUG_ON(rdstate->uds_cookie >= MAXRDCOOKIE);
+}
+
+struct unionfs_getdents_callback {
+	struct unionfs_dir_state *rdstate;
+	void *dirent;
+	int entries_written;
+	int filldir_called;
+	int filldir_error;
+	filldir_t filldir;
+	struct super_block *sb;
+};
+
+/* copied from generic filldir in fs/readir.c */
+static int unionfs_filldir(void *dirent, const char *name, int namelen,
+			   loff_t offset, ino_t ino, unsigned int d_type)
+{
+	struct unionfs_getdents_callback *buf =
+	    (struct unionfs_getdents_callback *)dirent;
+	struct filldir_node *found = NULL;
+	int err = 0;
+	int is_wh_entry = 0;
+
+	dprint(PRINT_DEBUG, "unionfs_filldir name=%*s\n", namelen, name);
+
+	buf->filldir_called++;
+
+	if ((namelen > WHLEN) && !strncmp(name, WHPFX, WHLEN)) {
+		name += WHLEN;
+		namelen -= WHLEN;
+		is_wh_entry = 1;
+	}
+
+	found = find_filldir_node(buf->rdstate, name, namelen);
+
+	if (found)
+		goto out;
+
+	/* if 'name' isn't a whiteout filldir it. */
+	if (!is_wh_entry) {
+		off_t pos = rdstate2offset(buf->rdstate);
+		ino_t unionfs_ino = ino;
+#ifdef UNIONFS_IMAP
+		if (stopd(buf->sb)->usi_persistent)
+			err = read_uin(buf->sb, buf->rdstate->uds_bindex,
+				       ino, O_CREAT, &unionfs_ino);
+#endif
+		if (!err) {
+			err = buf->filldir(buf->dirent, name, namelen, pos,
+					   unionfs_ino, d_type);
+			buf->rdstate->uds_offset++;
+			verify_rdstate_offset(buf->rdstate);
+		}
+	}
+	/* If we did fill it, stuff it in our hash, otherwise return an error */
+	if (err) {
+		buf->filldir_error = err;
+		goto out;
+	}
+	buf->entries_written++;
+	if ((err = add_filldir_node(buf->rdstate, name, namelen,
+				    buf->rdstate->uds_bindex, is_wh_entry)))
+		buf->filldir_error = err;
+
+      out:
+	return err;
+}
+
+static int unionfs_readdir(struct file *file, void *dirent, filldir_t filldir)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+	struct inode *inode = NULL;
+	struct unionfs_getdents_callback buf;
+	struct unionfs_dir_state *uds;
+	int bend;
+	loff_t offset;
+
+	print_entry("file = %p, pos = %llx", file, file->f_pos);
+
+	print_file("In unionfs_readdir()", file);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	inode = file->f_dentry->d_inode;
+	checkinode(inode, "unionfs_readdir");
+
+	uds = ftopd(file)->rdstate;
+	if (!uds) {
+		if (file->f_pos == DIREOF) {
+			goto out;
+		} else if (file->f_pos > 0) {
+			uds = find_rdstate(inode, file->f_pos);
+			if (!uds) {
+				err = -ESTALE;
+				goto out;
+			}
+			ftopd(file)->rdstate = uds;
+		} else {
+			init_rdstate(file);
+			uds = ftopd(file)->rdstate;
+		}
+	}
+	bend = fbend(file);
+
+	while (uds->uds_bindex <= bend) {
+		hidden_file = ftohf_index(file, uds->uds_bindex);
+		if (!hidden_file) {
+			dprint(PRINT_DEBUG,
+				    "Incremented bindex to %d of %d,"
+				    " because hidden file is NULL.\n",
+				    uds->uds_bindex, bend);
+			uds->uds_bindex++;
+			uds->uds_dirpos = 0;
+			continue;
+		}
+
+		/* prepare callback buffer */
+		buf.filldir_called = 0;
+		buf.filldir_error = 0;
+		buf.entries_written = 0;
+		buf.dirent = dirent;
+		buf.filldir = filldir;
+		buf.rdstate = uds;
+		buf.sb = inode->i_sb;
+
+		/* Read starting from where we last left off. */
+		offset = vfs_llseek(hidden_file, uds->uds_dirpos, 0);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		dprint(PRINT_DEBUG, "calling readdir for %d.%lld (offset = %lld)\n",
+			    uds->uds_bindex, uds->uds_dirpos, offset);
+		err = vfs_readdir(hidden_file, unionfs_filldir, (void *)&buf);
+		dprint(PRINT_DEBUG,
+			    "readdir on %d.%lld = %d (entries written %d, filldir called %d)\n",
+			    uds->uds_bindex, (long long)uds->uds_dirpos, err,
+			    buf.entries_written, buf.filldir_called);
+		/* Save the position for when we continue. */
+
+		offset = vfs_llseek(hidden_file, 0, 1);
+		if (offset < 0) {
+			err = offset;
+			goto out;
+		}
+		uds->uds_dirpos = offset;
+
+		/* Copy the atime. */
+		fist_copy_attr_atime(inode, hidden_file->f_dentry->d_inode);
+
+		if (err < 0) {
+			goto out;
+		}
+
+		if (buf.filldir_error) {
+			break;
+		}
+
+		if (!buf.entries_written) {
+			uds->uds_bindex++;
+			uds->uds_dirpos = 0;
+		}
+	}
+
+	if (!buf.filldir_error && uds->uds_bindex >= bend) {
+		dprint(PRINT_DEBUG,
+			    "Discarding rdstate because readdir is over (hashsize = %d)\n",
+			    uds->uds_hashentries);
+		/* Save the number of hash entries for next time. */
+		itopd(inode)->uii_hashsize = uds->uds_hashentries;
+		free_rdstate(uds);
+		ftopd(file)->rdstate = NULL;
+		file->f_pos = DIREOF;
+	} else {
+		file->f_pos = rdstate2offset(uds);
+		dprint(PRINT_DEBUG, "rdstate now has a cookie of %u (err = %d)\n",
+			    uds->uds_cookie, err);
+	}
+
+      out:
+	checkinode(inode, "post unionfs_readdir");
+	print_exit_status(err);
+	return err;
+}
+
+/* This is not meant to be a generic repositioning function.  If you do
+ * things that aren't supported, then we return EINVAL.
+ *
+ * What is allowed:
+ *  (1) seeking to the same position that you are currently at
+ *	This really has no effect, but returns where you are.
+ *  (2) seeking to the end of the file, if you've read everything
+ *	This really has no effect, but returns where you are.
+ *  (3) seeking to the beginning of the file
+ *	This throws out all state, and lets you begin again.
+ */
+static loff_t unionfs_dir_llseek(struct file *file, loff_t offset, int origin)
+{
+	struct unionfs_dir_state *rdstate;
+	loff_t err;
+
+	print_entry(" file=%p, offset=0x%llx, origin = %d", file, offset,
+		    origin);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	rdstate = ftopd(file)->rdstate;
+
+	/* We let users seek to their current position, but not anywhere else. */
+	if (!offset) {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				free_rdstate(rdstate);
+				ftopd(file)->rdstate = NULL;
+			}
+			init_rdstate(file);
+			err = 0;
+			break;
+		case SEEK_CUR:
+			if (file->f_pos) {
+				if (file->f_pos == DIREOF)
+					err = DIREOF;
+				else
+					BUG_ON(file->f_pos !=
+					       rdstate2offset(rdstate));
+				err = file->f_pos;
+			} else {
+				err = 0;
+			}
+			break;
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	} else {
+		switch (origin) {
+		case SEEK_SET:
+			if (rdstate) {
+				if (offset == rdstate2offset(rdstate)) {
+					err = offset;
+				} else if (file->f_pos == DIREOF) {
+					err = DIREOF;
+				} else {
+					err = -EINVAL;
+				}
+			} else {
+				if ((rdstate =
+				     find_rdstate(file->f_dentry->d_inode,
+						  offset))) {
+					ftopd(file)->rdstate = rdstate;
+					err = rdstate->uds_offset;
+				} else {
+					err = -EINVAL;
+				}
+			}
+			break;
+		case SEEK_CUR:
+		case SEEK_END:
+			/* Unsupported, because we would break everything.  */
+			err = -EINVAL;
+			break;
+		}
+	}
+
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+
+/* Trimmed directory options, we shouldn't pass everything down since
+ * we don't want to operate on partial directories.
+ */
+struct file_operations unionfs_dir_fops = {
+	.llseek = unionfs_dir_llseek,
+	.read = generic_read_dir,
+	.readdir = unionfs_readdir,
+	.unlocked_ioctl = unionfs_ioctl,
+	.open = unionfs_open,
+	.release = unionfs_file_release,
+	.flush = unionfs_flush,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/dirhelper.c linux-2.6.20-sabayon-r1/fs/unionfs/dirhelper.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/dirhelper.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/dirhelper.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,308 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: dirhelper.c,v 1.32 2006/10/31 18:05:33 yiannos Exp $
+ */
+
+#include "unionfs.h"
+
+/* Delete all of the whiteouts in a given directory for rmdir. */
+int do_delete_whiteouts(struct dentry *dentry, int bindex,
+		     struct unionfs_dir_state *namelist)
+{
+	int err = 0;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *hidden_dentry;
+	char *name = NULL, *p;
+	struct inode *hidden_dir;
+
+	int i;
+	struct list_head *pos;
+	struct filldir_node *cursor;
+
+	/* Find out hidden parent dentry */
+	hidden_dir_dentry = dtohd_index(dentry, bindex);
+	BUG_ON(!S_ISDIR(hidden_dir_dentry->d_inode->i_mode));
+	hidden_dir = hidden_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(hidden_dir->i_mode));
+
+	err = -ENOMEM;
+	name = __getname();
+	if (!name)
+		goto out;
+	strcpy(name, WHPFX);
+	p = name + WHLEN;
+
+	err = 0;
+	for (i = 0; !err && i < namelist->uds_size; i++) {
+		list_for_each(pos, &namelist->uds_list[i]) {
+			cursor =
+			    list_entry(pos, struct filldir_node, file_list);
+			/* Only operate on whiteouts in this branch. */
+			if (cursor->bindex != bindex)
+				continue;
+			if (!cursor->whiteout)
+				continue;
+
+			strcpy(p, cursor->name);
+			hidden_dentry =
+			    lookup_one_len(name, hidden_dir_dentry,
+					   cursor->namelen + WHLEN);
+			if (IS_ERR(hidden_dentry)) {
+				err = PTR_ERR(hidden_dentry);
+				break;
+			}
+			if (hidden_dentry->d_inode)
+				err = vfs_unlink(hidden_dir, hidden_dentry);
+			dput(hidden_dentry);
+			if (err)
+				break;
+		}
+	}
+
+	__putname(name);
+
+	/* After all of the removals, we should copy the attributes once. */
+	fist_copy_attr_times(dentry->d_inode, hidden_dir_dentry->d_inode);
+
+out:
+	return err;
+}
+
+/* Delete all of the whiteouts in a given directory for rmdir. */
+int delete_whiteouts(struct dentry *dentry, int bindex,
+		     struct unionfs_dir_state *namelist)
+{
+	int err = 0;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct super_block *sb;
+	char *name = NULL, *p;
+	struct inode *hidden_dir;
+
+	struct sioq_args args;
+
+	print_entry_location();
+
+	sb = dentry->d_sb;
+	unionfs_read_lock(sb);
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+	BUG_ON(bindex < dbstart(dentry));
+	BUG_ON(bindex > dbend(dentry));
+	err = is_robranch_super(sb, bindex);
+	if (err)
+		goto out;
+
+	/* Find out hidden parent dentry */
+	hidden_dir_dentry = dtohd_index(dentry, bindex);
+	BUG_ON(!S_ISDIR(hidden_dir_dentry->d_inode->i_mode));
+	hidden_dir = hidden_dir_dentry->d_inode;
+	BUG_ON(!S_ISDIR(hidden_dir->i_mode));
+
+	err = -ENOMEM;
+	name = __getname();
+	if (!name)
+		goto out;
+	strcpy(name, WHPFX);
+	p = name + WHLEN;
+
+	err = 0;
+	mutex_lock(&hidden_dir->i_mutex);
+
+	if (!permission(hidden_dir, MAY_WRITE | MAY_EXEC, NULL))
+		err = do_delete_whiteouts(dentry, bindex, namelist);
+	else {
+		args.deletewh.namelist = namelist;
+		args.deletewh.dentry = dentry;
+		args.deletewh.bindex = bindex;
+		run_sioq(__delete_whiteouts, &args);
+		err = args.err;
+	}
+
+	mutex_unlock(&hidden_dir->i_mutex);
+
+      out:
+	unionfs_read_unlock(sb);
+	print_exit_status(err);
+	return err;
+}
+
+#define RD_NONE 0
+#define RD_CHECK_EMPTY 1
+/* The callback structure for check_empty. */
+struct unionfs_rdutil_callback {
+	int err;
+	int filldir_called;
+	struct unionfs_dir_state *rdstate;
+	int mode;
+};
+
+/* This filldir function makes sure only whiteouts exist within a directory. */
+static int readdir_util_callback(void *dirent, const char *name, int namelen,
+				 loff_t offset, ino_t ino, unsigned int d_type)
+{
+	int err = 0;
+	struct unionfs_rdutil_callback *buf =
+	    (struct unionfs_rdutil_callback *)dirent;
+	int whiteout = 0;
+	struct filldir_node *found;
+
+	print_entry_location();
+
+	buf->filldir_called = 1;
+
+	if (name[0] == '.'
+	    && (namelen == 1 || (name[1] == '.' && namelen == 2)))
+		goto out;
+
+	if ((namelen > WHLEN) && !strncmp(name, WHPFX, WHLEN)) {
+		namelen -= WHLEN;
+		name += WHLEN;
+		whiteout = 1;
+	}
+
+	found = find_filldir_node(buf->rdstate, name, namelen);
+	/* If it was found in the table there was a previous whiteout. */
+	if (found)
+		goto out;
+
+	/* If it wasn't found and isn't a whiteout, the directory isn't empty. */
+	err = -ENOTEMPTY;
+	if ((buf->mode == RD_CHECK_EMPTY) && !whiteout)
+		goto out;
+
+	err = add_filldir_node(buf->rdstate, name, namelen,
+			       buf->rdstate->uds_bindex, whiteout);
+
+      out:
+	buf->err = err;
+	print_exit_status(err);
+	return err;
+}
+
+/* Is a directory logically empty? */
+int check_empty(struct dentry *dentry, struct unionfs_dir_state **namelist)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct super_block *sb;
+	struct file *hidden_file;
+	struct unionfs_rdutil_callback *buf = NULL;
+	int bindex, bstart, bend, bopaque;
+
+	print_entry_location();
+
+	sb = dentry->d_sb;
+
+	unionfs_read_lock(sb);
+
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode));
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	bopaque = dbopaque(dentry);
+	if (0 <= bopaque && bopaque < bend)
+		bend = bopaque;
+
+	buf = KMALLOC(sizeof(struct unionfs_rdutil_callback), GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+	buf->err = 0;
+	buf->mode = RD_CHECK_EMPTY;
+	buf->rdstate = alloc_rdstate(dentry->d_inode, bstart);
+	if (!buf->rdstate) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* Process the hidden directories with rdutil_callback as a filldir. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (!hidden_dentry->d_inode)
+			continue;
+		if (!S_ISDIR(hidden_dentry->d_inode->i_mode))
+			continue;
+
+		DGET(hidden_dentry);
+		mntget(stohiddenmnt_index(sb, bindex));
+		branchget(sb, bindex);
+		hidden_file =
+		    DENTRY_OPEN(hidden_dentry, stohiddenmnt_index(sb, bindex),
+				O_RDONLY);
+		if (IS_ERR(hidden_file)) {
+			err = PTR_ERR(hidden_file);
+			DPUT(hidden_dentry);
+			branchput(sb, bindex);
+			goto out;
+		}
+
+		do {
+			buf->filldir_called = 0;
+			buf->rdstate->uds_bindex = bindex;
+			err = vfs_readdir(hidden_file,
+					  readdir_util_callback, buf);
+			if (buf->err)
+				err = buf->err;
+		} while ((err >= 0) && buf->filldir_called);
+
+		/* fput calls dput for hidden_dentry */
+		fput(hidden_file);
+		branchput(sb, bindex);
+
+		if (err < 0)
+			goto out;
+	}
+
+      out:
+	if (buf) {
+		if (namelist && !err)
+			*namelist = buf->rdstate;
+		else if (buf->rdstate)
+			free_rdstate(buf->rdstate);
+		KFREE(buf);
+	}
+
+	unionfs_read_unlock(sb);
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/file.c linux-2.6.20-sabayon-r1/fs/unionfs/file.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/file.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/file.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,393 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: file.c,v 1.143 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations for sparse */
+extern ssize_t unionfs_read(struct file *, char __user *, size_t, loff_t *);
+extern ssize_t unionfs_write(struct file *, const char __user *, size_t,
+			     loff_t *);
+
+/*******************
+ * File Operations *
+ *******************/
+
+#ifndef UNIONFS_MMAP
+/* SP: Disable unionfs_llseek, as use generic_file_llseek on upper file */
+static loff_t unionfs_llseek(struct file *file, loff_t offset, int origin)
+{
+	loff_t err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	dprint(PRINT_DEBUG, "unionfs_llseek: file=%p, offset=0x%llx, origin=%d\n",
+		    file, offset, origin);
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	hidden_file = ftohf(file);
+	/* always set hidden position to this one */
+	hidden_file->f_pos = file->f_pos;
+
+	memcpy(&(hidden_file->f_ra), &(file->f_ra),
+	       sizeof(struct file_ra_state));
+
+	if (hidden_file->f_op && hidden_file->f_op->llseek)
+		err = hidden_file->f_op->llseek(hidden_file, offset, origin);
+	else
+		err = generic_file_llseek(hidden_file, offset, origin);
+
+	if (err < 0)
+		goto out;
+	if (err != file->f_pos) {
+		file->f_pos = err;
+		// ION maybe this?
+		//      file->f_pos = hidden_file->f_pos;
+
+		file->f_version++;
+	}
+      out:
+	print_exit_status((int)err);
+	return err;
+}
+#endif
+ssize_t __unionfs_read(struct file * file, char __user * buf, size_t count,
+		       loff_t * ppos)
+{
+	int err = -EINVAL;
+	struct file *hidden_file = NULL;
+	loff_t pos = *ppos;
+
+	print_file("entering __unionfs_read()", file);
+
+	hidden_file = ftohf(file);
+	if (!hidden_file->f_op || !hidden_file->f_op->read)
+		goto out;
+
+	err = hidden_file->f_op->read(hidden_file, buf, count, &pos);
+	*ppos = pos;
+
+      out:
+	print_file("leaving __unionfs_read()", file);
+
+	print_exit_status(err);
+	return err;
+}
+
+ssize_t unionfs_read(struct file * file, char __user * buf, size_t count,
+		     loff_t * ppos)
+{
+	int err = -EINVAL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+#ifdef UNIONFS_MMAP
+	err = generic_file_read(file, buf, count, ppos);
+	if (err >= 0)
+		file_accessed(ftohf(file));
+#else
+	err = __unionfs_read(file, buf, count, ppos);
+#endif
+
+      out:
+
+	print_exit_status(err);
+	return err;
+}
+
+/* SP: Sendfile code not updated, but should be able to use
+ * generic_file_sendfile, as it would use readpage, which we now have */
+#ifdef SUPPORT_BROKEN_LOSETUP
+static ssize_t unionfs_sendfile(struct file *file, loff_t * ppos,
+				size_t count, read_actor_t actor, void *target)
+{
+	ssize_t err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 0)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	err = -EINVAL;
+	if (!hidden_file->f_op || !hidden_file->f_op->sendfile)
+		goto out;
+
+	err = hidden_file->f_op->sendfile(hidden_file, ppos, count, actor,
+					  target);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+#endif
+ssize_t __unionfs_write(struct file * file, const char __user * buf,
+			size_t count, loff_t * ppos)
+{
+	int err = -EINVAL;
+	struct file *hidden_file = NULL;
+	struct inode *inode;
+	struct inode *hidden_inode;
+	loff_t pos = *ppos;
+	int bstart, bend;
+
+	print_entry_location();
+
+	inode = file->f_dentry->d_inode;
+
+	bstart = fbstart(file);
+	bend = fbend(file);
+
+	BUG_ON(bstart == -1);
+
+	hidden_file = ftohf(file);
+	hidden_inode = hidden_file->f_dentry->d_inode;
+
+	if (!hidden_file->f_op || !hidden_file->f_op->write)
+		goto out;
+
+	/* adjust for append -- seek to the end of the file */
+	if (file->f_flags & O_APPEND)
+		pos = inode->i_size;
+
+	err = hidden_file->f_op->write(hidden_file, buf, count, &pos);
+
+	/*
+	 * copy ctime and mtime from lower layer attributes
+	 * atime is unchanged for both layers
+	 */
+	if (err >= 0)
+		fist_copy_attr_times(inode, hidden_inode);
+
+	*ppos = pos;
+
+	/* update this inode's size */
+	if (pos > inode->i_size)
+		inode->i_size = pos;
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+ssize_t unionfs_write(struct file * file, const char __user * buf, size_t count,
+		      loff_t * ppos)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+#ifdef UNIONFS_MMAP
+	err = generic_file_write(file, buf, count, ppos);
+#else
+	err = __unionfs_write(file, buf, count, ppos);
+#endif
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_file_readdir(struct file *file, void *dirent,
+				filldir_t filldir)
+{
+	int err = -ENOTDIR;
+	print_entry_location();
+	print_exit_status(err);
+	return err;
+}
+
+static unsigned int unionfs_poll(struct file *file, poll_table * wait)
+{
+	unsigned int mask = DEFAULT_POLLMASK;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if (unionfs_file_revalidate(file, 0)) {
+		/* We should pretend an error happend. */
+		mask = POLLERR | POLLIN | POLLOUT;
+		goto out;
+	}
+
+	hidden_file = ftohf(file);
+
+	if (!hidden_file->f_op || !hidden_file->f_op->poll)
+		goto out;
+
+	mask = hidden_file->f_op->poll(hidden_file, wait);
+
+      out:
+	print_exit_status(mask);
+	return mask;
+}
+
+#ifndef UNIONFS_MMAP
+static int __do_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err;
+	struct file *hidden_file;
+
+	print_entry_location();
+	hidden_file = ftohf(file);
+
+	err = -ENODEV;
+	if (!hidden_file->f_op || !hidden_file->f_op->mmap)
+		goto out;
+
+	vma->vm_file = hidden_file;
+	err = hidden_file->f_op->mmap(hidden_file, vma);
+	get_file(hidden_file);	/* make sure it doesn't get freed on us */
+	fput(file);		/* no need to keep extra ref on ours */
+      out:
+	print_exit_status(err);
+	return err;
+}
+#endif
+/* SP: mmap code now maps upper file
+ * like old code, will only copyup at this point, it's possible to copyup
+ * in writepage(), but I haven't bothered with that, as only apt-get seem
+ * to want to write to a shared/write mapping
+ */
+static int unionfs_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	int err = 0;
+	int willwrite;
+
+	print_entry_location();
+
+	/* This might could be deferred to mmap's writepage. */
+	willwrite = ((vma->vm_flags | VM_SHARED | VM_WRITE) == vma->vm_flags);
+	if ((err = unionfs_file_revalidate(file, willwrite)))
+		goto out;
+#ifdef UNIONFS_MMAP
+	err = generic_file_mmap(file, vma);
+	if (err) {
+		printk("unionfs_mmap: generic_file_mmap failed\n");
+	}
+#else
+	err = __do_mmap(file, vma);
+#endif
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/* SP: disabled as use the generic file_fsync */
+#ifndef UNIONFS_MMAP
+static int unionfs_fsync(struct file *file, struct dentry *dentry, int datasync)
+{
+	int err;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	err = -EINVAL;
+	if (!hidden_file->f_op || !hidden_file->f_op->fsync)
+		goto out;
+
+	mutex_lock(&hidden_file->f_dentry->d_inode->i_mutex);
+	err = hidden_file->f_op->fsync(hidden_file, hidden_file->f_dentry,
+				       datasync);
+	mutex_unlock(&hidden_file->f_dentry->d_inode->i_mutex);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+#endif
+
+/* SP: disabled as none of the other in kernel fs's seem to use it */
+static int unionfs_fasync(int fd, struct file *file, int flag)
+{
+	int err = 0;
+	struct file *hidden_file = NULL;
+
+	print_entry_location();
+
+	if ((err = unionfs_file_revalidate(file, 1)))
+		goto out;
+
+	hidden_file = ftohf(file);
+
+	if (hidden_file->f_op && hidden_file->f_op->fasync)
+		err = hidden_file->f_op->fasync(fd, hidden_file, flag);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+struct file_operations unionfs_main_fops = {
+#ifdef UNIONFS_MMAP
+	.llseek = generic_file_llseek,
+#else
+	.llseek = unionfs_llseek,
+#endif
+	.read = unionfs_read,
+	.write = unionfs_write,
+	.readdir = unionfs_file_readdir,
+	.poll = unionfs_poll,
+	.unlocked_ioctl = unionfs_ioctl,
+	.mmap = unionfs_mmap,
+	.open = unionfs_open,
+	.flush = unionfs_flush,
+	.release = unionfs_file_release,
+#ifdef UNIONFS_MMAP
+	.fsync = file_fsync,
+#else
+	.fsync = unionfs_fsync,
+#endif
+	.fasync = unionfs_fasync,
+#ifdef SUPPORT_BROKEN_LOSETUP
+	.sendfile = unionfs_sendfile,
+#endif
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/inode.c linux-2.6.20-sabayon-r1/fs/unionfs/inode.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/inode.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,1014 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: inode.c,v 1.275 2006/10/31 18:05:33 yiannos Exp $
+ */
+
+#include "unionfs.h"
+
+/* declarations added for "sparse" */
+extern struct dentry *unionfs_lookup(struct inode *, struct dentry *,
+				     struct nameidata *);
+extern int unionfs_readlink(struct dentry *dentry, char __user * buf,
+			    int bufsiz);
+extern void unionfs_put_link(struct dentry *dentry, struct nameidata *nd,
+			     void *cookie);
+
+static int unionfs_create(struct inode *parent, struct dentry *dentry,
+			  int mode, struct nameidata *nd)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *whiteout_dentry = NULL;
+	struct dentry *new_hidden_dentry;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_create", dentry);
+
+	/* We start out in the leftmost branch. */
+	bstart = dbstart(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	/* check if whiteout exists in this branch, i.e. lookup .wh.foo first */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		whiteout_dentry = NULL;
+		goto out;
+	}
+
+	if (whiteout_dentry->d_inode) {
+		/* .wh.foo has been found. */
+		/* First truncate it and then rename it to foo (hence having
+		 * the same overall effect as a normal create.
+		 *
+		 * XXX: This is not strictly correct.  If we have unlinked the
+		 * file and it still has a reference count, then we should
+		 * actually unlink the whiteout so that user's data isn't
+		 * hosed over.
+		 */
+		struct dentry *hidden_dir_dentry;
+		struct iattr newattrs;
+
+		mutex_lock(&whiteout_dentry->d_inode->i_mutex);
+		newattrs.ia_valid = ATTR_CTIME | ATTR_MODE | ATTR_ATIME
+		    | ATTR_MTIME | ATTR_UID | ATTR_GID | ATTR_FORCE
+		    | ATTR_KILL_SUID | ATTR_KILL_SGID;
+
+		newattrs.ia_mode = mode & ~current->fs->umask;
+		newattrs.ia_uid = current->fsuid;
+		newattrs.ia_gid = current->fsgid;
+
+		if (whiteout_dentry->d_inode->i_size != 0) {
+			newattrs.ia_valid |= ATTR_SIZE;
+			newattrs.ia_size = 0;
+		}
+
+		err = notify_change(whiteout_dentry, &newattrs);
+
+		mutex_unlock(&whiteout_dentry->d_inode->i_mutex);
+
+		if (err)
+			printk(KERN_WARNING
+			       "unionfs: %s:%d: notify_change failed: %d, ignoring..\n",
+			       __FILE__, __LINE__, err);
+
+		new_hidden_dentry = dtohd(dentry);
+		DGET(new_hidden_dentry);
+
+		hidden_dir_dentry = GET_PARENT(whiteout_dentry);
+		lock_rename(hidden_dir_dentry, hidden_dir_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			err =
+			    vfs_rename(hidden_dir_dentry->d_inode,
+				       whiteout_dentry,
+				       hidden_dir_dentry->d_inode,
+				       new_hidden_dentry);
+		}
+		if (!err) {
+			fist_copy_attr_timesizes(parent,
+						 new_hidden_dentry->d_parent->
+						 d_inode);
+			parent->i_nlink = get_nlinks(parent);
+		}
+
+		unlock_rename(hidden_dir_dentry, hidden_dir_dentry);
+		DPUT(hidden_dir_dentry);
+
+		DPUT(new_hidden_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			/* We were not able to create the file in this branch,
+			 * so, we try to create it in one branch to left
+			 */
+			bstart--;
+		} else {
+			/* reset the unionfs dentry to point to the .wh.foo entry. */
+
+			/* Discard any old reference. */
+			DPUT(dtohd(dentry));
+
+			/* Trade one reference to another. */
+			set_dtohd_index(dentry, bstart, whiteout_dentry);
+			whiteout_dentry = NULL;
+
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			goto out;
+		}
+	}
+
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			/* if hidden_dentry is NULL, create the entire
+			 * dentry directory structure in branch 'bindex'.
+			 * hidden_dentry will NOT be null when bindex == bstart
+			 * because lookup passed as a negative unionfs dentry
+			 * pointing to a lone negative underlying dentry */
+			hidden_dentry = create_parents(parent, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				if (IS_ERR(hidden_dentry))
+					err = PTR_ERR(hidden_dentry);
+				continue;
+			}
+		}
+
+		checkinode(parent, "unionfs_create");
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		/* We shouldn't create things in a read-only branch. */
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			//DQ: vfs_create has a different prototype in 2.6
+			err = vfs_create(hidden_parent_dentry->d_inode,
+					 hidden_dentry, mode, nd);
+		}
+		if (err || !hidden_dentry->d_inode) {
+			unlock_dir(hidden_parent_dentry);
+
+			/* break out of for loop if the error wasn't  -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(parent,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				parent->i_nlink = get_nlinks(parent);
+			}
+			unlock_dir(hidden_parent_dentry);
+			break;
+		}
+	}
+
+      out:
+	DPUT(whiteout_dentry);
+	KFREE(name);
+
+	print_dentry("OUT unionfs_create :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+struct dentry *unionfs_lookup(struct inode *parent, struct dentry *dentry,
+			      struct nameidata *nd)
+{
+	/* The locking is done by unionfs_lookup_backend. */
+	return unionfs_lookup_backend(dentry, INTERPOSE_LOOKUP);
+}
+
+static int unionfs_link(struct dentry *old_dentry, struct inode *dir,
+			struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *hidden_old_dentry = NULL;
+	struct dentry *hidden_new_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *whiteout_dentry;
+	char *name = NULL;
+
+	print_entry_location();
+	double_lock_dentry(new_dentry, old_dentry);
+
+	hidden_new_dentry = dtohd(new_dentry);
+
+	/* check if whiteout exists in the branch of new dentry, i.e. lookup
+	 * .wh.foo first. If present, delete it */
+	name = alloc_whname(new_dentry->d_name.name, new_dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_new_dentry->d_parent,
+			   new_dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found a .wh.foo entry, unlink it and then call vfs_link() */
+		hidden_dir_dentry = lock_parent(whiteout_dentry);
+		if (!
+		    (err =
+		     is_robranch_super(new_dentry->d_sb,
+				       dbstart(new_dentry)))) {
+			err =
+			    vfs_unlink(hidden_dir_dentry->d_inode,
+				       whiteout_dentry);
+		}
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		dir->i_nlink = get_nlinks(dir);
+		unlock_dir(hidden_dir_dentry);
+		hidden_dir_dentry = NULL;
+		DPUT(whiteout_dentry);
+		if (err)
+			goto out;
+	}
+
+	if (dbstart(old_dentry) != dbstart(new_dentry)) {
+		hidden_new_dentry =
+		    create_parents(dir, new_dentry, dbstart(old_dentry));
+		err = PTR_ERR(hidden_new_dentry);
+		if (IS_COPYUP_ERR(err))
+			goto docopyup;
+		if (!hidden_new_dentry || IS_ERR(hidden_new_dentry))
+			goto out;
+	}
+	hidden_new_dentry = dtohd(new_dentry);
+	hidden_old_dentry = dtohd(old_dentry);
+
+	BUG_ON(dbstart(old_dentry) != dbstart(new_dentry));
+	hidden_dir_dentry = lock_parent(hidden_new_dentry);
+	if (!(err = is_robranch(old_dentry)))
+		err =
+		    vfs_link(hidden_old_dentry, hidden_dir_dentry->d_inode,
+			     hidden_new_dentry);
+	unlock_dir(hidden_dir_dentry);
+
+      docopyup:
+	if (IS_COPYUP_ERR(err)) {
+		int old_bstart = dbstart(old_dentry);
+		int bindex;
+
+		for (bindex = old_bstart - 1; bindex >= 0; bindex--) {
+			err =
+			    copyup_dentry(old_dentry->d_parent->
+					  d_inode, old_dentry,
+					  old_bstart, bindex, NULL,
+					  old_dentry->d_inode->i_size);
+			if (!err) {
+				hidden_new_dentry =
+				    create_parents(dir, new_dentry, bindex);
+				hidden_old_dentry = dtohd(old_dentry);
+				hidden_dir_dentry =
+				    lock_parent(hidden_new_dentry);
+				/* do vfs_link */
+				err =
+				    vfs_link(hidden_old_dentry,
+					     hidden_dir_dentry->d_inode,
+					     hidden_new_dentry);
+				unlock_dir(hidden_dir_dentry);
+				goto check_link;
+			}
+		}
+		goto out;
+	}
+      check_link:
+	if (err || !hidden_new_dentry->d_inode)
+		goto out;
+
+	/* Its a hard link, so use the same inode */
+	new_dentry->d_inode = IGRAB(old_dentry->d_inode);
+	d_instantiate(new_dentry, new_dentry->d_inode);
+	fist_copy_attr_all(dir, hidden_new_dentry->d_parent->d_inode);
+	/* propagate number of hard-links */
+	old_dentry->d_inode->i_nlink = get_nlinks(old_dentry->d_inode);
+
+      out:
+	if (!new_dentry->d_inode)
+		d_drop(new_dentry);
+
+	KFREE(name);
+
+	unlock_dentry(new_dentry);
+	unlock_dentry(old_dentry);
+
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_symlink(struct inode *dir, struct dentry *dentry,
+			   const char *symname)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *whiteout_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	umode_t mode;
+	int bindex = 0, bstart;
+	char *name = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_symlink", dentry);
+
+	/* We start out in the leftmost branch. */
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	/* check if whiteout exists in this branch, i.e. lookup .wh.foo first. If present, delete it */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found a .wh.foo entry, unlink it and then call vfs_symlink() */
+		hidden_dir_dentry = lock_parent(whiteout_dentry);
+
+		print_dentry("HDD", hidden_dir_dentry);
+		print_dentry("WD", whiteout_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			err =
+			    vfs_unlink(hidden_dir_dentry->d_inode,
+				       whiteout_dentry);
+		}
+		DPUT(whiteout_dentry);
+
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		dir->i_nlink = get_nlinks(dir);
+
+		unlock_dir(hidden_dir_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			/* should now try to create symlink in the another branch */
+			bstart--;
+		}
+	}
+
+	/* deleted whiteout if it was present, now do a normal vfs_symlink() with
+	   possible recursive directory creation */
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			/* if hidden_dentry is NULL, create the entire
+			 * dentry directory structure in branch 'bindex'. hidden_dentry will NOT be null when
+			 * bindex == bstart because lookup passed as a negative unionfs dentry pointing to a
+			 * lone negative underlying dentry */
+			hidden_dentry = create_parents(dir, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				if (IS_ERR(hidden_dentry)) {
+					err = PTR_ERR(hidden_dentry);
+				}
+				dprint(PRINT_DEBUG,
+					    "hidden dentry NULL (or error) for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			mode = S_IALLUGO;
+			err =
+			    vfs_symlink(hidden_dir_dentry->d_inode,
+					hidden_dentry, symname, mode);
+		}
+		unlock_dir(hidden_dir_dentry);
+
+		if (err || !hidden_dentry->d_inode) {
+			/* break out of for loop if error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, dir->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(dir,
+							 hidden_dir_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				dir->i_nlink = get_nlinks(dir);
+			}
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	KFREE(name);
+	print_dentry("OUT unionfs_symlink :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_mkdir(struct inode *parent, struct dentry *dentry, int mode)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int whiteout_unlinked = 0;
+	struct sioq_args args;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_mkdir", dentry);
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	// check if whiteout exists in this branch, i.e. lookup .wh.foo first
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		hidden_parent_dentry = lock_parent(whiteout_dentry);
+
+		//found a.wh.foo entry, remove it then do vfs_mkdir
+		if (!(err = is_robranch_super(dentry->d_sb, bstart))) {
+			args.unlink.parent = hidden_parent_dentry->d_inode;
+			args.unlink.dentry = whiteout_dentry;
+			run_sioq(__unionfs_unlink, &args);
+			err = args.err;
+		}
+		DPUT(whiteout_dentry);
+
+		unlock_dir(hidden_parent_dentry);
+
+		if (err) {
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			bstart--;
+		} else {
+			whiteout_unlinked = 1;
+		}
+	}
+
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			hidden_dentry = create_parents(parent, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				dprint(PRINT_DEBUG,
+					    "hidden dentry NULL for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err =
+			    vfs_mkdir(hidden_parent_dentry->d_inode,
+				      hidden_dentry, mode);
+		}
+		unlock_dir(hidden_parent_dentry);
+
+		/* XXX this could potentially return a negative hidden_dentry! */
+		if (err || !hidden_dentry->d_inode) {
+			/* break out of for loop if error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			int i;
+			int bend = dbend(dentry);
+
+			for (i = bindex + 1; i < bend; i++) {
+				if (dtohd_index(dentry, i)) {
+					DPUT(dtohd_index(dentry, i));
+					set_dtohd_index(dentry, i, NULL);
+				}
+			}
+			bend = bindex;
+			set_dbend(dentry, bend);
+
+			err = unionfs_interpose(dentry, parent->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(parent,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				parent->i_nlink = get_nlinks(parent);
+			}
+
+			err = make_dir_opaque(dentry, dbstart(dentry));
+			if (err) {
+				dprint(PRINT_DEBUG,
+					    "mkdir: error creating directory override entry: %d\n",
+					    err);
+				goto out;
+			}
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	KFREE(name);
+
+	print_dentry("OUT unionfs_mkdir :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_mknod(struct inode *dir, struct dentry *dentry, int mode,
+			 dev_t dev)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL, *whiteout_dentry = NULL;
+	struct dentry *hidden_parent_dentry = NULL;
+	int bindex = 0, bstart;
+	char *name = NULL;
+	int whiteout_unlinked = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_mknod", dentry);
+	bstart = dbstart(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	// check if whiteout exists in this branch, i.e. lookup .wh.foo first
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	whiteout_dentry =
+	    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+			   dentry->d_name.len + WHLEN);
+	if (IS_ERR(whiteout_dentry)) {
+		err = PTR_ERR(whiteout_dentry);
+		goto out;
+	}
+
+	if (!whiteout_dentry->d_inode) {
+		DPUT(whiteout_dentry);
+		whiteout_dentry = NULL;
+	} else {
+		/* found .wh.foo, unlink it */
+		hidden_parent_dentry = lock_parent(whiteout_dentry);
+
+		//found a.wh.foo entry, remove it then do vfs_mkdir
+		if (!(err = is_robranch_super(dentry->d_sb, bstart)))
+			err = vfs_unlink(hidden_parent_dentry->d_inode,
+					 whiteout_dentry);
+		DPUT(whiteout_dentry);
+
+		unlock_dir(hidden_parent_dentry);
+
+		if (err) {
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+
+			bstart--;
+		} else {
+			whiteout_unlinked = 1;
+		}
+	}
+
+	for (bindex = bstart; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			hidden_dentry = create_parents(dir, dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				dprint(PRINT_DEBUG,
+					    "hidden dentry NULL for bindex = %d\n",
+					    bindex);
+				continue;
+			}
+		}
+
+		hidden_parent_dentry = lock_parent(hidden_dentry);
+		if (IS_ERR(hidden_parent_dentry)) {
+			err = PTR_ERR(hidden_parent_dentry);
+			goto out;
+		}
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err = vfs_mknod(hidden_parent_dentry->d_inode,
+					hidden_dentry, mode, dev);
+		}
+		/* XXX this could potentially return a negative hidden_dentry! */
+		if (err || !hidden_dentry->d_inode) {
+			unlock_dir(hidden_parent_dentry);
+			/* break out of for, if error was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				break;
+		} else {
+			err = unionfs_interpose(dentry, dir->i_sb, 0);
+			if (!err) {
+				fist_copy_attr_timesizes(dir,
+							 hidden_parent_dentry->
+							 d_inode);
+				/* update number of links on parent directory */
+				dir->i_nlink = get_nlinks(dir);
+			}
+			unlock_dir(hidden_parent_dentry);
+
+			break;
+		}
+	}
+
+      out:
+	if (!dentry->d_inode)
+		d_drop(dentry);
+
+	if (name) {
+		KFREE(name);
+	}
+
+	print_dentry("OUT unionfs_mknod :", dentry);
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_readlink(struct dentry *dentry, char __user * buf, int bufsiz)
+{
+	int err;
+	struct dentry *hidden_dentry;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+	print_dentry("unionfs_readlink IN", dentry);
+
+	if (!hidden_dentry->d_inode->i_op ||
+	    !hidden_dentry->d_inode->i_op->readlink) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	err = hidden_dentry->d_inode->i_op->readlink(hidden_dentry,
+						     buf, bufsiz);
+	if (err > 0)
+		fist_copy_attr_atime(dentry->d_inode, hidden_dentry->d_inode);
+
+      out:
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* We don't lock the dentry here, because readlink does the heavy lifting. */
+static void *unionfs_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	char *buf;
+	int len = PAGE_SIZE, err;
+	mm_segment_t old_fs;
+
+	print_entry_location();
+
+	/* This is freed by the put_link method assuming a successful call. */
+	buf = (char *)KMALLOC(len, GFP_KERNEL);
+	if (!buf) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* read the symlink, and then we will follow it */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err = dentry->d_inode->i_op->readlink(dentry, (char __user *)buf, len);
+	set_fs(old_fs);
+	if (err < 0) {
+		KFREE(buf);
+		buf = NULL;
+		goto out;
+	}
+	buf[err] = 0;
+	nd_set_link(nd, buf);
+	err = 0;
+
+      out:
+	print_exit_status(err);
+	return ERR_PTR(err);
+}
+
+void unionfs_put_link(struct dentry *dentry, struct nameidata *nd, void *cookie)
+{
+	char *link;
+	print_entry_location();
+	link = nd_get_link(nd);
+	KFREE(link);
+	print_exit_location();
+}
+
+/* Basically copied from the kernel vfs permission(), but we've changed
+ * the following: (1) the IS_RDONLY check is skipped, and (2) if you set
+ * the mount option `nfsperms=insceure', we assume that -EACCES means that
+ * the export is read-only and we should check standard Unix permissions.
+ * This means that NFS ACL checks (or other advanced permission features)
+ * are bypassed.
+ */
+static int inode_permission(struct inode *inode, int mask, struct nameidata *nd,
+			    int bindex)
+{
+	int retval, submask;
+
+	if (mask & MAY_WRITE) {
+		/* The first branch is allowed to be really readonly. */
+		if (bindex == 0) {
+			umode_t mode = inode->i_mode;
+			if (IS_RDONLY(inode) && (S_ISREG(mode) || S_ISDIR(mode)
+						 || S_ISLNK(mode)))
+				return -EROFS;
+		}
+		/*
+		 * Nobody gets write access to an immutable file.
+		 */
+		if (IS_IMMUTABLE(inode))
+			return -EACCES;
+	}
+
+	/* Ordinary permission routines do not understand MAY_APPEND. */
+	submask = mask & ~MAY_APPEND;
+	if (inode->i_op && inode->i_op->permission) {
+		retval = inode->i_op->permission(inode, submask, nd);
+		if ((retval == -EACCES) && (submask & MAY_WRITE) &&
+		    (!strcmp("nfs", (inode)->i_sb->s_type->name)) &&
+		    (nd) && (nd->mnt) && (nd->mnt->mnt_sb) &&
+		    (branchperms(nd->mnt->mnt_sb, bindex) & MAY_NFSRO)) {
+			retval = generic_permission(inode, submask, NULL);
+		}
+	} else {
+		retval = generic_permission(inode, submask, NULL);
+	}
+
+	if (retval && retval != -EROFS) /* ignore EROFS */
+		return retval;
+
+	retval = security_inode_permission(inode, mask, nd);
+	return ((retval == -EROFS) ? 0 : retval); /* ignore EROFS */
+}
+
+static int unionfs_permission(struct inode *inode, int mask,
+			      struct nameidata *nd)
+{
+	struct inode *hidden_inode = NULL;
+	int err = 0;
+	int bindex, bstart, bend;
+	const int is_file = !S_ISDIR(inode->i_mode);
+	const int write_mask = (mask & MAY_WRITE) && !(mask & MAY_READ);
+
+	print_entry_location();
+
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+
+	print_inode("IN unionfs_permission", inode);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_inode = itohi_index(inode, bindex);
+		if (!hidden_inode)
+			continue;
+
+		/* check the condition for D-F-D underlying files/directories,
+		 * we dont have to check for files, if we are checking for
+		 * directories.
+		 */
+		if (!is_file && !S_ISDIR(hidden_inode->i_mode))
+			continue;
+		/* We use our own special version of permission, such that
+		 * only the first branch returns -EROFS. */
+		err = inode_permission(hidden_inode, mask, nd, bindex);
+		/* The permissions are an intersection of the overall directory
+		 * permissions, so we fail if one fails. */
+		if (err)
+			goto out;
+		/* only the leftmost file matters. */
+		if (is_file || write_mask) {
+			if (is_file && write_mask) {
+				err = get_write_access(hidden_inode);
+				if (!err)
+					put_write_access(hidden_inode);
+			}
+			break;
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_setattr(struct dentry *dentry, struct iattr *ia)
+{
+	int err = 0;
+	struct dentry *hidden_dentry;
+	struct inode *inode = NULL;
+	struct inode *hidden_inode = NULL;
+	int bstart, bend, bindex;
+	int i;
+	int copyup = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	inode = dentry->d_inode;
+
+	for (bindex = bstart; (bindex <= bend) || (bindex == bstart); bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		BUG_ON(hidden_dentry->d_inode == NULL);
+
+		/* If the file is on a read only branch */
+		if (is_robranch_super(dentry->d_sb, bindex)
+		    || IS_RDONLY(hidden_dentry->d_inode)) {
+			if (copyup || (bindex != bstart))
+				continue;
+			/* Only if its the leftmost file, copyup the file */
+			for (i = bstart - 1; i >= 0; i--) {
+				loff_t size = dentry->d_inode->i_size;
+				if (ia->ia_valid & ATTR_SIZE)
+					size = ia->ia_size;
+				err = copyup_dentry(dentry->d_parent->d_inode,
+						    dentry, bstart, i, NULL,
+						    size);
+
+				if (!err) {
+					copyup = 1;
+					hidden_dentry = dtohd(dentry);
+					break;
+				}
+				/* if error is in the leftmost f/s, pass it up */
+				if (i == 0)
+					goto out;
+			}
+
+		}
+		err = notify_change(hidden_dentry, ia);
+		if (err)
+			goto out;
+		break;
+	}
+#ifdef UNIONFS_MMAP
+	/*
+	 * SP: notify_change will change the lower file's size,
+	 * but we need to truncate the page tables, so need to call
+	 * vmtruncate()
+	 */
+
+	if (ia->ia_valid & ATTR_SIZE) {
+		if (ia->ia_size != i_size_read(inode)) {
+			err = vmtruncate(inode, ia->ia_size);
+			if (err) {
+				printk("unionfs_setattr: vmtruncate failed\n");
+			}
+		}
+	}
+#endif
+	/* get the size from the first hidden inode */
+	hidden_inode = itohi(dentry->d_inode);
+	checkinode(inode, "unionfs_setattr");
+	fist_copy_attr_all(inode, hidden_inode);
+
+      out:
+	unlock_dentry(dentry);
+	checkinode(inode, "post unionfs_setattr");
+	print_exit_status(err);
+	return err;
+}
+
+struct inode_operations unionfs_symlink_iops = {
+	.readlink = unionfs_readlink,
+	.permission = unionfs_permission,
+	.follow_link = unionfs_follow_link,
+	.setattr = unionfs_setattr,
+	.put_link = unionfs_put_link,
+};
+
+struct inode_operations unionfs_dir_iops = {
+	.create = unionfs_create,
+	.lookup = unionfs_lookup,
+	.link = unionfs_link,
+	.unlink = unionfs_unlink,
+	.symlink = unionfs_symlink,
+	.mkdir = unionfs_mkdir,
+	.rmdir = unionfs_rmdir,
+	.mknod = unionfs_mknod,
+	.rename = unionfs_rename,
+	.permission = unionfs_permission,
+	.setattr = unionfs_setattr,
+	.setxattr = unionfs_setxattr,
+	.getxattr = unionfs_getxattr,
+	.removexattr = unionfs_removexattr,
+	.listxattr = unionfs_listxattr,
+};
+
+struct inode_operations unionfs_main_iops = {
+	.permission = unionfs_permission,
+	.setattr = unionfs_setattr,
+	.setxattr = unionfs_setxattr,
+	.getxattr = unionfs_getxattr,
+	.removexattr = unionfs_removexattr,
+	.listxattr = unionfs_listxattr,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/INSTALL linux-2.6.20-sabayon-r1/fs/unionfs/INSTALL
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/INSTALL	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/INSTALL	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,189 @@
+To build Unionfs, there are two main components:
+
+-  unionfs.ko: the kernel module in 2.6
+
+-  unionctl: a user utility which allows you to add and remove branches
+
+You should be able to just type "make" and Unionfs will build itself for the
+running kernel.  The Makefile will look for your running kernel sources in
+/lib/modules/`uname -r`/build/include.
+
+If your kernel sources are located in a different directory, create a
+"fistdev.mk" file along the lines of:
+LINUXSRC=/path/to/my/kernel/sources/linux-2.6.xx
+TOPINC=-I$(LINUXSRC)/include
+MODDIR=/lib/modules/2.6.xx
+
+LINUXSRC points to the root of a Linux source tree.  TOPINC should point to
+that tree's include directory.  Finally, the module will be copied to
+$MODDIR/kernel/fs/unionfs.ko.
+
+You must set all three variables together, otherwise you can have problems
+compiling, installing, or loading the module.
+
+You also need to have the headers for e2fsprogs installed, on Red Hat
+derived systems (like Fedora Core), this means that you need to have
+e2fsprogs-devel installed.
+
+There are two Makefile options related to extended attribute support,
+which is turned off by default.  You should define UNIONFS_XATTR to turn
+it on.  Vanilla kernels should work automatically, but if you (or your
+vendor) has applied the ACL/EA patches you might need to define
+FIST_SETXATTR_CONSTVOID to correct the setxattr operation's function
+prototype.
+
+Using fistdev.mk, you can also turn on the debugging print system,
+which adds to the modules code size significantly.  Just add
+"EXTRACFLAGS=-DUNIONFS_DEBUG" to fistdev.mk.
+
+The doit.sh script included in the distribution will mount unionfs
+with two branches (/branch0 and /branch1) by default.  You can use it
+as an example and edit to your tastes.
+
+To install unionfs run "make install".  This copies unionfs.ko into
+/lib/modules/`uname -r`/kernel/fs/unionfs; copies the utilities into
+/usr/local/sbin; and copies man pages into /usr/local/man;
+
+fistdev.mk summary:
+UNIONFS_OPT_CFLAG	By default -O2.  If you want a different optimization
+			level change this variable.
+UNIONFS_DEBUG_CFLAG	By default -g.  If you want to remove debug, set
+			this variable to nothing.  This will result in a
+			smaller (but harder to debug) Unionfs.
+EXTRACFLAGS		Additional stuff to pass to the compiler, this
+			is useful when combined with the definitions below.
+			(e.g., EXTRACFLAGS=-DUNIONFS_DEBUG to turn on
+			debugging).
+LINUXSRC		Where to find the kernel build directory.
+TOPINC			Where to find the kernel headers.
+PREFIX			Where to install Unionfs utilities.
+			By default /usr/local.
+MODPREFIX		What is the prefix to the root directory for modules,
+			by default this is unset.  Your modules will end up
+			in /lib/modules/`uname -r`/kernel/fs.  With
+			MODPREFIX=/foo they end up in
+			/foo/lib/modules/`uname -r`/kernel/fs.
+UNIONFS_IMAP		Compiles in persistent inode code.  Mounting will
+			fail if you try to use the imap option without this
+			compile option.  The imap option is important if you
+			export your unionfs mount via NFS, because NFS
+			(v2/v3 at least) expects inode numbers to be
+			persistent, whereas Unionfs by default uses dynamic
+			inode numbers which may change silently.  Without
+			this imap option, NFS clients may see many "stale
+			file handle" errors, among others.
+Define options summary:
+UNIONFS_DEBUG		Turn on debugging facility (increases code size).
+UNIONFS_UNSUPPORTED	Bypass kernel versions checks.
+SUPPORT_BROKEN_SETUP	Enable sendfile, which allows you to run losetup, but
+			if you try to write to a loop file, you will cause
+			an Oops.
+UNIONFS_DELETE_ALL	Enable delete=all mode.
+UNIONFS_MMAP		Enable mmap support in unionfs still experimental.
+
+Known interactions with other kernel features/patches:
+* If you get an error like this on Fedora Core 4:
+  make: *** /lib/modules/2.6.11-1.1369_FC4/build: No such file or directory.  Stop.
+  Then you need to install the kernel-devel package.
+
+* If you get an error like this:
+  unionimap.h:9:23: uuid/uuid.h: No such file or directory
+  Followed, by more parse errors,  then you need to make sure you have
+  e2fsprogs-devel installed (or your distribution's equivalent).
+
+* Some NFS servers return -EACCES instead of -EROFS when they are exported
+  read-only.  This means that we can't legitimately determine when a user is
+  not allowed to access a file.  To enable a hack so that NFS appears to work
+  correctly (but NFS ACLs will break), mount the nfs-branch with mode nfsro.
+
+* If you want to export Unionfs over NFS, then you need to add
+  extra information to /etc/exports.  knfsd will not export Unionfs unless
+  you have an fsid option in /etc/exports.  This is because Unionfs has no
+  real device.  See man exports(5) for more information on fsid.
+
+* If you want to use Unionfs as your root file system you need to use
+  pivot_root.  www.linux-live.org provides scripts for creating live CDs with
+  Unionfs as the root.  The following commands are adapted from the linuxrc
+  from linux-live 5.0.16.  You may want to look at the original script from
+  www.linux-live.org if you are having problems.  SLAX (www.slax.org) is a
+  an actual live CD distribution based on these scripts.
+
+  UNION=/union
+  MEMORY=/memory
+  MOUNTDIR=/mnt
+  CHANGES=$MEMORY/changes
+
+  mkdir -p $UNION
+  mkdir -p $MEMORY
+  mount -t tmpfs tmpfs $MEMORY
+
+  mkdir -p $CHANGES
+  mount -t unionfs -o dirs=$CHANGES=rw unionfs $UNION
+
+  # Here other things can be added to the Union, by using unionctl.
+
+  # Finally set union as root
+  cd $UNION
+  mkdir -p initrd
+  pivot_root . initrd
+  exec chroot . sbin/init <dev/console >dev/console 2>&1
+  # You should never get here
+
+* If you want to use losetup, then you need to define -DSUPPORT_BROKEN_LOSETUP
+  You will be able to use it read-only, but when you try to use it read-write,
+  you will get an Oops.  This should eventually be fixed when we have our
+  own address-space operations (so that we can support sendfile).
+
+* Selinux requires extended attributes (but has not been tested by us).
+  You should compile Unionfs with Extended Attribute support by adding
+  EXTRACFLAGS=-DUNIONFS_XATTR to fistdev.mk.  After this, you can follow
+  the following instructions are from Jaspreet Singh:
+
+  1. Install strict/targetted selinux policy sources
+  2. Open /etc/selinux/<policy_type>/src/policy/fs_use
+  3. Append "fs_use_xattr unionfs system_u:object_r:fs_t;"
+  4. Compile, install, and reload the selinux policy
+
+  "There were a couple of issues with Unionfs but they were minor."
+
+* tmpfs does not support fsyncing directories, so if you have a Union with
+  tmpfs as the leftmost branch, fsync returns EINVAL.
+
+Other known limitations:
+* Unionfs does not provide cache coherency.  What this means to you is that
+  if you directly modify the lower-level branches, then Unionfs will get
+  confused.  You can tell Unionfs to throw out its cache and recreate all
+  of its objects (lazily), by running "uniondbg -g UNION".
+
+  It is especially dangerous to create or remove whiteouts from underneath
+  Unionfs, as there are several places where it asserts on invariants
+  that must be true (e.g., if the file exists, the whiteout should not and
+  vice versa).
+
+* Unionfs doesn't support sendfile.  This often manifests itself as apache
+  serving zero length files.  You can turn off sendfile n Apache with the
+  EnableSendfile httpd.conf directive (see
+  http://httpd.apache.org/docs/2.0/mod/core.html).   This is also the reason
+  that losetup is unsupported, Unionfs needs its own address space operations
+  otherwise upper and lower-level files and pages get mixed and matched.
+
+* If you restart an NFS server, you will get ESTALE errors on the client
+  because Unionfs does not have persistent inode numbers.  You should also
+  consider NFS over TCP, so lost packets don't cause readdir to get confused.
+
+* Renaming a directory on a read-only branch returns an EXDEV error.  The "mv"
+  utility is designed to handle this error (at least GNU coreutils and busybox
+  will handle this correctly), so a user will not see anything.  The only
+  issue will be applications that internally rename a directory, but do not
+  properly handle EXDEV (which is really a bug on the application's part).
+
+* The documentation needs to improve
+
+Integrating Unionfs into a 2.6 kernel source tree (2.4 is not supported):
+1. First run patch-kernel.sh included with Unionfs. Its first argument is the
+   path to your kernel source tree.
+2. Configure and compile your kernel as you normally would.   Unionfs is at the
+   bottom of the the File systems -> Miscellaenous filesystems menu.
+3. To install the Unionfs utilities (i.e., unionctl and uniondbg), run
+   "make utils install-utils" from the Unionfs source directory.
+4. Boot into your new kernel, and enjoy Unionfs.
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/lookup.c linux-2.6.20-sabayon-r1/fs/unionfs/lookup.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/lookup.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/lookup.c	2007-02-12 15:33:03.000000000 +0100
@@ -0,0 +1,508 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: lookup.c,v 1.49 2006/10/31 18:05:33 yiannos Exp $
+ */
+
+#include "unionfs.h"
+
+static int is_opaque_dir(struct dentry *dentry, int bindex);
+static int is_validname(const char *name);
+
+struct dentry *unionfs_lookup_backend(struct dentry *dentry, int lookupmode)
+{
+	int err = 0;
+	struct dentry *hidden_dentry = NULL;
+	struct dentry *wh_hidden_dentry = NULL;
+	struct dentry *hidden_dir_dentry = NULL;
+	struct dentry *parent_dentry = NULL;
+	int bindex, bstart, bend, bopaque;
+	int dentry_count = 0;	/* Number of positive dentries. */
+	int first_dentry_offset = -1;
+	struct dentry *first_hidden_dentry = NULL;
+	int locked_parent = 0;
+	int locked_child = 0;
+
+	int opaque;
+	char *whname = NULL;
+	const char *name;
+	int namelen;
+
+	print_entry("mode = %d", lookupmode);
+
+	/* We should already have a lock on this dentry in the case of a
+	 * partial lookup, or a revalidation. Otherwise it is returned from
+	 * new_dentry_private_data already locked.  */
+	if (lookupmode == INTERPOSE_PARTIAL || lookupmode == INTERPOSE_REVAL
+	    || lookupmode == INTERPOSE_REVAL_NEG) {
+		verify_locked(dentry);
+	} else {
+		BUG_ON(dtopd_nocheck(dentry) != NULL);
+		locked_child = 1;
+	}
+	if (lookupmode != INTERPOSE_PARTIAL)
+		if ((err = new_dentry_private_data(dentry)))
+			goto out;
+	/* must initialize dentry operations */
+	dentry->d_op = &unionfs_dops;
+
+	parent_dentry = GET_PARENT(dentry);
+	/* We never partial lookup the root directory. */
+	if (parent_dentry != dentry) {
+		lock_dentry(parent_dentry);
+		locked_parent = 1;
+	} else {
+		DPUT(parent_dentry);
+		parent_dentry = NULL;
+		goto out;
+	}
+
+	print_dentry("IN unionfs_lookup (parent)", parent_dentry);
+	print_dentry("IN unionfs_lookup (child)", dentry);
+
+	name = dentry->d_name.name;
+	namelen = dentry->d_name.len;
+
+	/* No dentries should get created for possible whiteout names. */
+	if (!is_validname(name)) {
+		err = -EPERM;
+		goto out_free;
+	}
+
+	/* Now start the actual lookup procedure. */
+	bstart = dbstart(parent_dentry);
+	bend = dbend(parent_dentry);
+	bopaque = dbopaque(parent_dentry);
+	BUG_ON(bstart < 0);
+
+	/* It would be ideal if we could convert partial lookups to only have
+	 * to do this work when they really need to.  It could probably improve
+	 * performance quite a bit, and maybe simplify the rest of the code. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		bstart++;
+		if ((bopaque != -1) && (bopaque < bend))
+			bend = bopaque;
+	}
+
+	dprint(PRINT_DEBUG, "bstart = %d, bend = %d\n", bstart, bend);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (lookupmode == INTERPOSE_PARTIAL && hidden_dentry)
+			continue;
+		BUG_ON(hidden_dentry != NULL);
+
+		hidden_dir_dentry = dtohd_index(parent_dentry, bindex);
+
+		/* if the parent hidden dentry does not exist skip this */
+		if (!(hidden_dir_dentry && hidden_dir_dentry->d_inode))
+			continue;
+
+		/* also skip it if the parent isn't a directory. */
+		if (!S_ISDIR(hidden_dir_dentry->d_inode->i_mode))
+			continue;
+
+		/* Reuse the whiteout name because its value doesn't change. */
+		if (!whname) {
+			whname = alloc_whname(name, namelen);
+			if (IS_ERR(whname)) {
+				err = PTR_ERR(whname);
+				goto out_free;
+			}
+		}
+
+		/* check if whiteout exists in this branch: lookup .wh.foo */
+		wh_hidden_dentry = LOOKUP_ONE_LEN(whname, hidden_dir_dentry,
+						  namelen + WHLEN);
+		if (IS_ERR(wh_hidden_dentry)) {
+			DPUT(first_hidden_dentry);
+			err = PTR_ERR(wh_hidden_dentry);
+			goto out_free;
+		}
+
+		if (wh_hidden_dentry->d_inode) {
+			/* We found a whiteout so lets give up. */
+			dprint(PRINT_DEBUG, "whiteout found in %d\n", bindex);
+			if (S_ISREG(wh_hidden_dentry->d_inode->i_mode)) {
+				set_dbend(dentry, bindex);
+				set_dbopaque(dentry, bindex);
+				DPUT(wh_hidden_dentry);
+				break;
+			}
+			err = -EIO;
+			printk(KERN_NOTICE "EIO: Invalid whiteout entry type"
+			       " %d.\n", wh_hidden_dentry->d_inode->i_mode);
+			DPUT(wh_hidden_dentry);
+			DPUT(first_hidden_dentry);
+			goto out_free;
+		}
+
+		DPUT(wh_hidden_dentry);
+		wh_hidden_dentry = NULL;
+
+		/* Now do regular lookup; lookup foo */
+		hidden_dentry = LOOKUP_ONE_LEN(name, hidden_dir_dentry,
+					       namelen);
+		print_dentry("hidden result", hidden_dentry);
+		if (IS_ERR(hidden_dentry)) {
+			DPUT(first_hidden_dentry);
+			err = PTR_ERR(hidden_dentry);
+			goto out_free;
+		}
+
+		/* Store the first negative dentry specially, because if they
+		 * are all negative we need this for future creates. */
+		if (!hidden_dentry->d_inode) {
+			if (!first_hidden_dentry && (dbstart(dentry) == -1)) {
+				first_hidden_dentry = hidden_dentry;
+				first_dentry_offset = bindex;
+			} else {
+				DPUT(hidden_dentry);
+			}
+			continue;
+		}
+
+		/* number of positive dentries */
+		dentry_count++;
+
+		/* store underlying dentry */
+		if (dbstart(dentry) == -1)
+			set_dbstart(dentry, bindex);
+		set_dtohd_index(dentry, bindex, hidden_dentry);
+		set_dbend(dentry, bindex);
+
+		/* update parent directory's atime with the bindex */
+		fist_copy_attr_atime(parent_dentry->d_inode,
+				     hidden_dir_dentry->d_inode);
+
+		/* We terminate file lookups here. */
+		if (!S_ISDIR(hidden_dentry->d_inode->i_mode)) {
+			if (lookupmode == INTERPOSE_PARTIAL)
+				continue;
+			if (dentry_count == 1)
+				goto out_positive;
+			/* This can only happen with mixed D-*-F-* */
+			BUG_ON(!S_ISDIR(dtohd(dentry)->d_inode->i_mode));
+			continue;
+		}
+
+		opaque = is_opaque_dir(dentry, bindex);
+		if (opaque < 0) {
+			DPUT(first_hidden_dentry);
+			err = opaque;
+			goto out_free;
+		}
+		if (opaque) {
+			set_dbend(dentry, bindex);
+			set_dbopaque(dentry, bindex);
+			break;
+		}
+	}
+
+	if (dentry_count)
+		goto out_positive;
+	else
+		goto out_negative;
+
+      out_negative:
+	if (lookupmode == INTERPOSE_PARTIAL)
+		goto out;
+
+	/* If we've only got negative dentries, then use the leftmost one. */
+	if (lookupmode == INTERPOSE_REVAL) {
+		if (dentry->d_inode) {
+			itopd(dentry->d_inode)->uii_stale = 1;
+		}
+		goto out;
+	}
+	/* This should only happen if we found a whiteout. */
+	if (first_dentry_offset == -1) {
+		first_hidden_dentry = LOOKUP_ONE_LEN(name, hidden_dir_dentry,
+						     namelen);
+		first_dentry_offset = bindex;
+		if (IS_ERR(first_hidden_dentry)) {
+			err = PTR_ERR(first_hidden_dentry);
+			goto out;
+		}
+	}
+	set_dtohd_index(dentry, first_dentry_offset, first_hidden_dentry);
+	set_dbstart(dentry, first_dentry_offset);
+	set_dbend(dentry, first_dentry_offset);
+
+	if (lookupmode == INTERPOSE_REVAL_NEG)
+		BUG_ON(dentry->d_inode != NULL);
+	else
+		d_add(dentry, NULL);
+	goto out;
+
+/* This part of the code is for positive dentries. */
+      out_positive:
+	BUG_ON(dentry_count <= 0);
+
+	/* If we're holding onto the first negative dentry throw it out. */
+	DPUT(first_hidden_dentry);
+
+	/* Partial lookups need to reinterpose, or throw away older negs. */
+	if (lookupmode == INTERPOSE_PARTIAL) {
+		if (dentry->d_inode) {
+			unionfs_reinterpose(dentry);
+			goto out;
+		}
+
+		/* This somehow turned positive, so it is as if we had a
+		 * negative revalidation.  */
+		lookupmode = INTERPOSE_REVAL_NEG;
+
+		update_bstart(dentry);
+		bstart = dbstart(dentry);
+		bend = dbend(dentry);
+	}
+
+	err = unionfs_interpose(dentry, dentry->d_sb, lookupmode);
+	if (err)
+		goto out_drop;
+
+	checkinode(dentry->d_inode, "unionfs_lookup OUT: child");
+	checkinode(parent_dentry->d_inode, "unionfs_lookup OUT: dir");
+	goto out;
+
+      out_drop:
+	d_drop(dentry);
+
+      out_free:
+	/* should dput all the underlying dentries on error condition */
+	bstart = dbstart(dentry);
+	if (bstart >= 0) {
+		bend = dbend(dentry);
+		for (bindex = bstart; bindex <= bend; bindex++)
+			DPUT(dtohd_index(dentry, bindex));
+	}
+	KFREE(dtohd_ptr(dentry));
+	dtohd_ptr(dentry) = NULL;
+	set_dbstart(dentry, -1);
+	set_dbend(dentry, -1);
+
+      out:
+	if (!err && dtopd(dentry)) {
+		BUG_ON(dbend(dentry) > dtopd(dentry)->udi_bcount);
+		BUG_ON(dbend(dentry) > sbmax(dentry->d_sb));
+		BUG_ON(dbstart(dentry) < 0);
+	}
+	KFREE(whname);
+	print_dentry("OUT unionfs_lookup (parent)", parent_dentry);
+	print_dentry("OUT unionfs_lookup (child)", dentry);
+	if (locked_parent)
+		unlock_dentry(parent_dentry);
+	DPUT(parent_dentry);
+	if (locked_child)
+		unlock_dentry(dentry);
+	print_exit_status(err);
+	return ERR_PTR(err);
+}
+
+/* This is a utility function that fills in a unionfs dentry.*/
+int unionfs_partial_lookup(struct dentry *dentry)
+{
+	struct dentry *tmp;
+
+	tmp = unionfs_lookup_backend(dentry, INTERPOSE_PARTIAL);
+	if (!tmp)
+		return 0;
+	if (IS_ERR(tmp))
+		return PTR_ERR(tmp);
+	/* need to change the interface */
+	BUG_ON(tmp != dentry);
+	return -ENOSYS;
+}
+
+/* The rest of these are utility functions for lookup. */
+static int is_opaque_dir(struct dentry *dentry, int bindex)
+{
+	int err = 0;
+	struct dentry *hidden_dentry;
+	struct dentry *wh_hidden_dentry;
+	struct inode *hidden_inode;
+	struct sioq_args args;
+
+	print_entry_location();
+
+	hidden_dentry = dtohd_index(dentry, bindex);
+	hidden_inode = hidden_dentry->d_inode;
+
+	BUG_ON(!S_ISDIR(hidden_inode->i_mode));
+
+	mutex_lock(&hidden_inode->i_mutex);
+	if (!permission(hidden_inode, MAY_EXEC, NULL))
+		wh_hidden_dentry = LOOKUP_ONE_LEN(UNIONFS_DIR_OPAQUE,
+					  hidden_dentry,
+					  sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	else {
+		args.isopaque.dentry = hidden_dentry;
+		run_sioq(__is_opaque_dir, &args);
+		wh_hidden_dentry = args.ret;
+	}
+
+	mutex_unlock(&hidden_inode->i_mutex);
+	if (IS_ERR(wh_hidden_dentry)) {
+		err = PTR_ERR(wh_hidden_dentry);
+		dprint(PRINT_DEBUG, "LOOKUP_ONE_LEN returned: %d\n", err);
+		goto out;
+	}
+	if (wh_hidden_dentry->d_inode)
+		err = 1;
+	DPUT(wh_hidden_dentry);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+static int is_validname(const char *name)
+{
+	if (!strncmp(name, WHPFX, WHLEN))
+		return 0;
+	if (!strncmp(name, UNIONFS_DIR_OPAQUE_NAME,
+		     sizeof(UNIONFS_DIR_OPAQUE_NAME) - 1))
+		return 0;
+	return 1;
+}
+
+/* The dentry cache is just so we have properly sized dentries. */
+static kmem_cache_t *unionfs_dentry_cachep;
+int init_dentry_cache(void)
+{
+	unionfs_dentry_cachep =
+	    kmem_cache_create("unionfs_dentry",
+			      sizeof(struct unionfs_dentry_info), 0,
+			      SLAB_RECLAIM_ACCOUNT, NULL, NULL);
+
+	if (!unionfs_dentry_cachep)
+		return -ENOMEM;
+	return 0;
+}
+
+void destroy_dentry_cache(void)
+{
+	if (!unionfs_dentry_cachep)
+		return;
+	return;
+}
+
+void free_dentry_private_data(struct unionfs_dentry_info *udi)
+{
+	if (!udi)
+		return;
+	kmem_cache_free(unionfs_dentry_cachep, udi);
+}
+
+int new_dentry_private_data(struct dentry *dentry)
+{
+	int newsize;
+	int oldsize = 0;
+
+	spin_lock(&dentry->d_lock);
+	if (!dtopd_nocheck(dentry)) {
+		dtopd_lhs(dentry) = (struct unionfs_dentry_info *)
+		    kmem_cache_alloc(unionfs_dentry_cachep, GFP_ATOMIC);
+		if (!dtopd_nocheck(dentry))
+			goto out;
+		init_MUTEX_LOCKED(&dtopd_nocheck(dentry)->udi_sem);
+#ifdef TRACKLOCK
+		printk("INITLOCK:%p\n", dentry);
+#endif
+		dtohd_ptr(dentry) = NULL;
+	} else {
+		oldsize = sizeof(struct dentry *) * dtopd(dentry)->udi_bcount;
+	}
+
+	dtopd_nocheck(dentry)->udi_bstart = -1;
+	dtopd_nocheck(dentry)->udi_bend = -1;
+	dtopd_nocheck(dentry)->udi_bopaque = -1;
+	dtopd_nocheck(dentry)->udi_bcount = sbmax(dentry->d_sb);
+	atomic_set(&dtopd_nocheck(dentry)->udi_generation,
+		   atomic_read(&stopd(dentry->d_sb)->usi_generation));
+	newsize = sizeof(struct dentry *) * sbmax(dentry->d_sb);
+
+	/* Don't reallocate when we already have enough space. */
+	/* It would be ideal if we could actually use the slab macros to
+	 * determine what our object sizes is, but those are not exported.
+	 */
+	if (oldsize) {
+		int minsize = malloc_sizes[0].cs_size;
+
+		if (!newsize || ((oldsize < newsize) && (newsize > minsize))) {
+			KFREE(dtohd_ptr(dentry));
+			dtohd_ptr(dentry) = NULL;
+		}
+	}
+
+	if (!dtohd_ptr(dentry) && newsize) {
+		dtohd_ptr(dentry) = KMALLOC(newsize, GFP_ATOMIC);
+		if (!dtohd_ptr(dentry))
+			goto out;
+	}
+
+	if (oldsize > newsize)
+		memset(dtohd_ptr(dentry), 0, oldsize);
+	else
+		memset(dtohd_ptr(dentry), 0, newsize);
+
+	spin_unlock(&dentry->d_lock);
+	return 0;
+
+      out:
+	free_dentry_private_data(dtopd_nocheck(dentry));
+	dtopd_lhs(dentry) = NULL;
+	spin_unlock(&dentry->d_lock);
+	return -ENOMEM;
+}
+
+void update_bstart(struct dentry *dentry)
+{
+	int bindex;
+	int bstart = dbstart(dentry);
+	int bend = dbend(dentry);
+	struct dentry *hidden_dentry;
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+		if (hidden_dentry->d_inode) {
+			set_dbstart(dentry, bindex);
+			break;
+		}
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	}
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/main.c linux-2.6.20-sabayon-r1/fs/unionfs/main.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/main.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/main.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,857 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: main.c,v 1.176 2006/10/10 07:28:13 jsipek Exp $
+ */
+
+#include "unionfs.h"
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+/* declarations added for "sparse" */
+extern void unionfs_kill_block_super(struct super_block *sb);
+
+/* declarations added for malloc_debugging */
+
+#ifdef FIST_MALLOC_DEBUG
+extern atomic_t unionfs_malloc_counter;
+extern atomic_t unionfs_mallocs_outstanding;
+#endif
+/* sb we pass is unionfs's super_block */
+int unionfs_interpose(struct dentry *dentry, struct super_block *sb, int flag)
+{
+	struct inode *hidden_inode;
+	struct dentry *hidden_dentry;
+	int err = 0;
+	struct inode *inode;
+	int is_negative_dentry = 1;
+	int bindex, bstart, bend;
+
+	print_entry("flag = %d", flag);
+
+	verify_locked(dentry);
+
+	print_dentry("In unionfs_interpose", dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* Make sure that we didn't get a negative dentry. */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		if (dtohd_index(dentry, bindex) &&
+		    dtohd_index(dentry, bindex)->d_inode) {
+			is_negative_dentry = 0;
+			break;
+		}
+	}
+	BUG_ON(is_negative_dentry);
+
+	/* We allocate our new inode below, by calling iget.
+	 * iget will call our read_inode which will initialize some
+	 * of the new inode's fields
+	 */
+
+	/* On revalidate we've already got our own inode and just need
+	 * to fix it up. */
+	if (flag == INTERPOSE_REVAL) {
+		inode = dentry->d_inode;
+		itopd(inode)->b_start = -1;
+		itopd(inode)->b_end = -1;
+		atomic_set(&itopd(inode)->uii_generation,
+			   atomic_read(&stopd(sb)->usi_generation));
+
+		itohi_ptr(inode) =
+		    KZALLOC(sbmax(sb) * sizeof(struct inode *), GFP_KERNEL);
+		if (!itohi_ptr(inode)) {
+			err = -ENOMEM;
+			goto out;
+		}
+		mutex_lock(&inode->i_mutex);
+	} else {
+		ino_t ino;
+		/* get unique inode number for unionfs */
+#ifdef UNIONFS_IMAP
+		if (stopd(sb)->usi_persistent) {
+			err = read_uin(sb, bindex,
+				       dtohd_index(dentry,
+						   bindex)->d_inode->i_ino,
+				       O_CREAT, &ino);
+			if (err)
+				goto out;
+		} else
+#endif
+			ino = iunique(sb, UNIONFS_ROOT_INO);
+
+		inode = IGET(sb, ino);
+		if (!inode) {
+			err = -EACCES;	/* should be impossible??? */
+			goto out;
+		}
+
+		mutex_lock(&inode->i_mutex);
+		if (atomic_read(&inode->i_count) > 1)
+			goto skip;
+	}
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry) {
+			set_itohi_index(inode, bindex, NULL);
+			continue;
+		}
+		/* Initialize the hidden inode to the new hidden inode. */
+		if (!hidden_dentry->d_inode)
+			continue;
+		set_itohi_index(inode, bindex, IGRAB(hidden_dentry->d_inode));
+	}
+
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	/* Use attributes from the first branch. */
+	hidden_inode = itohi(inode);
+
+	/* Use different set of inode ops for symlinks & directories */
+	if (S_ISLNK(hidden_inode->i_mode))
+		inode->i_op = &unionfs_symlink_iops;
+	else if (S_ISDIR(hidden_inode->i_mode))
+		inode->i_op = &unionfs_dir_iops;
+
+	/* Use different set of file ops for directories */
+	if (S_ISDIR(hidden_inode->i_mode))
+		inode->i_fop = &unionfs_dir_fops;
+
+	/* properly initialize special inodes */
+	if (S_ISBLK(hidden_inode->i_mode) || S_ISCHR(hidden_inode->i_mode) ||
+	    S_ISFIFO(hidden_inode->i_mode) || S_ISSOCK(hidden_inode->i_mode))
+		init_special_inode(inode, hidden_inode->i_mode,
+				   hidden_inode->i_rdev);
+#ifndef UNIONFS_MMAP
+	/* Fix our inode's address operations to that of the lower inode (Unionfs is FiST-Lite) */
+	if (inode->i_mapping->a_ops != hidden_inode->i_mapping->a_ops) {
+		dprint(PRINT_DEBUG, "fixing inode 0x%p a_ops (0x%p -> 0x%p)\n",
+		       inode, inode->i_mapping->a_ops,
+		       hidden_inode->i_mapping->a_ops);
+		inode->i_mapping->a_ops = hidden_inode->i_mapping->a_ops;
+	}
+#endif
+	/* all well, copy inode attributes */
+	fist_copy_attr_all(inode, hidden_inode);
+
+      skip:
+	/* only (our) lookup wants to do a d_add */
+	switch (flag) {
+	case INTERPOSE_DEFAULT:
+	case INTERPOSE_REVAL_NEG:
+		d_instantiate(dentry, inode);
+		break;
+	case INTERPOSE_LOOKUP:
+		err = PTR_ERR(d_splice_alias(inode, dentry));
+		break;
+	case INTERPOSE_REVAL:
+		/* Do nothing. */
+		break;
+	default:
+		printk(KERN_ERR "Invalid interpose flag passed!");
+		BUG();
+	}
+
+	print_dentry("Leaving unionfs_interpose", dentry);
+	print_inode("Leaving unionfs_interpose", inode);
+	mutex_unlock(&inode->i_mutex);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+void unionfs_reinterpose(struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct inode *inode;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+	verify_locked(dentry);
+	print_dentry("IN: unionfs_reinterpose: ", dentry);
+
+	/* This is pre-allocated inode */
+	inode = dentry->d_inode;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		if (!hidden_dentry->d_inode)
+			continue;
+		if (itohi_index(inode, bindex))
+			continue;
+		set_itohi_index(inode, bindex, IGRAB(hidden_dentry->d_inode));
+	}
+	ibstart(inode) = dbstart(dentry);
+	ibend(inode) = dbend(dentry);
+
+	print_dentry("OUT: unionfs_reinterpose: ", dentry);
+	print_inode("OUT: unionfs_reinterpose: ", inode);
+
+	print_exit_location();
+}
+
+int check_branch(struct nameidata *nd)
+{
+	if (!strcmp(nd->dentry->d_sb->s_type->name, "unionfs"))
+		return -EINVAL;
+	if (!nd->dentry->d_inode)
+		return -ENOENT;
+	if (!S_ISDIR(nd->dentry->d_inode->i_mode))
+		return -ENOTDIR;
+	return 0;
+}
+
+/* checks if two hidden_dentries have overlapping branches */
+int is_branch_overlap(struct dentry *dent1, struct dentry *dent2)
+{
+	struct dentry *dent = NULL;
+
+	dent = dent1;
+	while ((dent != dent2) && (dent->d_parent != dent)) {
+		dent = dent->d_parent;
+	}
+	if (dent == dent2) {
+		return 1;
+	}
+
+	dent = dent2;
+	while ((dent != dent1) && (dent->d_parent != dent)) {
+		dent = dent->d_parent;
+	}
+	if (dent == dent1) {
+		return 1;
+	}
+
+	return 0;
+}
+static int parse_branch_mode(char *name)
+{
+	int perms;
+	int l = strlen(name);
+	if (!strcmp(name + l - 3, "=ro")) {
+		perms = MAY_READ;
+		name[l - 3] = '\0';
+	} else if (!strcmp(name + l - 6, "=nfsro")) {
+		perms = MAY_READ | MAY_NFSRO;
+		name[l - 6] = '\0';
+	} else if (!strcmp(name + l - 3, "=rw")) {
+		perms = MAY_READ | MAY_WRITE;
+		name[l - 3] = '\0';
+	} else {
+		perms = MAY_READ | MAY_WRITE;
+	}
+
+	return perms;
+}
+static int get_separator_count(char *options, char *separator)
+{
+	char *token, *locopts, *locsep = NULL;
+	int count = 0;
+	/*
+	 * We copy options so we dont destroy our pointer for parsing
+	 */
+	if (separator == NULL) {
+		locsep = KMALLOC(2, GFP_KERNEL);
+		if (!locsep) {
+			count = -ENOMEM;
+			goto out;
+		}
+		strcpy(locsep, ":");
+	} else {
+		locsep = separator;
+	}
+	locopts = KMALLOC(strlen(options) + 1, GFP_KERNEL);
+	if (!locopts) {
+		count = -ENOMEM;
+		goto out;
+	}
+	strcpy(locopts, options);
+	while ((token = strsep(&locopts, locsep)) != NULL)
+		count++;
+      out:
+	KFREE(locopts);
+	return count;
+}
+static int parse_dirs_option(struct super_block *sb, struct unionfs_dentry_info
+			     *hidden_root_info, char *options, char *separator)
+{
+	struct nameidata nd;
+	char *name, *locsep = NULL;
+	int err = 0;
+	int branches = 1;
+	int bindex = 0;
+	int i = 0;
+	int j = 0;
+
+	struct dentry *dent1 = NULL;
+	struct dentry *dent2 = NULL;
+
+	if (options[0] == '\0') {
+		printk(KERN_WARNING "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+	/*
+	 * Check to see if separator is specified otherwise use ':'
+	 */
+	if (separator == NULL) {
+		locsep = KMALLOC(2, GFP_KERNEL);
+		if (!locsep) {
+			err = -ENOMEM;
+			goto out;
+		}
+		strcpy(locsep, ":");
+	} else {
+		locsep = separator;
+	}
+	branches = get_separator_count(options, separator);
+	/* allocate space for underlying pointers to hidden dentry */
+	if (!(stopd(sb)->usi_data = alloc_new_data(branches))) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	if (!(hidden_root_info->udi_dentry = alloc_new_dentries(branches))) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	/* now parsing the string b1:b2=rw:b3=ro:b4 */
+	branches = 0;
+	while ((name = strsep(&options, locsep)) != NULL) {
+		int perms;
+
+		if (!*name)
+			continue;
+		branches++;
+
+		/* strip off =rw or =ro if it is specified. */
+		perms = parse_branch_mode(name);
+		if (!bindex && !(perms & MAY_WRITE)) {
+			err = -EINVAL;
+			goto out;
+		}
+
+		dprint(PRINT_DEBUG, "using directory: %s (%c%c%c)\n",
+		       name, perms & MAY_READ ? 'r' : '-',
+		       perms & MAY_WRITE ? 'w' : '-',
+		       perms & MAY_NFSRO ? 'n' : '-');
+
+		err = path_lookup(name, LOOKUP_FOLLOW, &nd);
+		RECORD_PATH_LOOKUP(&nd);
+		if (err) {
+			printk(KERN_WARNING "unionfs: error accessing "
+			       "hidden directory '%s' (error %d)\n", name, err);
+			goto out;
+		}
+
+		if ((err = check_branch(&nd))) {
+			printk(KERN_WARNING "unionfs: hidden directory "
+			       "'%s' is not a valid branch\n", name);
+			path_release(&nd);
+			RECORD_PATH_RELEASE(&nd);
+			goto out;
+		}
+
+		hidden_root_info->udi_dentry[bindex] = nd.dentry;
+
+		set_stohiddenmnt_index(sb, bindex, nd.mnt);
+		set_branchperms(sb, bindex, perms);
+		set_branch_count(sb, bindex, 0);
+
+		if (hidden_root_info->udi_bstart < 0)
+			hidden_root_info->udi_bstart = bindex;
+		hidden_root_info->udi_bend = bindex;
+		bindex++;
+	}
+
+	if (branches == 0) {
+		printk(KERN_WARNING "unionfs: no branches specified\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	BUG_ON(branches != (hidden_root_info->udi_bend + 1));
+
+	/* ensure that no overlaps exist in the branches */
+	for (i = 0; i < branches; i++) {
+		for (j = i + 1; j < branches; j++) {
+			dent1 = hidden_root_info->udi_dentry[i];
+			dent2 = hidden_root_info->udi_dentry[j];
+
+			if (is_branch_overlap(dent1, dent2)) {
+				goto out_overlap;
+			}
+		}
+	}
+
+      out_overlap:
+
+	if (i != branches) {
+		printk(KERN_WARNING "unionfs: branches %d and %d overlap\n", i,
+		       j);
+		err = -EINVAL;
+		goto out;
+	}
+
+      out:
+	if (err) {
+		for (i = 0; i < branches; i++) {
+			if (hidden_root_info->udi_dentry[i])
+				DPUT(hidden_root_info->udi_dentry[i]);
+		}
+
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(stopd(sb)->usi_data);
+
+		/* MUST clear the pointers to prevent potential double free if
+		 * the caller dies later on
+		 */
+		hidden_root_info->udi_dentry = NULL;
+		stopd(sb)->usi_data = NULL;
+	}
+	if (!separator)
+		KFREE(locsep);
+	return err;
+}
+
+/*
+ * Parse mount options.  See the manual page for usage instructions.
+ *
+ * Returns the dentry object of the lower-level (hidden) directory;
+ * We want to mount our stackable file system on top of that hidden directory.
+ *
+ * Sets default debugging level to N, if any.
+ */
+static struct unionfs_dentry_info *unionfs_parse_options(struct super_block *sb,
+							 char *options)
+{
+	struct unionfs_dentry_info *hidden_root_info;
+	char *optname, *separator = NULL;
+	int err = 0;
+	int bindex;
+	int sepfound = 0;
+	int dirsfound = 0;
+#ifdef UNIONFS_IMAP
+	int imapfound = 0;
+#endif
+	print_entry_location();
+
+	/* allocate private data area */
+	err = -ENOMEM;
+	hidden_root_info =
+	    KZALLOC(sizeof(struct unionfs_dentry_info), GFP_KERNEL);
+	if (!hidden_root_info)
+		goto out_error;
+	hidden_root_info->udi_bstart = -1;
+	hidden_root_info->udi_bend = -1;
+	hidden_root_info->udi_bopaque = -1;
+
+	while ((optname = strsep(&options, ",")) != NULL) {
+		char *optarg;
+		char *endptr;
+		int intval;
+
+		if (!*optname) {
+			continue;
+		}
+
+		optarg = strchr(optname, '=');
+		if (optarg) {
+			*optarg++ = '\0';
+		}
+
+		/* All of our options take an argument now. Insert ones that
+		 * don't, above this check.  */
+		if (!optarg) {
+			printk("unionfs: %s requires an argument.\n", optname);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("dirs", optname)) {
+			if (++dirsfound > 1) {
+				printk(KERN_WARNING
+				       "unionfs: multiple dirs specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err =
+			    parse_dirs_option(sb, hidden_root_info, optarg,
+					      separator);
+			if (err)
+				goto out_error;
+			continue;
+		}
+#ifdef UNIONFS_IMAP
+		if (!strcmp("imap", optname)) {
+			if (++imapfound > 1) {
+				printk(KERN_WARNING
+				       "unionfs: multiple imap specified\n");
+				err = -EINVAL;
+				goto out_error;
+			}
+			err = parse_imap_option(sb, hidden_root_info, optarg);
+			if (err)
+				goto out_error;
+			continue;
+		}
+#endif
+		if (!strcmp("delete", optname)) {
+			if (!strcmp("whiteout", optarg)) {
+				/* default */
+#ifdef UNIONFS_DELETE_ALL
+			} else if (!strcmp("all", optarg)) {
+				MOUNT_FLAG(sb) |= DELETE_ALL;
+#endif
+			} else {
+				printk(KERN_WARNING
+				       "unionfs: invalid delete option '%s'\n",
+				       optarg);
+				err = -EINVAL;
+				goto out_error;
+			}
+			continue;
+		}
+
+		if (!strcmp("separator", optname)) {
+			if (dirsfound) {
+				printk(KERN_WARNING
+				       "unionfs: dirs= already parsed separator '%s' will have no effect\n",
+				       optarg);
+				continue;
+			}
+			sepfound = 1;
+			separator = KMALLOC(strlen(optarg) + 1, GFP_KERNEL);
+			if (!separator) {
+				err = -ENOMEM;
+				goto out_error;
+			}
+			strcpy(separator, optarg);
+			continue;
+		}
+		/* All of these options require an integer argument. */
+		intval = simple_strtoul(optarg, &endptr, 0);
+		if (*endptr) {
+			printk(KERN_WARNING
+			       "unionfs: invalid %s option '%s'\n",
+			       optname, optarg);
+			err = -EINVAL;
+			goto out_error;
+		}
+
+		if (!strcmp("debug", optname)) {
+			set_debug_mask(intval);
+			continue;
+		}
+
+		err = -EINVAL;
+		printk(KERN_WARNING
+		       "unionfs: unrecognized option '%s'\n", optname);
+		goto out_error;
+	}
+	if (dirsfound != 1) {
+		printk(KERN_WARNING "unionfs: dirs option required\n");
+		err = -EINVAL;
+		goto out_error;
+	}
+	goto out;
+
+      out_error:
+	if (hidden_root_info && hidden_root_info->udi_dentry) {
+		for (bindex = hidden_root_info->udi_bstart;
+		     bindex >= 0 && bindex <= hidden_root_info->udi_bend;
+		     bindex++) {
+			struct dentry *d;
+			d = hidden_root_info->udi_dentry[bindex];
+			DPUT(d);
+			if (stohiddenmnt_index(sb, bindex))
+				mntput(stohiddenmnt_index(sb, bindex));
+		}
+	}
+
+	KFREE(hidden_root_info->udi_dentry);
+	KFREE(hidden_root_info);
+
+	KFREE(stopd(sb)->usi_data);
+	stopd(sb)->usi_data = NULL;
+
+	hidden_root_info = ERR_PTR(err);
+	KFREE(separator);
+      out:
+	print_exit_location();
+	return hidden_root_info;
+}
+
+static struct dentry *unionfs_d_alloc_root(struct super_block *sb)
+{
+	struct dentry *ret = NULL;
+
+	if (sb) {
+		static const struct qstr name = {.name = "/",.len = 1 };
+
+		ret = d_alloc(NULL, &name);
+		if (ret) {
+			ret->d_op = &unionfs_dops;
+			ret->d_sb = sb;
+			ret->d_parent = ret;
+		}
+	}
+	return ret;
+}
+
+static int unionfs_read_super(struct super_block *sb, void *raw_data,
+			      int silent)
+{
+	int err = 0;
+
+	struct unionfs_dentry_info *hidden_root_info = NULL;
+	int bindex, bstart, bend;
+	unsigned long long maxbytes;
+
+	print_entry_location();
+
+	if (!raw_data) {
+		printk(KERN_WARNING
+		       "unionfs_read_super: missing data argument\n");
+		err = -EINVAL;
+		goto out;
+	}
+
+	/*
+	 * Allocate superblock private data
+	 */
+	stopd_lhs(sb) = KZALLOC(sizeof(struct unionfs_sb_info), GFP_KERNEL);
+	if (!stopd(sb)) {
+		printk(KERN_WARNING "%s: out of memory\n", __FUNCTION__);
+		err = -ENOMEM;
+		goto out;
+	}
+	stopd(sb)->b_end = -1;
+	atomic_set(&stopd(sb)->usi_generation, 1);
+	init_rwsem(&stopd(sb)->usi_rwsem);
+
+	hidden_root_info = unionfs_parse_options(sb, raw_data);
+	if (IS_ERR(hidden_root_info)) {
+		printk(KERN_WARNING
+		       "unionfs_read_super: error while parsing options (err = %ld)\n",
+		       PTR_ERR(hidden_root_info));
+		err = PTR_ERR(hidden_root_info);
+		hidden_root_info = NULL;
+		goto out_free;
+	}
+	if (hidden_root_info->udi_bstart == -1) {
+		err = -ENOENT;
+		goto out_free;
+	}
+
+	/* set the hidden superblock field of upper superblock */
+	bstart = hidden_root_info->udi_bstart;
+	BUG_ON(bstart != 0);
+	sbend(sb) = bend = hidden_root_info->udi_bend;
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+
+		d = hidden_root_info->udi_dentry[bindex];
+
+		set_stohs_index(sb, bindex, d->d_sb);
+	}
+
+	/* Unionfs: Max Bytes is the maximum bytes from among all the branches */
+	maxbytes = -1;
+	for (bindex = bstart; bindex <= bend; bindex++)
+		if (maxbytes < stohs_index(sb, bindex)->s_maxbytes)
+			maxbytes = stohs_index(sb, bindex)->s_maxbytes;
+	sb->s_maxbytes = maxbytes;
+
+	sb->s_op = &unionfs_sops;
+#ifdef CONFIG_EXPORTFS
+	sb->s_export_op = &unionfs_export_ops;
+#endif
+
+	/*
+	 * we can't use d_alloc_root if we want to use
+	 * our own interpose function unchanged,
+	 * so we simply call our own "fake" d_alloc_root
+	 */
+	sb->s_root = unionfs_d_alloc_root(sb);
+	if (!sb->s_root) {
+		err = -ENOMEM;
+		goto out_dput;
+	}
+
+	/* link the upper and lower dentries */
+	dtopd_lhs(sb->s_root) = NULL;
+	if ((err = new_dentry_private_data(sb->s_root)))
+		goto out_freedpd;
+
+	/* Set the hidden dentries for s_root */
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		struct dentry *d;
+
+		d = hidden_root_info->udi_dentry[bindex];
+
+		set_dtohd_index(sb->s_root, bindex, d);
+	}
+	set_dbstart(sb->s_root, bstart);
+	set_dbend(sb->s_root, bend);
+
+	/* Set the generation number to one, since this is for the mount. */
+	atomic_set(&dtopd(sb->s_root)->udi_generation, 1);
+
+	/* call interpose to create the upper level inode */
+	if ((err = unionfs_interpose(sb->s_root, sb, 0)))
+		goto out_freedpd;
+	unlock_dentry(sb->s_root);
+	goto out;
+
+      out_freedpd:
+	if (dtopd(sb->s_root)) {
+		KFREE(dtohd_ptr(sb->s_root));
+		free_dentry_private_data(dtopd(sb->s_root));
+	}
+	DPUT(sb->s_root);
+      out_dput:
+	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
+		for (bindex = hidden_root_info->udi_bstart;
+		     bindex <= hidden_root_info->udi_bend; bindex++) {
+			struct dentry *d;
+
+			d = hidden_root_info->udi_dentry[bindex];
+
+			if (d)
+				DPUT(d);
+
+			if (stopd(sb) && stohiddenmnt_index(sb, bindex))
+				mntput(stohiddenmnt_index(sb, bindex));
+		}
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(hidden_root_info);
+		hidden_root_info = NULL;
+	}
+      out_free:
+	KFREE(stopd(sb)->usi_data);
+	KFREE(stopd(sb));
+	stopd_lhs(sb) = NULL;
+      out:
+	if (hidden_root_info && !IS_ERR(hidden_root_info)) {
+		KFREE(hidden_root_info->udi_dentry);
+		KFREE(hidden_root_info);
+	}
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_get_sb(struct file_system_type *fs_type,
+			  int flags, const char *dev_name,
+			  void *raw_data, struct vfsmount *mnt)
+{
+	return get_sb_nodev(fs_type, flags, raw_data, unionfs_read_super, mnt);
+}
+
+void unionfs_kill_block_super(struct super_block *sb)
+{
+	generic_shutdown_super(sb);
+}
+
+static struct file_system_type unionfs_fs_type = {
+	.owner = THIS_MODULE,
+	.name = "unionfs",
+	.get_sb = unionfs_get_sb,
+	.kill_sb = unionfs_kill_block_super,
+	.fs_flags = FS_REVAL_DOT,
+};
+
+static int init_debug = 0;
+module_param_named(debug, init_debug, int, S_IRUGO);
+MODULE_PARM_DESC(debug, "Initial Unionfs debug value.");
+
+static int __init init_unionfs_fs(void)
+{
+	int err;
+	printk("Registering unionfs " UNIONFS_VERSION "\n");
+
+	set_debug_mask(init_debug);
+
+#ifdef FIST_MALLOC_DEBUG
+	atomic_set(&unionfs_malloc_counter, 0);
+	atomic_set(&unionfs_mallocs_outstanding, 0);
+#endif				/* FIST_MALLOC_DEBUG */
+
+	if ((err = init_filldir_cache()))
+		goto out;
+	if ((err = init_inode_cache()))
+		goto out;
+	if ((err = init_dentry_cache()))
+		goto out;
+	if ((err = init_sioq()))
+		goto out;
+	err = register_filesystem(&unionfs_fs_type);
+      out:
+	if (err) {
+		fin_sioq();
+		destroy_filldir_cache();
+		destroy_inode_cache();
+		destroy_dentry_cache();
+	}
+	return err;
+}
+static void __exit exit_unionfs_fs(void)
+{
+	fin_sioq();
+	destroy_filldir_cache();
+	destroy_inode_cache();
+	destroy_dentry_cache();
+	unregister_filesystem(&unionfs_fs_type);
+	printk("Completed unionfs module unload.\n");
+}
+
+MODULE_AUTHOR
+    ("Filesystems and Storage Lab, Stony Brook University (http://www.fsl.cs.sunysb.edu/)");
+MODULE_DESCRIPTION("Unionfs " UNIONFS_VERSION
+		   " (http://unionfs.filesystems.org/)");
+MODULE_LICENSE("GPL");
+
+module_init(init_unionfs_fs);
+module_exit(exit_unionfs_fs);
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/Makefile linux-2.6.20-sabayon-r1/fs/unionfs/Makefile
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/Makefile	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,16 @@
+UNIONFS_VERSION  = 1.5pre-cvs200611080310
+SUP_MAJOR= 2
+SUP_MINOR= 6
+SUP_PATCH= 19
+
+EXTRA_CFLAGS+=-DUNIONFS_VERSION=\"${UNIONFS_VERSION}\" -DSUP_MAJOR=${SUP_MAJOR} -DSUP_MINOR=${SUP_MINOR} -DSUP_PATCH=${SUP_PATCH}
+
+# This will enable full debugging support
+# EXTRA_CFLAGS+=-DUNIONFS_DEBUG
+
+obj-$(CONFIG_UNION_FS) += unionfs.o
+
+unionfs-objs := subr.o dentry.o file.o inode.o main.o super.o \
+	stale_inode.o branchman.o xattr.o rdstate.o copyup.o  \
+	dirhelper.o rename.o unlink.o lookup.o persistent_inode.o \
+	commonfops.o dirfops.o print.o sioq.o
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/malloc_debug.c linux-2.6.20-sabayon-r1/fs/unionfs/malloc_debug.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/malloc_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/malloc_debug.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,199 @@
+#ifdef FIST_MALLOC_DEBUG
+
+#include "unionfs.h"
+
+/* for malloc debugging */
+atomic_t unionfs_malloc_counter = ATOMIC_INIT(0);
+atomic_t unionfs_mallocs_outstanding = ATOMIC_INIT(0);
+atomic_t unionfs_dget_counter = ATOMIC_INIT(0);
+atomic_t unionfs_dgets_outstanding = ATOMIC_INIT(0);
+atomic_t unionfs_iget_counter = ATOMIC_INIT(0);
+atomic_t unionfs_igets_outstanding = ATOMIC_INIT(0);
+
+void *unionfs_kzalloc(size_t size, gfp_t flags, int line, const char *file)
+{
+	void *ptr = kzalloc(size, flags);
+	if (ptr) {
+		atomic_inc(&unionfs_malloc_counter);
+		atomic_inc(&unionfs_mallocs_outstanding);
+		printk("KZA:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_malloc_counter),
+		       atomic_read(&unionfs_mallocs_outstanding), ptr, line,
+		       file);
+	}
+	return ptr;
+}
+void *unionfs_kmalloc(size_t size, gfp_t flags, int line, const char *file)
+{
+	void *ptr = kmalloc(size, flags);
+	if (ptr) {
+		atomic_inc(&unionfs_malloc_counter);
+		atomic_inc(&unionfs_mallocs_outstanding);
+		printk("KM:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_malloc_counter),
+		       atomic_read(&unionfs_mallocs_outstanding), ptr, line,
+		       file);
+	}
+	return ptr;
+}
+
+void unionfs_kfree(void *ptr, int line, const char *file)
+{
+	atomic_inc(&unionfs_malloc_counter);
+	if (ptr) {
+		BUG_ON(IS_ERR(ptr));
+		atomic_dec(&unionfs_mallocs_outstanding);
+	}
+	printk("KF:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_malloc_counter),
+	       atomic_read(&unionfs_mallocs_outstanding), ptr, line, file);
+	kfree(ptr);
+}
+
+void record_set(struct dentry *upper, int index, struct dentry *ptr,
+		struct dentry *old, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	printk("DD:%d:%d:%d:%p:%d:%s %p, %d\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       old ? atomic_read(&old->d_count) : 0, old, line, file, upper,
+	       index);
+	atomic_inc(&unionfs_dget_counter);
+	printk("DS:%d:%d:%d:%p:%d:%s %p, %d\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file, upper,
+	       index);
+}
+
+void record_path_lookup(struct nameidata *nd, int line, const char *file)
+{
+	struct dentry *ptr = nd->dentry;
+	if (ptr) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DL:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+}
+
+void record_path_release(struct nameidata *nd, int line, const char *file)
+{
+	struct dentry *ptr = nd->dentry;
+
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr)
+		atomic_dec(&unionfs_dgets_outstanding);
+	printk("DP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+}
+
+struct file *unionfs_dentry_open(struct dentry *ptr, struct vfsmount *mnt,
+				 int flags, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr)
+		atomic_dec(&unionfs_dgets_outstanding);
+	printk("DO:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+	return dentry_open(ptr, mnt, flags);
+}
+
+struct dentry *unionfs_dget(struct dentry *ptr, int line, const char *file)
+{
+	ptr = dget(ptr);
+	if (ptr) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DG:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+	return ptr;
+}
+
+struct dentry *unionfs_dget_parent(struct dentry *child, int line,
+				   const char *file)
+{
+	struct dentry *ptr;
+
+	ptr = dget_parent(child);
+	atomic_inc(&unionfs_dget_counter);
+	atomic_inc(&unionfs_dgets_outstanding);
+	printk("DG:%d:%d:%d:%p:%d:%s\n",
+	       atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       atomic_read(&ptr->d_count), ptr, line, file);
+
+	return ptr;
+}
+
+struct dentry *unionfs_lookup_one_len(const char *name, struct dentry *parent,
+				      int len, int line, const char *file)
+{
+	struct dentry *ptr = lookup_one_len(name, parent, len);
+	if (ptr && !IS_ERR(ptr)) {
+		atomic_inc(&unionfs_dget_counter);
+		atomic_inc(&unionfs_dgets_outstanding);
+		printk("DL:%d:%d:%d:%p:%d:%s\n",
+		       atomic_read(&unionfs_dget_counter),
+		       atomic_read(&unionfs_dgets_outstanding),
+		       atomic_read(&ptr->d_count), ptr, line, file);
+	}
+	return ptr;
+}
+
+void unionfs_dput(struct dentry *ptr, int line, const char *file)
+{
+	atomic_inc(&unionfs_dget_counter);
+	if (ptr) {
+		BUG_ON(IS_ERR(ptr));
+		atomic_dec(&unionfs_dgets_outstanding);
+	}
+	printk("DP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_dget_counter),
+	       atomic_read(&unionfs_dgets_outstanding),
+	       ptr ? atomic_read(&ptr->d_count) : 0, ptr, line, file);
+	dput(ptr);
+}
+
+struct inode *unionfs_igrab(struct inode *inode, int line, char *file)
+{
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_inc(&unionfs_igets_outstanding);
+	printk("IR:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	return igrab(inode);
+}
+
+void unionfs_iput(struct inode *inode, int line, char *file)
+{
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_dec(&unionfs_igets_outstanding);
+	printk("IP:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	iput(inode);
+}
+
+struct inode *unionfs_iget(struct super_block *sb, unsigned long ino, int line,
+			   char *file)
+{
+	struct inode *inode = iget(sb, ino);
+	atomic_inc(&unionfs_iget_counter);
+	if (inode)
+		atomic_inc(&unionfs_igets_outstanding);
+	printk("IG:%d:%d:%d:%p:%d:%s\n", atomic_read(&unionfs_iget_counter),
+	       atomic_read(&unionfs_igets_outstanding),
+	       inode ? atomic_read(&inode->i_count) : 0, inode, line, file);
+	return inode;
+}
+
+#endif				/* FIST_MALLOC_DEBUG */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/mmap.c linux-2.6.20-sabayon-r1/fs/unionfs/mmap.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/mmap.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/mmap.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,326 @@
+/*
+ * Copyright (c) 1997-2005 Erez Zadok <ezk@cs.stonybrook.edu>
+ * Copyright (c) 2001-2005 Stony Brook University
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package, or get one from ftp://ftp.filesystems.org/pub/fistgen/COPYING.
+ *
+ * This Copyright notice must be kept intact and distributed with all
+ * fistgen sources INCLUDING sources generated by fistgen.
+ */
+/*
+ *  $Id: mmap.c,v 1.11 2006/07/08 17:58:31 ezk Exp $
+ */
+
+#include "unionfs.h"
+
+/* SP: writepage doesn't handle copyup yet
+ * a possible solution
+ *
+ * inode = d_find_alias(inode);
+ * dentry = d_find_alias(inode);
+ *
+ * then can determine if dentry needs to be copied up
+ *
+ * Questions:
+ *
+ * 1) will d_find_alias() always return a dentry?
+ * 2) hard links? (generic problem)
+ */
+int unionfs_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int err = -EIO;
+	struct inode *inode;
+	struct inode *lower_inode;
+	struct page *lower_page;
+	char *kaddr, *lower_kaddr;
+
+	print_entry_location();
+
+	inode = page->mapping->host;
+	lower_inode = itohi(inode);
+
+	/* find lower page (returns a locked page) */
+	lower_page = grab_cache_page(lower_inode->i_mapping, page->index);
+	if (!lower_page)
+		goto out;
+
+	/* get page address, and encode it */
+	kaddr = (char *)kmap(page);
+	lower_kaddr = (char *)kmap(lower_page);
+
+	memcpy(lower_kaddr, kaddr, PAGE_CACHE_SIZE);
+
+	kunmap(page);
+	kunmap(lower_page);
+
+	/* call lower writepage (expects locked page) */
+	err = lower_inode->i_mapping->a_ops->writepage(lower_page, wbc);
+
+	/*
+	 * update mtime and ctime of lower level file system
+	 * unionfs' mtime and ctime are updated by generic_file_write
+	 */
+	lower_inode->i_mtime = lower_inode->i_ctime = CURRENT_TIME;
+
+	page_cache_release(lower_page);	/* b/c grab_cache_page increased refcnt */
+
+	if (err)
+		ClearPageUptodate(page);
+	else
+		SetPageUptodate(page);
+      out:
+	unlock_page(page);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * readpage is called from generic_page_read and the fault handler.
+ * If your file system uses generic_page_read for the read op, it
+ * must implement readpage.
+ *
+ * Readpage expects a locked page, and must unlock it.
+ */
+int unionfs_do_readpage(struct file *file, struct page *page)
+{
+	int err = -EIO;
+	struct dentry *dentry;
+	struct file *lower_file = NULL;
+	struct inode *inode, *lower_inode;
+	char *page_data;
+	struct page *lower_page;
+	char *lower_page_data;
+
+	print_entry_location();
+
+	dentry = file->f_dentry;
+	if (ftopd(file) == NULL) {
+		err = -ENOENT;
+		goto out_err;
+	}
+	lower_file = ftohf(file);
+	inode = dentry->d_inode;
+	lower_inode = itohi(inode);
+
+	lower_page = NULL;
+
+	/* find lower page (returns a locked page) */
+	lower_page = read_cache_page(lower_inode->i_mapping,
+				     page->index,
+				     (filler_t *) lower_inode->i_mapping->
+				     a_ops->readpage, (void *)lower_file);
+
+	if (IS_ERR(lower_page)) {
+		err = PTR_ERR(lower_page);
+		lower_page = NULL;
+		goto out_release;
+	}
+
+	/*
+	 * wait for the page data to show up
+	 * (signaled by readpage as unlocking the page)
+	 */
+	wait_on_page_locked(lower_page);
+	if (!PageUptodate(lower_page)) {
+		/*
+		 * call readpage() again if we returned from wait_on_page with a
+		 * page that's not up-to-date; that can happen when a partial
+		 * page has a few buffers which are ok, but not the whole
+		 * page.
+		 */
+		lock_page(lower_page);
+		err = lower_inode->i_mapping->a_ops->readpage(lower_file,
+							      lower_page);
+		if (err) {
+			lower_page = NULL;
+			goto out_release;
+		}
+		wait_on_page_locked(lower_page);
+		if (!PageUptodate(lower_page)) {
+			err = -EIO;
+			goto out_release;
+		}
+	}
+
+	/* map pages, get their addresses */
+	page_data = (char *)kmap(page);
+	lower_page_data = (char *)kmap(lower_page);
+
+	memcpy(page_data, lower_page_data, PAGE_CACHE_SIZE);
+
+	err = 0;
+
+	kunmap(lower_page);
+	kunmap(page);
+
+      out_release:
+	if (lower_page)
+		page_cache_release(lower_page);	/* undo read_cache_page */
+
+	if (err == 0)
+		SetPageUptodate(page);
+	else
+		ClearPageUptodate(page);
+
+      out_err:
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_readpage(struct file *file, struct page *page)
+{
+	int err;
+	print_entry_location();
+
+	err = unionfs_do_readpage(file, page);
+
+	/*
+	 * we have to unlock our page, b/c we _might_ have gotten a locked page.
+	 * but we no longer have to wakeup on our page here, b/c UnlockPage does
+	 * it
+	 */
+
+	unlock_page(page);
+
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_prepare_write(struct file *file, struct page *page, unsigned from,
+			  unsigned to)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	print_exit_status(err);
+	return err;
+}
+
+int unionfs_commit_write(struct file *file, struct page *page, unsigned from,
+			 unsigned to)
+{
+	int err = -ENOMEM;
+	struct inode *inode, *lower_inode;
+	struct file *lower_file = NULL;
+	loff_t pos;
+	unsigned bytes = to - from;
+	char *page_data = NULL;
+	mm_segment_t old_fs;
+
+	print_entry_location();
+
+	BUG_ON(file == NULL);
+
+	inode = page->mapping->host;	/* CPW: Moved below print_entry_location */
+	lower_inode = itohi(inode);
+
+	if (ftopd(file) != NULL)
+		lower_file = ftohf(file);
+
+	BUG_ON(lower_file == NULL);	/* XXX: is this assertion right here? */
+
+	page_data = (char *)kmap(page);
+	lower_file->f_pos = (page->index << PAGE_CACHE_SHIFT) + from;
+
+	/* SP: I use vfs_write instead of copying page data and the
+	 * prepare_write/commit_write combo because file system's like
+	 * GFS/OCFS2 don't like things touching those directly,
+	 * calling the underlying write op, while a little bit slower, will
+	 * call all the FS specific code as well
+	 */
+	old_fs = get_fs();
+	set_fs(KERNEL_DS);
+	err =
+	    vfs_write(lower_file, page_data + from, bytes, &lower_file->f_pos);
+	set_fs(old_fs);
+
+	kunmap(page);
+
+	if (err < 0)
+		goto out;
+
+	inode->i_blocks = lower_inode->i_blocks;
+	/* we may have to update i_size */
+	pos = ((loff_t) page->index << PAGE_CACHE_SHIFT) + to;
+	if (pos > i_size_read(inode))
+		i_size_write(inode, pos);
+
+	/*
+	 * update mtime and ctime of lower level file system
+	 * unionfs' mtime and ctime are updated by generic_file_write
+	 */
+	lower_inode->i_mtime = lower_inode->i_ctime = CURRENT_TIME;
+
+	mark_inode_dirty_sync(inode);
+
+      out:
+	if (err < 0)
+		ClearPageUptodate(page);
+
+	print_exit_status(err);
+	return err;		/* assume all is ok */
+}
+
+sector_t unionfs_bmap(struct address_space * mapping, sector_t block)
+{
+	int err = 0;
+	struct inode *inode, *lower_inode;
+
+	print_entry_location();
+
+	inode = (struct inode *)mapping->host;
+	lower_inode = itohi(inode);
+
+	if (lower_inode->i_mapping->a_ops->bmap)
+		err =
+		    lower_inode->i_mapping->a_ops->bmap(lower_inode->i_mapping,
+							block);
+	print_exit_location();
+	return err;
+}
+
+void unionfs_sync_page(struct page *page)
+{
+	struct inode *inode;
+	struct inode *lower_inode;
+	struct page *lower_page;
+	struct address_space *mapping = page->mapping;
+
+	print_entry_location();
+
+	inode = page->mapping->host;	/* CPW: Moved below print_entry_location */
+	lower_inode = itohi(inode);
+
+	/* find lower page (returns a locked page) */
+	lower_page = grab_cache_page(lower_inode->i_mapping, page->index);
+	if (!lower_page)
+		goto out;
+
+	/* do the actual sync */
+	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+		mapping->a_ops->sync_page(page);
+
+	unlock_page(lower_page);	/* b/c grab_cache_page locked it */
+	page_cache_release(lower_page);	/* b/c grab_cache_page increased refcnt */
+
+      out:
+	print_exit_status(0);
+	return;
+}
+
+struct address_space_operations unionfs_aops = {
+      writepage:unionfs_writepage,
+      readpage:unionfs_readpage,
+      prepare_write:unionfs_prepare_write,
+      commit_write:unionfs_commit_write,
+      bmap:unionfs_bmap,
+      sync_page:unionfs_sync_page,
+};
+
+/*
+ * Local variables:
+ * c-basic-offset: 4
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/NEWS linux-2.6.20-sabayon-r1/fs/unionfs/NEWS
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/NEWS	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/NEWS	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,249 @@
+* Unionfs 1.4 (intended for use with 2.6.18)
+- Cleaned up xattr code
+- Fixed 64-bit system compilation
+- Fixed copyup of files >= 2GB
+- Allow limited remount
+- Privileged operations now use a kernel thread
+- Added separator mount option
+
+* Unionfs 1.3 (intended for use with 2.6.17)
+- Fixed makefile release & build target
+- Fixed up uniondbg & unionimap man pages
+- Updated RPM specfile
+- Implemented export functions (for NFS)
+- Updated to compile with 2.6.17
+
+* Unionfs 1.2 (intended for use with 2.6.16)
+- Added basic mmap support (experimental, off by default)
+- Added check to see if its necessary to run the delete_all
+  regression tests
+- Cleaned up list/get xattr code
+- Created documentation directory
+- Fixed unionfs_permission on reiserfs and XFS
+- Fixed link-unlink issue (i_nlink going down to zero)
+- Fixed Bug #501: mv dir ..
+- On error, NULL the pointers after free - Fixes nasty mount bug
+- Moved userspace utilities into utils subdirectory
+- Updated to work with the new mutex subsystem
+- Simplified and cleaned up debugging support (use -DUNIONFS_DEBUG to
+  _enable_ debugging)
+- Header files simplified
+
+* Unionfs 1.1.5
+- Backport: Corrected sample mount commands
+- Backport: Fixed link-unlink issue
+- Backport: Fixed refcounting leak (if a branch doesn't exist during mount,
+  the previously looked up branches were not freed properly)
+- Backport: Fixed inode_permission returning EROFS when it wasn't supposed
+  to
+- Backport: Fixed bug #501 (mv dir ..)
+
+* Unionfs 1.1.4
+- Backport: On error, NULL the pointers after free - Fixes nasty mount bug
+- Backport: Fixed unionfs_permission on reiserfs and XFS
+- Backport: Added check to see if its necessary to run the delete_all
+  regression tests
+- Added explicit check for kernel versions newer than 2.6.15
+(If you want to use 2.6.16 or newer, look at Unionfs 1.2.x)
+
+* Unionfs 1.1.3
+- Simplified delete=whiteout
+- Switched default delete mode to the simpler whiteout mode
+- Disable delete=all by default (enable with -DUNIONFS_DELETE_ALL)
+- Removed all copy up modes except preserve (the old default)
+- Unlink partially copied up files
+- Compartmentalize malloc debugging
+- Fix uid/gid/mode not being reset when a whiteout is recreated
+- Fix stale atime/mtime bugs for recreated whiteouts
+- Cleaned up peristent inode code a bit (still unstable)
+
+* Unionfs 1.1.2
+- Added inode refcounting debugging tool
+- Fixed race between lookup and d_free
+- Fixed double free/unchecked malloc
+- Fixed permission bug, creat/open truncates the running executable
+- Fixed many reference counting bugs
+- Moved code from fist.h into unionfs*.h
+- Removed unneeded UNIONFS_XATTR
+- Removed ASSERTs in favor of BUG_ONs
+- Removed FISTBUG
+- Rename dentry locking changed to use 2.6 calls
+- Replaced NFS_SECURITY_HOLE by nfsro branch option
+- Cleaned up code to "pass" a Sparse run
+- RPM spec file updated
+- Miscellaneous cleanups
+
+* Unionfs 1.1.1
+- Directory reading is fixed
+- Improved locking for branch manipulation operations
+- Fix for removing an opaque directory
+- Some cleanups and error handling fixes to the copyup code
+
+* Unionfs 1.1.0
+- Removed excess 2.4 code (Unionfs 1.1.0 is for 2.6 only)
+- Removed file locking code, as the VFS does a better job of it.
+- Fixed off by one errors when kmallocing names in inode.c.
+- Fixed several deadlock bugs.
+- Fixed several rename and rmdir bugs.
+- Permissions checked on files that are on read-only file systems
+- AMD64 fix for compiling on gentoo.
+- Properly update generation when we combine copyup and reopening.
+- Cleanedup Makefile to remove 2.4 clutter.
+- Added documentation for the MODDIR option in the INSTALL file.
+
+* Unionfs 1.0.14
+Features:
+- Dropped unmaintained setattr,diropaque,delete=first and mount flags
+- Updated unionfs.4 to reflect default mount modes
+- You can use the root of the Union to remove branches with unionctl
+- Use official Debian packaging files.
+- Linux 2.6.13 support.
+
+Bug fixes:
+- Fixed several dentry refcount bugs introduced by new deletion framework.
+- Fixed uninitialized fd_set in the query ioctl.
+- Branch reference counting now works across insertion and removal of branches.
+  This prevents the branch counts from getting "confused".
+- Handle "/" as a branch in unionctl.
+- Removed static buffer for debug prints in favor of vprintk.
+- NFS silly renames avoided during several cases.
+- Attempting a write lock causes a copyup, so that the underying flock will
+  work.
+- Cleaned up mount option parsing.
+- Improved link counting for directories.
+
+* Unionfs 1.0.13
+- Unionfs now handles deleting an open file (and several other deletion fixes).
+  Thanks to the Knoppix people and Tomas Matejicek for finding these bugs.
+- The NODEBUG flag has been renamed to UNIONFS_NDEBUG.
+- Instead of allocating all of the lower-level pointers in dentries, inodes
+  and files, we have a fixed number of them preallocated and malloc only if
+  we exceed that number.
+- Fixed a dentry reference count bug with UNIONFS_NDEBUG.
+- Support for persistent inode numbers across mounts.
+- Added a "which-branch" ioctl and corresponding --query to unionctl, so that
+  it is possible to find out where a file or directory is coming from.
+- In 2.6.11 and onwards, don't take the BKL for ioctls.
+
+* Unionfs 1.0.12
+- Copy-up is delayed until a write operation occurs, so spurious copy-ups are
+  avoided.
+- Improved copyup UID spoofing for mkdir
+- Instructions and shell script for compiling Unionfs into a monolothic kernel.
+- Added support for opaque directories, which mask the contents of
+  lower-priority directories.  This makes recreating a removed directory an
+  O(1)  operation instead of an O(n) operation, and also makes subsequent
+  operations faster.  There were also several whiteout related fixes bundled
+  in here.
+- Fixed bug with whiteouts on Reiserfs
+- Fixed bug when a file transitioned from a negative dentry to a positive
+  dentry (i.e., if you add a branch that inserts a file you previously
+  looked up, but did not exist)
+- Fixed return code for extended attribute functions
+- amd64 compile fixes
+- Extended attribute copy-up
+- Unionfs returns EXDEV instead of copying up a directory on move, this
+  fixes a bug where Unionfs would "forget" the contents of a copied up
+  directory after unmount.
+- Fix for following symlinks
+- Improved print routines (separated generic from unionfs printing routines)
+- INSTALL has some instructions for using Unionfs as a root file system and
+  also for using Unionfs with Selinux.
+- Dentry private data uses a separate kmem_cache and inodes in 2.6 use their
+  own kmem_cache.  This should improve performance a bit because there are
+  fewer individual memory allocations (and less wasted space).
+
+* Unionfs 1.0.11
+This release fixes NFS exporting which was broken in 1.0.10.
+- f_pos and lseek's offsets are unified, so readdir works on NFS exported
+  unionfs mounts again.
+
+* Unionfs 1.0.10
+This release fixes several bugs over 1.0.9, but it will not correctly work if
+you want to NFS export it.  For that you need to use 1.0.9 on 2.4.  In 1.0.11,
+we will fix NFS exports correctly.
+
+- Don't d_delete entries that don't have positive refcounts (Fabian Franz)
+- Hardlinks should point to the same inode (Fabian Franz)
+- File locking works correctly.
+- Improved directory llseeking.
+- snapmerge preserves permissions/times after copying files
+- Improved Makefile
+- Unionfs_d_revalidate copies attributes so the cache appears more coherent.
+- Directory reading bug fixed.
+- symlink copyup fixed
+- Don't oops when creating files longer than 252 characters
+- Some readdir fixes.
+- df produces correct size results
+
+* Unionfs 1.0.9
+- Fixed copyup permissions bugs (Anton Farygin)
+- NTFS mmap will no longer cause Oops (but it won't do the mmap, as NTFS
+  doesn't support mmap).
+- Moved directory reading helper routines into dirhelper.c from subr.c
+- We no longer require hacked copies of vfs_create and vfs_unlink
+- Moved finding and adding filldir_nodes into rdstate.c
+- Added a sample RPM spec file, for those who want to package Unionfs
+  (Note, we are currently not distributing source or binary RPMS)
+- Fixed unionfs_link to allow hard-linking of files with a source of a
+  readonly file system.
+- Fixed apt-get on rw/ro branch configuration (related to unionfs_link)
+- Modified regression/link.sh to reflect the changes in unionfs_link. It
+  now includes tests to make sure linking on a read only filesystem works.
+- Fixed an issue where unionfs_dir_llseek would cause an Oops
+
+* Unionfs 1.0.8
+- Fixed bug with readdir (but oddly not ls) that prevented that last entry
+  from being shown.
+- Include INSTALL file with information about installing Unionfs.
+- Fix unionctl bug with "/" as the path to search for
+- Fix to copyup permissions on directories
+- Allow llseek to current directory position, but no others
+
+* Unionfs 1.0.7
+- Fixed locking for readdir state, this fixes a kernel Oops on preemptive
+  kernels, and deadlocks on SMP kernels.
+- Prevent readdir from giving -ESTALE on last entry.
+- Fixes for gcc 2.9.5 (Alex de Landegraaf)
+- Debian package scripts (Alex de Landegraaf)
+- NFS Export on 2.6 (Sai Suman)
+- Copyup permissions fix (Sai Suman)
+- Warn when compiling on unsupported kernels (<2.6.9 or <2.4.20)
+- Improved hardlink support (but not quite there yet)
+
+* Unionfs 1.0.6
+A lot of code has changed in the 1.0.6 release, so it may not be as stable as
+the 1.0.5 release.
+
+- Makefile fix over 1.0.5 for install target on 2.6
+- unionfs.h, fist.h Makefile dependency fixed
+- Support for readdir over NFS
+- Hash table sizes are now based on the size of the lower-level directory
+- In 2.4 inode private data resides in the inode.u field, saving memory
+- Use kmem caches for filldir nodes rather than wasting space with extra
+  large kmallocs, also move short names inline
+
+* Unionfs 1.0.5
+- Support for both 2.6 and 2.4 kernels
+
+* Unionfs 1.0.4
+- Copyup now correctly handles directories, devices, and symlinks.
+- Extended attributes are now off by default because they cause too many
+  compile problems.
+- The regression tests is now included in the release, but is not actually
+  installed.  These tests are rather primitive, but do check some fundamental
+  Unionfs behavior on multiple branches.
+
+* Unionfs 1.0.3
+- Compile fixes for older (and newer) compilers than found on Redhat 9.
+- Compile fixes for older kernels.
+- Don't Oops when passed bad directories.
+
+* Unionfs 1.0.2
+- Minor README updates
+
+* Unionfs 1.0.1
+- Fix to release target which includes manual pages.
+
+* Unionfs 1.0
+- First public release
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/persistent_inode.c linux-2.6.20-sabayon-r1/fs/unionfs/persistent_inode.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/persistent_inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/persistent_inode.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,658 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: persistent_inode.c,v 1.36 2006/07/08 17:58:31 ezk Exp $
+ */
+#ifdef UNIONFS_IMAP
+
+#include "unionfs.h"
+
+static ssize_t __fread(struct file *filp, void *buf, size_t size, loff_t * pos)
+{
+	int err;
+	mm_segment_t oldfs;
+	ssize_t(*func) (struct file *, char __user *, size_t, loff_t *);
+
+	func = do_sync_read;
+	if (filp->f_op && filp->f_op->read)
+		func = filp->f_op->read;
+
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		err = func(filp, (char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+	return err;
+}
+
+static ssize_t __fwrite(struct file *filp, void *buf, size_t size, loff_t * pos)
+{
+	int err;
+	mm_segment_t oldfs;
+	unsigned long flim;
+	struct rlimit *rl;
+	ssize_t(*func) (struct file *, const char __user *, size_t, loff_t *);
+
+	func = do_sync_write;
+	if (filp->f_op && filp->f_op->write)
+		func = filp->f_op->write;
+
+	/*
+	 * it breaks RLIMIT_FSIZE,
+	 * but users should be careful to quota.
+	 */
+	rl = current->signal->rlim + RLIMIT_FSIZE;
+	flim = rl->rlim_cur;
+	rl->rlim_cur = RLIM_INFINITY;
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	do {
+		err = func(filp, (const char __user *)buf, size, pos);
+	} while (err == -EAGAIN || err == -EINTR);
+	set_fs(oldfs);
+	rl->rlim_cur = flim;
+	return err;
+}
+
+/*
+ * verify_forwardmap(super_block *sb)
+ * sb: pointer to a superblock containing the forwardmap.
+ * returns: 0 on success EINVAL or ENOMEM on failure;
+ */
+static int verify_forwardmap(struct super_block *sb)
+{
+	int err = 0, bytesread = 0, bindex = 0, mallocsize = 0;
+	loff_t readpos = 0;
+	struct file *forwardmap = NULL;
+	struct fmaphdr header;
+	struct unionfs_sb_info *spd = NULL;
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	forwardmap = spd->usi_forwardmap;
+	if (!forwardmap) {
+		err = -EINVAL;
+		goto out;
+	}
+	bytesread = __fread(forwardmap, &header, sizeof(struct fmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct fmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (header.magic != FORWARDMAP_MAGIC
+	    || header.version != FORWARDMAP_VERSION) {
+		err = -EINVAL;
+		goto out;
+	}
+	spd->usi_bmap =
+	    KMALLOC(sizeof(struct bmapent) * header.usedbranches, GFP_KERNEL);
+
+	if (!spd->usi_bmap) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	while (bindex < header.usedbranches) {
+		bytesread = __fread(forwardmap, &stopd(sb)->usi_bmap[bindex],
+				    sizeof(struct bmapent), &readpos);
+		if (bytesread < sizeof(struct bmapent)) {
+			err = -EINVAL;
+			goto out_err;
+		}
+		bindex++;
+	}
+
+	mallocsize = sizeof(int) * header.usedbranches;
+	goto out;
+      out_err:
+	if (spd->usi_bmap)
+		KFREE(spd->usi_bmap);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * verify_reversemap(struct super_block sb, int rmapindex)
+ *
+ * sb: The unionfs superblock containing all of the current imap info
+ * rmapindex: the index in the usi_reversemaps array that we wish to
+ * verify
+ *
+ * Assumes the reverse maps less than rmapindex are valid.
+ *
+ * returns: 0 if the opperation succeds
+ * 	-EINVAL if the map file does not belong to the forward map
+ *
+ */
+static int verify_reversemap(struct super_block *sb, int rmapindex,
+			     struct unionfs_dentry_info *hidden_root_info)
+{
+	int err = 0, i = 0, bindex = 0, found = 0, bytesread;
+	loff_t readpos = 0;
+	struct file *forwardmap, *reversemap;
+	struct fmaphdr fheader;
+	struct rmaphdr rheader;
+	struct kstatfs st;
+	struct unionfs_sb_info *spd = NULL;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	forwardmap = spd->usi_forwardmap;
+	if (!forwardmap) {
+		err = -EINVAL;
+		goto out;
+	}
+	reversemap = spd->usi_reversemaps[rmapindex];
+	if (!reversemap) {
+		err = -EINVAL;
+		goto out;
+	}
+	bytesread = __fread(forwardmap, &fheader, sizeof(struct fmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct fmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	readpos = 0;
+	bytesread = __fread(reversemap, &rheader, sizeof(struct rmaphdr),
+			    &readpos);
+	if (bytesread < sizeof(struct rmaphdr)) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (rheader.magic != REVERSEMAP_MAGIC
+	    || rheader.version != REVERSEMAP_VERSION) {
+		err = -EINVAL;
+		goto out;
+	}
+	if (memcmp(fheader.uuid, rheader.fwduuid, sizeof(fheader.uuid))) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* XXX: Ok so here we take the new map and read the fsid from it. Then
+	 * we go through all the branches in the union and see which ones it
+	 * matches with*/
+	for (i = 0; i < spd->usi_num_bmapents && !found; i++) {
+		if (memcmp
+		    (rheader.revuuid, spd->usi_bmap[i].uuid,
+		     sizeof(rheader.revuuid)))
+			continue;
+
+		found = 1;
+		for (bindex = 0; bindex <= hidden_root_info->udi_bend; bindex++) {
+			struct dentry *d;
+			fsid_t fsid;
+			dev_t dev;
+			memset(&st, 0, sizeof(struct kstatfs));
+
+			d = hidden_root_info->udi_dentry[bindex];
+
+			err = d->d_sb->s_op->statfs(d->d_sb, &st);
+			if (err)
+				goto out;
+
+			if (st.f_fsid.val[0] || st.f_fsid.val[1]) {
+				fsid = st.f_fsid;
+			} else {
+
+				dev = d->d_sb->s_dev;
+				fsid.val[0] = MAJOR(dev);
+				fsid.val[1] = MINOR(dev);
+			}
+
+			if (memcmp(&fsid, &rheader.fsid, sizeof(fsid)))
+				continue;
+
+			if (spd->usi_bnum_table[bindex] == -1)
+				spd->usi_bnum_table[bindex] = i;
+			if (spd->usi_map_table[bindex]) {
+				printk(KERN_WARNING
+				       "Two reverse maps share fsid %u%u!\n",
+				       rheader.fsid.val[0],
+				       rheader.fsid.val[1]);
+				err = -EINVAL;
+				goto out;
+			} else {
+				spd->usi_map_table[bindex] = reversemap;
+			}
+		}
+	}
+	if (!found) {
+		printk(KERN_WARNING
+		       "Could not match the reversemap uuid with an entry in the forwardmap table\n");
+		err = -EINVAL;
+	}
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int init_imap_data(struct super_block *sb,
+		   struct unionfs_dentry_info *hidden_root_info)
+{
+	int i, err = 0, mallocsize = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	spd->usi_forwardmap = NULL;
+	spd->usi_reversemaps = NULL;
+	spd->usi_bnum_table = NULL;
+
+	mallocsize = sizeof(struct file *) * (hidden_root_info->udi_bend + 1);
+	spd->usi_reversemaps = KZALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_reversemaps) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	spd->usi_map_table = KZALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_map_table) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	mallocsize = sizeof(int) * (hidden_root_info->udi_bend + 1);
+	spd->usi_bnum_table = KMALLOC(mallocsize, GFP_KERNEL);
+	if (!spd->usi_bnum_table) {
+		err = -ENOMEM;
+		goto out_error;
+	}
+
+	for (i = 0; i <= hidden_root_info->udi_bend; i++) {
+		spd->usi_bnum_table[i] = -1;
+	}
+
+	if (!err)
+		goto out;
+      out_error:
+
+	if (spd->usi_reversemaps) {
+		KFREE(spd->usi_reversemaps);
+		spd->usi_reversemaps = NULL;
+	}
+
+	if (spd->usi_map_table) {
+		KFREE(spd->usi_map_table);
+		spd->usi_map_table = NULL;
+	}
+
+	if (spd->usi_bnum_table) {
+		KFREE(spd->usi_bnum_table);
+		spd->usi_bnum_table = NULL;
+
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+
+}
+
+void cleanup_imap_data(struct super_block *sb)
+{
+	int count = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+
+	spd->usi_persistent = 0;
+	count = spd->usi_num_bmapents;
+	while (count - 1 >= 0) {
+		if (spd->usi_reversemaps[count - 1]) {
+			filp_close(spd->usi_reversemaps[count - 1], NULL);
+			spd->usi_reversemaps[count - 1] = NULL;
+		}
+		count--;
+	}
+	if (spd->usi_reversemaps) {
+		KFREE(spd->usi_reversemaps);
+		spd->usi_reversemaps = NULL;
+	}
+
+	if (spd->usi_map_table) {
+		KFREE(spd->usi_map_table);
+		spd->usi_map_table = NULL;
+	}
+
+	if (spd->usi_bnum_table) {
+		KFREE(spd->usi_bnum_table);
+		spd->usi_bnum_table = NULL;
+	}
+	if (spd->usi_forwardmap) {
+		filp_close(spd->usi_forwardmap, NULL);
+		spd->usi_forwardmap = NULL;
+	}
+	print_exit_location();
+}
+
+int parse_imap_option(struct super_block *sb,
+		      struct unionfs_dentry_info *hidden_root_info,
+		      char *options)
+{
+	int count = 0, err = 0;
+	char *name;
+	struct unionfs_sb_info *spd = NULL;
+
+	print_entry_location();
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	err = init_imap_data(sb, hidden_root_info);
+	if (err)
+		goto out_error;
+	while ((name = strsep(&options, ":")) != NULL) {
+		if (!*name)
+			continue;
+		if (!spd->usi_forwardmap) {
+			spd->usi_forwardmap = filp_open(name, O_RDWR, 0);
+			if (IS_ERR(spd->usi_forwardmap)) {
+				err = PTR_ERR(spd->usi_forwardmap);
+				spd->usi_forwardmap = NULL;
+				goto out_error;
+			}
+		} else {
+			spd->usi_reversemaps[count] =
+			    filp_open(name, O_RDWR, 0);
+			if (IS_ERR(spd->usi_reversemaps[count])) {
+				err = PTR_ERR(spd->usi_reversemaps[count]);
+				spd->usi_reversemaps[count] = NULL;
+				goto out_error;
+
+			}
+			count++;
+		}
+	}
+	if (count <= 0) {
+		printk(KERN_WARNING "unionfs: no reverse maps specified.\n");
+		err = -EINVAL;
+	}
+	if (err)
+		goto out_error;
+
+	/* Initialize the super block's next_avail field */
+	/* Dave, you can't use 64-bit division here because the i386 doesn't
+	 * support it natively.  Instead you need to punt if the size is
+	 * greater than unsigned long, and then cast it down.  Then you should
+	 * be able to assign to this value, without having these problems. */
+
+	if (spd->usi_forwardmap->f_dentry->d_inode->i_size > ULONG_MAX) {
+		err = -EFBIG;
+		goto out_error;
+	}
+	spd->usi_next_avail =
+	    ((unsigned long)(spd->usi_forwardmap->f_dentry->d_inode->
+			     i_size - (sizeof(struct fmaphdr) +
+				       sizeof(struct bmapent[256])))
+	     / sizeof(struct fmapent));
+
+	if (spd->usi_next_avail < FIRST_VALID_INODE)
+		spd->usi_next_avail = FIRST_VALID_INODE;
+
+	spd->usi_num_bmapents = count;
+	err = verify_forwardmap(sb);
+	if (err)
+		goto out_error;
+	while (count > 0) {
+		err = verify_reversemap(sb, --count, hidden_root_info);
+		if (err)
+			goto out_error;
+	}
+	spd->usi_persistent = 1;
+
+	goto out;
+
+      out_error:
+	spd->usi_num_bmapents = count;
+	cleanup_imap_data(sb);
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+ /*
+  * get @ino from @hidden_ino.
+  */
+static int __read_uin(struct unionfs_sb_info *sbi, ino_t hidden_ino, int bindex,
+		      ino_t * ino)
+{
+	int err;
+	struct file *rev;
+	loff_t pos;
+	ssize_t sz;
+	uint64_t ino64;
+	const int elmnt = sizeof(ino64);
+
+	rev = sbi->usi_map_table[bindex];
+	pos = sizeof(struct rmaphdr) + elmnt * hidden_ino;
+	*ino = 0;
+	err = 0;
+	if (pos + elmnt > rev->f_dentry->d_inode->i_size)
+		goto out;
+
+	sz = __fread(rev, &ino64, elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = 0;
+	*ino = -1;
+	if (sz != elmnt || ino64 > *ino)
+		err = -EIO;
+	*ino = ino64;
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * put unionfs @ino for @hidden_ino on @bindex.
+ */
+static int __write_uin(struct unionfs_sb_info *sbi, ino_t ino, int bindex,
+		       ino_t hidden_ino)
+{
+	struct file *fwd, *rev;
+	struct fmapent ent;
+	loff_t pos;
+	ssize_t sz;
+	int err;
+	uint64_t ino64;
+	const int fwdhdr = sizeof(struct fmaphdr) + sizeof(struct bmapent[256]);
+	const int fwd_elmnt = sizeof(ent);
+	const int rev_elmnt = sizeof(ino64);
+
+	err = -ENOSPC;
+	if (ino < FIRST_VALID_INODE)
+		goto out;
+
+	fwd = sbi->usi_forwardmap;
+	ent.fsnum = sbi->usi_bnum_table[bindex];
+	ent.inode = hidden_ino;
+	pos = fwdhdr + fwd_elmnt * ino;
+	sz = __fwrite(fwd, &ent, fwd_elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = -EIO;
+	if (sz != fwd_elmnt)
+		goto out;
+
+	rev = sbi->usi_map_table[bindex];
+	pos = sizeof(struct rmaphdr) + rev_elmnt * hidden_ino;
+	ino64 = ino;
+	sz = __fwrite(rev, &ino64, rev_elmnt, &pos);
+	err = sz;
+	if (err < 0)
+		goto out;
+	err = 0;
+	if (sz != rev_elmnt)
+		err = -EIO;
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * read_uin(struct super_block *sb, uint8_t branchnum, ino_t inode_number, int flag, ino_t *uino)
+ * fsnum: branch to reference when getting the inode number
+ * inode_number: lower level inode number use to reference the proper inode.
+ * flag: if set to O_CREAT it will creat the entry if it doesent exist
+ * 		 otherwise it will return the existing one.
+ * returns: the unionfs inode number either created or retrieved based on
+ * 			the information.
+ */
+int read_uin(struct super_block *sb, uint8_t branchnum, ino_t inode_number,
+	     int flag, ino_t * uino)
+{
+	int err = 0;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	/* Find appropriate reverse map and then read from the required position */
+	/* get it from the array. */
+	err = __read_uin(spd, inode_number, branchnum, uino);
+	if (err || *uino)
+		goto out;
+
+	err = -EIO;
+	if (!(flag & O_CREAT))
+		goto out;
+
+	/* If we haven't found an entry and we have the O_CREAT flag set we want to
+	 * create a new entry write it out to the file and return its index
+	 */
+	mutex_lock(&sb->s_lock);
+	*uino = spd->usi_next_avail++;
+	err = __write_uin(spd, *uino, branchnum, inode_number);
+	if (err)
+		spd->usi_next_avail--;
+	mutex_unlock(&sb->s_lock);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int write_uin(struct super_block *sb, ino_t ino, int bindex, ino_t hidden_ino)
+{
+	int err;
+
+	print_entry_location();
+	err = __write_uin(stopd(sb), ino, bindex, hidden_ino);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * get_lin(ino_t inode_number)
+ * inode_number : inode number for the unionfs inode
+ * returns: the lower level inode# and branch#
+ */
+/* entry should use a poiner on the stack. should be staticly allocated one
+ * level up*/
+int get_lin(struct super_block *sb, ino_t inode_number, struct fmapent *entry)
+{
+	struct file *forwardmap;
+	loff_t seek_size;
+	mm_segment_t oldfs;
+	int err = 0, bytesread = 0;
+
+	print_entry_location();
+
+	if (!entry) {
+		entry = ERR_PTR(-ENOMEM);
+		goto out;
+	}
+	forwardmap = stopd(sb)->usi_forwardmap;
+	seek_size =
+	    sizeof(struct fmaphdr) + sizeof(struct bmapent[256]) +
+	    (sizeof(struct fmapent) * inode_number);
+	oldfs = get_fs();
+	set_fs(KERNEL_DS);
+	bytesread = __fread(forwardmap, entry, sizeof(*entry), &seek_size);
+	set_fs(oldfs);
+	if (bytesread != sizeof(*entry))
+		err = -EINVAL;
+
+      out:
+	print_exit_location();
+	return err;
+}
+
+/*
+ * remove_map(struct super_block *sb,int bindex)
+ *
+ * sb: The super block containing all the current imap info
+ * bindex: the index of the branch that is being removed.
+ *
+ * This assumes that end hasen't been decremented yet.
+ *
+ * Returns: This function really can't fail. The only thing
+ * that could possibly happen is that it will oops but that
+ * requires unionfs to be in an inconsistant state which
+ * shoulden't happen.
+ */
+int remove_map(struct super_block *sb, int bindex)
+{
+	int i;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	spd = stopd(sb);
+	BUG_ON(!spd);
+
+	for (i = bindex; i < sbend(sb); i++) {
+		spd->usi_map_table[i] = spd->usi_map_table[i + 1];
+		spd->usi_bnum_table[i] = spd->usi_bnum_table[i + 1];
+	}
+	return 0;
+}
+
+#endif
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/print.c linux-2.6.20-sabayon-r1/fs/unionfs/print.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/print.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/print.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,439 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: print.c,v 1.77 2006/07/08 17:58:31 ezk Exp $
+ */
+
+/* Print debugging functions */
+
+#include "unionfs.h"
+
+static unsigned int debug_mask = DEFAULT_DEBUG_MASK;
+
+/* get value of debugging variable */
+unsigned int get_debug_mask(void)
+{
+	return debug_mask;
+}
+
+/* set debug level variable and return the previous value */
+int set_debug_mask(int val)
+{
+#ifdef UNIONFS_DEBUG
+	int prev = debug_mask;
+
+	debug_mask = val;
+
+	printk(KERN_INFO UNIONFS_NAME ": debug mask set to %u\n", debug_mask);
+
+	return prev;
+#else /* UNIONFS_DEBUG */
+	printk(KERN_WARNING UNIONFS_NAME ": debugging is not enabled\n");
+	return -ENOTSUPP;
+#endif /* ! UNIONFS_DEBUG */
+}
+
+static inline int should_print(const unsigned int req)
+{
+	return (req & debug_mask);
+}
+
+static void unionfs_print_generic_inode(const char *prefix,
+		const char *prefix2, const struct inode *inode)
+{
+	if (!inode) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: NULL INODE PASSED!\n", prefix, prefix2);
+		return;
+	}
+
+	if (IS_ERR(inode)) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: ERROR INODE PASSED: %ld\n", prefix, prefix2,
+		       PTR_ERR(inode));
+		return;
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_ino=%lu\n",
+			prefix, prefix2, inode->i_ino);
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_count=%u\n",
+			prefix, prefix2, atomic_read(&inode->i_count));
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_nlink=%u\n",
+			prefix, prefix2, inode->i_nlink);
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_mode=%o\n",
+			prefix, prefix2, inode->i_mode);
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_size=%llu\n",
+			prefix, prefix2, inode->i_size);
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_op=%p\n",
+			prefix, prefix2, inode->i_op);
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s%s: i_sb=%p (%s)\n",
+			prefix, prefix2, inode->i_sb, (inode->i_sb ? sbt(inode->i_sb) : "NullTypeSB"));
+}
+
+void unionfs_print_inode(const unsigned int req, const char *prefix, const struct inode *inode)
+{
+	int bindex;
+
+	if (!should_print(req))
+		return;
+
+	if (!inode) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PI:%s: NULL INODE PASSED!\n", prefix);
+		return;
+	}
+	if (IS_ERR(inode)) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PI:%s: ERROR INODE PASSED: %ld\n", prefix, PTR_ERR(inode));
+		return;
+	}
+
+	unionfs_print_generic_inode(prefix, "", inode);
+
+	if (strcmp("unionfs", sbt(inode->i_sb))) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PI:%s: Not a " UNIONFS_NAME " inode.\n", prefix);
+		return;
+	}
+
+	if (!itopd(inode))
+		return;
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PI:%s: ibstart=%d, ibend=%d\n", prefix, ibstart(inode), ibend(inode));
+
+	if (ibstart(inode) == -1)
+		return;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		struct inode *hidden_inode = itohi_index(inode, bindex);
+		char newstr[10];
+		if (!hidden_inode) {
+			printk(KERN_DEBUG UNIONFS_NAME ": PI:%s: HI#%d: NULL\n", prefix, bindex);
+			continue;
+		}
+		snprintf(newstr, 10, ": HI%d", bindex);
+		unionfs_print_generic_inode(prefix, newstr, hidden_inode);
+	}
+}
+
+static void unionfs_print_generic_file(const char *prefix, const char *prefix2,
+				     const struct file *file)
+{
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_dentry=0x%p\n", prefix, prefix2, file->f_dentry);
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: name=%s\n", prefix, prefix2, file->f_dentry->d_name.name);
+	if (file->f_dentry->d_inode) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_dentry->d_inode->i_ino=%lu\n", prefix, prefix2, file->f_dentry->d_inode->i_ino);
+		printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_dentry->d_inode->i_mode=%o\n", prefix, prefix2, file->f_dentry->d_inode->i_mode);
+	}
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_op=0x%p\n", prefix, prefix2, file->f_op);
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_mode=0x%x\n", prefix, prefix2, file->f_mode);
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_pos=0x%llu\n", prefix, prefix2, file->f_pos);
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_count=%u\n", prefix, prefix2, atomic_read(&file->f_count));
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_flags=0x%x\n", prefix, prefix2, file->f_flags);
+	printk(KERN_DEBUG UNIONFS_NAME ": PF:%s%s: f_version=%lu\n", prefix, prefix2, file->f_version);
+}
+
+void unionfs_print_file(const unsigned int req, const char *prefix, const struct file *file)
+{
+	struct file *hidden_file;
+
+	if (!should_print(req))
+		return;
+
+	if (!file) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PF:%s: NULL FILE PASSED!\n", prefix);
+		return;
+	}
+
+	unionfs_print_generic_file(prefix, "", file);
+
+	if (strcmp("unionfs", sbt(file->f_dentry->d_sb))) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PF:%s: Not a " UNIONFS_NAME " file.\n", prefix);
+		return;
+	}
+
+	if (ftopd(file)) {
+		int bindex;
+
+		printk(KERN_DEBUG UNIONFS_NAME ": PF:%s: fbstart=%d, fbend=%d\n", prefix, fbstart(file), fbend(file));
+
+		for (bindex = fbstart(file); bindex <= fbend(file); bindex++) {
+			char newstr[10];
+			hidden_file = ftohf_index(file, bindex);
+			if (!hidden_file) {
+				printk(KERN_DEBUG UNIONFS_NAME ": PF:%s: HF#%d is NULL\n", prefix, bindex);
+				continue;
+			}
+			snprintf(newstr, 10, ": HF%d", bindex);
+			unionfs_print_generic_file(prefix, newstr, hidden_file);
+		}
+	}
+}
+
+static char mode_to_type(mode_t mode)
+{
+	if (S_ISDIR(mode))
+		return 'd';
+	if (S_ISLNK(mode))
+		return 'l';
+	if (S_ISCHR(mode))
+		return 'c';
+	if (S_ISBLK(mode))
+		return 'b';
+	if (S_ISREG(mode))
+		return 'f';
+	return '?';
+}
+
+static void unionfs_print_generic_dentry(const char *prefix, const char *prefix2, const
+				 struct dentry *dentry, int check)
+{
+	if (!dentry) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: NULL DENTRY PASSED!\n", prefix, prefix2);
+		return;
+	}
+
+	if (IS_ERR(dentry)) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: ERROR DENTRY (%ld)!\n", prefix, prefix2,
+			    PTR_ERR(dentry));
+		return;
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: dentry = %p\n", prefix, prefix2, dentry);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_count=%d\n", prefix, prefix2, atomic_read(&dentry->d_count));
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_flags=%x\n", prefix, prefix2, (int)dentry->d_flags);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_name.name=\"%s\" (len = %d)\n", prefix, prefix2, dentry->d_name.name, dentry->d_name.len);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_sb=%p (%s)\n", prefix, prefix2, dentry->d_sb, sbt(dentry->d_sb));
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_inode=%p\n", prefix, prefix2, dentry->d_inode);
+
+	if (dentry->d_inode) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_inode->i_ino=%ld (%s)\n", prefix, prefix2,
+			    dentry->d_inode->i_ino,
+			    sbt(dentry->d_inode->i_sb));
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: dentry->d_inode->i_mode: %c%o\n", prefix,
+			    prefix2, mode_to_type(dentry->d_inode->i_mode),
+			    dentry->d_inode->i_mode);
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_parent=%p (%s)\n", prefix, prefix2,
+		    dentry->d_parent,
+		    (dentry->d_parent ? sbt(dentry->d_parent->d_sb) : "nil"));
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_parent->d_name.name=\"%s\"\n", prefix, prefix2,
+		    dentry->d_parent->d_name.name);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_parent->d_count=%d\n", prefix, prefix2,
+		    atomic_read(&dentry->d_parent->d_count));
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_op=%p\n", prefix, prefix2, dentry->d_op);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: d_fsdata=%p\n", prefix, prefix2,
+		    dentry->d_fsdata);
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s%s: hlist_unhashed(d_hash)=%d\n", prefix, prefix2,
+		    hlist_unhashed(&((struct dentry *)dentry)->d_hash));
+
+	/* After we have printed it, we can assert something about it. */
+	if (check)
+		BUG_ON(atomic_read(&dentry->d_count) <= 0);
+}
+
+static void __unionfs_print_dentry(const char *prefix, const struct dentry *dentry,
+			 int check)
+{
+	if (!dentry) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s: NULL DENTRY PASSED!\n", prefix);
+		return;
+	}
+
+	if (IS_ERR(dentry)) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s: ERROR DENTRY (%ld)!\n", prefix,
+			    PTR_ERR(dentry));
+		return;
+	}
+
+	unionfs_print_generic_dentry(prefix, "", dentry, check);
+
+	if (strcmp("unionfs", sbt(dentry->d_sb))) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PD:%s: Not a " UNIONFS_NAME " dentry.\n", prefix);
+		return;
+	}
+
+	if (!dtopd(dentry))
+		return;
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PD:%s: dbstart=%d, dbend=%d, dbopaque=%d\n",
+		    prefix, dbstart(dentry), dbend(dentry), dbopaque(dentry));
+
+	if (dbstart(dentry) != -1) {
+		int bindex;
+		char newstr[10];
+		struct dentry *hidden_dentry;
+
+		for (bindex = dbstart(dentry); bindex <= dbend(dentry);
+		     bindex++) {
+			hidden_dentry = dtohd_index(dentry, bindex);
+			if (!hidden_dentry) {
+				printk(KERN_DEBUG UNIONFS_NAME ": PD:%s: HD#%d: NULL\n", prefix, bindex);
+				continue;
+			}
+			snprintf(newstr, 10, ": HD%d", bindex);
+			unionfs_print_generic_dentry(prefix, newstr, hidden_dentry, check);
+		}
+	}
+}
+
+void unionfs_print_dentry(const unsigned int req, const char *prefix, const struct dentry *dentry)
+{
+	if (!should_print(req))
+		return;
+
+	__unionfs_print_dentry(prefix, dentry, 1);
+}
+
+void unionfs_print_dentry_nocheck(const unsigned int req, const char *prefix, const struct dentry *dentry)
+{
+	if (!should_print(req))
+		return;
+
+	__unionfs_print_dentry(prefix, dentry, 0);
+}
+
+void unionfs_checkinode(const unsigned int req, const struct inode *inode, const char *msg)
+{
+	if (!should_print(req))
+		return;
+
+	if (!inode) {
+		printk(KERN_DEBUG UNIONFS_NAME ": unionfs_checkinode - inode is NULL! (%s)\n",
+		       msg);
+		return;
+	}
+
+	if (!itopd(inode)) {
+		printk(KERN_DEBUG UNIONFS_NAME ": unionfs_checkinode(%ld) - no private data (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+
+	if ((itopd(inode)->b_start < 0) || !itohi(inode)) {
+		printk(KERN_DEBUG UNIONFS_NAME
+			    "unionfs_checkinode(%ld) - underlying is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+
+	if (!inode->i_sb) {
+		printk(KERN_DEBUG UNIONFS_NAME
+			    ": unionfs_checkinode(%ld) - inode->i_sb is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME ": inode->i_sb->s_type %p\n", inode->i_sb->s_type);
+	if (!inode->i_sb->s_type) {
+		printk(KERN_DEBUG UNIONFS_NAME
+			    ": unionfs_checkinode(%ld) - inode->i_sb->s_type is NULL! (%s)\n",
+			    inode->i_ino, msg);
+		return;
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME
+		    ": CI: %s: inode->i_count = %d, hidden_inode->i_count = %d, inode = %lu, sb = %s, hidden_sb = %s\n",
+		    msg, atomic_read(&inode->i_count),
+		    itopd(inode)->b_start >=
+		    0 ? atomic_read(&itohi(inode)->i_count) : -1, inode->i_ino,
+		    inode->i_sb->s_type->name,
+		    itopd(inode)->b_start >=
+		    0 ? itohi(inode)->i_sb->s_type->name : "(none)");
+}
+
+void unionfs_print_sb(const unsigned int req, const char *prefix, const struct super_block *sb)
+{
+	struct super_block *hidden_superblock;
+
+	if (!should_print(req))
+		return;
+
+	if (!sb) {
+		printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: NULL SB PASSED!\n", prefix);
+		return;
+	}
+
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_blocksize=%lu\n", prefix, sb->s_blocksize);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_blocksize_bits=%u\n", prefix, sb->s_blocksize_bits);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_flags=0x%lx\n", prefix, sb->s_flags);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_magic=0x%lx\n", prefix, sb->s_magic);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_maxbytes=%llu\n", prefix, sb->s_maxbytes);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_count=%d\n", prefix, sb->s_count);
+	printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: s_active=%d\n", prefix, atomic_read(&sb->s_active));
+
+	if (stopd(sb))
+		printk(KERN_DEBUG UNIONFS_NAME ": sbstart=%d, sbend=%d\n", sbstart(sb),
+			    sbend(sb));
+
+	if (stopd(sb)) {
+		int bindex;
+		for (bindex = sbstart(sb); bindex <= sbend(sb); bindex++) {
+			hidden_superblock = stohs_index(sb, bindex);
+			if (!hidden_superblock) {
+				printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d is NULL", prefix,
+					    bindex);
+				continue;
+			}
+
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_blocksize=%lu\n", prefix, bindex,
+				    hidden_superblock->s_blocksize);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_blocksize_bits=%u\n", prefix, bindex,
+				    hidden_superblock->s_blocksize_bits);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_flags=0x%lx\n", prefix, bindex,
+				    hidden_superblock->s_flags);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_magic=0x%lx\n", prefix, bindex,
+				    hidden_superblock->s_magic);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_maxbytes=%llu\n", prefix, bindex,
+				    hidden_superblock->s_maxbytes);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_count=%d\n", prefix, bindex,
+				    hidden_superblock->s_count);
+			printk(KERN_DEBUG UNIONFS_NAME ": PSB:%s: HS#%d: s_active=%d\n", prefix, bindex,
+				    atomic_read(&hidden_superblock->s_active));
+		}
+	}
+}
+
+int unionfs_print(const unsigned int req, const char *fmt, ...)
+{
+        va_list ap;
+	int r;
+
+	if (!should_print(req))
+		return 0;
+
+	printk(KERN_DEBUG UNIONFS_NAME ": ");
+	va_start(ap, fmt);
+	r = vprintk(fmt, ap);
+	va_end(ap);
+
+	return r;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/rdstate.c linux-2.6.20-sabayon-r1/fs/unionfs/rdstate.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/rdstate.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/rdstate.c	2007-02-12 15:32:22.000000000 +0100
@@ -0,0 +1,327 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: rdstate.c,v 1.34 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+/* This file contains the routines for maintaining readdir state. */
+/* There are two structures here, rdstate which is a hash table
+ * of the second structure which is a filldir_node. */
+
+/* This is a kmem_cache_t for filldir nodes, because we allocate a lot of them
+ * and they shouldn't waste memory.  If the node has a small name (as defined
+ * by the dentry structure), then we use an inline name to preserve kmalloc
+ * space. */
+static kmem_cache_t *unionfs_filldir_cachep;
+int init_filldir_cache(void)
+{
+	unionfs_filldir_cachep =
+	    kmem_cache_create("unionfs_filldir", sizeof(struct filldir_node), 0,
+			      SLAB_RECLAIM_ACCOUNT, NULL, NULL);
+
+	if (!unionfs_filldir_cachep)
+		return -ENOMEM;
+
+	return 0;
+}
+
+void destroy_filldir_cache(void)
+{
+	if (!unionfs_filldir_cachep)
+		return;
+	return;
+}
+
+/* This is a tuning parameter that tells us roughly how big to make the
+ * hash table in directory entries per page.  This isn't perfect, but
+ * at least we get a hash table size that shouldn't be too overloaded.
+ * The following averages are based on my home directory.
+ * 14.44693	Overall
+ * 12.29	Single Page Directories
+ * 117.93	Multi-page directories
+ */
+#define DENTPAGE 4096
+#define DENTPERONEPAGE 12
+#define DENTPERPAGE 118
+#define MINHASHSIZE 1
+static int guesstimate_hash_size(struct inode *inode)
+{
+	struct inode *hidden_inode;
+	int bindex;
+	int hashsize = MINHASHSIZE;
+
+	if (itopd(inode)->uii_hashsize > 0)
+		return itopd(inode)->uii_hashsize;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		if (!(hidden_inode = itohi_index(inode, bindex)))
+			continue;
+
+		if (hidden_inode->i_size == DENTPAGE) {
+			hashsize += DENTPERONEPAGE;
+		} else {
+			hashsize +=
+			    (hidden_inode->i_size / DENTPAGE) * DENTPERPAGE;
+		}
+	}
+
+	return hashsize;
+}
+
+int init_rdstate(struct file *file)
+{
+	BUG_ON(sizeof(loff_t) != (sizeof(unsigned int) + sizeof(unsigned int)));
+	BUG_ON(ftopd(file)->rdstate != NULL);
+
+	ftopd(file)->rdstate =
+	    alloc_rdstate(file->f_dentry->d_inode, fbstart(file));
+	if (!ftopd(file)->rdstate)
+		return -ENOMEM;
+	return 0;
+}
+
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos)
+{
+	struct unionfs_dir_state *rdstate = NULL;
+	struct list_head *pos;
+
+	print_entry("f_pos: %lld", fpos);
+	spin_lock(&itopd(inode)->uii_rdlock);
+	list_for_each(pos, &itopd(inode)->uii_readdircache) {
+		struct unionfs_dir_state *r =
+		    list_entry(pos, struct unionfs_dir_state, uds_cache);
+		if (fpos == rdstate2offset(r)) {
+			itopd(inode)->uii_rdcount--;
+			list_del(&r->uds_cache);
+			rdstate = r;
+			break;
+		}
+	}
+	spin_unlock(&itopd(inode)->uii_rdlock);
+	print_exit_pointer(rdstate);
+	return rdstate;
+}
+
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex)
+{
+	int i = 0;
+	int hashsize;
+	int mallocsize = sizeof(struct unionfs_dir_state);
+	struct unionfs_dir_state *rdstate;
+
+	hashsize = guesstimate_hash_size(inode);
+	mallocsize += hashsize * sizeof(struct list_head);
+	/* Round it up to the next highest power of two. */
+	mallocsize--;
+	mallocsize |= mallocsize >> 1;
+	mallocsize |= mallocsize >> 2;
+	mallocsize |= mallocsize >> 4;
+	mallocsize |= mallocsize >> 8;
+	mallocsize |= mallocsize >> 16;
+	mallocsize++;
+
+	/* This should give us about 500 entries anyway. */
+	if (mallocsize > PAGE_SIZE)
+		mallocsize = PAGE_SIZE;
+
+	hashsize =
+	    (mallocsize -
+	     sizeof(struct unionfs_dir_state)) / sizeof(struct list_head);
+
+	rdstate = KMALLOC(mallocsize, GFP_KERNEL);
+	if (!rdstate)
+		return NULL;
+
+	spin_lock(&itopd(inode)->uii_rdlock);
+	if (itopd(inode)->uii_cookie >= (MAXRDCOOKIE - 1))
+		itopd(inode)->uii_cookie = 1;
+	else
+		itopd(inode)->uii_cookie++;
+
+	rdstate->uds_cookie = itopd(inode)->uii_cookie;
+	spin_unlock(&itopd(inode)->uii_rdlock);
+	rdstate->uds_offset = 1;
+	rdstate->uds_access = jiffies;
+	rdstate->uds_bindex = bindex;
+	rdstate->uds_dirpos = 0;
+	rdstate->uds_hashentries = 0;
+	rdstate->uds_size = hashsize;
+	for (i = 0; i < rdstate->uds_size; i++)
+		INIT_LIST_HEAD(&rdstate->uds_list[i]);
+
+	return rdstate;
+}
+
+static void free_filldir_node(struct filldir_node *node)
+{
+	if (node->namelen >= DNAME_INLINE_LEN_MIN)
+		KFREE(node->name);
+	kmem_cache_free(unionfs_filldir_cachep, node);
+}
+
+void free_rdstate(struct unionfs_dir_state *state)
+{
+	struct filldir_node *tmp;
+	int i;
+
+	for (i = 0; i < state->uds_size; i++) {
+		struct list_head *head = &(state->uds_list[i]);
+		struct list_head *pos, *n;
+
+		/* traverse the list and deallocate space */
+		list_for_each_safe(pos, n, head) {
+			tmp = list_entry(pos, struct filldir_node, file_list);
+			list_del(&tmp->file_list);
+			free_filldir_node(tmp);
+		}
+	}
+
+	KFREE(state);
+}
+
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen)
+{
+	int index;
+	unsigned int hash;
+	struct list_head *head;
+	struct list_head *pos;
+	struct filldir_node *cursor = NULL;
+	int found = 0;
+
+	/* If we print entry, we end up with spurious data. */
+	/* print_entry("name = %*s", namelen, name); */
+	print_entry_location();
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->uds_size;
+
+	head = &(rdstate->uds_list[index]);
+	list_for_each(pos, head) {
+		cursor = list_entry(pos, struct filldir_node, file_list);
+
+		if (cursor->namelen == namelen && cursor->hash == hash
+		    && !strncmp(cursor->name, name, namelen)) {
+			/* a duplicate exists, and hence no need to create entry to the list */
+			found = 1;
+			/* if the duplicate is in this branch, then the file system is corrupted. */
+			if (cursor->bindex == rdstate->uds_bindex) {
+				//buf->error = err = -EIO;
+				dprint(PRINT_DEBUG,
+					    "Possible I/O error unionfs_filldir: a file is duplicated in the same branch %d: %s\n",
+					    rdstate->uds_bindex, cursor->name);
+			}
+			break;
+		}
+	}
+
+	if (!found) {
+		cursor = NULL;
+	}
+	print_exit_pointer(cursor);
+	return cursor;
+}
+
+inline struct filldir_node *alloc_filldir_node(const char *name, int namelen,
+					       unsigned int hash, int bindex)
+{
+	struct filldir_node *newnode;
+
+	newnode =
+	    (struct filldir_node *)kmem_cache_alloc(unionfs_filldir_cachep,
+						    GFP_KERNEL);
+	if (!newnode)
+		goto out;
+
+      out:
+	return newnode;
+}
+
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout)
+{
+	struct filldir_node *new;
+	unsigned int hash;
+	int index;
+	int err = 0;
+	struct list_head *head;
+
+	/* We can't print this because we end up Oopsing. */
+	/* print_entry("name = %*s", namelen, name); */
+	print_entry_location();
+
+	BUG_ON(namelen <= 0);
+
+	hash = full_name_hash(name, namelen);
+	index = hash % rdstate->uds_size;
+	head = &(rdstate->uds_list[index]);
+
+	new = alloc_filldir_node(name, namelen, hash, bindex);
+	if (!new) {
+		err = -ENOMEM;
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&new->file_list);
+	new->namelen = namelen;
+	new->hash = hash;
+	new->bindex = bindex;
+	new->whiteout = whiteout;
+
+	if (namelen < DNAME_INLINE_LEN_MIN) {
+		new->name = new->iname;
+	} else {
+		new->name = (char *)KMALLOC(namelen + 1, GFP_KERNEL);
+		if (!new->name) {
+			kmem_cache_free(unionfs_filldir_cachep, new);
+			new = NULL;
+			goto out;
+		}
+	}
+
+	memcpy(new->name, name, namelen);
+	new->name[namelen] = '\0';
+
+	rdstate->uds_hashentries++;
+
+	list_add(&(new->file_list), head);
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/README linux-2.6.20-sabayon-r1/fs/unionfs/README
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/README	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/README	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,84 @@
+Copyright (c) 2003-2006 Erez Zadok
+Copyright (c) 2003-2006 Charles P. Wright
+Copyright (c) 2005-2006 Josef Sipek
+Copyright (c) 2005      Arun M. Krishnakumar
+Copyright (c) 2005-2006 David P. Quigley
+Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+Copyright (c) 2003      Puja Gupta
+Copyright (c) 2003      Harikesavan Krishnan
+Copyright (c) 2003-2006 Stony Brook University
+Copyright (c) 2003-2006 The Research Foundation of State University of New York
+
+THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY
+EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+We're pleased to announce the first release of a unioning file system
+for Linux, called Unionfs.  To download software and documentation,
+see
+
+	http://www.fsl.cs.sunysb.edu/project-unionfs.html
+
+Unionfs is a stackable unification file system, which can appear to merge
+the contents of several directories (branches), while keeping their physical
+content separate.  Unionfs is useful for unified source tree management,
+merged contents of split CD-ROM, merged separate software package
+directories, data grids, and more.  Unionfs allows any mix of read-only and
+read-write branches, as well as insertion and deletion of branches anywhere
+in the fan-out.  To maintain Unix semantics, Unionfs handles elimination of
+duplicates, partial-error conditions, and more.  This release also includes
+additional preliminary features that were specifically designed for security
+applications, such as snapshotting and sandboxing.
+
+This Unionfs release supports only one 2.6 kernel version (run 'make kvers'
+to find out which).  For older kernels look into Unionfs version 1.0.x and
+1.1.x.  For detailed information about the new Unionfs versioning scheme,
+look at docs/versions.txt.  You also need to have the development headers
+for e2fsprogs installed.
+
+Unionfs is released under the GPL (see the COPYING file in the distribution
+for details).
+
+For more information on using Unionfs, download the tarball and see the
+following man pages:
+
+- unionfs.4:  Describes how to mount unionfs
+
+- unionctl.8: Describes how to control an already mounted Union
+
+For more information about Unionfs internals (which we think are really cool
+:-), see the following technical report at the above Web site:
+
+  C. P. Wright, J. Dave, P. Gupta, H. Krishnan, E. Zadok, and M. Zubair
+  "Versatility and Unix Semantics in a Fan-Out Unification File System"
+  Technical Report FSL-04-01b, October 2004
+  Computer Science Department, Stony Brook University
+  http://www.fsl.cs.sunysb.edu/docs/unionfs-tr/unionfs.pdf
+
+In addition, you can find an article in Linux Journal (December 2004 issue)
+titled "Unionfs: Bringing File Systems Together."  It is available online at
+http://www.linuxjournal.com/article/7714.
+
+See the INSTALL file for instructions on building Unionfs, iteractions with
+kernel features, and known bugs and limitations.
+
+To report bugs, please email them to the "unionfs@filesystems.org" list (see
+www.filesystems.org), or submit them via Bugzilla to
+https://bugzilla.filesystems.org/.  But reports with fixes are most welcome.
+
+Enjoy,
+Erez and Charles (on behalf of the Unionfs team)
+
+##############################################################################
+## For Emacs:
+# Local variables:
+# fill-column: 70
+# End:
+##############################################################################
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/rename.c linux-2.6.20-sabayon-r1/fs/unionfs/rename.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/rename.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/rename.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,942 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: rename.c,v 1.47 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+static int do_rename(struct inode *old_dir, struct dentry *old_dentry,
+		     struct inode *new_dir, struct dentry *new_dentry,
+		     int bindex, struct dentry **wh_old)
+{
+	int err = 0;
+	struct dentry *hidden_old_dentry;
+	struct dentry *hidden_new_dentry;
+	struct dentry *hidden_old_dir_dentry;
+	struct dentry *hidden_new_dir_dentry;
+	struct dentry *hidden_wh_dentry;
+	struct dentry *hidden_wh_dir_dentry;
+	char *wh_name = NULL;
+
+	print_entry(" bindex=%d", bindex);
+
+	print_dentry("IN: do_rename, old_dentry", old_dentry);
+	print_dentry("IN: do_rename, new_dentry", new_dentry);
+	dprint(PRINT_DEBUG, "do_rename for bindex = %d\n", bindex);
+
+	hidden_new_dentry = dtohd_index(new_dentry, bindex);
+	hidden_old_dentry = dtohd_index(old_dentry, bindex);
+
+	if (!hidden_new_dentry) {
+		hidden_new_dentry =
+		    create_parents(new_dentry->d_parent->d_inode, new_dentry,
+				   bindex);
+		if (IS_ERR(hidden_new_dentry)) {
+			dprint(PRINT_DEBUG,
+				    "error creating directory tree for rename, bindex = %d\n",
+				    bindex);
+			err = PTR_ERR(hidden_new_dentry);
+			goto out;
+		}
+	}
+
+	wh_name = alloc_whname(new_dentry->d_name.name, new_dentry->d_name.len);
+	if (IS_ERR(wh_name)) {
+		err = PTR_ERR(wh_name);
+		goto out;
+	}
+
+	hidden_wh_dentry =
+	    LOOKUP_ONE_LEN(wh_name, hidden_new_dentry->d_parent,
+			   new_dentry->d_name.len + WHLEN);
+	if (IS_ERR(hidden_wh_dentry)) {
+		err = PTR_ERR(hidden_wh_dentry);
+		goto out;
+	}
+
+	if (hidden_wh_dentry->d_inode) {
+		/* get rid of the whiteout that is existing */
+		if (hidden_new_dentry->d_inode) {
+			printk(KERN_WARNING
+			       "Both a whiteout and a dentry exist when doing a rename!\n");
+			err = -EIO;
+
+			DPUT(hidden_wh_dentry);
+			goto out;
+		}
+
+		hidden_wh_dir_dentry = lock_parent(hidden_wh_dentry);
+		if (!(err = is_robranch_super(old_dentry->d_sb, bindex))) {
+			err =
+			    vfs_unlink(hidden_wh_dir_dentry->d_inode,
+				       hidden_wh_dentry);
+		}
+		DPUT(hidden_wh_dentry);
+		unlock_dir(hidden_wh_dir_dentry);
+		if (err)
+			goto out;
+	} else
+		DPUT(hidden_wh_dentry);
+
+	DGET(hidden_old_dentry);
+	hidden_old_dir_dentry = GET_PARENT(hidden_old_dentry);
+	hidden_new_dir_dentry = GET_PARENT(hidden_new_dentry);
+
+	lock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+	err = is_robranch_super(old_dentry->d_sb, bindex);
+	if (err)
+		goto out_unlock;
+
+	/* ready to whiteout for old_dentry.
+	   caller will create the actual whiteout,
+	   and must dput(*wh_old) */
+	if (wh_old) {
+		char *whname;
+		whname = alloc_whname(old_dentry->d_name.name,
+				      old_dentry->d_name.len);
+		err = PTR_ERR(whname);
+		if (IS_ERR(whname))
+			goto out_unlock;
+		*wh_old = LOOKUP_ONE_LEN(whname, hidden_old_dir_dentry,
+					 old_dentry->d_name.len + WHLEN);
+		KFREE(whname);
+		err = PTR_ERR(*wh_old);
+		if (IS_ERR(*wh_old)) {
+			*wh_old = NULL;
+			goto out_unlock;
+		}
+	}
+
+	print_dentry("NEWBEF", new_dentry);
+	print_dentry("OLDBEF", old_dentry);
+	err = vfs_rename(hidden_old_dir_dentry->d_inode, hidden_old_dentry,
+			 hidden_new_dir_dentry->d_inode, hidden_new_dentry);
+	print_dentry("NEWAFT", new_dentry);
+	print_dentry("OLDAFT", old_dentry);
+
+      out_unlock:
+	unlock_rename(hidden_old_dir_dentry, hidden_new_dir_dentry);
+
+	DPUT(hidden_old_dir_dentry);
+	DPUT(hidden_new_dir_dentry);
+	DPUT(hidden_old_dentry);
+
+      out:
+	if (!err) {
+		/* Fixup the newdentry. */
+		if (bindex < dbstart(new_dentry))
+			set_dbstart(new_dentry, bindex);
+		else if (bindex > dbend(new_dentry))
+			set_dbend(new_dentry, bindex);
+	}
+
+	KFREE(wh_name);
+
+	print_dentry("OUT: do_rename, old_dentry", old_dentry);
+	print_dentry("OUT: do_rename, new_dentry", new_dentry);
+
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_rename_whiteout(struct inode *old_dir,
+				   struct dentry *old_dentry,
+				   struct inode *new_dir,
+				   struct dentry *new_dentry)
+{
+	int err = 0;
+	int bindex, bwh_old;
+	int old_bstart, old_bend;
+	int new_bstart, new_bend;
+	int do_copyup = -1;
+	struct dentry *parent_dentry;
+	int local_err = 0;
+	int eio = 0;
+	int revert = 0;
+	struct dentry *wh_old = NULL;
+
+	print_entry_location();
+
+	old_bstart = dbstart(old_dentry);
+	bwh_old = old_bstart;
+	old_bend = dbend(old_dentry);
+	parent_dentry = old_dentry->d_parent;
+
+	new_bstart = dbstart(new_dentry);
+	new_bend = dbend(new_dentry);
+
+	/* Rename source to destination. */
+	err = do_rename(old_dir, old_dentry, new_dir, new_dentry, old_bstart,
+			&wh_old);
+	if (err) {
+		if (!IS_COPYUP_ERR(err)) {
+			goto out;
+		}
+		do_copyup = old_bstart - 1;
+	} else {
+		revert = 1;
+	}
+
+	/* Unlink all instances of destination that exist to the left of
+	 * bstart of source. On error, revert back, goto out.
+	 */
+	for (bindex = old_bstart - 1; bindex >= new_bstart; bindex--) {
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		unlink_dentry = dtohd_index(new_dentry, bindex);
+		if (!unlink_dentry) {
+			continue;
+		}
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, bindex))) {
+			err =
+			    vfs_unlink(unlink_dir_dentry->d_inode,
+				       unlink_dentry);
+		}
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		/* propagate number of hard-links */
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+		if (!err) {
+			if (bindex != new_bstart) {
+				DPUT(unlink_dentry);
+				set_dtohd_index(new_dentry, bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			do_copyup = bindex - 1;
+		} else if (revert) {
+			DPUT(wh_old);
+			goto revert;
+		}
+	}
+
+	if (do_copyup != -1) {
+		for (bindex = do_copyup; bindex >= 0; bindex--) {
+			/* copyup the file into some left directory, so that you can rename it */
+			err =
+			    copyup_dentry(old_dentry->d_parent->d_inode,
+					  old_dentry, old_bstart, bindex, NULL,
+					  old_dentry->d_inode->i_size);
+			if (!err) {
+				DPUT(wh_old);
+				bwh_old = bindex;
+				err =
+				    do_rename(old_dir, old_dentry, new_dir,
+					      new_dentry, bindex, &wh_old);
+				break;
+			}
+		}
+	}
+
+	/* make it opaque */
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+		err = make_dir_opaque(old_dentry, dbstart(old_dentry));
+		if (err)
+			goto revert;
+	}
+
+	/* Create whiteout for source, only if:
+	 * (1) There is more than one underlying instance of source.
+	 * (2) We did a copy_up
+	 */
+	if ((old_bstart != old_bend) || (do_copyup != -1)) {
+		struct dentry *hidden_parent;
+		BUG_ON(!wh_old || IS_ERR(wh_old) || wh_old->d_inode
+		       || bwh_old < 0);
+		hidden_parent = lock_parent(wh_old);
+		local_err = vfs_create(hidden_parent->d_inode, wh_old, S_IRUGO,
+				       NULL);
+		unlock_dir(hidden_parent);
+		if (!local_err)
+			set_dbopaque(old_dentry, bwh_old);
+		else {
+			/* We can't fix anything now, so we cop-out and use -EIO. */
+			printk
+			    ("<0>We can't create a whiteout for the source in rename!\n");
+			err = -EIO;
+		}
+	}
+
+      out:
+	DPUT(wh_old);
+	print_exit_status(err);
+	return err;
+
+      revert:
+	/* Do revert here. */
+	local_err = unionfs_refresh_hidden_dentry(new_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the new refresh failed.\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_hidden_dentry(old_dentry, old_bstart);
+	if (local_err) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the old refresh failed.\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (!dtohd_index(new_dentry, bindex)
+	    || !dtohd_index(new_dentry, bindex)->d_inode) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the object disappeared from under us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	if (dtohd_index(old_dentry, bindex)
+	    && dtohd_index(old_dentry, bindex)->d_inode) {
+		printk(KERN_WARNING
+		       "Revert failed in rename: the object was created underneath us!\n");
+		eio = -EIO;
+		goto revert_out;
+	}
+
+	local_err =
+	    do_rename(new_dir, new_dentry, old_dir, old_dentry, old_bstart,
+		      NULL);
+
+	/* If we can't fix it, then we cop-out with -EIO. */
+	if (local_err) {
+		printk(KERN_WARNING "Revert failed in rename!\n");
+		eio = -EIO;
+	}
+
+	local_err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+	local_err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+	if (local_err)
+		eio = -EIO;
+
+      revert_out:
+	if (eio)
+		err = eio;
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Unfortunately, we cannot simply call things like dbstart() in different
+ * places of the rename code because we move things around. So, we use this
+ * structure to pass the necessary information around to all the places that
+ * need it.
+ */
+struct rename_info {
+	int do_copyup;
+	int do_whiteout;
+	int rename_ok;
+
+	int old_bstart;
+	int old_bend;
+	int new_bstart;
+	int new_bend;
+
+	int isdir;		/* Is the source a directory? */
+	int clobber;		/* Are we clobbering the destination? */
+
+	int bwh_old;		/* where we create the whiteout */
+	struct dentry *wh_old;	/* lookup and set by do_rename() */
+};
+#ifdef UNIONFS_DELETE_ALL
+/*
+ * Rename all occurences of source except for the leftmost destination
+ */
+static int __rename_all(struct inode *old_dir, struct dentry *old_dentry,
+			struct inode *new_dir, struct dentry *new_dentry,
+			fd_set * success_mask, struct rename_info *info)
+{
+	int bindex;
+	int err = 0;
+
+	print_entry_location();
+
+	/* Loop through all the branches from right to left and rename all
+	 * instances of source to destination, except the leftmost destination
+	 */
+	for (bindex = info->old_bend; bindex >= info->old_bstart; bindex--) {
+		/* We don't rename if there is no source. */
+		if (dtohd_index(old_dentry, bindex) == NULL)
+			continue;
+
+		/* we rename the bstart of destination only at the last of
+		 * all operations, so that we don't lose it on error
+		 */
+		if (info->clobber && (bindex == info->new_bstart))
+			continue;
+
+		DPUT(info->wh_old);
+		info->bwh_old = bindex;
+		/* We shouldn't have a handle on this if there is no inode. */
+		err =
+		    do_rename(old_dir, old_dentry, new_dir, new_dentry, bindex,
+			      &info->wh_old);
+		if (!err) {
+			/* For reverting. */
+			FD_SET(bindex, success_mask);
+			/* So we know not to copyup on failures the right */
+			info->rename_ok = bindex;
+		} else if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				break;
+			}
+
+			/* we need a whiteout... */
+			info->do_whiteout = bindex - 1;
+
+			if (bindex == info->old_bstart)
+				/* ...and a copyup */
+				info->do_copyup = bindex - 1;
+
+			err = 0;	/* reset error */
+		} else
+			break;	/* error is set by do_rename */
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Unlink all destinations (if they exist) to the left of the left-most
+ * source
+ */
+static int __rename_all_unlink(struct inode *old_dir, struct dentry *old_dentry,
+			       struct inode *new_dir, struct dentry *new_dentry,
+			       struct rename_info *info)
+{
+	int bindex;
+
+	struct dentry *unlink_dentry;
+	struct dentry *unlink_dir_dentry;
+
+	int err = 0;
+
+	print_entry_location();
+
+	for (bindex = info->old_bstart - 1; bindex > info->new_bstart; bindex--) {
+		unlink_dentry = dtohd_index(new_dentry, bindex);
+		if (!unlink_dentry)
+			continue;
+
+		/* lock, unlink if possible, copyup times, unlock */
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, bindex)))
+			err =
+			    vfs_unlink(unlink_dir_dentry->d_inode,
+				       unlink_dentry);
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+
+		if (!err) {
+			if (bindex != info->new_bstart) {
+				DPUT(unlink_dentry);
+				set_dtohd_index(new_dentry, bindex, NULL);
+			}
+		} else if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				break;
+			}
+			info->do_copyup = bindex - 1;
+
+			err = 0;	/* reset error */
+		} else
+			break;	/* err is set by is_ro_branch_super or vfs_unlink */
+	}
+
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * Try to revert everything we have done in __rename_all and __rename_all_unlink
+ */
+static int __rename_all_revert(struct inode *old_dir, struct dentry *old_dentry,
+			       struct inode *new_dir, struct dentry *new_dentry,
+			       fd_set * success_mask, struct rename_info *info)
+{
+	int bindex;
+
+	int err;
+	int eio = 0;
+
+	print_entry_location();
+
+	for (bindex = info->old_bstart; bindex <= info->old_bend; bindex++) {
+		if (!FD_ISSET(bindex, success_mask))
+			continue;
+
+		err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the new refresh failed.\n");
+			eio = -EIO;
+		}
+
+		err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the old refresh failed.\n");
+			eio = -EIO;
+			continue;
+		}
+
+		if (!dtohd_index(new_dentry, bindex)
+		    || !dtohd_index(new_dentry, bindex)->d_inode) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the object disappeared from under us!\n");
+			eio = -EIO;
+			continue;
+		}
+
+		if (dtohd_index(old_dentry, bindex)
+		    && dtohd_index(old_dentry, bindex)->d_inode) {
+			printk(KERN_WARNING "Revert failed in rename: "
+			       "the object was created underneath us!\n");
+			eio = -EIO;
+			continue;
+		}
+
+		err =
+		    do_rename(new_dir, new_dentry, old_dir, old_dentry, bindex,
+			      NULL);
+		/* If we can't fix it, then we cop-out with -EIO. */
+		if (err) {
+			printk(KERN_WARNING "Revert failed in rename!\n");
+			eio = -EIO;
+		}
+
+		err = unionfs_refresh_hidden_dentry(new_dentry, bindex);
+		if (err)
+			eio = -EIO;
+		err = unionfs_refresh_hidden_dentry(old_dentry, bindex);
+		if (err)
+			eio = -EIO;
+	}
+
+	print_exit_status(eio);
+	return eio;
+}
+
+/*
+ * Finish off the rename, by either over writing the last destination or
+ * unlinking the last destination to the left of us
+ */
+static int __rename_all_clobber(struct inode *old_dir,
+				struct dentry *old_dentry,
+				struct inode *new_dir,
+				struct dentry *new_dentry,
+				struct rename_info *info)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	if (dtohd_index(old_dentry, info->new_bstart)) {
+		/* rename the last source, knowing we're overwriting something */
+		DPUT(info->wh_old);
+		info->bwh_old = info->new_bstart;
+		err =
+		    do_rename(old_dir, old_dentry, new_dir, new_dentry,
+			      info->new_bstart, &info->wh_old);
+		if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				goto out;
+			}
+			if (info->rename_ok > info->new_bstart) {
+				if ((info->do_copyup == -1)
+				    || (info->new_bstart - 1 < info->do_copyup))
+					info->do_copyup = info->new_bstart - 1;
+			}
+			if ((info->do_whiteout == -1)
+			    || (info->new_bstart - 1 < info->do_whiteout)) {
+				info->do_whiteout = info->new_bstart - 1;
+			}
+			err = 0;	// reset error
+		}
+	} else if (info->new_bstart < info->old_bstart) {
+		/* the newly renamed file would get hidden, let's unlink the
+		 * file to the left of it */
+		struct dentry *unlink_dentry;
+		struct dentry *unlink_dir_dentry;
+
+		unlink_dentry = dtohd_index(new_dentry, info->new_bstart);
+
+		unlink_dir_dentry = lock_parent(unlink_dentry);
+		if (!(err = is_robranch_super(old_dir->i_sb, info->new_bstart)))
+			err = vfs_unlink(unlink_dir_dentry->d_inode,
+					 unlink_dentry);
+
+		fist_copy_attr_times(new_dentry->d_parent->d_inode,
+				     unlink_dir_dentry->d_inode);
+		new_dentry->d_parent->d_inode->i_nlink =
+		    get_nlinks(new_dentry->d_parent->d_inode);
+
+		unlock_dir(unlink_dir_dentry);
+
+		if (IS_COPYUP_ERR(err)) {
+			if (info->isdir) {
+				err = -EXDEV;
+				goto out;
+			}
+			if ((info->do_copyup == -1)
+			    || (info->new_bstart - 1 < info->do_copyup))
+				info->do_copyup = info->new_bstart - 1;
+
+			err = 0;	// reset error
+		}
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ * The function is nasty, nasty, nasty, but so is rename. :(
+ */
+static int unionfs_rename_all(struct inode *old_dir, struct dentry *old_dentry,
+			      struct inode *new_dir, struct dentry *new_dentry)
+{
+	struct dentry *parent_dentry = NULL;
+	int err = 0;
+	int eio;
+
+	/* These variables control error handling. */
+	fd_set success_mask;
+	char *name = NULL;
+
+	/* unfortunately, we have to resort to this, because dbstart/dbend would
+	   return different things in different place of the rename code */
+	struct rename_info info;
+
+	info.rename_ok = FD_SETSIZE;	/* The last rename that is ok. */
+	info.do_copyup = -1;	/* Where we should start copyup. */
+	info.do_whiteout = -1;	/* Where we should start whiteouts of the source. */
+	info.wh_old = NULL;
+	info.bwh_old = -1;
+
+	print_entry_location();
+
+	parent_dentry = old_dentry->d_parent;
+	name = KMALLOC(old_dentry->d_name.len + 1, GFP_KERNEL);
+	if (!name) {
+		err = -ENOMEM;
+		goto out;
+	}
+	strncpy(name, old_dentry->d_name.name, old_dentry->d_name.len + 1);
+
+	info.new_bstart = dbstart(new_dentry);
+	info.new_bend = dbend(new_dentry);
+
+	info.old_bstart = dbstart(old_dentry);
+	info.old_bend = dbend(old_dentry);
+
+	BUG_ON(info.new_bstart < 0);
+	BUG_ON(info.old_bstart < 0);
+
+	/* The failure mask only can deal with FD_SETSIZE entries. */
+	BUG_ON(info.old_bend > FD_SETSIZE);
+	BUG_ON(info.new_bend > FD_SETSIZE);
+	FD_ZERO(&success_mask);
+
+	/* Life is simpler if the dentry doesn't exist. */
+	info.clobber =
+	    (dtohd_index(new_dentry, info.new_bstart)->d_inode) ? 1 : 0;
+	info.isdir = S_ISDIR(old_dentry->d_inode->i_mode);
+
+	/* rename everything we can */
+	err =
+	    __rename_all(old_dir, old_dentry, new_dir, new_dentry,
+			 &success_mask, &info);
+	if (err)
+		goto revert;
+
+	/* unlink destinations even further left */
+	err =
+	    __rename_all_unlink(old_dir, old_dentry, new_dir, new_dentry,
+				&info);
+	if (err)
+		goto revert;
+
+	if (info.clobber) {
+		/* Now we need to handle the leftmost of the destination. */
+		err =
+		    __rename_all_clobber(old_dir, old_dentry, new_dir,
+					 new_dentry, &info);
+		if (err)
+			goto revert;
+	}
+
+	/* Copy up if necessary */
+	if (info.do_copyup != -1) {
+		int bindex;
+
+		for (bindex = info.do_copyup; bindex >= 0; bindex--) {
+			err =
+			    copyup_dentry(old_dentry->d_parent->d_inode,
+					  old_dentry, info.old_bstart, bindex,
+					  NULL, old_dentry->d_inode->i_size);
+			if (!err) {
+				DPUT(info.wh_old);
+				info.bwh_old = bindex;
+				err =
+				    do_rename(old_dir, old_dentry, new_dir,
+					      new_dentry, bindex, &info.wh_old);
+				break;
+			}
+		}
+	}
+
+	/* make it opaque */
+	if (S_ISDIR(old_dentry->d_inode->i_mode)) {
+		err = make_dir_opaque(old_dentry, dbstart(old_dentry));
+		if (err)
+			goto revert;
+	}
+
+	/* Create a whiteout for the source. */
+	if (info.do_whiteout != -1) {
+		struct dentry *hidden_parent;
+		BUG_ON(info.do_whiteout < 0
+		       || !info.wh_old || IS_ERR(info.wh_old)
+		       || info.wh_old->d_inode || info.bwh_old < 0);
+		hidden_parent = lock_parent(info.wh_old);
+		err = vfs_create(hidden_parent->d_inode, info.wh_old, S_IRUGO,
+				 NULL);
+		unlock_dir(hidden_parent);
+		if (!err)
+			set_dbopaque(old_dentry, info.bwh_old);
+		else {
+			/* We can't fix anything now, so we -EIO. */
+			printk(KERN_WARNING "We can't create a whiteout for the"
+			       "source in rename!\n");
+			err = -EIO;
+			goto out;
+		}
+	}
+
+	/* We are at the point where reverting doesn't happen. */
+	goto out;
+
+      revert:
+	/* something bad happened, try to revert */
+	eio =
+	    __rename_all_revert(old_dir, old_dentry, new_dir, new_dentry,
+				&success_mask, &info);
+	if (eio)
+		err = eio;
+
+      out:
+	DPUT(info.wh_old);
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+#endif
+
+static struct dentry *lookup_whiteout(struct dentry *dentry)
+{
+	char *whname;
+	int bindex = -1, bstart = -1, bend = -1;
+	struct dentry *parent, *hidden_parent, *wh_dentry;
+
+	whname = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(whname))
+		return (void *)whname;
+
+	parent = GET_PARENT(dentry);
+	lock_dentry(parent);
+	bstart = dbstart(parent);
+	bend = dbend(parent);
+	wh_dentry = ERR_PTR(-ENOENT);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_parent = dtohd_index(parent, bindex);
+		if (!hidden_parent)
+			continue;
+		wh_dentry =
+		    LOOKUP_ONE_LEN(whname, hidden_parent,
+				   dentry->d_name.len + WHLEN);
+		if (IS_ERR(wh_dentry))
+			continue;
+		if (wh_dentry->d_inode)
+			break;
+		DPUT(wh_dentry);
+		wh_dentry = ERR_PTR(-ENOENT);
+	}
+	unlock_dentry(parent);
+	DPUT(parent);
+	KFREE(whname);
+	return wh_dentry;
+}
+
+/* We can't copyup a directory, because it may involve huge
+ * numbers of children, etc.  Doing that in the kernel would
+ * be bad, so instead we let the userspace recurse and ask us
+ * to copy up each file separately
+ */
+static int may_rename_dir(struct dentry *dentry)
+{
+	int err, bstart;
+
+	err = check_empty(dentry, NULL);
+	if (err == -ENOTEMPTY) {
+		if (is_robranch(dentry))
+			return -EXDEV;
+	} else if (err)
+		return err;
+
+	bstart = dbstart(dentry);
+	if (dbend(dentry) == bstart || dbopaque(dentry) == bstart)
+		return 0;
+
+	set_dbstart(dentry, bstart + 1);
+	err = check_empty(dentry, NULL);
+	set_dbstart(dentry, bstart);
+	if (err == -ENOTEMPTY)
+		err = -EXDEV;
+	return err;
+}
+
+int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+		   struct inode *new_dir, struct dentry *new_dentry)
+{
+	int err = 0;
+	struct dentry *wh_dentry;
+
+	print_entry_location();
+
+	double_lock_dentry(old_dentry, new_dentry);
+
+	checkinode(old_dir, "unionfs_rename-old_dir");
+	checkinode(new_dir, "unionfs_rename-new_dir");
+	print_dentry("IN: unionfs_rename, old_dentry", old_dentry);
+	print_dentry("IN: unionfs_rename, new_dentry", new_dentry);
+
+	if (!S_ISDIR(old_dentry->d_inode->i_mode))
+		err = unionfs_partial_lookup(old_dentry);
+	else
+		err = may_rename_dir(old_dentry);
+
+	if (err)
+		goto out;
+
+	err = unionfs_partial_lookup(new_dentry);
+	if (err)
+		goto out;
+
+	/*
+	 * if new_dentry is already hidden because of whiteout,
+	 * simply override it even if the whiteouted dir is not empty.
+	 */
+	wh_dentry = lookup_whiteout(new_dentry);
+	if (!IS_ERR(wh_dentry))
+		DPUT(wh_dentry);
+	else if (new_dentry->d_inode) {
+		if (S_ISDIR(old_dentry->d_inode->i_mode) !=
+		    S_ISDIR(new_dentry->d_inode->i_mode)) {
+			err =
+			    S_ISDIR(old_dentry->d_inode->
+				    i_mode) ? -ENOTDIR : -EISDIR;
+			goto out;
+		}
+
+		if (S_ISDIR(new_dentry->d_inode->i_mode)) {
+			struct unionfs_dir_state *namelist;
+			/* check if this unionfs directory is empty or not */
+			err = check_empty(new_dentry, &namelist);
+			if (err)
+				goto out;
+
+			if (!is_robranch(new_dentry))
+				err = delete_whiteouts(new_dentry,
+						dbstart(new_dentry),
+						namelist);
+
+			free_rdstate(namelist);
+
+			if (err)
+				goto out;
+		}
+	}
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(old_dir->i_sb, DELETE_ALL))
+		err = unionfs_rename_all(old_dir, old_dentry, new_dir,
+					 new_dentry);
+	else
+#endif
+		err = unionfs_rename_whiteout(old_dir, old_dentry, new_dir,
+					      new_dentry);
+
+      out:
+	checkinode(new_dir, "post unionfs_rename-new_dir");
+	print_dentry("OUT: unionfs_rename, old_dentry", old_dentry);
+
+	if (err) {
+		/* clear the new_dentry stuff created */
+		d_drop(new_dentry);
+	} else {
+		/* force re-lookup since the dir on ro branch is not renamed,
+		   and hidden dentries still indicate the un-renamed ones. */
+		if (S_ISDIR(old_dentry->d_inode->i_mode))
+			atomic_dec(&dtopd(old_dentry)->udi_generation);
+		print_dentry("OUT: unionfs_rename, new_dentry",
+				  new_dentry);
+	}
+
+	unlock_dentry(new_dentry);
+	unlock_dentry(old_dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/sioq.c linux-2.6.20-sabayon-r1/fs/unionfs/sioq.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/sioq.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/sioq.c	2007-02-12 13:00:41.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2004-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+
+#include "unionfs.h"
+
+struct workqueue_struct *sioq;
+
+int __init init_sioq(void)
+{
+	int err;
+
+	sioq = create_workqueue("unionfs_siod");
+	if (!IS_ERR(sioq))
+		return 0;
+
+	err = PTR_ERR(sioq);
+	printk(KERN_ERR "create_workqueue failed %d\n", err);
+	sioq = NULL;
+	return err;
+}
+
+void fin_sioq(void)
+{
+	if (sioq)
+		destroy_workqueue(sioq);
+}
+
+void run_sioq(work_func_t func, struct sioq_args *args)
+{
+	INIT_WORK(&args->tqueue, func);
+
+	init_completion(&args->comp);
+	while (!queue_work(sioq, &args->tqueue)) {
+		// TODO: do accounting if needed
+		schedule();
+	}
+	wait_for_completion(&args->comp);
+}
+
+void __unionfs_create(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct create_args *c = &args->create;
+	args->err = vfs_create(c->parent, c->dentry, c->mode, c->nd);
+	complete(&args->comp);
+}
+
+void __unionfs_mkdir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct mkdir_args *m = &args->mkdir;
+	args->err = vfs_mkdir(m->parent, m->dentry, m->mode);
+	complete(&args->comp);
+}
+
+void __unionfs_mknod(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct mknod_args *m = &args->mknod;
+	args->err = vfs_mknod(m->parent, m->dentry, m->mode, m->dev);
+	complete(&args->comp);
+}
+void __unionfs_symlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct symlink_args *s = &args->symlink;
+	args->err = vfs_symlink(s->parent, s->dentry, s->symbuf, s->mode);
+	complete(&args->comp);
+}
+
+void __unionfs_unlink(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct unlink_args *u = &args->unlink;
+	args->err = vfs_unlink(u->parent, u->dentry);
+	complete(&args->comp);
+}
+
+void __delete_whiteouts(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	struct deletewh_args *d = &args->deletewh;
+	args->err = delete_whiteouts(d->dentry, d->bindex, d->namelist);
+	complete(&args->comp);
+}
+
+void __is_opaque_dir(struct work_struct *work)
+{
+	struct sioq_args *args = container_of(work, struct sioq_args, tqueue);
+	args->ret = lookup_one_len(UNIONFS_DIR_OPAQUE, args->isopaque.dentry,
+				sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	complete(&args->comp);
+}
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/sioq.h linux-2.6.20-sabayon-r1/fs/unionfs/sioq.h
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/sioq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/sioq.h	2007-02-12 13:02:12.000000000 +0100
@@ -0,0 +1,81 @@
+#ifndef _SIOQ_H
+#define _SIOQ_H
+
+struct deletewh_args {
+	struct unionfs_dir_state *namelist;
+	struct dentry *dentry;
+	int bindex;
+};
+
+struct isopaque_args {
+	struct dentry *dentry;
+};
+
+struct create_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	struct nameidata *nd;
+};
+
+struct mkdir_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+};
+
+struct mknod_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	umode_t mode;
+	dev_t dev;
+};
+
+struct symlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+	char *symbuf;
+	umode_t mode;
+};
+
+struct unlink_args {
+	struct inode *parent;
+	struct dentry *dentry;
+};
+
+
+struct sioq_args {
+
+	struct completion comp;
+	int err;
+	void *ret;
+
+struct work_struct tqueue;
+
+	union {
+		struct deletewh_args deletewh;
+		struct isopaque_args isopaque;
+		struct create_args create;
+		struct mkdir_args mkdir;
+		struct mknod_args mknod;
+		struct symlink_args symlink;
+		struct unlink_args unlink;
+	}; //} u;
+};
+
+extern struct workqueue_struct *sioq;
+int __init init_sioq(void);
+extern void fin_sioq(void);
+extern void run_sioq(work_func_t func, struct sioq_args *args);
+
+/* Extern definitions for our privledge escalation helpers */
+extern void __unionfs_create(struct work_struct *work);
+extern void __unionfs_mkdir(struct work_struct *work);
+extern void __unionfs_mknod(struct work_struct *work);
+extern void __unionfs_symlink(struct work_struct *work);
+extern void __unionfs_unlink(struct work_struct *work);
+extern void __delete_whiteouts(struct work_struct *work);
+extern void __is_opaque_dir(struct work_struct *work);
+
+#endif /* _SIOQ_H */
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/stale_inode.c linux-2.6.20-sabayon-r1/fs/unionfs/stale_inode.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/stale_inode.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/stale_inode.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,133 @@
+/*
+ *  Adpated from linux/fs/bad_inode.c
+ *
+ *  Copyright (C) 1997, Stephen Tweedie
+ *
+ *  Provide stub functions for "stale" inodes, a bit friendlier than the
+ *  -EIO that bad_inode.c does.
+ */
+/*
+ *  $Id: stale_inode.c,v 1.14 2006/11/08 08:10:32 jsipek Exp $
+ */
+
+#include <linux/version.h>
+
+#include <linux/fs.h>
+#include <linux/stat.h>
+#include <linux/sched.h>
+
+static struct address_space_operations unionfs_stale_aops;
+
+/* declarations for "sparse */
+extern struct inode_operations stale_inode_ops;
+
+/*
+ * The follow_link operation is special: it must behave as a no-op
+ * so that a stale root inode can at least be unmounted. To do this
+ * we must dput() the base and return the dentry with a dget().
+ */
+static void *stale_follow_link(struct dentry *dent, struct nameidata *nd)
+{
+	int err = vfs_follow_link(nd, ERR_PTR(-ESTALE));
+	return ERR_PTR(err);
+}
+
+static int return_ESTALE(void)
+{
+	return -ESTALE;
+}
+
+#define ESTALE_ERROR ((void *) (return_ESTALE))
+
+static struct file_operations stale_file_ops = {
+	.llseek = ESTALE_ERROR,
+	.read = ESTALE_ERROR,
+	.write = ESTALE_ERROR,
+	.readdir = ESTALE_ERROR,
+	.poll = ESTALE_ERROR,
+	.ioctl = ESTALE_ERROR,
+	.mmap = ESTALE_ERROR,
+	.open = ESTALE_ERROR,
+	.flush = ESTALE_ERROR,
+	.release = ESTALE_ERROR,
+	.fsync = ESTALE_ERROR,
+	.fasync = ESTALE_ERROR,
+	.lock = ESTALE_ERROR,
+};
+
+struct inode_operations stale_inode_ops = {
+	.create = ESTALE_ERROR,
+	.lookup = ESTALE_ERROR,
+	.link = ESTALE_ERROR,
+	.unlink = ESTALE_ERROR,
+	.symlink = ESTALE_ERROR,
+	.mkdir = ESTALE_ERROR,
+	.rmdir = ESTALE_ERROR,
+	.mknod = ESTALE_ERROR,
+	.rename = ESTALE_ERROR,
+	.readlink = ESTALE_ERROR,
+	.follow_link = stale_follow_link,
+	.truncate = ESTALE_ERROR,
+	.permission = ESTALE_ERROR,
+};
+
+/*
+ * When a filesystem is unable to read an inode due to an I/O error in
+ * its read_inode() function, it can call make_stale_inode() to return a
+ * set of stubs which will return ESTALE errors as required.
+ *
+ * We only need to do limited initialisation: all other fields are
+ * preinitialised to zero automatically.
+ */
+
+/**
+ *	make_stale_inode - mark an inode stale due to an I/O error
+ *	@inode: Inode to mark stale
+ *
+ *	When an inode cannot be read due to a media or remote network
+ *	failure this function makes the inode "stale" and causes I/O operations
+ *	on it to fail from this point on.
+ */
+
+void make_stale_inode(struct inode *inode)
+{
+	inode->i_mode = S_IFREG;
+	inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	inode->i_op = &stale_inode_ops;
+	inode->i_fop = &stale_file_ops;
+	inode->i_mapping->a_ops = &unionfs_stale_aops;
+}
+
+/*
+ * This tests whether an inode has been flagged as stale. The test uses
+ * &stale_inode_ops to cover the case of invalidated inodes as well as
+ * those created by make_stale_inode() above.
+ */
+
+/**
+ *	is_stale_inode - is an inode errored
+ *	@inode: inode to test
+ *
+ *	Returns true if the inode in question has been marked as stale.
+ */
+
+int is_stale_inode(struct inode *inode)
+{
+	return (inode->i_op == &stale_inode_ops);
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/subr.c linux-2.6.20-sabayon-r1/fs/unionfs/subr.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/subr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/subr.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: subr.c,v 1.142 2006/09/21 18:19:36 jsipek Exp $
+ */
+
+#include "unionfs.h"
+#include <linux/security.h>
+
+/* Pass an unionfs dentry and an index.  It will try to create a whiteout
+ * for the filename in dentry, and will try in branch 'index'.  On error,
+ * it will proceed to a branch to the left.
+ */
+int create_whiteout(struct dentry *dentry, int start)
+{
+	int bstart, bend, bindex;
+	struct dentry *hidden_dir_dentry;
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_wh_dentry;
+	char *name = NULL;
+	int err = -EINVAL;
+
+	print_entry("start = %d", start);
+
+	verify_locked(dentry);
+
+	print_dentry("IN create_whiteout", dentry);
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	/* create dentry's whiteout equivalent */
+	name = alloc_whname(dentry->d_name.name, dentry->d_name.len);
+	if (IS_ERR(name)) {
+		err = PTR_ERR(name);
+		goto out;
+	}
+
+	for (bindex = start; bindex >= 0; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+
+		if (!hidden_dentry) {
+			/* if hidden dentry is not present, create the entire
+			 * hidden dentry directory structure and go ahead.
+			 * Since we want to just create whiteout, we only want
+			 * the parent dentry, and hence get rid of this dentry.
+			 */
+			hidden_dentry = create_parents(dentry->d_inode,
+						       dentry, bindex);
+			if (!hidden_dentry || IS_ERR(hidden_dentry)) {
+				dprint(PRINT_DEBUG_WHITEOUT,
+				       "create_parents failed for bindex = %d\n",
+				       bindex);
+				continue;
+			}
+		}
+		hidden_wh_dentry =
+		    LOOKUP_ONE_LEN(name, hidden_dentry->d_parent,
+				   dentry->d_name.len + WHLEN);
+		if (IS_ERR(hidden_wh_dentry))
+			continue;
+
+		/* The whiteout already exists. This used to be impossible, but
+		 * now is possible because of opaqueness. */
+		if (hidden_wh_dentry->d_inode) {
+			DPUT(hidden_wh_dentry);
+			err = 0;
+			goto out;
+		}
+
+		hidden_dir_dentry = lock_parent(hidden_wh_dentry);
+		if (!(err = is_robranch_super(dentry->d_sb, bindex))) {
+			err =
+			    vfs_create(hidden_dir_dentry->d_inode,
+				       hidden_wh_dentry,
+				       ~current->fs->umask & S_IRWXUGO, NULL);
+
+		}
+		unlock_dir(hidden_dir_dentry);
+		DPUT(hidden_wh_dentry);
+
+		if (!err)
+			break;
+
+		if (!IS_COPYUP_ERR(err))
+			break;
+	}
+
+	/* set dbopaque  so that lookup will not proceed after this branch */
+	if (!err)
+		set_dbopaque(dentry, bindex);
+
+	print_dentry("OUT create_whiteout", dentry);
+      out:
+	KFREE(name);
+	print_exit_status(err);
+	return err;
+}
+
+/* This is a helper function for rename, which ends up with hosed over dentries
+ * when it needs to revert. */
+int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_parent;
+	int err = 0;
+
+	print_entry(" bindex = %d", bindex);
+
+	verify_locked(dentry);
+	lock_dentry(dentry->d_parent);
+	hidden_parent = dtohd_index(dentry->d_parent, bindex);
+	unlock_dentry(dentry->d_parent);
+
+	BUG_ON(!S_ISDIR(hidden_parent->d_inode->i_mode));
+
+	hidden_dentry =
+	    LOOKUP_ONE_LEN(dentry->d_name.name, hidden_parent,
+			   dentry->d_name.len);
+	if (IS_ERR(hidden_dentry)) {
+		err = PTR_ERR(hidden_dentry);
+		goto out;
+	}
+
+	if (dtohd_index(dentry, bindex))
+		DPUT(dtohd_index(dentry, bindex));
+	if (itohi_index(dentry->d_inode, bindex)) {
+		IPUT(itohi_index(dentry->d_inode, bindex));
+		set_itohi_index(dentry->d_inode, bindex, NULL);
+	}
+	if (!hidden_dentry->d_inode) {
+		DPUT(hidden_dentry);
+		set_dtohd_index(dentry, bindex, NULL);
+	} else {
+		set_dtohd_index(dentry, bindex, hidden_dentry);
+		set_itohi_index(dentry->d_inode, bindex,
+				IGRAB(hidden_dentry->d_inode));
+	}
+
+      out:
+	print_exit_status(err);
+	return err;
+}
+
+int make_dir_opaque(struct dentry *dentry, int bindex)
+{
+	int err;
+	struct dentry *hidden_dentry, *diropq;
+	struct inode *hidden_dir;
+
+	hidden_dentry = dtohd_index(dentry, bindex);
+	hidden_dir = hidden_dentry->d_inode;
+	BUG_ON(!S_ISDIR(dentry->d_inode->i_mode)
+	       || !S_ISDIR(hidden_dir->i_mode));
+
+	mutex_lock(&hidden_dir->i_mutex);
+	diropq = LOOKUP_ONE_LEN(UNIONFS_DIR_OPAQUE, hidden_dentry,
+				sizeof(UNIONFS_DIR_OPAQUE) - 1);
+	err = PTR_ERR(diropq);
+	if (IS_ERR(diropq))
+		goto out;
+	err = 0;
+
+	if (!diropq->d_inode)
+		err = vfs_create(hidden_dir, diropq, S_IRUGO, NULL);
+	DPUT(diropq);
+	if (!err)
+		set_dbopaque(dentry, bindex);
+
+      out:
+	mutex_unlock(&hidden_dir->i_mutex);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/super.c linux-2.6.20-sabayon-r1/fs/unionfs/super.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/super.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/super.c	2007-02-12 15:30:14.000000000 +0100
@@ -0,0 +1,828 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: super.c,v 1.101 2006/11/04 22:27:51 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* The inode cache is used with alloc_inode for both our inode info and the
+ * vfs inode.  */
+static kmem_cache_t *unionfs_inode_cachep;
+
+static void unionfs_read_inode(struct inode *inode)
+{
+#ifdef UNIONFS_MMAP
+	/* SP: use real address operations */
+	extern struct address_space_operations unionfs_aops;
+#else
+	static struct address_space_operations unionfs_empty_aops;
+#endif
+	int size;
+
+	print_entry_location();
+
+	if (!itopd(inode)) {
+		printk(KERN_ERR
+		       "No kernel memory when allocating inode private data!\n");
+		BUG();
+	}
+
+	memset(itopd(inode), 0, sizeof(struct unionfs_inode_info));
+	itopd(inode)->b_start = -1;
+	itopd(inode)->b_end = -1;
+	atomic_set(&itopd(inode)->uii_generation,
+		   atomic_read(&stopd(inode->i_sb)->usi_generation));
+	itopd(inode)->uii_rdlock = SPIN_LOCK_UNLOCKED;
+	itopd(inode)->uii_rdcount = 1;
+	itopd(inode)->uii_hashsize = -1;
+	INIT_LIST_HEAD(&itopd(inode)->uii_readdircache);
+
+	size = sbmax(inode->i_sb) * sizeof(struct inode *);
+	itohi_ptr(inode) = KZALLOC(size, GFP_KERNEL);
+	if (!itohi_ptr(inode)) {
+		printk(KERN_ERR
+		       "No kernel memory when allocating lower-pointer array!\n");
+		BUG();
+	}
+
+	inode->i_version++;
+	inode->i_op = &unionfs_main_iops;
+	inode->i_fop = &unionfs_main_fops;
+#ifdef UNIONFS_MMAP
+	inode->i_mapping->a_ops = &unionfs_aops;
+#else
+	/* I don't think ->a_ops is ever allowed to be NULL */
+	inode->i_mapping->a_ops = &unionfs_empty_aops;
+	dprint(PRINT_DEBUG, "setting inode 0x%p a_ops to empty (0x%p)\n",
+	       inode, inode->i_mapping->a_ops);
+#endif
+
+	print_exit_location();
+}
+
+static void unionfs_put_inode(struct inode *inode)
+{
+	print_entry_location();
+
+	dprint(PRINT_DEBUG, "%s i_count = %d, i_nlink = %d\n", __FUNCTION__,
+	       atomic_read(&inode->i_count), inode->i_nlink);
+
+	/*
+	 * This is really funky stuff:
+	 * Basically, if i_count == 1, iput will then decrement it and this
+	 * inode will be destroyed.  It is currently holding a reference to the
+	 * hidden inode.  Therefore, it needs to release that reference by
+	 * calling iput on the hidden inode.  iput() _will_ do it for us (by
+	 * calling our clear_inode), but _only_ if i_nlink == 0.  The problem
+	 * is, NFS keeps i_nlink == 1 for silly_rename'd files.  So we must for
+	 * our i_nlink to 0 here to trick iput() into calling our clear_inode.
+	 */
+
+	if (atomic_read(&inode->i_count) == 1)
+		inode->i_nlink = 0;
+
+	print_exit_location();
+}
+
+/*
+ * we now define delete_inode, because there are two VFS paths that may
+ * destroy an inode: one of them calls clear inode before doing everything
+ * else that's needed, and the other is fine.  This way we truncate the inode
+ * size (and its pages) and then clear our own inode, which will do an iput
+ * on our and the lower inode.
+ */
+static void unionfs_delete_inode(struct inode *inode)
+{
+	print_entry_location();
+
+	checkinode(inode, "unionfs_delete_inode IN");
+	inode->i_size = 0;	/* every f/s seems to do that */
+
+#ifdef UNIONFS_MMAP
+	/* SP: if you try to clear_inode() when
+	 * inode->i_data.nrpages != 0, you'll hit a BUG
+	 * this is also what generic_delete_inode does */
+	if (inode->i_data.nrpages)
+		truncate_inode_pages(&inode->i_data, 0);
+#endif
+	clear_inode(inode);
+
+	print_exit_location();
+}
+
+/* final actions when unmounting a file system */
+static void unionfs_put_super(struct super_block *sb)
+{
+	int bindex, bstart, bend;
+	struct unionfs_sb_info *spd;
+
+	print_entry_location();
+
+	if ((spd = stopd(sb))) {
+#ifdef UNIONFS_IMAP
+		/* XXX: Free persistent inode stuff. */
+		cleanup_imap_data(sb);
+#endif
+		bstart = sbstart(sb);
+		bend = sbend(sb);
+		for (bindex = bstart; bindex <= bend; bindex++)
+			mntput(stohiddenmnt_index(sb, bindex));
+
+		/* Make sure we have no leaks of branchget/branchput. */
+		for (bindex = bstart; bindex <= bend; bindex++)
+			BUG_ON(branch_count(sb, bindex) != 0);
+
+		KFREE(spd->usi_data);
+		KFREE(spd);
+		stopd_lhs(sb) = NULL;
+	}
+	dprint(PRINT_DEBUG, "unionfs: released super\n");
+
+	print_exit_location();
+}
+
+static int unionfs_statfs(struct dentry *dentry, struct kstatfs *buf)
+{
+	int err = 0;
+	struct super_block *sb, *hidden_sb;
+	struct kstatfs rsb;
+	int bindex, bindex1, bstart, bend;
+
+	print_entry_location();
+
+	sb = dentry->d_sb;
+
+	memset(buf, 0, sizeof(struct kstatfs));
+	buf->f_type = UNIONFS_SUPER_MAGIC;
+
+	buf->f_frsize = 0;
+	buf->f_namelen = 0;
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		int dup = 0;
+
+		hidden_sb = stohs_index(sb, bindex);
+		/* Ignore duplicate super blocks. */
+		for (bindex1 = bstart; bindex1 < bindex; bindex1++) {
+			if (hidden_sb == stohs_index(sb, bindex1)) {
+				dup = 1;
+				break;
+			}
+		}
+		if (dup) {
+			continue;
+		}
+
+		err = vfs_statfs(hidden_sb->s_root, &rsb);
+		dprint(PRINT_DEBUG,
+		       "adding values for bindex:%d bsize:%d blocks:%d bfree:%d bavail:%d\n",
+		       bindex, (int)rsb.f_bsize, (int)rsb.f_blocks,
+		       (int)rsb.f_bfree, (int)rsb.f_bavail);
+
+		if (!buf->f_frsize)
+			buf->f_frsize = rsb.f_frsize;
+		if (!buf->f_namelen) {
+			buf->f_namelen = rsb.f_namelen;
+		} else {
+			if (buf->f_namelen > rsb.f_namelen)
+				buf->f_namelen = rsb.f_namelen;
+		}
+		if (!buf->f_bsize) {
+			buf->f_bsize = rsb.f_bsize;
+		} else {
+			if (buf->f_bsize < rsb.f_bsize) {
+				int shifter = 0;
+				while (buf->f_bsize < rsb.f_bsize) {
+					shifter++;
+					rsb.f_bsize >>= 1;
+				}
+				rsb.f_blocks <<= shifter;
+				rsb.f_bfree <<= shifter;
+				rsb.f_bavail <<= shifter;
+			} else {
+				int shifter = 0;
+				while (buf->f_bsize > rsb.f_bsize) {
+					shifter++;
+					rsb.f_bsize <<= 1;
+				}
+				rsb.f_blocks >>= shifter;
+				rsb.f_bfree >>= shifter;
+				rsb.f_bavail >>= shifter;
+			}
+		}
+		buf->f_blocks += rsb.f_blocks;
+		buf->f_bfree += rsb.f_bfree;
+		buf->f_bavail += rsb.f_bavail;
+		buf->f_files += rsb.f_files;
+		buf->f_ffree += rsb.f_ffree;
+	}
+	buf->f_namelen -= WHLEN;
+
+	memset(&buf->f_fsid, 0, sizeof(__kernel_fsid_t));
+	memset(&buf->f_spare, 0, sizeof(buf->f_spare));
+	print_exit_status(err);
+	return err;
+}
+
+static int do_binary_remount(struct super_block *sb, int *flags, char *data)
+{
+	unsigned long *uldata = (unsigned long *)data;
+	int err;
+
+	uldata++;
+
+	switch (*uldata) {
+	case UNIONFS_IOCTL_DELBRANCH:
+		err = unionfs_ioctl_delbranch(sb, *(uldata + 1));
+		break;
+	default:
+		err = -ENOTTY;
+	}
+
+	return err;
+}
+
+/* We don't support a standard text remount, but we do have a magic remount
+ * for unionctl.  The idea is that you can remove a branch without opening
+ * the union.  Eventually it would be nice to support a full-on remount, so
+ * that you can have all of the directories change at once, but that would
+ * require some pretty complicated matching code. */
+static int unionfs_remount_fs(struct super_block *sb, int *flags, char *data)
+{
+	if (data && *((unsigned long *)data) == UNIONFS_REMOUNT_MAGIC)
+		return do_binary_remount(sb, flags, data);
+	printk("Warning! dirs delete and imap options to remount are ignored\n");
+	return 0;
+}
+
+/*
+ * Called by iput() when the inode reference count reached zero
+ * and the inode is not hashed anywhere.  Used to clear anything
+ * that needs to be, before the inode is completely destroyed and put
+ * on the inode free list.
+ */
+static void unionfs_clear_inode(struct inode *inode)
+{
+	int bindex, bstart, bend;
+	struct inode *hidden_inode;
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	print_entry_location();
+
+	checkinode(inode, "unionfs_clear_inode IN");
+
+	list_for_each_safe(pos, n, &itopd(inode)->uii_readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, uds_cache);
+		list_del(&rdstate->uds_cache);
+		free_rdstate(rdstate);
+	}
+
+	/* Decrement a reference to a hidden_inode, which was incremented
+	 * by our read_inode when it was created initially.  */
+	bstart = ibstart(inode);
+	bend = ibend(inode);
+	if (bstart >= 0) {
+		for (bindex = bstart; bindex <= bend; bindex++) {
+			hidden_inode = itohi_index(inode, bindex);
+			if (!hidden_inode)
+				continue;
+			IPUT(hidden_inode);
+		}
+	}
+	// XXX: why this assertion fails?
+	// because it doesn't like us
+	// BUG_ON((inode->i_state & I_DIRTY) != 0);
+	KFREE(itohi_ptr(inode));
+	itohi_ptr(inode) = NULL;
+
+	print_exit_location();
+}
+
+static struct inode *unionfs_alloc_inode(struct super_block *sb)
+{
+	struct unionfs_inode_container *c;
+
+	print_entry_location();
+
+	c = (struct unionfs_inode_container *)
+	    kmem_cache_alloc(unionfs_inode_cachep, GFP_KERNEL);
+	if (!c) {
+		print_exit_pointer(NULL);
+		return NULL;
+	}
+
+	memset(&c->info, 0, sizeof(c->info));
+
+	c->vfs_inode.i_version = 1;
+	print_exit_pointer(&c->vfs_inode);
+	return &c->vfs_inode;
+}
+
+static void unionfs_destroy_inode(struct inode *inode)
+{
+	print_entry("inode = %p", inode);
+	kmem_cache_free(unionfs_inode_cachep, itopd(inode));
+	print_exit_location();
+}
+
+static void init_once(void *v, kmem_cache_t * cachep, unsigned long flags)
+{
+	struct unionfs_inode_container *c = (struct unionfs_inode_container *)v;
+
+	print_entry_location();
+
+	if ((flags & (SLAB_CTOR_VERIFY | SLAB_CTOR_CONSTRUCTOR)) ==
+	    SLAB_CTOR_CONSTRUCTOR)
+		inode_init_once(&c->vfs_inode);
+
+	print_exit_location();
+}
+
+int init_inode_cache(void)
+{
+	int err = 0;
+
+	print_entry_location();
+
+	unionfs_inode_cachep =
+	    kmem_cache_create("unionfs_inode_cache",
+			      sizeof(struct unionfs_inode_container), 0,
+			      SLAB_RECLAIM_ACCOUNT, init_once, NULL);
+	if (!unionfs_inode_cachep)
+		err = -ENOMEM;
+	print_exit_status(err);
+	return err;
+}
+
+void destroy_inode_cache(void)
+{
+	print_entry_location();
+	if (!unionfs_inode_cachep)
+		goto out;
+      out:
+	print_exit_location();
+	return;
+}
+
+/* Called when we have a dirty inode, right here we only throw out
+ * parts of our readdir list that are too old.
+ */
+static int unionfs_write_inode(struct inode *inode, int sync)
+{
+	struct list_head *pos, *n;
+	struct unionfs_dir_state *rdstate;
+
+	print_entry_location();
+
+	spin_lock(&itopd(inode)->uii_rdlock);
+	list_for_each_safe(pos, n, &itopd(inode)->uii_readdircache) {
+		rdstate = list_entry(pos, struct unionfs_dir_state, uds_cache);
+		/* We keep this list in LRU order. */
+		if ((rdstate->uds_access + RDCACHE_JIFFIES) > jiffies)
+			break;
+		itopd(inode)->uii_rdcount--;
+		list_del(&rdstate->uds_cache);
+		free_rdstate(rdstate);
+	}
+	spin_unlock(&itopd(inode)->uii_rdlock);
+
+	print_exit_location();
+	return 0;
+}
+
+/*
+ * Used only in nfs, to kill any pending RPC tasks, so that subsequent
+ * code can actually succeed and won't leave tasks that need handling.
+ *
+ * PS. I wonder if this is somehow useful to undo damage that was
+ * left in the kernel after a user level file server (such as amd)
+ * dies.
+ */
+static void unionfs_umount_begin(struct vfsmount *mnt, int flags)
+{
+	struct super_block *sb, *hidden_sb;
+	struct vfsmount *hidden_mnt;
+	int bindex, bstart, bend;
+
+	print_entry_location();
+
+	if (!(flags & MNT_FORCE))
+		/* we are not being MNT_FORCEd, therefore we should emulate old
+		 * behaviour
+		 */
+		goto out;
+
+	sb = mnt->mnt_sb;
+
+	bstart = sbstart(sb);
+	bend = sbend(sb);
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_mnt = stohiddenmnt_index(sb, bindex);
+		hidden_sb  = stohs_index(sb, bindex);
+
+		if (hidden_mnt && hidden_sb && hidden_sb->s_op &&
+		    hidden_sb->s_op->umount_begin)
+			hidden_sb->s_op->umount_begin(hidden_mnt, flags);
+	}
+
+out:
+	print_exit_location();
+}
+
+static int unionfs_show_options(struct seq_file *m, struct vfsmount *mnt)
+{
+	struct super_block *sb = mnt->mnt_sb;
+	int ret = 0;
+	unsigned long tmp = 0;
+	char *hidden_path;
+	int bindex, bstart, bend;
+	int perms;
+
+	lock_dentry(sb->s_root);
+
+	tmp = __get_free_page(GFP_KERNEL);
+	if (!tmp) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
+	bindex = bstart = sbstart(sb);
+	bend = sbend(sb);
+
+	seq_printf(m, ",dirs=");
+	for (bindex = bstart; bindex <= bend; bindex++) {
+		hidden_path =
+		    d_path(dtohd_index(sb->s_root, bindex),
+			   stohiddenmnt_index(sb, bindex), (char *)tmp,
+			   PAGE_SIZE);
+		perms = branchperms(sb, bindex);
+		seq_printf(m, "%s=%s", hidden_path,
+			   perms & MAY_WRITE ? "rw" :
+			   perms & MAY_NFSRO ? "nfsro" : "ro");
+		if (bindex != bend) {
+			seq_printf(m, ":");
+		}
+	}
+
+	seq_printf(m, ",debug=%u", get_debug_mask());
+
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(sb, DELETE_ALL))
+		seq_printf(m, ",delete=all");
+	else
+#endif
+		seq_printf(m, ",delete=whiteout");
+      out:
+	if (tmp)
+		free_page(tmp);
+	unlock_dentry(sb->s_root);
+	return ret;
+}
+
+#ifdef CONFIG_EXPORTFS
+/*
+ * export operations.
+ * unionfs cannot handle disconnected dentry, since it has no hidden dentries.
+ */
+/* un-tested 64 bit environment (pointer and inode number) */
+
+#define is_anon(d) ((d)->d_flags & DCACHE_DISCONNECTED)
+extern struct export_operations export_op_default;
+
+static void prepend_path(char **path, const char *name, int len)
+{
+	*path -= len;
+	memcpy(*path, name, len);
+	(*path)--;
+	**path = '/';
+}
+
+struct filldir_arg {
+	int found, called;
+	char *path;
+	ino_t ino, parent_ino;
+};
+
+static int filldir(void *arg, const char *name, int len, loff_t pos, ino_t ino,
+		   unsigned int d_type)
+{
+	struct filldir_arg *a = arg;
+
+	a->called++;
+	if (len == 2 && !strncmp(name, "..", 2)) {
+		a->parent_ino = ino;
+		a->found++;
+	} else if (ino == a->ino) {
+		if (len != 1 || *name != '.')
+			prepend_path(&a->path, name, len);
+		a->found++;
+	}
+	return (a->found == 2) ? 1 : 0;
+}
+
+static struct dentry *get_hidden_parent(struct super_block *hidden_sb,
+					ino_t hidden_parent_ino)
+{
+	__u32 fh[2];
+
+	if (hidden_sb->s_root->d_inode->i_ino == hidden_parent_ino)
+		return DGET(hidden_sb->s_root);
+
+	fh[0] = hidden_parent_ino;
+	fh[1] = 0;
+	return export_op_default.get_dentry(hidden_sb, fh);
+}
+
+static struct dentry *do_get_dentry(struct super_block *sb, ino_t ino,
+				    __u32 gen, struct dentry *hidden_root,
+				    ino_t hidden_ino, ino_t hidden_parent_ino)
+{
+	struct dentry *dentry, *hidden_parent, *parent;
+	char *path, *p;
+	struct filldir_arg arg = {
+		.ino = hidden_ino,
+		.parent_ino = hidden_parent_ino
+	};
+	int open_flags, err, bindex, bend, found;
+	struct file *hidden_file;
+	struct super_block *hidden_sb;
+
+	print_entry("hr%p, hi%lu, hpi%lu",
+		    hidden_root, hidden_ino, hidden_parent_ino);
+
+	dentry = ERR_PTR(-ENOMEM);
+	path = __getname();
+	if (!path)
+		goto out;
+	arg.path = path + PATH_MAX - 1;
+	*arg.path = 0;
+
+	open_flags = O_RDONLY | O_DIRECTORY /* | O_NOATIME */ ;
+	if (force_o_largefile())
+		open_flags |= O_LARGEFILE;
+
+	dentry = ERR_PTR(-ESTALE);
+	unionfs_read_lock(sb);
+	lock_dentry(sb->s_root);
+	bend = dbend(sb->s_root);
+	found = -1;
+	for (bindex = 0; found == -1 && bindex <= bend; bindex++)
+		if (hidden_root == dtohd_index(sb->s_root, bindex))
+			found = bindex;
+	unlock_dentry(sb->s_root);
+	if (found == -1)
+		goto out_unlock;
+
+	bindex = found;
+	hidden_sb = stohs_index(sb, bindex);
+	while (1) {
+		hidden_parent = get_hidden_parent(hidden_sb, hidden_parent_ino);
+		dentry = hidden_parent;
+		if (IS_ERR(hidden_parent))
+			goto out_unlock;
+
+		branchget(sb, bindex);
+		hidden_file = DENTRY_OPEN(DGET(hidden_parent), NULL,
+					  open_flags);
+		if (IS_ERR(hidden_file)) {
+			dentry = (void *)hidden_file;
+			DPUT(hidden_parent);
+			branchput(sb, bindex);
+			goto out_unlock;
+		}
+
+		arg.found = 0;
+		while (arg.found != 2) {
+			arg.called = 0;
+			err = vfs_readdir(hidden_file, filldir, &arg);
+			if (!arg.called || err < 0)
+				break;
+		}
+		fput(hidden_file);
+		branchput(sb, bindex);
+		if (arg.found != 2) {
+			dentry = ERR_PTR(-ESTALE);
+			DPUT(hidden_parent);
+			goto out_unlock;
+		}
+
+		DPUT(hidden_parent);
+		if (hidden_parent_ino == hidden_root->d_inode->i_ino)
+			break;
+		arg.ino = hidden_parent_ino;
+		hidden_parent_ino = arg.parent_ino;
+	}
+	BUG_ON(arg.path < path);
+
+	parent = DGET(sb->s_root);
+	p = strchr(++arg.path, '/');
+	while (p) {
+		mutex_lock(&parent->d_inode->i_mutex);
+		dentry = LOOKUP_ONE_LEN(arg.path, parent, p - arg.path);
+		mutex_unlock(&parent->d_inode->i_mutex);
+		DPUT(parent);
+		if (IS_ERR(dentry))
+			goto out_unlock;
+		if (!dentry->d_inode || !S_ISDIR(dentry->d_inode->i_mode)) {
+			DPUT(dentry);
+			dentry = ERR_PTR(-ESTALE);
+			goto out_unlock;
+		}
+		parent = dentry;
+		arg.path = p + 1;
+		p = strchr(arg.path, '/');
+	}
+	mutex_lock(&parent->d_inode->i_mutex);
+	dentry = LOOKUP_ONE_LEN(arg.path, parent, strlen(arg.path));
+	mutex_unlock(&parent->d_inode->i_mutex);
+	DPUT(parent);
+	if (!IS_ERR(dentry)
+	    && (!dentry->d_inode
+		|| dentry->d_inode->i_ino != ino
+		|| dentry->d_inode->i_generation != gen)) {
+		DPUT(dentry);
+		dentry = ERR_PTR(-ESTALE);
+	}
+
+      out_unlock:
+	unionfs_read_unlock(sb);
+	__putname(path);
+      out:
+	print_exit_pointer(dentry);
+	return dentry;
+}
+
+enum {
+	FhHead = 4, FhHRoot1 = FhHead, FhHRoot2,
+	FhHIno1, FhHIno2, FhHPIno1, FhHPIno2,
+	FhTail
+};
+
+static void do_decode(__u32 * fh, struct dentry **hidden_root,
+		      ino_t * hidden_ino, ino_t * hidden_parent_ino)
+{
+	unsigned long root;
+	
+	root = fh[FhHRoot2];
+	*hidden_ino = fh[FhHIno2];
+	*hidden_parent_ino = fh[FhHPIno2];
+#if BITS_PER_LONG == 64
+	root |= ((unsigned long)fh[FhHRoot1]) << 32;
+	*hidden_ino |= ((unsigned long) fh[FhHIno1]) << 32;
+	*hidden_parent_ino |= ((unsigned long) fh[FhHPIno1]) << 32;
+#elif BITS_PER_LONG == 32
+	/* ok */
+#else
+#error unknown size
+#endif
+
+	*hidden_root = (struct dentry*) root;
+}
+
+static int unionfs_encode_fh(struct dentry *dentry, __u32 * fh, int *max_len,
+			     int connectable)
+{
+	int type, len, bindex;
+	struct super_block *sb;
+	struct dentry *h_root;
+	ino_t h_ino, hp_ino;
+	static int warn;
+
+	print_entry("dentry %p", dentry);
+	BUG_ON(is_anon(dentry) || !dentry->d_inode
+	       || is_anon(dentry->d_parent));
+
+#ifdef UNIONFS_IMAP
+	if (!warn && stopd(dentry->d_sb)->usi_persistent)
+		warn++;
+#endif
+	if (!warn) {
+		printk(KERN_WARNING "Exporting Unionfs without imap"
+		       " option may stop your NFS server or client");
+		warn++;
+	}
+
+	sb = dentry->d_sb;
+	unionfs_read_lock(sb);
+	lock_dentry(dentry);
+
+	len = *max_len;
+	type = export_op_default.encode_fh(dentry, fh, max_len, connectable);
+	if (type == 255 || *max_len > FhHead || len < FhTail) {
+		type = 255;
+		goto out;
+	}
+
+	*max_len = FhTail;
+	bindex = dbstart(dentry);
+	lock_dentry(sb->s_root);
+	h_root = dtohd_index(sb->s_root, bindex);
+	unlock_dentry(sb->s_root);
+	h_ino = itohi_index(dentry->d_inode, bindex)->i_ino;
+	hp_ino = parent_ino(dtohd(dentry));
+	fh[FhHRoot2] = (unsigned long) h_root;
+	fh[FhHIno2] = h_ino;
+	fh[FhHPIno2] = hp_ino;
+#if BITS_PER_LONG == 64
+	fh[FhHRoot1] = ((unsigned long) h_root) >> 32;
+	fh[FhHIno1] = h_ino >> 32;
+	fh[FhHPIno1] = hp_ino >> 32;
+#endif
+
+      out:
+	unionfs_print(PRINT_MAIN_EXIT, "%d, fh{i%u, g%d, hr%x, hi%u, hpi%u}\n",
+		      type, fh[0], fh[1], fh[FhHRoot2], fh[FhHIno2],
+		      fh[FhHPIno2]);
+	unlock_dentry(dentry);
+	unionfs_read_unlock(sb);
+	return type;
+}
+
+static struct dentry *unionfs_decode_fh(struct super_block *sb, __u32 * fh,
+					int fh_len, int fh_type,
+					int (*acceptable) (void *context,
+							   struct dentry * de),
+					void *context)
+{
+	struct dentry *dentry, *hidden_root;
+	ino_t hidden_ino, hidden_parent_ino;
+
+	print_entry("%d, fh{i%u, g%d, hr%x, hi%u, hpi%u}",
+		    fh_type, fh[0], fh[1], fh[FhHRoot2], fh[FhHIno2],
+		    fh[FhHPIno2]);
+
+	dentry = export_op_default.get_dentry(sb, fh);
+	if (!dentry || IS_ERR(dentry) || (dentry->d_inode && !is_anon(dentry)))
+		return dentry;
+
+	d_drop(dentry);
+	DPUT(dentry);
+	do_decode(fh, &hidden_root, &hidden_ino, &hidden_parent_ino);
+	dentry = do_get_dentry(sb, fh[0], fh[1], hidden_root, hidden_ino,
+			       hidden_parent_ino);
+	if (!IS_ERR(dentry)) {
+		if (acceptable(context, dentry))
+			return dentry;	/* success */
+		DPUT(dentry);
+		dentry = NULL;
+	}
+	return dentry;
+}
+
+struct export_operations unionfs_export_ops = {
+	.decode_fh = unionfs_decode_fh,
+	.encode_fh = unionfs_encode_fh
+};
+#endif
+
+struct super_operations unionfs_sops = {
+	.read_inode = unionfs_read_inode,
+	.put_inode = unionfs_put_inode,
+	.delete_inode = unionfs_delete_inode,
+	.put_super = unionfs_put_super,
+	.statfs = unionfs_statfs,
+	.remount_fs = unionfs_remount_fs,
+	.clear_inode = unionfs_clear_inode,
+	.umount_begin = unionfs_umount_begin,
+	.show_options = unionfs_show_options,
+	.write_inode = unionfs_write_inode,
+	.alloc_inode = unionfs_alloc_inode,
+	.destroy_inode = unionfs_destroy_inode,
+};
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_debug.h linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_debug.h
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_debug.h	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionfs_debug.h,v 1.3 2006/06/01 21:25:18 jsipek Exp $
+ */
+
+#ifndef __UNIONFS_H_
+#error This file should only be included from unionfs.h!
+#endif
+
+#ifdef UNIONFS_DEBUG
+#define DEFAULT_DEBUG_MASK	0
+#else
+#define DEFAULT_DEBUG_MASK	(~0)
+#endif
+
+/* debug print levels */
+#define PRINT_NONE		0x0000
+#define PRINT_MAIN_ENTRY	0x0001
+#define PRINT_MAIN_EXIT		0x0002
+#define PRINT_UTILITY_ENTRY	0x0004
+#define PRINT_UTILITY_EXIT	0x0008
+#define PRINT_MISC_ENTRY	0x0010
+#define PRINT_MISC_EXIT		0x0020
+#define PRINT_DATA_DENTRY	0x0040
+#define PRINT_DATA_FILE		0x0080
+#define PRINT_DATA_INODE	0x0100
+#define PRINT_DATA_SB		0x0200
+#define PRINT_DEBUG		0x0400
+#define __PRINT_DEBUG_XATTR	0x0800
+#define PRINT_DEBUG_XATTR	(PRINT_DEBUG | __PRINT_DEBUG_XATTR)
+#define __PRINT_DEBUG_WHITEOUT	0x1000
+#define PRINT_DEBUG_WHITEOUT	(PRINT_DEBUG | __PRINT_DEBUG_WHITEOUT)
+
+#define PRINT_MAX		(0x2000 - 1)
+#define PRINT_ALL		(~PRINT_NONE)
+
+extern unsigned int get_debug_mask(void);
+extern int set_debug_mask(int val);
+
+/* print inode */
+extern void unionfs_print_inode(const unsigned int req, const char *prefix, const struct inode *inode);
+
+/* check inode */
+extern void unionfs_checkinode(const unsigned int req, const struct inode *inode, const char *msg);
+
+/* prunt file */
+extern void unionfs_print_file(const unsigned int req, const char *prefix, const struct file *file);
+
+/* print dentry */
+extern void unionfs_print_dentry(const unsigned int req, const char *prefix, const struct dentry *dentry);
+
+extern void unionfs_print_dentry_nocheck(const unsigned int req, const char *prefix, const struct dentry *dentry);
+
+/* print superblock */
+extern void unionfs_print_sb(const unsigned int req, const char *prefix, const struct super_block *sb);
+
+/* print message */
+extern int unionfs_print(const unsigned int req, const char *fmt, ...);
+
+/* forced print-debugging functions */
+#define force_print_dentry(prefix, ptr) \
+		unionfs_print_dentry(PRINT_ALL, (prefix), (ptr))
+#define force_print_dentry_nocheck(prefix, ptr) \
+		unionfs_print_dentry_nocheck(PRINT_ALL, (prefix), (ptr))
+#define force_print_file(prefix, ptr) \
+		unionfs_print_file(PRINT_ALL, (prefix), (ptr))
+#define force_print_inode(prefix, ptr) \
+		unionfs_print_inode(PRINT_ALL, (prefix), (ptr))
+#define force_print_sb(prefix, ptr) \
+		unionfs_print_sb(PRINT_ALL, (prefix), (ptr))
+
+#ifdef UNIONFS_DEBUG
+/*
+ * Full-fledged debugging enabled
+ */
+
+#define print_dentry(prefix, ptr) \
+		unionfs_print_dentry(PRINT_DATA_DENTRY, (prefix), (ptr))
+#define print_dentry_nocheck(prefix, ptr) \
+		unionfs_print_dentry_nocheck(PRINT_DATA_DENTRY, (prefix), (ptr))
+#define print_file(prefix, ptr) \
+		unionfs_print_file(PRINT_DATA_FILE, (prefix), (ptr))
+#define print_inode(prefix, ptr) \
+		unionfs_print_inode(PRINT_DATA_INODE, (prefix), (ptr))
+#define print_sb(prefix, ptr) \
+		unionfs_print_sb(PRINT_DATA_SB, (prefix), (ptr))
+#define dprint(req, fmt, args...) \
+		unionfs_print(req, fmt, ## args)
+
+#define checkinode(ptr, msg) \
+		unionfs_checkinode(PRINT_DEBUG, (ptr), (msg))
+
+#define __print_entryexit(req, ee, fmt, args...) \
+		unionfs_print((req), \
+			ee "  %s %s:%d" fmt "\n", \
+			__FUNCTION__, \
+			__FILE__, \
+			__LINE__, \
+			##args)
+
+#define print_entry(fmt, args...) \
+		__print_entryexit(PRINT_MAIN_ENTRY, \
+			"IN: ", " " fmt, ##args)
+
+#define print_entry_location() \
+		__print_entryexit(PRINT_MAIN_ENTRY, \
+			"IN: ", "")
+
+#define print_exit_location() \
+		__print_entryexit(PRINT_MAIN_EXIT, \
+			"OUT:", "")
+
+#define print_exit_status(status) \
+		__print_entryexit(PRINT_MAIN_EXIT, \
+			"OUT:", ", STATUS: %d", status)
+
+static inline void __print_exit_pointer(unsigned int req, void *status)
+{
+	if (IS_ERR(status))
+		__print_entryexit(req, "OUT:", ", STATUS: %ld",
+				PTR_ERR(status));
+	else
+		__print_entryexit(req, "OUT:", ", STATUS: 0x%p",
+				status);
+}
+#define print_exit_pointer(status) \
+		__print_exit_pointer(PRINT_MAIN_EXIT, status)
+
+#define print_util_entry(fmt, args...) \
+		__print_entryexit(PRINT_UTILITY_ENTRY, \
+			"IN: ", " " fmt, ##args)
+
+#define print_util_entry_location() \
+		__print_entryexit(PRINT_UTILITY_ENTRY, \
+			"IN: ", "")
+
+#define print_util_exit_location() \
+		__print_entryexit(PRINT_UTILITY_EXIT, \
+			"OUT:", "")
+
+#define print_util_exit_status(status) \
+		__print_entryexit(PRINT_UTILITY_EXIT, \
+			"OUT:", ", STATUS: %d", status)
+
+#define print_util_exit_pointer(status) \
+		__print_exit_pointer(PRINT_UTILITY_EXIT, status)
+
+#else /* UNIONFS_DEBUG */
+/*
+ * Full-fledged debugging disabled
+ */
+
+#define print_dentry(prefix, ptr)
+#define print_dentry_nocheck(prefix, ptr)
+#define print_file(prefix, ptr)
+#define print_inode(prefix, ptr)
+#define print_sb(prefix, ptr)
+#define dprint(req, fmt, args...)
+
+#define checkinode(ptr, msg)
+
+#define print_entry(args...)
+#define print_entry_location()
+#define print_exit_location()
+#define print_exit_status(status)
+#define print_exit_pointer(status)
+#define print_util_entry(args...)
+#define print_util_entry_location()
+#define print_util_exit_location()
+#define print_util_exit_status(status)
+#define print_util_exit_pointer(status)
+
+#endif /* ! UNIONFS_DEBUG */
+
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs.h linux-2.6.20-sabayon-r1/fs/unionfs/unionfs.h
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/unionfs.h	2007-02-12 15:19:09.000000000 +0100
@@ -0,0 +1,733 @@
+#ifndef __UNIONFS_H_
+#define __UNIONFS_H_
+
+#ifdef __KERNEL__
+
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/string.h>
+#include <linux/stat.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/limits.h>
+#include <linux/random.h>
+#include <linux/poll.h>
+#include <linux/buffer_head.h>
+#include <linux/pagemap.h>
+#include <linux/namei.h>
+#include <linux/module.h>
+#include <linux/mount.h>
+#include <linux/page-flags.h>
+#include <linux/writeback.h>
+#include <linux/page-flags.h>
+#include <linux/statfs.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/file.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/poll.h>
+#include <linux/list.h>
+#include <linux/init.h>
+#include <linux/xattr.h>
+#include <linux/security.h>
+#include <linux/spinlock.h>
+#include <linux/compat.h>
+
+#include <linux/swap.h>
+
+#include <asm/system.h>
+#include <asm/mman.h>
+#include <linux/seq_file.h>
+#include <linux/dcache.h>
+#include <linux/poll.h>
+
+/* the file system name */
+#define UNIONFS_NAME "unionfs"
+
+/* unionfs file systems superblock magic */
+#define UNIONFS_SUPER_MAGIC 0xf15f083d
+
+/* unionfs root inode number */
+#define UNIONFS_ROOT_INO     1
+
+/* Mount time flags */
+#define MOUNT_FLAG(sb)     (stopd(sb)->usi_mount_flag)
+
+/* number of characters while generating unique temporary file names */
+#define	UNIONFS_TMPNAM_LEN	12
+
+/* Operations vectors defined in specific files. */
+extern struct file_operations unionfs_main_fops;
+extern struct file_operations unionfs_dir_fops;
+extern struct inode_operations unionfs_main_iops;
+extern struct inode_operations unionfs_dir_iops;
+extern struct inode_operations unionfs_symlink_iops;
+extern struct super_operations unionfs_sops;
+extern struct dentry_operations unionfs_dops;
+#ifdef CONFIG_EXPORTFS
+extern struct export_operations unionfs_export_ops;
+#endif
+
+/* How long should an entry be allowed to persist */
+#define RDCACHE_JIFFIES 5*HZ
+
+/* file private data. */
+struct unionfs_file_info {
+	int b_start;
+	int b_end;
+	atomic_t ufi_generation;
+
+	struct unionfs_dir_state *rdstate;
+	struct file **ufi_file;
+};
+
+/* unionfs inode data in memory */
+struct unionfs_inode_info {
+	int b_start;
+	int b_end;
+	atomic_t uii_generation;
+	int uii_stale;
+	/* Stuff for readdir over NFS. */
+	spinlock_t uii_rdlock;
+	struct list_head uii_readdircache;
+	int uii_rdcount;
+	int uii_hashsize;
+	int uii_cookie;
+	/* The hidden inodes */
+	struct inode **uii_inode;
+	/* to keep track of reads/writes for unlinks before closes */
+	atomic_t uii_totalopens;
+};
+
+struct unionfs_inode_container {
+	struct unionfs_inode_info info;
+	struct inode vfs_inode;
+};
+
+/* unionfs dentry data in memory */
+struct unionfs_dentry_info {
+	/* The semaphore is used to lock the dentry as soon as we get into a
+	 * unionfs function from the VFS.  Our lock ordering is that children
+	 * go before their parents. */
+	struct semaphore udi_sem;
+	int udi_bstart;
+	int udi_bend;
+	int udi_bopaque;
+	int udi_bcount;
+	atomic_t udi_generation;
+	struct dentry **udi_dentry;
+};
+
+/* A putmap is used so that older files can still do branchput correctly. */
+struct putmap {
+	atomic_t count;
+	int bend;
+	int map[0];
+};
+
+/* These are the pointers to our various objects. */
+struct unionfs_usi_data {
+	struct super_block *sb;
+	struct vfsmount *hidden_mnt;
+	atomic_t sbcount;
+	int branchperms;
+};
+
+/* unionfs super-block data in memory */
+struct unionfs_sb_info {
+	int b_end;
+
+	atomic_t usi_generation;
+	unsigned long usi_mount_flag;
+	struct rw_semaphore usi_rwsem;
+
+	struct unionfs_usi_data *usi_data;
+
+	/* These map branch numbers for old generation numbers to the new bindex,
+	 * so that branchput will behave properly. */
+	int usi_firstputmap;
+	int usi_lastputmap;
+	struct putmap **usi_putmaps;
+
+#ifdef UNIONFS_IMAP
+	int usi_persistent;
+	/* These will need a lock. */
+	uint64_t usi_next_avail;
+	uint8_t usi_num_bmapents;
+	struct bmapent *usi_bmap;
+	struct file *usi_forwardmap;
+	struct file **usi_reversemaps;
+	struct file **usi_map_table;
+	int *usi_bnum_table;	//This is a table of branches to fsnums.
+#endif				/* UNIONFS_IMAP */
+};
+
+/*
+ * structure for making the linked list of entries by readdir on left branch
+ * to compare with entries on right branch
+ */
+struct filldir_node {
+	struct list_head file_list;	// list for directory entries
+	char *name;		// name entry
+	int hash;		// name hash
+	int namelen;		// name len since name is not 0 terminated
+	int bindex;		// we can check for duplicate whiteouts and files in the same branch in order to return -EIO.
+	int whiteout;		// is this a whiteout entry?
+	char iname[DNAME_INLINE_LEN_MIN];	// Inline name, so we don't need to separately kmalloc small ones
+};
+
+/* Directory hash table. */
+struct unionfs_dir_state {
+	unsigned int uds_cookie;	/* The cookie, which is based off of uii_rdversion */
+	unsigned int uds_offset;	/* The entry we have returned. */
+	int uds_bindex;
+	loff_t uds_dirpos;	/* The offset within the lower level directory. */
+	int uds_size;		/* How big is the hash table? */
+	int uds_hashentries;	/* How many entries have been inserted? */
+	unsigned long uds_access;
+	/* This cache list is used when the inode keeps us around. */
+	struct list_head uds_cache;
+	struct list_head uds_list[0];
+};
+
+/* privileged io workqueue */
+#include "sioq.h"
+
+/* include miscellaneous macros */
+#include "unionfs_macros.h"
+
+/* include debug macros */
+#include "unionfs_debug.h"
+
+/* include persistent imap code */
+#include "unionfs_imap.h"
+
+/* Cache creation/deletion routines. */
+void destroy_filldir_cache(void);
+int init_filldir_cache(void);
+int init_inode_cache(void);
+void destroy_inode_cache(void);
+int init_dentry_cache(void);
+void destroy_dentry_cache(void);
+
+/* Initialize and free readdir-specific  state. */
+int init_rdstate(struct file *file);
+struct unionfs_dir_state *alloc_rdstate(struct inode *inode, int bindex);
+struct unionfs_dir_state *find_rdstate(struct inode *inode, loff_t fpos);
+void free_rdstate(struct unionfs_dir_state *state);
+int add_filldir_node(struct unionfs_dir_state *rdstate, const char *name,
+		     int namelen, int bindex, int whiteout);
+struct filldir_node *find_filldir_node(struct unionfs_dir_state *rdstate,
+				       const char *name, int namelen);
+
+struct dentry **alloc_new_dentries(int objs);
+struct unionfs_usi_data *alloc_new_data(int objs);
+
+#ifdef FIST_MALLOC_DEBUG
+
+extern void *unionfs_kzalloc(size_t size, gfp_t flags, int line,
+			     const char *file);
+extern void *unionfs_kmalloc(size_t size, gfp_t flags, int line,
+			     const char *file);
+extern void unionfs_kfree(void *ptr, int line, const char *file);
+
+extern struct dentry *unionfs_dget_parent(struct dentry *child, int line,
+					  const char *file);
+extern struct dentry *unionfs_dget(struct dentry *ptr, int line,
+				   const char *file);
+extern void unionfs_dput(struct dentry *ptr, int line, const char *file);
+extern struct inode *unionfs_igrab(struct inode *inode, int line, char *file);
+extern void unionfs_iput(struct inode *inode, int line, char *file);
+extern struct inode *unionfs_iget(struct super_block *sb, unsigned long ino,
+				  int line, char *file);
+extern struct dentry *unionfs_lookup_one_len(const char *name,
+					     struct dentry *parent, int len,
+					     int line, const char *file);
+void record_path_lookup(struct nameidata *nd, int line, const char *file);
+void record_path_release(struct nameidata *nd, int line, const char *file);
+struct file *unionfs_dentry_open(struct dentry *ptr, struct vfsmount *mnt,
+				 int flags, int line, const char *file);
+void record_set(struct dentry *upper, int index, struct dentry *ptr,
+		struct dentry *old, int line, const char *file);
+
+#define KZALLOC(size,flags) unionfs_kzalloc((size),(flags),__LINE__,__FILE__)
+#define KMALLOC(size,flags) unionfs_kmalloc((size),(flags),__LINE__,__FILE__)
+#define KFREE(ptr) unionfs_kfree((ptr),__LINE__,__FILE__)
+#define DGET(d) unionfs_dget((d),__LINE__,__FILE__)
+#define DPUT(d) unionfs_dput((d),__LINE__,__FILE__)
+# define IPUT(a)		unionfs_iput((a),__LINE__,__FILE__)
+# define IGET(a,b)		unionfs_iget((a),(b),__LINE__,__FILE__)
+# define IGRAB(a)		unionfs_igrab((a),__LINE__,__FILE__)
+#define LOOKUP_ONE_LEN(name,parent,len) unionfs_lookup_one_len((name),(parent),(len),__LINE__,__FILE__)
+# define RECORD_PATH_LOOKUP(nd)	record_path_lookup((nd),__LINE__,__FILE__)
+# define RECORD_PATH_RELEASE(nd) record_path_release((nd),__LINE__,__FILE__)
+/* This has the effect of reducing the reference count sooner or later,
+ * if the file is closed.  If it isn't then the mount will be busy and
+ * you can't unmount.
+ */
+# define DENTRY_OPEN(d,m,f) unionfs_dentry_open((d),(m),(f),__LINE__,__FILE__)
+# define GET_PARENT(dentry) unionfs_dget_parent((dentry),__LINE__,__FILE__)
+#else				/* not FIST_MALLOC_DEBUG */
+# define KZALLOC(a,b)		kzalloc((a),(b))
+# define KMALLOC(a,b)		kmalloc((a),(b))
+# define KFREE(a)		kfree((a))
+# define DPUT(a)		dput((a))
+# define DGET(a)		dget((a))
+# define IPUT(a)		iput((a))
+# define IGET(a,b)		iget((a),(b))
+# define IGRAB(a)		igrab((a))
+# define LOOKUP_ONE_LEN(a,b,c)	lookup_one_len((a),(b),(c))
+# define RECORD_PATH_LOOKUP(a)
+# define RECORD_PATH_RELEASE(a)
+# define DENTRY_OPEN(d,m,f)	dentry_open((d),(m),(f))
+# define GET_PARENT(d)		dget_parent(d)
+#endif				/* not FIST_MALLOC_DEBUG */
+
+/* We can only use 32-bits of offset for rdstate --- blech! */
+#define DIREOF (0xfffff)
+#define RDOFFBITS 20		/* This is the number of bits in DIREOF. */
+#define MAXRDCOOKIE (0xfff)
+/* Turn an rdstate into an offset. */
+static inline off_t rdstate2offset(struct unionfs_dir_state *buf)
+{
+	off_t tmp;
+	tmp =
+	    ((buf->uds_cookie & MAXRDCOOKIE) << RDOFFBITS) | (buf->
+							      uds_offset &
+							      DIREOF);
+	return tmp;
+}
+
+#define unionfs_read_lock(sb) down_read(&stopd(sb)->usi_rwsem)
+#define unionfs_read_unlock(sb) up_read(&stopd(sb)->usi_rwsem)
+#define unionfs_write_lock(sb) down_write(&stopd(sb)->usi_rwsem)
+#define unionfs_write_unlock(sb) up_write(&stopd(sb)->usi_rwsem)
+
+/* The double lock function needs to go after the debugmacros, so that
+ * dtopd is defined.  */
+static inline void double_lock_dentry(struct dentry *d1, struct dentry *d2)
+{
+	if (d2 < d1) {
+		struct dentry *tmp = d1;
+		d1 = d2;
+		d2 = tmp;
+	}
+	lock_dentry(d1);
+	lock_dentry(d2);
+}
+
+extern int new_dentry_private_data(struct dentry *dentry);
+void free_dentry_private_data(struct unionfs_dentry_info *udi);
+void update_bstart(struct dentry *dentry);
+#define sbt(sb) ((sb)->s_type->name)
+
+/*
+ * EXTERNALS:
+ */
+/* replicates the directory structure upto given dentry in given branch */
+extern struct dentry *create_parents(struct inode *dir, struct dentry *dentry,
+				     int bindex);
+struct dentry *create_parents_named(struct inode *dir, struct dentry *dentry,
+				    const char *name, int bindex);
+
+/* check if two branches overlap */
+extern int is_branch_overlap(struct dentry *dent1, struct dentry *dent2);
+
+/* partial lookup */
+extern int unionfs_partial_lookup(struct dentry *dentry);
+
+/* Pass an unionfs dentry and an index and it will try to create a whiteout in branch 'index'.
+   On error, it will proceed to a branch to the left */
+extern int create_whiteout(struct dentry *dentry, int start);
+/* copies a file from dbstart to newbindex branch */
+extern int copyup_file(struct inode *dir, struct file *file, int bstart,
+		       int newbindex, loff_t size);
+extern int copyup_named_file(struct inode *dir, struct file *file,
+			     char *name, int bstart, int new_bindex,
+			     loff_t len);
+
+/* copies a dentry from dbstart to newbindex branch */
+extern int copyup_dentry(struct inode *dir, struct dentry *dentry, int bstart,
+			 int new_bindex, struct file **copyup_file, loff_t len);
+extern int copyup_named_dentry(struct inode *dir, struct dentry *dentry,
+			       int bstart, int new_bindex, const char *name,
+			       int namelen, struct file **copyup_file,
+			       loff_t len);
+
+extern int remove_whiteouts(struct dentry *dentry, struct dentry *hidden_dentry,
+			    int bindex);
+
+/* Is this directory empty: 0 if it is empty, -ENOTEMPTY if not. */
+extern int check_empty(struct dentry *dentry,
+		       struct unionfs_dir_state **namelist);
+/* Delete whiteouts from this directory in branch bindex. */
+extern int delete_whiteouts(struct dentry *dentry, int bindex,
+			    struct unionfs_dir_state *namelist);
+
+/* Re-lookup a hidden dentry. */
+extern int unionfs_refresh_hidden_dentry(struct dentry *dentry, int bindex);
+
+extern void unionfs_reinterpose(struct dentry *this_dentry);
+extern struct super_block *unionfs_duplicate_super(struct super_block *sb);
+
+/* Locking functions. */
+extern int unionfs_setlk(struct file *file, int cmd, struct file_lock *fl);
+extern int unionfs_getlk(struct file *file, struct file_lock *fl);
+
+/* Common file operations. */
+extern int unionfs_file_revalidate(struct file *file, int willwrite);
+extern int unionfs_open(struct inode *inode, struct file *file);
+extern int unionfs_file_release(struct inode *inode, struct file *file);
+extern int unionfs_flush(struct file *file, fl_owner_t id);
+extern long unionfs_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg);
+
+/* Inode operations */
+extern int unionfs_rename(struct inode *old_dir, struct dentry *old_dentry,
+			  struct inode *new_dir, struct dentry *new_dentry);
+int unionfs_unlink(struct inode *dir, struct dentry *dentry);
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry);
+
+int unionfs_d_revalidate(struct dentry *dentry, struct nameidata *nd);
+
+/* The values for unionfs_interpose's flag. */
+#define INTERPOSE_DEFAULT	0
+#define INTERPOSE_LOOKUP	1
+#define INTERPOSE_REVAL		2
+#define INTERPOSE_REVAL_NEG	3
+#define INTERPOSE_PARTIAL	4
+
+extern int unionfs_interpose(struct dentry *this_dentry, struct super_block *sb,
+			     int flag);
+
+/* Branch management ioctls. */
+int unionfs_ioctl_branchcount(struct file *file, unsigned int cmd,
+			      unsigned long arg);
+int unionfs_ioctl_incgen(struct file *file, unsigned int cmd,
+			 unsigned long arg);
+int unionfs_ioctl_addbranch(struct inode *inode, unsigned int cmd,
+			    unsigned long arg);
+int unionfs_ioctl_delbranch(struct super_block *sb, unsigned long arg);
+int unionfs_ioctl_rdwrbranch(struct inode *inode, unsigned int cmd,
+			     unsigned long arg);
+int unionfs_ioctl_queryfile(struct file *file, unsigned int cmd,
+			    unsigned long arg);
+
+/* Verify that a branch is valid. */
+int check_branch(struct nameidata *nd);
+
+/* Extended attribute functions. */
+extern void *xattr_alloc(size_t size, size_t limit);
+extern void xattr_free(void *ptr, size_t size);
+extern ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size);
+
+extern ssize_t unionfs_getxattr(struct dentry *dentry, const char *name,
+				void *value, size_t size);
+extern int unionfs_removexattr(struct dentry *dentry, const char *name);
+extern ssize_t unionfs_listxattr(struct dentry *dentry, char *list,
+				 size_t size);
+
+int unionfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		     size_t size, int flags);
+
+/* The root directory is unhashed, but isn't deleted. */
+static inline int d_deleted(struct dentry *d)
+{
+	return d_unhashed(d) && (d != d->d_sb->s_root);
+}
+
+/* returns the sum of the n_link values of all the underlying inodes of the passed inode */
+static inline int get_nlinks(struct inode *inode)
+{
+	int sum_nlinks = 0;
+	int dirs = 0;
+	int bindex;
+	struct inode *hidden_inode;
+
+	if (!S_ISDIR(inode->i_mode))
+		return itohi(inode)->i_nlink;
+
+	for (bindex = ibstart(inode); bindex <= ibend(inode); bindex++) {
+		hidden_inode = itohi_index(inode, bindex);
+		if (!hidden_inode || !S_ISDIR(hidden_inode->i_mode))
+			continue;
+		BUG_ON(hidden_inode->i_nlink < 0);
+
+		/* A deleted directory. */
+		if (hidden_inode->i_nlink == 0)
+			continue;
+		dirs++;
+		/* A broken directory (e.g., squashfs). */
+		if (hidden_inode->i_nlink == 1)
+			sum_nlinks += 2;
+		else
+			sum_nlinks += (hidden_inode->i_nlink - 2);
+	}
+
+	if (!dirs)
+		return 0;
+	return sum_nlinks + 2;
+}
+
+static inline void fist_copy_attr_atime(struct inode *dest,
+					const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+}
+static inline void fist_copy_attr_times(struct inode *dest,
+					const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+}
+static inline void fist_copy_attr_timesizes(struct inode *dest,
+					    const struct inode *src)
+{
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+	dest->i_size = src->i_size;
+	dest->i_blocks = src->i_blocks;
+}
+static inline void fist_copy_attr_all(struct inode *dest,
+				      const struct inode *src)
+{
+	print_entry_location();
+
+	dest->i_mode = src->i_mode;
+	/* we do not need to copy if the file is a deleted file */
+	if (dest->i_nlink > 0)
+		dest->i_nlink = get_nlinks(dest);
+	dest->i_uid = src->i_uid;
+	dest->i_gid = src->i_gid;
+	dest->i_rdev = src->i_rdev;
+	dest->i_atime = src->i_atime;
+	dest->i_mtime = src->i_mtime;
+	dest->i_ctime = src->i_ctime;
+	dest->i_blkbits = src->i_blkbits;
+	dest->i_size = src->i_size;
+	dest->i_blocks = src->i_blocks;
+	dest->i_flags = src->i_flags;
+
+	print_exit_location();
+}
+
+struct dentry *unionfs_lookup_backend(struct dentry *dentry, int lookupmode);
+int is_stale_inode(struct inode *inode);
+void make_stale_inode(struct inode *inode);
+
+#define IS_SET(sb, check_flag) (check_flag & MOUNT_FLAG(sb))
+
+/* unionfs_permission, check if we should bypass error to facilitate copyup */
+#define IS_COPYUP_ERR(err) (err == -EROFS)
+
+/* unionfs_open, check if we need to copyup the file */
+#define OPEN_WRITE_FLAGS (O_WRONLY | O_RDWR | O_APPEND)
+#define IS_WRITE_FLAG(flag) (flag & (OPEN_WRITE_FLAGS))
+
+static inline int branchperms(struct super_block *sb, int index)
+{
+	BUG_ON(index < 0);
+
+	return stopd(sb)->usi_data[index].branchperms;
+}
+static inline int set_branchperms(struct super_block *sb, int index, int perms)
+{
+	BUG_ON(index < 0);
+
+	stopd(sb)->usi_data[index].branchperms = perms;
+
+	return perms;
+}
+
+/* Is this file on a read-only branch? */
+static inline int __is_robranch_super(struct super_block *sb, int index,
+				      char *file, const char *function,
+				      int line)
+{
+	int err = 0;
+
+	print_util_entry_location();
+
+	if (!(branchperms(sb, index) & MAY_WRITE))
+		err = -EROFS;
+
+	print_util_exit_status(err);
+	return err;
+}
+
+/* Is this file on a read-only branch? */
+static inline int __is_robranch_index(struct dentry *dentry, int index,
+				      char *file, const char *function,
+				      int line)
+{
+	int err = 0;
+	int perms;
+
+	print_util_entry_location();
+
+	BUG_ON(index < 0);
+
+	perms = stopd(dentry->d_sb)->usi_data[index].branchperms;
+
+	if ((!(perms & MAY_WRITE))
+	    || (IS_RDONLY(dtohd_index(dentry, index)->d_inode)))
+		err = -EROFS;
+
+	print_util_exit_status(err);
+
+	return err;
+}
+static inline int __is_robranch(struct dentry *dentry, char *file,
+				const char *function, int line)
+{
+	int index;
+	int err;
+
+	print_util_entry_location();
+
+	index = dtopd(dentry)->udi_bstart;
+	BUG_ON(index < 0);
+
+	err = __is_robranch_index(dentry, index, file, function, line);
+
+	print_util_exit_status(err);
+
+	return err;
+}
+
+#define is_robranch(d) __is_robranch(d, __FILE__, __FUNCTION__, __LINE__)
+#define is_robranch_super(s, n) __is_robranch_super(s, n, __FILE__, __FUNCTION__, __LINE__)
+
+/* What do we use for whiteouts. */
+#define WHPFX ".wh."
+#define WHLEN 4
+/* If a directory contains this file, then it is opaque.  We start with the
+ * .wh. flag so that it is blocked by loomkup.
+ */
+#define UNIONFS_DIR_OPAQUE_NAME "__dir_opaque"
+#define UNIONFS_DIR_OPAQUE WHPFX UNIONFS_DIR_OPAQUE_NAME
+
+/* construct whiteout filename */
+static inline char *alloc_whname(const char *name, int len)
+{
+	char *buf;
+
+	buf = KMALLOC(len + WHLEN + 1, GFP_KERNEL);
+	if (!buf)
+		return ERR_PTR(-ENOMEM);
+
+	strcpy(buf, WHPFX);
+	strlcat(buf, name, len + WHLEN + 1);
+
+	return buf;
+}
+
+/* Definitions for various ways to handle errors.
+   Each flag's value is its bit position */
+
+/* 1 = DELETE_ALL, 0 = check for DELETE_WHITEOUT */
+#ifdef UNIONFS_DELETE_ALL
+#define DELETE_ALL		4
+#else
+#define DELETE_ALL 		0
+#endif
+
+#define VALID_MOUNT_FLAGS (DELETE_ALL)
+
+/*
+ * MACROS:
+ */
+
+#ifndef SEEK_SET
+#define SEEK_SET 0
+#endif				/* not SEEK_SET */
+
+#ifndef SEEK_CUR
+#define SEEK_CUR 1
+#endif				/* not SEEK_CUR */
+
+#ifndef SEEK_END
+#define SEEK_END 2
+#endif				/* not SEEK_END */
+
+#ifndef DEFAULT_POLLMASK
+#define DEFAULT_POLLMASK (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM)
+#endif
+
+/*
+ * EXTERNALS:
+ */
+
+/* JS: These two functions are here because it is kind of daft to copy and paste the
+ * contents of the two functions to 32+ places in unionfs
+ */
+static inline struct dentry *lock_parent(struct dentry *dentry)
+{
+	struct dentry *dir = DGET(dentry->d_parent);
+
+	mutex_lock(&dir->d_inode->i_mutex);
+	return dir;
+}
+
+static inline void unlock_dir(struct dentry *dir)
+{
+	mutex_unlock(&dir->d_inode->i_mutex);
+	DPUT(dir);
+}
+
+extern int make_dir_opaque(struct dentry *dir, int bindex);
+
+#endif				/* __KERNEL__ */
+
+/*
+ * DEFINITIONS FOR USER AND KERNEL CODE:
+ * (Note: ioctl numbers 1--9 are reserved for fistgen, the rest
+ *  are auto-generated automatically based on the user's .fist file.)
+ */
+# define FIST_IOCTL_GET_DEBUG_VALUE	_IOR(0x15, 1, int)
+# define FIST_IOCTL_SET_DEBUG_VALUE	_IOW(0x15, 2, int)
+# define UNIONFS_IOCTL_BRANCH_COUNT	_IOR(0x15, 10, int)
+# define UNIONFS_IOCTL_INCGEN		_IOR(0x15, 11, int)
+# define UNIONFS_IOCTL_ADDBRANCH	_IOW(0x15, 12, int)
+# define UNIONFS_IOCTL_DELBRANCH	_IOW(0x15, 13, int)
+# define UNIONFS_IOCTL_RDWRBRANCH	_IOW(0x15, 14, int)
+# define UNIONFS_IOCTL_QUERYFILE	_IOR(0x15, 15, int)
+
+/* We don't support normal remount, but unionctl uses it. */
+# define UNIONFS_REMOUNT_MAGIC		0x4a5a4380
+
+/* should be at least LAST_USED_UNIONFS_PERMISSION<<1 */
+#define MAY_NFSRO			16
+
+struct unionfs_addbranch_args {
+	unsigned int ab_branch;
+	char *ab_path;
+	unsigned int ab_perms;
+};
+
+struct unionfs_rdwrbranch_args {
+	unsigned int rwb_branch;
+	unsigned int rwb_perms;
+};
+
+#endif				/* not __UNIONFS_H_ */
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_imap.h linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_imap.h
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_imap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_imap.h	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionfs_imap.h,v 1.1 2006/05/30 21:38:45 jsipek Exp $
+ */
+
+#ifndef __UNIONFS_H_
+#error This file should only be included from unionfs.h!
+#endif
+
+#ifdef UNIONFS_IMAP
+
+/*UUID typedef needed later*/
+typedef uint8_t uuid_t[16];
+
+/*
+* Defines,structs,and functions for persistent used by kernel and user
+*/
+#define MAX_MAPS 256
+#define UUID_LEN 16
+#define FORWARDMAP_MAGIC 0x4b1cb38f
+#define REVERSEMAP_MAGIC 0Xfcafad71
+#define FORWARDMAP_VERSION 0x02
+#define REVERSEMAP_VERSION 0x01
+#define FIRST_VALID_INODE 3
+struct fmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t usedbranches;
+	uint8_t uuid[UUID_LEN];
+};
+
+struct rmaphdr {
+	uint32_t magic;
+	uint32_t version;
+	uint8_t fwduuid[UUID_LEN];
+	uint8_t revuuid[UUID_LEN];
+	fsid_t fsid;
+};
+struct bmapent {
+	fsid_t fsid;
+	uint8_t uuid[UUID_LEN];
+};
+struct fmapent {
+	uint8_t fsnum;
+	uint64_t inode;
+};
+
+/* Persistant Inode functions */
+extern int read_uin(struct super_block *sb, uint8_t branchnum,
+		    ino_t inode_number, int flag, ino_t * uino);
+extern int write_uin(struct super_block *sb, ino_t ino, int bindex,
+		     ino_t hidden_ino);
+extern int get_lin(struct super_block *sb, ino_t inode_number,
+		   struct fmapent *entry);
+extern int parse_imap_option(struct super_block *sb,
+			     struct unionfs_dentry_info *hidden_root_info,
+			     char *options);
+extern void cleanup_imap_data(struct super_block *sb);
+
+#endif				/*#ifdef UNIONFS_IMAP */
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_macros.h linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_macros.h
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/unionfs_macros.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/unionfs_macros.h	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,206 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unionfs_macros.h,v 1.13 2006/06/01 03:11:03 jsipek Exp $
+ */
+
+#ifndef __UNIONFS_H_
+#error This file should only be included from unionfs.h!
+#endif
+
+/* Inode to private data */
+static inline struct unionfs_inode_info *itopd(const struct inode *inode)
+{
+	return
+	    &(container_of(inode, struct unionfs_inode_container, vfs_inode)->
+	      info);
+}
+
+#define itohi_ptr(ino) (itopd(ino)->uii_inode)
+#define ibstart(ino) (itopd(ino)->b_start)
+#define ibend(ino) (itopd(ino)->b_end)
+
+/* Superblock to private data */
+#define stopd(super) ((struct unionfs_sb_info *)(super)->s_fs_info)
+#define stopd_lhs(super) ((super)->s_fs_info)
+#define sbstart(sb) 0
+#define sbend(sb) stopd(sb)->b_end
+#define sbmax(sb) (stopd(sb)->b_end + 1)
+
+/* File to private Data */
+#define ftopd(file) ((struct unionfs_file_info *)((file)->private_data))
+#define ftopd_lhs(file) ((file)->private_data)
+#define ftohf_ptr(file)  (ftopd(file)->ufi_file)
+#define fbstart(file) (ftopd(file)->b_start)
+#define fbend(file) (ftopd(file)->b_end)
+
+/* File to hidden file. */
+static inline struct file *ftohf(struct file *f)
+{
+	return ftopd(f)->ufi_file[fbstart(f)];
+}
+
+static inline struct file *ftohf_index(const struct file *f, int index)
+{
+	return ftopd(f)->ufi_file[index];
+}
+
+static inline void set_ftohf_index(struct file *f, int index, struct file *val)
+{
+	ftopd(f)->ufi_file[index] = val;
+}
+
+static inline void set_ftohf(struct file *f, struct file *val)
+{
+	ftopd(f)->ufi_file[fbstart(f)] = val;
+}
+
+/* Inode to hidden inode. */
+static inline struct inode *itohi(const struct inode *i)
+{
+	return itopd(i)->uii_inode[ibstart(i)];
+}
+
+static inline struct inode *itohi_index(const struct inode *i, int index)
+{
+	return itopd(i)->uii_inode[index];
+}
+
+static inline void set_itohi_index(struct inode *i, int index,
+				   struct inode *val)
+{
+	itopd(i)->uii_inode[index] = val;
+}
+
+static inline void set_itohi(struct inode *i, struct inode *val)
+{
+	itopd(i)->uii_inode[ibstart(i)] = val;
+}
+
+/* Superblock to hidden superblock. */
+static inline struct super_block *stohs(const struct super_block *o)
+{
+	return stopd(o)->usi_data[sbstart(o)].sb;
+}
+
+static inline struct super_block *stohs_index(const struct super_block *o, int index)
+{
+	return stopd(o)->usi_data[index].sb;
+}
+
+static inline void set_stohs_index(struct super_block *o, int index,
+				   struct super_block *val)
+{
+	stopd(o)->usi_data[index].sb = val;
+}
+
+static inline void set_stohs(struct super_block *o, struct super_block *val)
+{
+	stopd(o)->usi_data[sbstart(o)].sb = val;
+}
+
+/* Super to hidden mount. */
+static inline struct vfsmount *stohiddenmnt_index(struct super_block *o,
+						  int index)
+{
+	return stopd(o)->usi_data[index].hidden_mnt;
+}
+
+static inline void set_stohiddenmnt_index(struct super_block *o, int index,
+					  struct vfsmount *val)
+{
+	stopd(o)->usi_data[index].hidden_mnt = val;
+}
+
+/* Branch count macros. */
+static inline int branch_count(struct super_block *o, int index)
+{
+	return atomic_read(&stopd(o)->usi_data[index].sbcount);
+}
+
+static inline void set_branch_count(struct super_block *o, int index, int val)
+{
+	atomic_set(&stopd(o)->usi_data[index].sbcount, val);
+}
+
+static inline void branchget(struct super_block *o, int index)
+{
+	atomic_inc(&stopd(o)->usi_data[index].sbcount);
+}
+
+static inline void branchput(struct super_block *o, int index)
+{
+	atomic_dec(&stopd(o)->usi_data[index].sbcount);
+}
+
+/* Dentry macros */
+static inline struct unionfs_dentry_info *dtopd(const struct dentry *dent)
+{
+	return (struct unionfs_dentry_info *)dent->d_fsdata;
+}
+
+#define dtopd_lhs(dent) ((dent)->d_fsdata)
+#define dtopd_nocheck(dent) dtopd(dent)
+#define dbstart(dent) (dtopd(dent)->udi_bstart)
+#define set_dbstart(dent, val) do { dtopd(dent)->udi_bstart = val; } while(0)
+#define dbend(dent) (dtopd(dent)->udi_bend)
+#define set_dbend(dent, val) do { dtopd(dent)->udi_bend = val; } while(0)
+#define dbopaque(dent) (dtopd(dent)->udi_bopaque)
+#define set_dbopaque(dent, val) do { dtopd(dent)->udi_bopaque = val; } while (0)
+
+static inline void set_dtohd_index(struct dentry *dent, int index,
+				   struct dentry *val)
+{
+	dtopd(dent)->udi_dentry[index] = val;
+}
+
+static inline struct dentry *dtohd_index(const struct dentry *dent, int index)
+{
+	return dtopd(dent)->udi_dentry[index];
+}
+
+static inline struct dentry *dtohd(const struct dentry *dent)
+{
+	return dtopd(dent)->udi_dentry[dbstart(dent)];
+}
+
+#define set_dtohd_index_nocheck(dent, index, val) set_dtohd_index(dent, index, val)
+#define dtohd_index_nocheck(dent, index) dtohd_index(dent, index)
+
+#define dtohd_ptr(dent) (dtopd_nocheck(dent)->udi_dentry)
+
+/* Macros for locking a dentry. */
+#define lock_dentry(d) down(&dtopd(d)->udi_sem)
+#define unlock_dentry(d) up(&dtopd(d)->udi_sem)
+#define verify_locked(d)
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/unlink.c linux-2.6.20-sabayon-r1/fs/unionfs/unlink.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/unlink.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/unlink.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,378 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef 'Jeff' Sipek
+ * Copyright (c) 2005-2006 Junjiro Okajima
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: unlink.c,v 1.44 2006/08/05 01:28:46 jro Exp $
+ */
+
+#include "unionfs.h"
+
+#ifdef UNIONFS_DELETE_ALL
+static int unionfs_unlink_all(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bstart, bend, bindex;
+	int err = 0;
+	int global_err = 0;
+
+	print_entry_location();
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bend; bindex >= bstart; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+
+		/* avoid destroying the hidden inode if the file is in use */
+		DGET(hidden_dentry);
+		if (!(err = is_robranch_super(dentry->d_sb, bindex)))
+			err = vfs_unlink(hidden_dir_dentry->d_inode,
+					 hidden_dentry);
+		DPUT(hidden_dentry);
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		unlock_dir(hidden_dir_dentry);
+
+		if (err) {
+			/* passup the last error we got */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+			global_err = err;
+		}
+	}
+
+	/* check if encountered error in the above loop */
+	if (global_err) {
+		/* If we failed in the leftmost branch, then err will be set
+		 * and we should move one over to create the whiteout.
+		 * Otherwise, we should try in the leftmost branch. */
+		if (err) {
+			if (dbstart(dentry) == 0) {
+				goto out;
+			}
+			err = create_whiteout(dentry, dbstart(dentry) - 1);
+		} else {
+			err = create_whiteout(dentry, dbstart(dentry));
+		}
+	} else if (dbopaque(dentry) != -1) {
+		/* There is a hidden lower-priority file with the same name. */
+		err = create_whiteout(dentry, dbopaque(dentry));
+	}
+      out:
+	/* propagate number of hard-links */
+	if (dentry->d_inode->i_nlink != 0) {
+		dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+		if (!err && global_err)
+			dentry->d_inode->i_nlink--;
+	}
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (global_err || dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	print_exit_status(err);
+	return err;
+}
+#endif
+static int unionfs_unlink_whiteout(struct inode *dir, struct dentry *dentry)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bindex;
+	int err = 0;
+
+	print_entry_location();
+
+	if ((err = unionfs_partial_lookup(dentry)))
+		goto out;
+
+	bindex = dbstart(dentry);
+
+	hidden_dentry = dtohd_index(dentry, bindex);
+	if (!hidden_dentry)
+		goto out;
+
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+
+	/* avoid destroying the hidden inode if the file is in use */
+	DGET(hidden_dentry);
+	if (!(err = is_robranch_super(dentry->d_sb, bindex)))
+		err = vfs_unlink(hidden_dir_dentry->d_inode, hidden_dentry);
+	DPUT(hidden_dentry);
+	fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+	unlock_dir(hidden_dir_dentry);
+
+	if (err && !IS_COPYUP_ERR(err))
+		goto out;
+
+	if (err) {
+		if (dbstart(dentry) == 0)
+			goto out;
+
+		err = create_whiteout(dentry, dbstart(dentry) - 1);
+	} else if (dbopaque(dentry) != -1) {
+		/* There is a hidden lower-priority file with the same name. */
+		err = create_whiteout(dentry, dbopaque(dentry));
+	} else {
+		err = create_whiteout(dentry, dbstart(dentry));
+	}
+
+      out:
+	if (!err)
+		dentry->d_inode->i_nlink--;
+
+	/* We don't want to leave negative leftover dentries for revalidate. */
+	if (!err && (dbopaque(dentry) != -1))
+		update_bstart(dentry);
+
+	print_exit_status(err);
+	return err;
+
+}
+
+int unionfs_unlink(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_unlink", dentry);
+
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(dir->i_sb, DELETE_ALL))
+		err = unionfs_unlink_all(dir, dentry);
+	else
+#endif
+		err = unionfs_unlink_whiteout(dir, dentry);
+	/* call d_drop so the system "forgets" about us */
+	if (!err)
+		d_drop(dentry);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+static int unionfs_rmdir_first(struct inode *dir, struct dentry *dentry,
+			       struct unionfs_dir_state *namelist)
+{
+	int err;
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry = NULL;
+
+	print_entry_location();
+	print_dentry("IN unionfs_rmdir_first: ", dentry);
+
+	/* Here we need to remove whiteout entries. */
+	err = delete_whiteouts(dentry, dbstart(dentry), namelist);
+	if (err) {
+		goto out;
+	}
+
+	hidden_dentry = dtohd(dentry);
+
+	hidden_dir_dentry = lock_parent(hidden_dentry);
+
+	/* avoid destroying the hidden inode if the file is in use */
+	DGET(hidden_dentry);
+	if (!(err = is_robranch(dentry))) {
+		err = vfs_rmdir(hidden_dir_dentry->d_inode, hidden_dentry);
+	}
+	DPUT(hidden_dentry);
+
+	fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+
+      out:
+	if (hidden_dir_dentry) {
+		unlock_dir(hidden_dir_dentry);
+	}
+	print_dentry("OUT unionfs_rmdir_first: ", dentry);
+	print_exit_status(err);
+	return err;
+}
+
+#ifdef UNIONFS_DELETE_ALL
+static int unionfs_rmdir_all(struct inode *dir, struct dentry *dentry,
+			     struct unionfs_dir_state *namelist)
+{
+	struct dentry *hidden_dentry;
+	struct dentry *hidden_dir_dentry;
+	int bstart, bend, bindex;
+	int err = 0;
+	int global_err = 0;
+
+	print_entry_location();
+	print_dentry("IN unionfs_rmdir_all: ", dentry);
+
+	bstart = dbstart(dentry);
+	bend = dbend(dentry);
+
+	for (bindex = bend; bindex >= bstart; bindex--) {
+		hidden_dentry = dtohd_index(dentry, bindex);
+		if (!hidden_dentry)
+			continue;
+
+		hidden_dir_dentry = lock_parent(hidden_dentry);
+		if (S_ISDIR(hidden_dentry->d_inode->i_mode)) {
+			err = delete_whiteouts(dentry, bindex, namelist);
+			if (!err
+			    && !(err =
+				 is_robranch_super(dentry->d_sb, bindex))) {
+				err =
+				    vfs_rmdir(hidden_dir_dentry->d_inode,
+					      hidden_dentry);
+			}
+		} else {
+			err = -EISDIR;
+		}
+
+		fist_copy_attr_times(dir, hidden_dir_dentry->d_inode);
+		unlock_dir(hidden_dir_dentry);
+		if (err) {
+			int local_err =
+			    unionfs_refresh_hidden_dentry(dentry, bindex);
+			if (local_err) {
+				err = local_err;
+				goto out;
+			}
+
+			if (!IS_COPYUP_ERR(err) && err != -ENOTEMPTY
+			    && err != -EISDIR)
+				goto out;
+
+			global_err = err;
+		}
+	}
+
+	/* check if encountered error in the above loop */
+	if (global_err) {
+		/* If we failed in the leftmost branch, then err will be set and we should
+		 * move one over to create the whiteout.  Otherwise, we should try in the
+		 * leftmost branch.
+		 */
+		if (err) {
+			if (dbstart(dentry) == 0) {
+				goto out;
+			}
+			err = create_whiteout(dentry, dbstart(dentry) - 1);
+		} else {
+			err = create_whiteout(dentry, dbstart(dentry));
+		}
+	} else {
+		err = create_whiteout(dentry, dbstart(dentry));
+	}
+
+      out:
+	/* propagate number of hard-links */
+	dentry->d_inode->i_nlink = get_nlinks(dentry->d_inode);
+
+	print_dentry("OUT unionfs_rmdir_all: ", dentry);
+	print_exit_status(err);
+	return err;
+}
+#endif
+int unionfs_rmdir(struct inode *dir, struct dentry *dentry)
+{
+	int err = 0;
+	struct unionfs_dir_state *namelist = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+	print_dentry("IN unionfs_rmdir: ", dentry);
+
+	/* check if this unionfs directory is empty or not */
+	err = check_empty(dentry, &namelist);
+	if (err) {
+#if 0
+		/* vfs_rmdir(our caller) unhashed the dentry.  This will recover
+		 * the Unionfs inode number for the directory itself, but the
+		 * children are already lost.  It seems that tmpfs manages its
+		 * way around this by upping the refcount on everything.
+		 *
+		 * Even if we do this, we still lose the inode numbers of the
+		 * children.  The best way to fix this is to fix the VFS (or
+		 * use persistent inode maps). */
+		if (d_unhashed(dentry))
+			d_rehash(dentry);
+#endif
+		goto out;
+	}
+#ifdef UNIONFS_DELETE_ALL
+	if (IS_SET(dir->i_sb, DELETE_ALL)) {
+		/* delete all. */
+		err = unionfs_rmdir_all(dir, dentry, namelist);
+	} else {		/* Delete the first directory. */
+#endif
+		err = unionfs_rmdir_first(dir, dentry, namelist);
+		/* create whiteout */
+		if (!err) {
+			err = create_whiteout(dentry, dbstart(dentry));
+		} else {
+			int new_err;
+
+			if (dbstart(dentry) == 0)
+				goto out;
+
+			/* exit if the error returned was NOT -EROFS */
+			if (!IS_COPYUP_ERR(err))
+				goto out;
+
+			new_err = create_whiteout(dentry, dbstart(dentry) - 1);
+			if (new_err != -EEXIST)
+				err = new_err;
+		}
+
+#ifdef UNIONFS_DELETE_ALL
+	}
+#endif
+      out:
+	/* call d_drop so the system "forgets" about us */
+	if (!err)
+		d_drop(dentry);
+
+	if (namelist)
+		free_rdstate(namelist);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/fs/unionfs/xattr.c linux-2.6.20-sabayon-r1/fs/unionfs/xattr.c
--- linux-2.6.20-sabayon-r1.orig/fs/unionfs/xattr.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/fs/unionfs/xattr.c	2007-02-12 12:52:30.000000000 +0100
@@ -0,0 +1,185 @@
+/*
+ * Copyright (c) 2003-2006 Erez Zadok
+ * Copyright (c) 2003-2006 Charles P. Wright
+ * Copyright (c) 2005-2006 Josef Sipek
+ * Copyright (c) 2005      Arun M. Krishnakumar
+ * Copyright (c) 2005-2006 David P. Quigley
+ * Copyright (c) 2003-2004 Mohammad Nayyer Zubair
+ * Copyright (c) 2003      Puja Gupta
+ * Copyright (c) 2003      Harikesavan Krishnan
+ * Copyright (c) 2003-2006 Stony Brook University
+ * Copyright (c) 2003-2006 The Research Foundation of State University of New York
+ *
+ * For specific licensing information, see the COPYING file distributed with
+ * this package.
+ *
+ * This Copyright notice must be kept intact and distributed with all sources.
+ */
+/*
+ *  $Id: xattr.c,v 1.32 2006/06/01 03:11:03 jsipek Exp $
+ */
+
+#include "unionfs.h"
+
+/* This is lifted from fs/xattr.c */
+void *xattr_alloc(size_t size, size_t limit)
+{
+	void *ptr;
+
+	if (size > limit)
+		return ERR_PTR(-E2BIG);
+
+	if (!size)		/* size request, no buffer is needed */
+		return NULL;
+	else if (size <= PAGE_SIZE)
+		ptr = KMALLOC((unsigned long)size, GFP_KERNEL);
+	else
+		ptr = vmalloc((unsigned long)size);
+	if (!ptr)
+		return ERR_PTR(-ENOMEM);
+	return ptr;
+}
+
+void xattr_free(void *ptr, size_t size)
+{
+	if (!size)		/* size request, no buffer was needed */
+		return;
+	else if (size <= PAGE_SIZE)
+		KFREE(ptr);
+	else
+		vfree(ptr);
+}
+
+/* Function supplied by guy from redhat. In here temporarily till he submits it
+ * to the kernel maling list
+ */
+ssize_t vfs_listxattr(struct dentry *d, char *list, size_t size)
+{
+	ssize_t error;
+
+	error = security_inode_listxattr(d);
+	if (error)
+		return error;
+	error = -EOPNOTSUPP;
+	if (d->d_inode->i_op && d->d_inode->i_op->listxattr) {
+		error = d->d_inode->i_op->listxattr(d, list, size);
+	} else {
+		error = security_inode_listsecurity(d->d_inode, list, size);
+		if (size && error > size)
+			error = -ERANGE;
+	}
+	return error;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ * ssize_t (*getxattr) (struct dentry *, const char *, void *, size_t);
+ */
+ssize_t unionfs_getxattr(struct dentry * dentry, const char *name, void *value,
+			 size_t size)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	print_entry_location();
+
+	dprint(PRINT_DEBUG_XATTR, "getxattr: name=\"%s\", value %lu bytes\n",
+			name, size);
+
+	lock_dentry(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	err = vfs_getxattr(hidden_dentry, (char*)name, value, size);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int
+unionfs_setxattr(struct dentry *dentry, const char *name, const void *value,
+		 size_t size, int flags)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	print_entry_location();
+
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	dprint(PRINT_DEBUG_XATTR, "setxattr: name=\"%s\", value %lu bytes,"
+			"flags=%x\n", name, (unsigned long)size, flags);
+
+	err =
+	    vfs_setxattr(hidden_dentry, (char *)name, (char *)value, size,
+			 flags);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+int unionfs_removexattr(struct dentry *dentry, const char *name)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+
+	print_entry_location();
+
+	lock_dentry(dentry);
+	hidden_dentry = dtohd(dentry);
+
+	dprint(PRINT_DEBUG_XATTR, "removexattr: name=\"%s\"\n", name);
+
+	err = vfs_removexattr(hidden_dentry, (char*)name);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/* BKL held by caller.
+ * dentry->d_inode->i_mutex locked
+ */
+ssize_t unionfs_listxattr(struct dentry * dentry, char *list, size_t size)
+{
+	struct dentry *hidden_dentry = NULL;
+	int err = -EOPNOTSUPP;
+	char *encoded_list = NULL;
+
+	print_entry_location();
+	lock_dentry(dentry);
+
+	hidden_dentry = dtohd(dentry);
+
+	encoded_list = list;
+	err = vfs_listxattr(hidden_dentry, encoded_list, size);
+
+	unlock_dentry(dentry);
+	print_exit_status(err);
+	return err;
+}
+
+/*
+ *
+ * vim:shiftwidth=8
+ * vim:tabstop=8
+ *
+ * For Emacs:
+ * Local variables:
+ * c-basic-offset: 8
+ * c-comment-only-line-offset: 0
+ * c-offsets-alist: ((statement-block-intro . +) (knr-argdecl-intro . 0)
+ *              (substatement-open . 0) (label . 0) (statement-cont . +))
+ * indent-tabs-mode: t
+ * tab-width: 8
+ * End:
+ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/8253pit.h linux-2.6.20-sabayon-r1/include/asm/8253pit.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/8253pit.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/8253pit.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,10 @@
+/*
+ * 8253/8254 Programmable Interval Timer
+ */
+
+#ifndef _8253PIT_H
+#define _8253PIT_H
+
+#define PIT_TICK_RATE 	1193182UL
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/acpi.h linux-2.6.20-sabayon-r1/include/asm/acpi.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/acpi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/acpi.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,148 @@
+/*
+ *  asm-x86_64/acpi.h
+ *
+ *  Copyright (C) 2001 Paul Diefenbaugh <paul.s.diefenbaugh@intel.com>
+ *  Copyright (C) 2001 Patrick Mochel <mochel@osdl.org>
+  *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+ */
+
+#ifndef _ASM_ACPI_H
+#define _ASM_ACPI_H
+
+#ifdef __KERNEL__
+
+#include <acpi/pdc_intel.h>
+
+#define COMPILER_DEPENDENT_INT64   long long
+#define COMPILER_DEPENDENT_UINT64  unsigned long long
+
+/*
+ * Calling conventions:
+ *
+ * ACPI_SYSTEM_XFACE        - Interfaces to host OS (handlers, threads)
+ * ACPI_EXTERNAL_XFACE      - External ACPI interfaces 
+ * ACPI_INTERNAL_XFACE      - Internal ACPI interfaces
+ * ACPI_INTERNAL_VAR_XFACE  - Internal variable-parameter list interfaces
+ */
+#define ACPI_SYSTEM_XFACE
+#define ACPI_EXTERNAL_XFACE
+#define ACPI_INTERNAL_XFACE
+#define ACPI_INTERNAL_VAR_XFACE
+
+/* Asm macros */
+
+#define ACPI_ASM_MACROS
+#define BREAKPOINT3
+#define ACPI_DISABLE_IRQS() local_irq_disable()
+#define ACPI_ENABLE_IRQS()  local_irq_enable()
+#define ACPI_FLUSH_CPU_CACHE()	wbinvd()
+
+int __acpi_acquire_global_lock(unsigned int *lock);
+int __acpi_release_global_lock(unsigned int *lock);
+
+#define ACPI_ACQUIRE_GLOBAL_LOCK(GLptr, Acq) \
+	((Acq) = __acpi_acquire_global_lock((unsigned int *) GLptr))
+
+#define ACPI_RELEASE_GLOBAL_LOCK(GLptr, Acq) \
+	((Acq) = __acpi_release_global_lock((unsigned int *) GLptr))
+
+/*
+ * Math helper asm macros
+ */
+#define ACPI_DIV_64_BY_32(n_hi, n_lo, d32, q32, r32) \
+        asm("divl %2;"        \
+        :"=a"(q32), "=d"(r32) \
+        :"r"(d32),            \
+        "0"(n_lo), "1"(n_hi))
+
+
+#define ACPI_SHIFT_RIGHT_64(n_hi, n_lo) \
+    asm("shrl   $1,%2;"             \
+        "rcrl   $1,%3;"             \
+        :"=r"(n_hi), "=r"(n_lo)     \
+        :"0"(n_hi), "1"(n_lo))
+
+#ifdef CONFIG_ACPI
+extern int acpi_lapic;
+extern int acpi_ioapic;
+extern int acpi_noirq;
+extern int acpi_strict;
+extern int acpi_disabled;
+extern int acpi_pci_disabled;
+extern int acpi_ht;
+static inline void disable_acpi(void) 
+{ 
+	acpi_disabled = 1; 
+	acpi_ht = 0; 
+	acpi_pci_disabled = 1;
+	acpi_noirq = 1;
+}
+
+/* Fixmap pages to reserve for ACPI boot-time tables (see fixmap.h) */
+#define FIX_ACPI_PAGES 4
+
+extern int acpi_gsi_to_irq(u32 gsi, unsigned int *irq);
+static inline void acpi_noirq_set(void) { acpi_noirq = 1; }
+static inline void acpi_disable_pci(void) 
+{
+	acpi_pci_disabled = 1; 
+	acpi_noirq_set();
+}
+extern int acpi_irq_balance_set(char *str);
+
+#else	/* !CONFIG_ACPI */
+
+#define acpi_lapic 0
+#define acpi_ioapic 0
+static inline void acpi_noirq_set(void) { }
+static inline void acpi_disable_pci(void) { }
+
+#endif /* !CONFIG_ACPI */
+
+extern int acpi_numa;
+extern int acpi_scan_nodes(unsigned long start, unsigned long end);
+#define NR_NODE_MEMBLKS (MAX_NUMNODES*2)
+
+#ifdef CONFIG_ACPI_SLEEP
+
+/* routines for saving/restoring kernel state */
+extern int acpi_save_state_mem(void);
+extern void acpi_restore_state_mem(void);
+
+extern unsigned long acpi_wakeup_address;
+
+/* early initialization routine */
+extern void acpi_reserve_bootmem(void);
+
+#endif /*CONFIG_ACPI_SLEEP*/
+
+extern int acpi_disabled;
+extern int acpi_pci_disabled;
+
+extern u8 x86_acpiid_to_apicid[];
+
+#define ARCH_HAS_POWER_INIT 1
+
+extern int acpi_skip_timer_override;
+extern int acpi_use_timer_override;
+
+#endif /*__KERNEL__*/
+
+#endif /*_ASM_ACPI_H*/
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/agp.h linux-2.6.20-sabayon-r1/include/asm/agp.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/agp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/agp.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,32 @@
+#ifndef AGP_H
+#define AGP_H 1
+
+#include <asm/cacheflush.h>
+
+/* 
+ * Functions to keep the agpgart mappings coherent.
+ * The GART gives the CPU a physical alias of memory. The alias is
+ * mapped uncacheable. Make sure there are no conflicting mappings
+ * with different cachability attributes for the same page.
+ */
+
+int map_page_into_agp(struct page *page);
+int unmap_page_from_agp(struct page *page);
+#define flush_agp_mappings() global_flush_tlb()
+
+/* Could use CLFLUSH here if the cpu supports it. But then it would
+   need to be called for each cacheline of the whole page so it may not be 
+   worth it. Would need a page for it. */
+#define flush_agp_cache() asm volatile("wbinvd":::"memory")
+
+/* Convert a physical address to an address suitable for the GART. */
+#define phys_to_gart(x) (x)
+#define gart_to_phys(x) (x)
+
+/* GATT allocation. Returns/accepts GATT kernel virtual address. */
+#define alloc_gatt_pages(order)		\
+	((char *)__get_free_pages(GFP_KERNEL, (order)))
+#define free_gatt_pages(table, order)	\
+	free_pages((unsigned long)(table), (order))
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/alternative-asm.i linux-2.6.20-sabayon-r1/include/asm/alternative-asm.i
--- linux-2.6.20-sabayon-r1.orig/include/asm/alternative-asm.i	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/alternative-asm.i	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,12 @@
+#ifdef CONFIG_SMP
+	.macro LOCK_PREFIX
+1:	lock
+	.section .smp_locks,"a"
+	.align 8
+	.quad 1b
+	.previous
+	.endm
+#else
+	.macro LOCK_PREFIX
+	.endm
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/alternative.h linux-2.6.20-sabayon-r1/include/asm/alternative.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/alternative.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/alternative.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,148 @@
+#ifndef _X86_64_ALTERNATIVE_H
+#define _X86_64_ALTERNATIVE_H
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <asm/cpufeature.h>
+
+struct alt_instr {
+	u8 *instr; 		/* original instruction */
+	u8 *replacement;
+	u8  cpuid;		/* cpuid bit set for replacement */
+	u8  instrlen;		/* length of original instruction */
+	u8  replacementlen; 	/* length of new instruction, <= instrlen */
+	u8  pad[5];
+};
+
+extern void apply_alternatives(struct alt_instr *start, struct alt_instr *end);
+
+struct module;
+
+#ifdef CONFIG_SMP
+extern void alternatives_smp_module_add(struct module *mod, char *name,
+					void *locks, void *locks_end,
+					void *text, void *text_end);
+extern void alternatives_smp_module_del(struct module *mod);
+extern void alternatives_smp_switch(int smp);
+#else
+static inline void alternatives_smp_module_add(struct module *mod, char *name,
+					void *locks, void *locks_end,
+					void *text, void *text_end) {}
+static inline void alternatives_smp_module_del(struct module *mod) {}
+static inline void alternatives_smp_switch(int smp) {}
+#endif
+
+#endif
+
+/*
+ * Alternative instructions for different CPU types or capabilities.
+ *
+ * This allows to use optimized instructions even on generic binary
+ * kernels.
+ *
+ * length of oldinstr must be longer or equal the length of newinstr
+ * It can be padded with nops as needed.
+ *
+ * For non barrier like inlines please define new variants
+ * without volatile and memory clobber.
+ */
+#define alternative(oldinstr, newinstr, feature) 	\
+	asm volatile ("661:\n\t" oldinstr "\n662:\n" 		     \
+		      ".section .altinstructions,\"a\"\n"     	     \
+		      "  .align 8\n"				       \
+		      "  .quad 661b\n"            /* label */          \
+		      "  .quad 663f\n"		  /* new instruction */ \
+		      "  .byte %c0\n"             /* feature bit */    \
+		      "  .byte 662b-661b\n"       /* sourcelen */      \
+		      "  .byte 664f-663f\n"       /* replacementlen */ \
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" :: "i" (feature) : "memory")
+
+/*
+ * Alternative inline assembly with input.
+ *
+ * Pecularities:
+ * No memory clobber here.
+ * Argument numbers start with 1.
+ * Best is to use constraints that are fixed size (like (%1) ... "r")
+ * If you use variable sized constraints like "m" or "g" in the
+ * replacement make sure to pad to the worst case length.
+ */
+#define alternative_input(oldinstr, newinstr, feature, input...)	\
+	asm volatile ("661:\n\t" oldinstr "\n662:\n"			\
+		      ".section .altinstructions,\"a\"\n"		\
+		      "  .align 8\n"					\
+		      "  .quad 661b\n"            /* label */		\
+		      "  .quad 663f\n"		  /* new instruction */	\
+		      "  .byte %c0\n"             /* feature bit */	\
+		      "  .byte 662b-661b\n"       /* sourcelen */	\
+		      "  .byte 664f-663f\n"       /* replacementlen */	\
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" :: "i" (feature), ##input)
+
+/* Like alternative_input, but with a single output argument */
+#define alternative_io(oldinstr, newinstr, feature, output, input...) \
+	asm volatile ("661:\n\t" oldinstr "\n662:\n"			\
+		      ".section .altinstructions,\"a\"\n"		\
+		      "  .align 8\n"					\
+		      "  .quad 661b\n"            /* label */		\
+		      "  .quad 663f\n"		  /* new instruction */	\
+		      "  .byte %c[feat]\n"        /* feature bit */	\
+		      "  .byte 662b-661b\n"       /* sourcelen */	\
+		      "  .byte 664f-663f\n"       /* replacementlen */	\
+		      ".previous\n"					\
+		      ".section .altinstr_replacement,\"ax\"\n"		\
+		      "663:\n\t" newinstr "\n664:\n"   /* replacement */ \
+		      ".previous" : output : [feat] "i" (feature), ##input)
+
+/*
+ * Alternative inline assembly for SMP.
+ *
+ * The LOCK_PREFIX macro defined here replaces the LOCK and
+ * LOCK_PREFIX macros used everywhere in the source tree.
+ *
+ * SMP alternatives use the same data structures as the other
+ * alternatives and the X86_FEATURE_UP flag to indicate the case of a
+ * UP system running a SMP kernel.  The existing apply_alternatives()
+ * works fine for patching a SMP kernel for UP.
+ *
+ * The SMP alternative tables can be kept after boot and contain both
+ * UP and SMP versions of the instructions to allow switching back to
+ * SMP at runtime, when hotplugging in a new CPU, which is especially
+ * useful in virtualized environments.
+ *
+ * The very common lock prefix is handled as special case in a
+ * separate table which is a pure address list without replacement ptr
+ * and size information.  That keeps the table sizes small.
+ */
+
+#ifdef CONFIG_SMP
+#define LOCK_PREFIX \
+		".section .smp_locks,\"a\"\n"	\
+		"  .align 8\n"			\
+		"  .quad 661f\n" /* address */	\
+		".previous\n"			\
+	       	"661:\n\tlock; "
+
+#else /* ! CONFIG_SMP */
+#define LOCK_PREFIX ""
+#endif
+
+struct paravirt_patch;
+#ifdef CONFIG_PARAVIRT
+void apply_paravirt(struct paravirt_patch *start, struct paravirt_patch *end);
+#else
+static inline void
+apply_paravirt(struct paravirt_patch *start, struct paravirt_patch *end)
+{}
+#define __start_parainstructions NULL
+#define __stop_parainstructions NULL
+#endif
+
+#endif /* _X86_64_ALTERNATIVE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/a.out.h linux-2.6.20-sabayon-r1/include/asm/a.out.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/a.out.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/a.out.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef __X8664_A_OUT_H__
+#define __X8664_A_OUT_H__
+
+/* 32bit a.out */
+
+struct exec
+{
+  unsigned int a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* length of text, in bytes */
+  unsigned a_data;		/* length of data, in bytes */
+  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* length of relocation info for text, in bytes */
+  unsigned a_drsize;		/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#ifdef __KERNEL__
+#include <linux/thread_info.h>
+#define STACK_TOP TASK_SIZE
+#endif
+
+#endif /* __A_OUT_GNU_H__ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/apicdef.h linux-2.6.20-sabayon-r1/include/asm/apicdef.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/apicdef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/apicdef.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,392 @@
+#ifndef __ASM_APICDEF_H
+#define __ASM_APICDEF_H
+
+/*
+ * Constants for various Intel APICs. (local APIC, IOAPIC, etc.)
+ *
+ * Alan Cox <Alan.Cox@linux.org>, 1995.
+ * Ingo Molnar <mingo@redhat.com>, 1999, 2000
+ */
+
+#define		APIC_DEFAULT_PHYS_BASE	0xfee00000
+ 
+#define		APIC_ID		0x20
+#define			APIC_ID_MASK		(0xFFu<<24)
+#define			GET_APIC_ID(x)		(((x)>>24)&0xFFu)
+#define			SET_APIC_ID(x)		(((x)<<24))
+#define		APIC_LVR	0x30
+#define			APIC_LVR_MASK		0xFF00FF
+#define			GET_APIC_VERSION(x)	((x)&0xFFu)
+#define			GET_APIC_MAXLVT(x)	(((x)>>16)&0xFFu)
+#define			APIC_INTEGRATED(x)	((x)&0xF0u)
+#define		APIC_TASKPRI	0x80
+#define			APIC_TPRI_MASK		0xFFu
+#define		APIC_ARBPRI	0x90
+#define			APIC_ARBPRI_MASK	0xFFu
+#define		APIC_PROCPRI	0xA0
+#define		APIC_EOI	0xB0
+#define			APIC_EIO_ACK		0x0		/* Write this to the EOI register */
+#define		APIC_RRR	0xC0
+#define		APIC_LDR	0xD0
+#define			APIC_LDR_MASK		(0xFFu<<24)
+#define			GET_APIC_LOGICAL_ID(x)	(((x)>>24)&0xFFu)
+#define			SET_APIC_LOGICAL_ID(x)	(((x)<<24))
+#define			APIC_ALL_CPUS		0xFFu
+#define		APIC_DFR	0xE0
+#define			APIC_DFR_CLUSTER		0x0FFFFFFFul
+#define			APIC_DFR_FLAT			0xFFFFFFFFul
+#define		APIC_SPIV	0xF0
+#define			APIC_SPIV_FOCUS_DISABLED	(1<<9)
+#define			APIC_SPIV_APIC_ENABLED		(1<<8)
+#define		APIC_ISR	0x100
+#define		APIC_ISR_NR	0x8	/* Number of 32 bit ISR registers. */
+#define		APIC_TMR	0x180
+#define 	APIC_IRR	0x200
+#define 	APIC_ESR	0x280
+#define			APIC_ESR_SEND_CS	0x00001
+#define			APIC_ESR_RECV_CS	0x00002
+#define			APIC_ESR_SEND_ACC	0x00004
+#define			APIC_ESR_RECV_ACC	0x00008
+#define			APIC_ESR_SENDILL	0x00020
+#define			APIC_ESR_RECVILL	0x00040
+#define			APIC_ESR_ILLREGA	0x00080
+#define		APIC_ICR	0x300
+#define			APIC_DEST_SELF		0x40000
+#define			APIC_DEST_ALLINC	0x80000
+#define			APIC_DEST_ALLBUT	0xC0000
+#define			APIC_ICR_RR_MASK	0x30000
+#define			APIC_ICR_RR_INVALID	0x00000
+#define			APIC_ICR_RR_INPROG	0x10000
+#define			APIC_ICR_RR_VALID	0x20000
+#define			APIC_INT_LEVELTRIG	0x08000
+#define			APIC_INT_ASSERT		0x04000
+#define			APIC_ICR_BUSY		0x01000
+#define			APIC_DEST_LOGICAL	0x00800
+#define			APIC_DEST_PHYSICAL	0x00000
+#define			APIC_DM_FIXED		0x00000
+#define			APIC_DM_LOWEST		0x00100
+#define			APIC_DM_SMI		0x00200
+#define			APIC_DM_REMRD		0x00300
+#define			APIC_DM_NMI		0x00400
+#define			APIC_DM_INIT		0x00500
+#define			APIC_DM_STARTUP		0x00600
+#define			APIC_DM_EXTINT		0x00700
+#define			APIC_VECTOR_MASK	0x000FF
+#define		APIC_ICR2	0x310
+#define			GET_APIC_DEST_FIELD(x)	(((x)>>24)&0xFF)
+#define			SET_APIC_DEST_FIELD(x)	((x)<<24)
+#define		APIC_LVTT	0x320
+#define		APIC_LVTTHMR	0x330
+#define		APIC_LVTPC	0x340
+#define		APIC_LVT0	0x350
+#define			APIC_LVT_TIMER_BASE_MASK	(0x3<<18)
+#define			GET_APIC_TIMER_BASE(x)		(((x)>>18)&0x3)
+#define			SET_APIC_TIMER_BASE(x)		(((x)<<18))
+#define			APIC_TIMER_BASE_CLKIN		0x0
+#define			APIC_TIMER_BASE_TMBASE		0x1
+#define			APIC_TIMER_BASE_DIV		0x2
+#define			APIC_LVT_TIMER_PERIODIC		(1<<17)
+#define			APIC_LVT_MASKED			(1<<16)
+#define			APIC_LVT_LEVEL_TRIGGER		(1<<15)
+#define			APIC_LVT_REMOTE_IRR		(1<<14)
+#define			APIC_INPUT_POLARITY		(1<<13)
+#define			APIC_SEND_PENDING		(1<<12)
+#define			APIC_MODE_MASK			0x700
+#define			GET_APIC_DELIVERY_MODE(x)	(((x)>>8)&0x7)
+#define			SET_APIC_DELIVERY_MODE(x,y)	(((x)&~0x700)|((y)<<8))
+#define				APIC_MODE_FIXED		0x0
+#define				APIC_MODE_NMI		0x4
+#define				APIC_MODE_EXTINT	0x7
+#define 	APIC_LVT1	0x360
+#define		APIC_LVTERR	0x370
+#define		APIC_TMICT	0x380
+#define		APIC_TMCCT	0x390
+#define		APIC_TDCR	0x3E0
+#define			APIC_TDR_DIV_TMBASE	(1<<2)
+#define			APIC_TDR_DIV_1		0xB
+#define			APIC_TDR_DIV_2		0x0
+#define			APIC_TDR_DIV_4		0x1
+#define			APIC_TDR_DIV_8		0x2
+#define			APIC_TDR_DIV_16		0x3
+#define			APIC_TDR_DIV_32		0x8
+#define			APIC_TDR_DIV_64		0x9
+#define			APIC_TDR_DIV_128	0xA
+
+#define APIC_BASE (fix_to_virt(FIX_APIC_BASE))
+
+#define MAX_IO_APICS 128
+#define MAX_LOCAL_APIC 256
+
+/*
+ * All x86-64 systems are xAPIC compatible.
+ * In the following, "apicid" is a physical APIC ID.
+ */
+#define XAPIC_DEST_CPUS_SHIFT	4
+#define XAPIC_DEST_CPUS_MASK	((1u << XAPIC_DEST_CPUS_SHIFT) - 1)
+#define XAPIC_DEST_CLUSTER_MASK	(XAPIC_DEST_CPUS_MASK << XAPIC_DEST_CPUS_SHIFT)
+#define APIC_CLUSTER(apicid)	((apicid) & XAPIC_DEST_CLUSTER_MASK)
+#define APIC_CLUSTERID(apicid)	(APIC_CLUSTER(apicid) >> XAPIC_DEST_CPUS_SHIFT)
+#define APIC_CPUID(apicid)	((apicid) & XAPIC_DEST_CPUS_MASK)
+#define NUM_APIC_CLUSTERS	((BAD_APICID + 1) >> XAPIC_DEST_CPUS_SHIFT)
+
+/*
+ * the local APIC register structure, memory mapped. Not terribly well
+ * tested, but we might eventually use this one in the future - the
+ * problem why we cannot use it right now is the P5 APIC, it has an
+ * errata which cannot take 8-bit reads and writes, only 32-bit ones ...
+ */
+#define u32 unsigned int
+
+struct local_apic {
+
+/*000*/	struct { u32 __reserved[4]; } __reserved_01;
+
+/*010*/	struct { u32 __reserved[4]; } __reserved_02;
+
+/*020*/	struct { /* APIC ID Register */
+		u32   __reserved_1	: 24,
+			phys_apic_id	:  4,
+			__reserved_2	:  4;
+		u32 __reserved[3];
+	} id;
+
+/*030*/	const
+	struct { /* APIC Version Register */
+		u32   version		:  8,
+			__reserved_1	:  8,
+			max_lvt		:  8,
+			__reserved_2	:  8;
+		u32 __reserved[3];
+	} version;
+
+/*040*/	struct { u32 __reserved[4]; } __reserved_03;
+
+/*050*/	struct { u32 __reserved[4]; } __reserved_04;
+
+/*060*/	struct { u32 __reserved[4]; } __reserved_05;
+
+/*070*/	struct { u32 __reserved[4]; } __reserved_06;
+
+/*080*/	struct { /* Task Priority Register */
+		u32   priority	:  8,
+			__reserved_1	: 24;
+		u32 __reserved_2[3];
+	} tpr;
+
+/*090*/	const
+	struct { /* Arbitration Priority Register */
+		u32   priority	:  8,
+			__reserved_1	: 24;
+		u32 __reserved_2[3];
+	} apr;
+
+/*0A0*/	const
+	struct { /* Processor Priority Register */
+		u32   priority	:  8,
+			__reserved_1	: 24;
+		u32 __reserved_2[3];
+	} ppr;
+
+/*0B0*/	struct { /* End Of Interrupt Register */
+		u32   eoi;
+		u32 __reserved[3];
+	} eoi;
+
+/*0C0*/	struct { u32 __reserved[4]; } __reserved_07;
+
+/*0D0*/	struct { /* Logical Destination Register */
+		u32   __reserved_1	: 24,
+			logical_dest	:  8;
+		u32 __reserved_2[3];
+	} ldr;
+
+/*0E0*/	struct { /* Destination Format Register */
+		u32   __reserved_1	: 28,
+			model		:  4;
+		u32 __reserved_2[3];
+	} dfr;
+
+/*0F0*/	struct { /* Spurious Interrupt Vector Register */
+		u32	spurious_vector	:  8,
+			apic_enabled	:  1,
+			focus_cpu	:  1,
+			__reserved_2	: 22;
+		u32 __reserved_3[3];
+	} svr;
+
+/*100*/	struct { /* In Service Register */
+/*170*/		u32 bitfield;
+		u32 __reserved[3];
+	} isr [8];
+
+/*180*/	struct { /* Trigger Mode Register */
+/*1F0*/		u32 bitfield;
+		u32 __reserved[3];
+	} tmr [8];
+
+/*200*/	struct { /* Interrupt Request Register */
+/*270*/		u32 bitfield;
+		u32 __reserved[3];
+	} irr [8];
+
+/*280*/	union { /* Error Status Register */
+		struct {
+			u32   send_cs_error			:  1,
+				receive_cs_error		:  1,
+				send_accept_error		:  1,
+				receive_accept_error		:  1,
+				__reserved_1			:  1,
+				send_illegal_vector		:  1,
+				receive_illegal_vector		:  1,
+				illegal_register_address	:  1,
+				__reserved_2			: 24;
+			u32 __reserved_3[3];
+		} error_bits;
+		struct {
+			u32 errors;
+			u32 __reserved_3[3];
+		} all_errors;
+	} esr;
+
+/*290*/	struct { u32 __reserved[4]; } __reserved_08;
+
+/*2A0*/	struct { u32 __reserved[4]; } __reserved_09;
+
+/*2B0*/	struct { u32 __reserved[4]; } __reserved_10;
+
+/*2C0*/	struct { u32 __reserved[4]; } __reserved_11;
+
+/*2D0*/	struct { u32 __reserved[4]; } __reserved_12;
+
+/*2E0*/	struct { u32 __reserved[4]; } __reserved_13;
+
+/*2F0*/	struct { u32 __reserved[4]; } __reserved_14;
+
+/*300*/	struct { /* Interrupt Command Register 1 */
+		u32   vector			:  8,
+			delivery_mode		:  3,
+			destination_mode	:  1,
+			delivery_status		:  1,
+			__reserved_1		:  1,
+			level			:  1,
+			trigger			:  1,
+			__reserved_2		:  2,
+			shorthand		:  2,
+			__reserved_3		:  12;
+		u32 __reserved_4[3];
+	} icr1;
+
+/*310*/	struct { /* Interrupt Command Register 2 */
+		union {
+			u32   __reserved_1	: 24,
+				phys_dest	:  4,
+				__reserved_2	:  4;
+			u32   __reserved_3	: 24,
+				logical_dest	:  8;
+		} dest;
+		u32 __reserved_4[3];
+	} icr2;
+
+/*320*/	struct { /* LVT - Timer */
+		u32   vector		:  8,
+			__reserved_1	:  4,
+			delivery_status	:  1,
+			__reserved_2	:  3,
+			mask		:  1,
+			timer_mode	:  1,
+			__reserved_3	: 14;
+		u32 __reserved_4[3];
+	} lvt_timer;
+
+/*330*/	struct { /* LVT - Thermal Sensor */
+		u32  vector		:  8,
+			delivery_mode	:  3,
+			__reserved_1	:  1,
+			delivery_status	:  1,
+			__reserved_2	:  3,
+			mask		:  1,
+			__reserved_3	: 15;
+		u32 __reserved_4[3];
+	} lvt_thermal;
+
+/*340*/	struct { /* LVT - Performance Counter */
+		u32   vector		:  8,
+			delivery_mode	:  3,
+			__reserved_1	:  1,
+			delivery_status	:  1,
+			__reserved_2	:  3,
+			mask		:  1,
+			__reserved_3	: 15;
+		u32 __reserved_4[3];
+	} lvt_pc;
+
+/*350*/	struct { /* LVT - LINT0 */
+		u32   vector		:  8,
+			delivery_mode	:  3,
+			__reserved_1	:  1,
+			delivery_status	:  1,
+			polarity	:  1,
+			remote_irr	:  1,
+			trigger		:  1,
+			mask		:  1,
+			__reserved_2	: 15;
+		u32 __reserved_3[3];
+	} lvt_lint0;
+
+/*360*/	struct { /* LVT - LINT1 */
+		u32   vector		:  8,
+			delivery_mode	:  3,
+			__reserved_1	:  1,
+			delivery_status	:  1,
+			polarity	:  1,
+			remote_irr	:  1,
+			trigger		:  1,
+			mask		:  1,
+			__reserved_2	: 15;
+		u32 __reserved_3[3];
+	} lvt_lint1;
+
+/*370*/	struct { /* LVT - Error */
+		u32   vector		:  8,
+			__reserved_1	:  4,
+			delivery_status	:  1,
+			__reserved_2	:  3,
+			mask		:  1,
+			__reserved_3	: 15;
+		u32 __reserved_4[3];
+	} lvt_error;
+
+/*380*/	struct { /* Timer Initial Count Register */
+		u32   initial_count;
+		u32 __reserved_2[3];
+	} timer_icr;
+
+/*390*/	const
+	struct { /* Timer Current Count Register */
+		u32   curr_count;
+		u32 __reserved_2[3];
+	} timer_ccr;
+
+/*3A0*/	struct { u32 __reserved[4]; } __reserved_16;
+
+/*3B0*/	struct { u32 __reserved[4]; } __reserved_17;
+
+/*3C0*/	struct { u32 __reserved[4]; } __reserved_18;
+
+/*3D0*/	struct { u32 __reserved[4]; } __reserved_19;
+
+/*3E0*/	struct { /* Timer Divide Configuration Register */
+		u32   divisor		:  4,
+			__reserved_1	: 28;
+		u32 __reserved_2[3];
+	} timer_dcr;
+
+/*3F0*/	struct { u32 __reserved[4]; } __reserved_20;
+
+} __attribute__ ((packed));
+
+#undef u32
+
+#define BAD_APICID 0xFFu
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/apic.h linux-2.6.20-sabayon-r1/include/asm/apic.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/apic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/apic.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,106 @@
+#ifndef __ASM_APIC_H
+#define __ASM_APIC_H
+
+#include <linux/pm.h>
+#include <asm/fixmap.h>
+#include <asm/apicdef.h>
+#include <asm/system.h>
+
+#define Dprintk(x...)
+
+/*
+ * Debugging macros
+ */
+#define APIC_QUIET   0
+#define APIC_VERBOSE 1
+#define APIC_DEBUG   2
+
+extern int apic_verbosity;
+extern int apic_runs_main_timer;
+extern int ioapic_force;
+extern int apic_mapped;
+
+/*
+ * Define the default level of output to be very little
+ * This can be turned up by using apic=verbose for more
+ * information and apic=debug for _lots_ of information.
+ * apic_verbosity is defined in apic.c
+ */
+#define apic_printk(v, s, a...) do {       \
+		if ((v) <= apic_verbosity) \
+			printk(s, ##a);    \
+	} while (0)
+
+struct pt_regs;
+
+/*
+ * Basic functions accessing APICs.
+ */
+
+static __inline void apic_write(unsigned long reg, unsigned int v)
+{
+	*((volatile unsigned int *)(APIC_BASE+reg)) = v;
+}
+
+static __inline unsigned int apic_read(unsigned long reg)
+{
+	return *((volatile unsigned int *)(APIC_BASE+reg));
+}
+
+static __inline__ void apic_wait_icr_idle(void)
+{
+	while (apic_read( APIC_ICR ) & APIC_ICR_BUSY)
+		cpu_relax();
+}
+
+static inline void ack_APIC_irq(void)
+{
+	/*
+	 * ack_APIC_irq() actually gets compiled as a single instruction:
+	 * - a single rmw on Pentium/82489DX
+	 * - a single write on P6+ cores (CONFIG_X86_GOOD_APIC)
+	 * ... yummie.
+	 */
+
+	/* Docs say use 0 for future compatibility */
+	apic_write(APIC_EOI, 0);
+}
+
+extern int get_maxlvt (void);
+extern void clear_local_APIC (void);
+extern void connect_bsp_APIC (void);
+extern void disconnect_bsp_APIC (int virt_wire_setup);
+extern void disable_local_APIC (void);
+extern int verify_local_APIC (void);
+extern void cache_APIC_registers (void);
+extern void sync_Arb_IDs (void);
+extern void init_bsp_APIC (void);
+extern void setup_local_APIC (void);
+extern void init_apic_mappings (void);
+extern void smp_local_timer_interrupt (void);
+extern void setup_boot_APIC_clock (void);
+extern void setup_secondary_APIC_clock (void);
+extern int APIC_init_uniprocessor (void);
+extern void disable_APIC_timer(void);
+extern void enable_APIC_timer(void);
+extern void clustered_apic_check(void);
+
+extern void setup_APIC_extened_lvt(unsigned char lvt_off, unsigned char vector,
+				   unsigned char msg_type, unsigned char mask);
+
+#define K8_APIC_EXT_LVT_BASE    0x500
+#define K8_APIC_EXT_INT_MSG_FIX 0x0
+#define K8_APIC_EXT_INT_MSG_SMI 0x2
+#define K8_APIC_EXT_INT_MSG_NMI 0x4
+#define K8_APIC_EXT_INT_MSG_EXT 0x7
+#define K8_APIC_EXT_LVT_ENTRY_THRESHOLD    0
+
+void smp_send_timer_broadcast_ipi(void);
+void switch_APIC_timer_to_ipi(void *cpumask);
+void switch_ipi_to_APIC_timer(void *cpumask);
+
+#define ARCH_APICTIMER_STOPS_ON_C3	1
+
+extern unsigned boot_cpu_id;
+
+#endif /* __ASM_APIC_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/atomic.h linux-2.6.20-sabayon-r1/include/asm/atomic.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/atomic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/atomic.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,435 @@
+#ifndef __ARCH_X86_64_ATOMIC__
+#define __ARCH_X86_64_ATOMIC__
+
+#include <asm/alternative.h>
+
+/* atomic_t should be 32 bit signed type */
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ */
+
+#ifdef CONFIG_SMP
+#define LOCK "lock ; "
+#else
+#define LOCK ""
+#endif
+
+/*
+ * Make sure gcc doesn't try to be clever and move things around
+ * on us. We need to use _exactly_ the address the user gave us,
+ * not some alias that contains the same information.
+ */
+typedef struct { int counter; } atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/**
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically reads the value of @v.
+ */ 
+#define atomic_read(v)		((v)->counter)
+
+/**
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ * 
+ * Atomically sets the value of @v to @i.
+ */ 
+#define atomic_set(v,i)		(((v)->counter) = (i))
+
+/**
+ * atomic_add - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically adds @i to @v.
+ */
+static __inline__ void atomic_add(int i, atomic_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "addl %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic_sub - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically subtracts @i from @v.
+ */
+static __inline__ void atomic_sub(int i, atomic_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "subl %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.
+ */
+static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "subl %2,%0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"ir" (i), "m" (v->counter) : "memory");
+	return c;
+}
+
+/**
+ * atomic_inc - increment atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically increments @v by 1.
+ */ 
+static __inline__ void atomic_inc(atomic_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "incl %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+/**
+ * atomic_dec - decrement atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically decrements @v by 1.
+ */ 
+static __inline__ void atomic_dec(atomic_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "decl %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+/**
+ * atomic_dec_and_test - decrement and test
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all other
+ * cases.
+ */ 
+static __inline__ int atomic_dec_and_test(atomic_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "decl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic_inc_and_test - increment and test 
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */ 
+static __inline__ int atomic_inc_and_test(atomic_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "incl %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic_add_negative - add and test if negative
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.
+ */ 
+static __inline__ int atomic_add_negative(int i, atomic_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "addl %2,%0; sets %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"ir" (i), "m" (v->counter) : "memory");
+	return c;
+}
+
+/**
+ * atomic_add_return - add and return
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ *
+ * Atomically adds @i to @v and returns @i + @v
+ */
+static __inline__ int atomic_add_return(int i, atomic_t *v)
+{
+	int __i = i;
+	__asm__ __volatile__(
+		LOCK_PREFIX "xaddl %0, %1"
+		:"+r" (i), "+m" (v->counter)
+		: : "memory");
+	return i + __i;
+}
+
+static __inline__ int atomic_sub_return(int i, atomic_t *v)
+{
+	return atomic_add_return(-i,v);
+}
+
+#define atomic_inc_return(v)  (atomic_add_return(1,v))
+#define atomic_dec_return(v)  (atomic_sub_return(1,v))
+
+/* An 64bit atomic type */
+
+typedef struct { volatile long counter; } atomic64_t;
+
+#define ATOMIC64_INIT(i)	{ (i) }
+
+/**
+ * atomic64_read - read atomic64 variable
+ * @v: pointer of type atomic64_t
+ *
+ * Atomically reads the value of @v.
+ * Doesn't imply a read memory barrier.
+ */
+#define atomic64_read(v)		((v)->counter)
+
+/**
+ * atomic64_set - set atomic64 variable
+ * @v: pointer to type atomic64_t
+ * @i: required value
+ *
+ * Atomically sets the value of @v to @i.
+ */
+#define atomic64_set(v,i)		(((v)->counter) = (i))
+
+/**
+ * atomic64_add - add integer to atomic64 variable
+ * @i: integer value to add
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically adds @i to @v.
+ */
+static __inline__ void atomic64_add(long i, atomic64_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "addq %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic64_sub - subtract the atomic64 variable
+ * @i: integer value to subtract
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically subtracts @i from @v.
+ */
+static __inline__ void atomic64_sub(long i, atomic64_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "subq %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/**
+ * atomic64_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.
+ */
+static __inline__ int atomic64_sub_and_test(long i, atomic64_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "subq %2,%0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"ir" (i), "m" (v->counter) : "memory");
+	return c;
+}
+
+/**
+ * atomic64_inc - increment atomic64 variable
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically increments @v by 1.
+ */
+static __inline__ void atomic64_inc(atomic64_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "incq %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+/**
+ * atomic64_dec - decrement atomic64 variable
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically decrements @v by 1.
+ */
+static __inline__ void atomic64_dec(atomic64_t *v)
+{
+	__asm__ __volatile__(
+		LOCK_PREFIX "decq %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+/**
+ * atomic64_dec_and_test - decrement and test
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all other
+ * cases.
+ */
+static __inline__ int atomic64_dec_and_test(atomic64_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "decq %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic64_inc_and_test - increment and test
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.
+ */
+static __inline__ int atomic64_inc_and_test(atomic64_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "incq %0; sete %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"m" (v->counter) : "memory");
+	return c != 0;
+}
+
+/**
+ * atomic64_add_negative - add and test if negative
+ * @i: integer value to add
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.
+ */
+static __inline__ int atomic64_add_negative(long i, atomic64_t *v)
+{
+	unsigned char c;
+
+	__asm__ __volatile__(
+		LOCK_PREFIX "addq %2,%0; sets %1"
+		:"=m" (v->counter), "=qm" (c)
+		:"ir" (i), "m" (v->counter) : "memory");
+	return c;
+}
+
+/**
+ * atomic64_add_return - add and return
+ * @i: integer value to add
+ * @v: pointer to type atomic64_t
+ *
+ * Atomically adds @i to @v and returns @i + @v
+ */
+static __inline__ long atomic64_add_return(long i, atomic64_t *v)
+{
+	long __i = i;
+	__asm__ __volatile__(
+		LOCK_PREFIX "xaddq %0, %1;"
+		:"=r"(i)
+		:"m"(v->counter), "0"(i));
+	return i + __i;
+}
+
+static __inline__ long atomic64_sub_return(long i, atomic64_t *v)
+{
+	return atomic64_add_return(-i,v);
+}
+
+#define atomic64_inc_return(v)  (atomic64_add_return(1,v))
+#define atomic64_dec_return(v)  (atomic64_sub_return(1,v))
+
+#define atomic_cmpxchg(v, old, new) ((int)cmpxchg(&((v)->counter), old, new))
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
+
+/**
+ * atomic_add_unless - add unless the number is a given value
+ * @v: pointer of type atomic_t
+ * @a: the amount to add to v...
+ * @u: ...unless v is equal to u.
+ *
+ * Atomically adds @a to @v, so long as it was not @u.
+ * Returns non-zero if @v was not @u, and zero otherwise.
+ */
+#define atomic_add_unless(v, a, u)				\
+({								\
+	int c, old;						\
+	c = atomic_read(v);					\
+	for (;;) {						\
+		if (unlikely(c == (u)))				\
+			break;					\
+		old = atomic_cmpxchg((v), c, c + (a));		\
+		if (likely(old == c))				\
+			break;					\
+		c = old;					\
+	}							\
+	c != (u);						\
+})
+#define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
+
+/* These are x86-specific, used by some header files */
+#define atomic_clear_mask(mask, addr) \
+__asm__ __volatile__(LOCK_PREFIX "andl %0,%1" \
+: : "r" (~(mask)),"m" (*addr) : "memory")
+
+#define atomic_set_mask(mask, addr) \
+__asm__ __volatile__(LOCK_PREFIX "orl %0,%1" \
+: : "r" ((unsigned)mask),"m" (*(addr)) : "memory")
+
+/* Atomic operations are already serializing on x86 */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#include <asm-generic/atomic.h>
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/auxvec.h linux-2.6.20-sabayon-r1/include/asm/auxvec.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/auxvec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/auxvec.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,4 @@
+#ifndef __ASM_X86_64_AUXVEC_H
+#define __ASM_X86_64_AUXVEC_H
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/bitops.h linux-2.6.20-sabayon-r1/include/asm/bitops.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/bitops.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/bitops.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,427 @@
+#ifndef _X86_64_BITOPS_H
+#define _X86_64_BITOPS_H
+
+/*
+ * Copyright 1992, Linus Torvalds.
+ */
+
+#include <asm/alternative.h>
+
+#if __GNUC__ < 4 || __GNUC_MINOR__ < 1
+/* Technically wrong, but this avoids compilation errors on some gcc
+   versions. */
+#define ADDR "=m" (*(volatile long *) addr)
+#else
+#define ADDR "+m" (*(volatile long *) addr)
+#endif
+
+/**
+ * set_bit - Atomically set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * This function is atomic and may not be reordered.  See __set_bit()
+ * if you do not require the atomic guarantees.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void set_bit(int nr, volatile void * addr)
+{
+	__asm__ __volatile__( LOCK_PREFIX
+		"btsl %1,%0"
+		:ADDR
+		:"dIr" (nr) : "memory");
+}
+
+/**
+ * __set_bit - Set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * Unlike set_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __set_bit(int nr, volatile void * addr)
+{
+	__asm__ volatile(
+		"btsl %1,%0"
+		:ADDR
+		:"dIr" (nr) : "memory");
+}
+
+/**
+ * clear_bit - Clears a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * clear_bit() is atomic and may not be reordered.  However, it does
+ * not contain a memory barrier, so if it is used for locking purposes,
+ * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
+ * in order to ensure changes are visible on other processors.
+ */
+static __inline__ void clear_bit(int nr, volatile void * addr)
+{
+	__asm__ __volatile__( LOCK_PREFIX
+		"btrl %1,%0"
+		:ADDR
+		:"dIr" (nr));
+}
+
+static __inline__ void __clear_bit(int nr, volatile void * addr)
+{
+	__asm__ __volatile__(
+		"btrl %1,%0"
+		:ADDR
+		:"dIr" (nr));
+}
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+/**
+ * __change_bit - Toggle a bit in memory
+ * @nr: the bit to change
+ * @addr: the address to start counting from
+ *
+ * Unlike change_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __change_bit(int nr, volatile void * addr)
+{
+	__asm__ __volatile__(
+		"btcl %1,%0"
+		:ADDR
+		:"dIr" (nr));
+}
+
+/**
+ * change_bit - Toggle a bit in memory
+ * @nr: Bit to change
+ * @addr: Address to start counting from
+ *
+ * change_bit() is atomic and may not be reordered.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void change_bit(int nr, volatile void * addr)
+{
+	__asm__ __volatile__( LOCK_PREFIX
+		"btcl %1,%0"
+		:ADDR
+		:"dIr" (nr));
+}
+
+/**
+ * test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_set_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__( LOCK_PREFIX
+		"btsl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr) : "memory");
+	return oldbit;
+}
+
+/**
+ * __test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_set_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__(
+		"btsl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr));
+	return oldbit;
+}
+
+/**
+ * test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to clear
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__( LOCK_PREFIX
+		"btrl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr) : "memory");
+	return oldbit;
+}
+
+/**
+ * __test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to clear
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__(
+		"btrl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr));
+	return oldbit;
+}
+
+/* WARNING: non atomic and it can be reordered! */
+static __inline__ int __test_and_change_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__(
+		"btcl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr) : "memory");
+	return oldbit;
+}
+
+/**
+ * test_and_change_bit - Change a bit and return its old value
+ * @nr: Bit to change
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_change_bit(int nr, volatile void * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__( LOCK_PREFIX
+		"btcl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit),ADDR
+		:"dIr" (nr) : "memory");
+	return oldbit;
+}
+
+#if 0 /* Fool kernel-doc since it doesn't do macros yet */
+/**
+ * test_bit - Determine whether a bit is set
+ * @nr: bit number to test
+ * @addr: Address to start counting from
+ */
+static int test_bit(int nr, const volatile void * addr);
+#endif
+
+static __inline__ int constant_test_bit(int nr, const volatile void * addr)
+{
+	return ((1UL << (nr & 31)) & (((const volatile unsigned int *) addr)[nr >> 5])) != 0;
+}
+
+static __inline__ int variable_test_bit(int nr, volatile const void * addr)
+{
+	int oldbit;
+
+	__asm__ __volatile__(
+		"btl %2,%1\n\tsbbl %0,%0"
+		:"=r" (oldbit)
+		:"m" (*(volatile long *)addr),"dIr" (nr));
+	return oldbit;
+}
+
+#define test_bit(nr,addr) \
+(__builtin_constant_p(nr) ? \
+ constant_test_bit((nr),(addr)) : \
+ variable_test_bit((nr),(addr)))
+
+#undef ADDR
+
+extern long find_first_zero_bit(const unsigned long * addr, unsigned long size);
+extern long find_next_zero_bit (const unsigned long * addr, long size, long offset);
+extern long find_first_bit(const unsigned long * addr, unsigned long size);
+extern long find_next_bit(const unsigned long * addr, long size, long offset);
+
+/* return index of first bet set in val or max when no bit is set */
+static inline unsigned long __scanbit(unsigned long val, unsigned long max)
+{
+	asm("bsfq %1,%0 ; cmovz %2,%0" : "=&r" (val) : "r" (val), "r" (max));
+	return val;
+}
+
+#define find_first_bit(addr,size) \
+((__builtin_constant_p(size) && (size) <= BITS_PER_LONG ? \
+  (__scanbit(*(unsigned long *)addr,(size))) : \
+  find_first_bit(addr,size)))
+
+#define find_next_bit(addr,size,off) \
+((__builtin_constant_p(size) && (size) <= BITS_PER_LONG ? 	  \
+  ((off) + (__scanbit((*(unsigned long *)addr) >> (off),(size)-(off)))) : \
+	find_next_bit(addr,size,off)))
+
+#define find_first_zero_bit(addr,size) \
+((__builtin_constant_p(size) && (size) <= BITS_PER_LONG ? \
+  (__scanbit(~*(unsigned long *)addr,(size))) : \
+  	find_first_zero_bit(addr,size)))
+	
+#define find_next_zero_bit(addr,size,off) \
+((__builtin_constant_p(size) && (size) <= BITS_PER_LONG ? 	  \
+  ((off)+(__scanbit(~(((*(unsigned long *)addr)) >> (off)),(size)-(off)))) : \
+	find_next_zero_bit(addr,size,off)))
+
+/* 
+ * Find string of zero bits in a bitmap. -1 when not found.
+ */ 
+extern unsigned long 
+find_next_zero_string(unsigned long *bitmap, long start, long nbits, int len);
+
+static inline void set_bit_string(unsigned long *bitmap, unsigned long i, 
+				  int len) 
+{ 
+	unsigned long end = i + len; 
+	while (i < end) {
+		__set_bit(i, bitmap); 
+		i++;
+	}
+} 
+
+static inline void __clear_bit_string(unsigned long *bitmap, unsigned long i, 
+				    int len) 
+{ 
+	unsigned long end = i + len; 
+	while (i < end) {
+		__clear_bit(i, bitmap); 
+		i++;
+	}
+} 
+
+/**
+ * ffz - find first zero in word.
+ * @word: The word to search
+ *
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static __inline__ unsigned long ffz(unsigned long word)
+{
+	__asm__("bsfq %1,%0"
+		:"=r" (word)
+		:"r" (~word));
+	return word;
+}
+
+/**
+ * __ffs - find first bit in word.
+ * @word: The word to search
+ *
+ * Undefined if no bit exists, so code should check against 0 first.
+ */
+static __inline__ unsigned long __ffs(unsigned long word)
+{
+	__asm__("bsfq %1,%0"
+		:"=r" (word)
+		:"rm" (word));
+	return word;
+}
+
+/*
+ * __fls: find last bit set.
+ * @word: The word to search
+ *
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static __inline__ unsigned long __fls(unsigned long word)
+{
+	__asm__("bsrq %1,%0"
+		:"=r" (word)
+		:"rm" (word));
+	return word;
+}
+
+#ifdef __KERNEL__
+
+#include <asm-generic/bitops/sched.h>
+
+/**
+ * ffs - find first bit set
+ * @x: the word to search
+ *
+ * This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+static __inline__ int ffs(int x)
+{
+	int r;
+
+	__asm__("bsfl %1,%0\n\t"
+		"cmovzl %2,%0" 
+		: "=r" (r) : "rm" (x), "r" (-1));
+	return r+1;
+}
+
+/**
+ * fls64 - find last bit set in 64 bit word
+ * @x: the word to search
+ *
+ * This is defined the same way as fls.
+ */
+static __inline__ int fls64(__u64 x)
+{
+	if (x == 0)
+		return 0;
+	return __fls(x) + 1;
+}
+
+/**
+ * fls - find last bit set
+ * @x: the word to search
+ *
+ * This is defined the same way as ffs.
+ */
+static __inline__ int fls(int x)
+{
+	int r;
+
+	__asm__("bsrl %1,%0\n\t"
+		"cmovzl %2,%0"
+		: "=&r" (r) : "rm" (x), "rm" (-1));
+	return r+1;
+}
+
+#define ARCH_HAS_FAST_MULTIPLIER 1
+
+#include <asm-generic/bitops/hweight.h>
+
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
+#include <asm-generic/bitops/ext2-non-atomic.h>
+
+#define ext2_set_bit_atomic(lock,nr,addr) \
+	        test_and_set_bit((nr),(unsigned long*)addr)
+#define ext2_clear_bit_atomic(lock,nr,addr) \
+	        test_and_clear_bit((nr),(unsigned long*)addr)
+
+#include <asm-generic/bitops/minix.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _X86_64_BITOPS_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/boot.h linux-2.6.20-sabayon-r1/include/asm/boot.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/boot.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/boot.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,15 @@
+#ifndef _LINUX_BOOT_H
+#define _LINUX_BOOT_H
+
+/* Don't touch these, unless you really know what you're doing. */
+#define DEF_INITSEG	0x9000
+#define DEF_SYSSEG	0x1000
+#define DEF_SETUPSEG	0x9020
+#define DEF_SYSSIZE	0x7F00
+
+/* Internal svga startup constants */
+#define NORMAL_VGA	0xffff		/* 80x25 mode */
+#define EXTENDED_VGA	0xfffe		/* 80x50 mode */
+#define ASK_VGA		0xfffd		/* ask for it at bootup */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/bootsetup.h linux-2.6.20-sabayon-r1/include/asm/bootsetup.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/bootsetup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/bootsetup.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,40 @@
+
+#ifndef _X86_64_BOOTSETUP_H
+#define _X86_64_BOOTSETUP_H 1
+
+#define BOOT_PARAM_SIZE		4096
+extern char x86_boot_params[BOOT_PARAM_SIZE];
+
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+#define PARAM	((unsigned char *)x86_boot_params)
+#define SCREEN_INFO (*(struct screen_info *) (PARAM+0))
+#define EXT_MEM_K (*(unsigned short *) (PARAM+2))
+#define ALT_MEM_K (*(unsigned int *) (PARAM+0x1e0))
+#define E820_MAP_NR (*(char*) (PARAM+E820NR))
+#define E820_MAP    ((struct e820entry *) (PARAM+E820MAP))
+#define APM_BIOS_INFO (*(struct apm_bios_info *) (PARAM+0x40))
+#define DRIVE_INFO (*(struct drive_info_struct *) (PARAM+0x80))
+#define SYS_DESC_TABLE (*(struct sys_desc_table_struct*)(PARAM+0xa0))
+#define MOUNT_ROOT_RDONLY (*(unsigned short *) (PARAM+0x1F2))
+#define RAMDISK_FLAGS (*(unsigned short *) (PARAM+0x1F8))
+#define SAVED_VIDEO_MODE (*(unsigned short *) (PARAM+0x1FA))
+#define ORIG_ROOT_DEV (*(unsigned short *) (PARAM+0x1FC))
+#define AUX_DEVICE_INFO (*(unsigned char *) (PARAM+0x1FF))
+#define LOADER_TYPE (*(unsigned char *) (PARAM+0x210))
+#define KERNEL_START (*(unsigned int *) (PARAM+0x214))
+#define INITRD_START (*(unsigned int *) (PARAM+0x218))
+#define INITRD_SIZE (*(unsigned int *) (PARAM+0x21c))
+#define EDID_INFO (*(struct edid_info *) (PARAM+0x140))
+#define EDD_NR     (*(unsigned char *) (PARAM+EDDNR))
+#define EDD_MBR_SIG_NR (*(unsigned char *) (PARAM+EDD_MBR_SIG_NR_BUF))
+#define EDD_MBR_SIGNATURE ((unsigned int *) (PARAM+EDD_MBR_SIG_BUF))
+#define EDD_BUF     ((struct edd_info *) (PARAM+EDDBUF))
+#define COMMAND_LINE saved_command_line
+
+#define RAMDISK_IMAGE_START_MASK  	0x07FF
+#define RAMDISK_PROMPT_FLAG		0x8000
+#define RAMDISK_LOAD_FLAG		0x4000	
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/bug.h linux-2.6.20-sabayon-r1/include/asm/bug.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/bug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/bug.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,34 @@
+#ifndef __ASM_X8664_BUG_H
+#define __ASM_X8664_BUG_H 1
+
+#ifdef CONFIG_BUG
+#define HAVE_ARCH_BUG
+
+#ifdef CONFIG_DEBUG_BUGVERBOSE
+#define BUG()								\
+	do {								\
+		asm volatile("1:\tud2\n"				\
+			     ".pushsection __bug_table,\"a\"\n"		\
+			     "2:\t.quad 1b, %c0\n"			\
+			     "\t.word %c1, 0\n"				\
+			     "\t.org 2b+%c2\n"				\
+			     ".popsection"				\
+			     : : "i" (__FILE__), "i" (__LINE__),	\
+			        "i" (sizeof(struct bug_entry)));	\
+		for(;;) ;						\
+	} while(0)
+#else
+#define BUG()								\
+	do {								\
+		asm volatile("ud2");					\
+		for(;;) ;						\
+	} while(0)
+#endif
+
+void out_of_line_bug(void);
+#else
+static inline void out_of_line_bug(void) { }
+#endif
+
+#include <asm-generic/bug.h>
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/bugs.h linux-2.6.20-sabayon-r1/include/asm/bugs.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/bugs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/bugs.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,28 @@
+/*
+ *  include/asm-x86_64/bugs.h
+ *
+ *  Copyright (C) 1994  Linus Torvalds
+ *  Copyright (C) 2000  SuSE
+ *
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *	void check_bugs(void);
+ */
+
+#include <asm/processor.h>
+#include <asm/i387.h>
+#include <asm/msr.h>
+#include <asm/pda.h>
+
+extern void alternative_instructions(void);
+
+static void __init check_bugs(void)
+{
+	identify_cpu(&boot_cpu_data);
+#if !defined(CONFIG_SMP)
+	printk("CPU: ");
+	print_cpu_info(&boot_cpu_data);
+#endif
+	alternative_instructions(); 
+}
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/byteorder.h linux-2.6.20-sabayon-r1/include/asm/byteorder.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/byteorder.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/byteorder.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,33 @@
+#ifndef _X86_64_BYTEORDER_H
+#define _X86_64_BYTEORDER_H
+
+#include <asm/types.h>
+#include <linux/compiler.h>
+
+#ifdef __GNUC__
+
+static __inline__ __attribute_const__ __u64 ___arch__swab64(__u64 x)
+{
+	__asm__("bswapq %0" : "=r" (x) : "0" (x));
+	return x;
+}
+
+static __inline__ __attribute_const__ __u32 ___arch__swab32(__u32 x)
+{
+	__asm__("bswapl %0" : "=r" (x) : "0" (x));
+	return x;
+}
+
+/* Do not define swab16.  Gcc is smart enough to recognize "C" version and
+   convert it into rotation or exhange.  */
+
+#define __arch__swab32(x) ___arch__swab32(x)
+#define __arch__swab64(x) ___arch__swab64(x)
+
+#endif /* __GNUC__ */
+
+#define __BYTEORDER_HAS_U64__
+
+#include <linux/byteorder/little_endian.h>
+
+#endif /* _X86_64_BYTEORDER_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/cacheflush.h linux-2.6.20-sabayon-r1/include/asm/cacheflush.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/cacheflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/cacheflush.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,35 @@
+#ifndef _X8664_CACHEFLUSH_H
+#define _X8664_CACHEFLUSH_H
+
+/* Keep includes the same across arches.  */
+#include <linux/mm.h>
+
+/* Caches aren't brain-dead on the intel. */
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_dup_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr, pfn)	do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_icache_range(start, end)		do { } while (0)
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
+#define flush_cache_vmap(start, end)		do { } while (0)
+#define flush_cache_vunmap(start, end)		do { } while (0)
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len) \
+	memcpy(dst, src, len)
+
+void global_flush_tlb(void); 
+int change_page_attr(struct page *page, int numpages, pgprot_t prot);
+int change_page_attr_addr(unsigned long addr, int numpages, pgprot_t prot);
+
+#ifdef CONFIG_DEBUG_RODATA
+void mark_rodata_ro(void);
+#endif
+
+#endif /* _X8664_CACHEFLUSH_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/cache.h linux-2.6.20-sabayon-r1/include/asm/cache.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/cache.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/cache.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,26 @@
+/*
+ * include/asm-x86_64/cache.h
+ */
+#ifndef __ARCH_X8664_CACHE_H
+#define __ARCH_X8664_CACHE_H
+
+
+/* L1 cache line size */
+#define L1_CACHE_SHIFT	(CONFIG_X86_L1_CACHE_SHIFT)
+#define L1_CACHE_BYTES	(1 << L1_CACHE_SHIFT)
+
+#ifdef CONFIG_X86_VSMP
+
+/* vSMP Internode cacheline shift */
+#define INTERNODE_CACHE_SHIFT (12)
+#ifdef CONFIG_SMP
+#define __cacheline_aligned_in_smp					\
+       __attribute__((__aligned__(1 << (INTERNODE_CACHE_SHIFT))))         \
+       __attribute__((__section__(".data.page_aligned")))
+#endif
+
+#endif
+
+#define __read_mostly __attribute__((__section__(".data.read_mostly")))
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/calgary.h linux-2.6.20-sabayon-r1/include/asm/calgary.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/calgary.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/calgary.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * Derived from include/asm-powerpc/iommu.h
+ *
+ * Copyright (C) IBM Corporation, 2006
+ *
+ * Author: Jon Mason <jdmason@us.ibm.com>
+ * Author: Muli Ben-Yehuda <muli@il.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef _ASM_X86_64_CALGARY_H
+#define _ASM_X86_64_CALGARY_H
+
+#include <linux/spinlock.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <asm/types.h>
+
+struct iommu_table {
+	unsigned long  it_base;      /* mapped address of tce table */
+	unsigned long  it_hint;      /* Hint for next alloc */
+	unsigned long *it_map;       /* A simple allocation bitmap for now */
+	void __iomem  *bbar;         /* Bridge BAR */
+	u64	       tar_val;      /* Table Address Register */
+	struct timer_list watchdog_timer;
+	spinlock_t     it_lock;      /* Protects it_map */
+	unsigned int   it_size;      /* Size of iommu table in entries */
+	unsigned char  it_busno;     /* Bus number this table belongs to */
+};
+
+#define TCE_TABLE_SIZE_UNSPECIFIED	~0
+#define TCE_TABLE_SIZE_64K		0
+#define TCE_TABLE_SIZE_128K		1
+#define TCE_TABLE_SIZE_256K		2
+#define TCE_TABLE_SIZE_512K		3
+#define TCE_TABLE_SIZE_1M		4
+#define TCE_TABLE_SIZE_2M		5
+#define TCE_TABLE_SIZE_4M		6
+#define TCE_TABLE_SIZE_8M		7
+
+extern int use_calgary;
+
+#ifdef CONFIG_CALGARY_IOMMU
+extern int calgary_iommu_init(void);
+extern void detect_calgary(void);
+#else
+static inline int calgary_iommu_init(void) { return 1; }
+static inline void detect_calgary(void) { return; }
+#endif
+
+#endif /* _ASM_X86_64_CALGARY_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/calling.h linux-2.6.20-sabayon-r1/include/asm/calling.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/calling.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/calling.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,162 @@
+/* 
+ * Some macros to handle stack frames in assembly.
+ */ 
+
+
+#define R15 0
+#define R14 8
+#define R13 16
+#define R12 24
+#define RBP 32
+#define RBX 40
+/* arguments: interrupts/non tracing syscalls only save upto here*/
+#define R11 48
+#define R10 56	
+#define R9 64
+#define R8 72
+#define RAX 80
+#define RCX 88
+#define RDX 96
+#define RSI 104
+#define RDI 112
+#define ORIG_RAX 120       /* + error_code */ 
+/* end of arguments */ 	
+/* cpu exception frame or undefined in case of fast syscall. */
+#define RIP 128
+#define CS 136
+#define EFLAGS 144
+#define RSP 152
+#define SS 160
+#define ARGOFFSET R11
+#define SWFRAME ORIG_RAX
+
+	.macro SAVE_ARGS addskip=0,norcx=0,nor891011=0
+	subq  $9*8+\addskip,%rsp
+	CFI_ADJUST_CFA_OFFSET	9*8+\addskip
+	movq  %rdi,8*8(%rsp) 
+	CFI_REL_OFFSET	rdi,8*8
+	movq  %rsi,7*8(%rsp) 
+	CFI_REL_OFFSET	rsi,7*8
+	movq  %rdx,6*8(%rsp)
+	CFI_REL_OFFSET	rdx,6*8
+	.if \norcx
+	.else
+	movq  %rcx,5*8(%rsp)
+	CFI_REL_OFFSET	rcx,5*8
+	.endif
+	movq  %rax,4*8(%rsp) 
+	CFI_REL_OFFSET	rax,4*8
+	.if \nor891011
+	.else
+	movq  %r8,3*8(%rsp) 
+	CFI_REL_OFFSET	r8,3*8
+	movq  %r9,2*8(%rsp) 
+	CFI_REL_OFFSET	r9,2*8
+	movq  %r10,1*8(%rsp) 
+	CFI_REL_OFFSET	r10,1*8
+	movq  %r11,(%rsp) 
+	CFI_REL_OFFSET	r11,0*8
+	.endif
+	.endm
+
+#define ARG_SKIP 9*8
+	.macro RESTORE_ARGS skiprax=0,addskip=0,skiprcx=0,skipr11=0,skipr8910=0,skiprdx=0
+	.if \skipr11
+	.else
+	movq (%rsp),%r11
+	CFI_RESTORE r11
+	.endif
+	.if \skipr8910
+	.else
+	movq 1*8(%rsp),%r10
+	CFI_RESTORE r10
+	movq 2*8(%rsp),%r9
+	CFI_RESTORE r9
+	movq 3*8(%rsp),%r8
+	CFI_RESTORE r8
+	.endif
+	.if \skiprax
+	.else
+	movq 4*8(%rsp),%rax
+	CFI_RESTORE rax
+	.endif
+	.if \skiprcx
+	.else
+	movq 5*8(%rsp),%rcx
+	CFI_RESTORE rcx
+	.endif
+	.if \skiprdx
+	.else
+	movq 6*8(%rsp),%rdx
+	CFI_RESTORE rdx
+	.endif
+	movq 7*8(%rsp),%rsi
+	CFI_RESTORE rsi
+	movq 8*8(%rsp),%rdi
+	CFI_RESTORE rdi
+	.if ARG_SKIP+\addskip > 0
+	addq $ARG_SKIP+\addskip,%rsp
+	CFI_ADJUST_CFA_OFFSET	-(ARG_SKIP+\addskip)
+	.endif
+	.endm	
+
+	.macro LOAD_ARGS offset
+	movq \offset(%rsp),%r11
+	movq \offset+8(%rsp),%r10
+	movq \offset+16(%rsp),%r9
+	movq \offset+24(%rsp),%r8
+	movq \offset+40(%rsp),%rcx
+	movq \offset+48(%rsp),%rdx
+	movq \offset+56(%rsp),%rsi
+	movq \offset+64(%rsp),%rdi
+	movq \offset+72(%rsp),%rax
+	.endm
+			
+#define REST_SKIP 6*8			
+	.macro SAVE_REST
+	subq $REST_SKIP,%rsp
+	CFI_ADJUST_CFA_OFFSET	REST_SKIP
+	movq %rbx,5*8(%rsp) 
+	CFI_REL_OFFSET	rbx,5*8
+	movq %rbp,4*8(%rsp) 
+	CFI_REL_OFFSET	rbp,4*8
+	movq %r12,3*8(%rsp) 
+	CFI_REL_OFFSET	r12,3*8
+	movq %r13,2*8(%rsp) 
+	CFI_REL_OFFSET	r13,2*8
+	movq %r14,1*8(%rsp) 
+	CFI_REL_OFFSET	r14,1*8
+	movq %r15,(%rsp) 
+	CFI_REL_OFFSET	r15,0*8
+	.endm		
+
+	.macro RESTORE_REST
+	movq (%rsp),%r15
+	CFI_RESTORE r15
+	movq 1*8(%rsp),%r14
+	CFI_RESTORE r14
+	movq 2*8(%rsp),%r13
+	CFI_RESTORE r13
+	movq 3*8(%rsp),%r12
+	CFI_RESTORE r12
+	movq 4*8(%rsp),%rbp
+	CFI_RESTORE rbp
+	movq 5*8(%rsp),%rbx
+	CFI_RESTORE rbx
+	addq $REST_SKIP,%rsp
+	CFI_ADJUST_CFA_OFFSET	-(REST_SKIP)
+	.endm
+		
+	.macro SAVE_ALL
+	SAVE_ARGS
+	SAVE_REST
+	.endm
+		
+	.macro RESTORE_ALL addskip=0
+	RESTORE_REST
+	RESTORE_ARGS 0,\addskip
+	.endm
+
+	.macro icebp
+	.byte 0xf1
+	.endm
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/checksum.h linux-2.6.20-sabayon-r1/include/asm/checksum.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/checksum.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/checksum.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,195 @@
+#ifndef _X86_64_CHECKSUM_H
+#define _X86_64_CHECKSUM_H
+
+/* 
+ * Checksums for x86-64 
+ * Copyright 2002 by Andi Kleen, SuSE Labs 
+ * with some code from asm-i386/checksum.h
+ */ 
+
+#include <linux/compiler.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+
+/** 
+ * csum_fold - Fold and invert a 32bit checksum.
+ * sum: 32bit unfolded sum
+ * 
+ * Fold a 32bit running checksum to 16bit and invert it. This is usually
+ * the last step before putting a checksum into a packet.
+ * Make sure not to mix with 64bit checksums.
+ */
+static inline __sum16 csum_fold(__wsum sum)
+{
+	__asm__(
+		"  addl %1,%0\n"
+		"  adcl $0xffff,%0"
+		: "=r" (sum)
+		: "r" ((__force u32)sum << 16),
+		  "0" ((__force u32)sum & 0xffff0000)
+	);
+	return (__force __sum16)(~(__force u32)sum >> 16);
+}
+
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ *
+ *	By Jorge Cwik <jorge@laser.satlink.net>, adapted for linux by
+ *	Arnt Gulbrandsen.
+ */
+
+/**
+ * ip_fast_csum - Compute the IPv4 header checksum efficiently.
+ * iph: ipv4 header
+ * ihl: length of header / 4
+ */ 
+static inline __sum16 ip_fast_csum(const void *iph, unsigned int ihl)
+{
+	unsigned int sum;
+
+	asm(	"  movl (%1), %0\n"
+		"  subl $4, %2\n"
+		"  jbe 2f\n"
+		"  addl 4(%1), %0\n"
+		"  adcl 8(%1), %0\n"
+		"  adcl 12(%1), %0\n"
+		"1: adcl 16(%1), %0\n"
+		"  lea 4(%1), %1\n"
+		"  decl %2\n"
+		"  jne	1b\n"
+		"  adcl $0, %0\n"
+		"  movl %0, %2\n"
+		"  shrl $16, %0\n"
+		"  addw %w2, %w0\n"
+		"  adcl $0, %0\n"
+		"  notl %0\n"
+		"2:"
+	/* Since the input registers which are loaded with iph and ihl
+	   are modified, we must also specify them as outputs, or gcc
+	   will assume they contain their original values. */
+	: "=r" (sum), "=r" (iph), "=r" (ihl)
+	: "1" (iph), "2" (ihl)
+	: "memory");
+	return (__force __sum16)sum;
+}
+
+/** 
+ * csum_tcpup_nofold - Compute an IPv4 pseudo header checksum.
+ * @saddr: source address
+ * @daddr: destination address
+ * @len: length of packet
+ * @proto: ip protocol of packet
+ * @sum: initial sum to be added in (32bit unfolded) 
+ * 
+ * Returns the pseudo header checksum the input data. Result is 
+ * 32bit unfolded.
+ */
+static inline __wsum
+csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,
+		   unsigned short proto, __wsum sum)
+{
+	asm("  addl %1, %0\n"
+	    "  adcl %2, %0\n"
+	    "  adcl %3, %0\n"
+	    "  adcl $0, %0\n"
+		: "=r" (sum)
+	    : "g" (daddr), "g" (saddr),
+	      "g" ((len + proto)<<8), "0" (sum));
+    return sum;
+}
+
+
+/** 
+ * csum_tcpup_magic - Compute an IPv4 pseudo header checksum.
+ * @saddr: source address
+ * @daddr: destination address
+ * @len: length of packet
+ * @proto: ip protocol of packet
+ * @sum: initial sum to be added in (32bit unfolded) 
+ * 
+ * Returns the 16bit pseudo header checksum the input data already
+ * complemented and ready to be filled in.
+ */
+static inline __sum16
+csum_tcpudp_magic(__be32 saddr, __be32 daddr,
+		  unsigned short len, unsigned short proto, __wsum sum)
+{
+	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+}
+
+/** 
+ * csum_partial - Compute an internet checksum.
+ * @buff: buffer to be checksummed
+ * @len: length of buffer.
+ * @sum: initial sum to be added in (32bit unfolded)
+ *
+ * Returns the 32bit unfolded internet checksum of the buffer.
+ * Before filling it in it needs to be csum_fold()'ed.
+ * buff should be aligned to a 64bit boundary if possible.
+ */ 
+extern __wsum csum_partial(const void *buff, int len, __wsum sum);
+
+#define  _HAVE_ARCH_COPY_AND_CSUM_FROM_USER 1
+#define HAVE_CSUM_COPY_USER 1
+
+
+/* Do not call this directly. Use the wrappers below */
+extern __wsum csum_partial_copy_generic(const void *src, const void *dst,
+					       int len,
+					       __wsum sum,
+					       int *src_err_ptr, int *dst_err_ptr);
+
+
+extern __wsum csum_partial_copy_from_user(const void __user *src, void *dst,
+				       int len, __wsum isum, int *errp);
+extern __wsum csum_partial_copy_to_user(const void *src, void __user *dst,
+				      int len, __wsum isum, int *errp);
+extern __wsum csum_partial_copy_nocheck(const void *src, void *dst, int len,
+					      __wsum sum);
+
+/* Old names. To be removed. */
+#define csum_and_copy_to_user csum_partial_copy_to_user
+#define csum_and_copy_from_user csum_partial_copy_from_user
+
+/** 
+ * ip_compute_csum - Compute an 16bit IP checksum.
+ * @buff: buffer address.
+ * @len: length of buffer.
+ *
+ * Returns the 16bit folded/inverted checksum of the passed buffer.
+ * Ready to fill in.
+ */
+extern __sum16 ip_compute_csum(const void *buff, int len);
+
+/**
+ * csum_ipv6_magic - Compute checksum of an IPv6 pseudo header.
+ * @saddr: source address
+ * @daddr: destination address
+ * @len: length of packet
+ * @proto: protocol of packet
+ * @sum: initial sum (32bit unfolded) to be added in
+ *
+ * Computes an IPv6 pseudo header checksum. This sum is added the checksum 
+ * into UDP/TCP packets and contains some link layer information.
+ * Returns the unfolded 32bit checksum.
+ */
+
+struct in6_addr;
+
+#define _HAVE_ARCH_IPV6_CSUM 1
+extern __sum16
+csum_ipv6_magic(const struct in6_addr *saddr, const struct in6_addr *daddr,
+		__u32 len, unsigned short proto, __wsum sum);
+
+static inline unsigned add32_with_carry(unsigned a, unsigned b)
+{
+	asm("addl %2,%0\n\t"
+	    "adcl $0,%0" 
+	    : "=r" (a) 
+	    : "0" (a), "r" (b));
+	return a;
+}
+
+#endif
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/compat.h linux-2.6.20-sabayon-r1/include/asm/compat.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/compat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/compat.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,210 @@
+#ifndef _ASM_X86_64_COMPAT_H
+#define _ASM_X86_64_COMPAT_H
+
+/*
+ * Architecture specific compatibility types
+ */
+#include <linux/types.h>
+#include <linux/sched.h>
+
+#define COMPAT_USER_HZ	100
+
+typedef u32		compat_size_t;
+typedef s32		compat_ssize_t;
+typedef s32		compat_time_t;
+typedef s32		compat_clock_t;
+typedef s32		compat_pid_t;
+typedef u16		__compat_uid_t;
+typedef u16		__compat_gid_t;
+typedef u32		__compat_uid32_t;
+typedef u32		__compat_gid32_t;
+typedef u16		compat_mode_t;
+typedef u32		compat_ino_t;
+typedef u16		compat_dev_t;
+typedef s32		compat_off_t;
+typedef s64		compat_loff_t;
+typedef u16		compat_nlink_t;
+typedef u16		compat_ipc_pid_t;
+typedef s32		compat_daddr_t;
+typedef u32		compat_caddr_t;
+typedef __kernel_fsid_t	compat_fsid_t;
+typedef s32		compat_timer_t;
+typedef s32		compat_key_t;
+
+typedef s32		compat_int_t;
+typedef s32		compat_long_t;
+typedef u32		compat_uint_t;
+typedef u32		compat_ulong_t;
+
+struct compat_timespec {
+	compat_time_t	tv_sec;
+	s32		tv_nsec;
+};
+
+struct compat_timeval {
+	compat_time_t	tv_sec;
+	s32		tv_usec;
+};
+
+struct compat_stat {
+	compat_dev_t	st_dev;
+	u16		__pad1;
+	compat_ino_t	st_ino;
+	compat_mode_t	st_mode;
+	compat_nlink_t	st_nlink;
+	__compat_uid_t	st_uid;
+	__compat_gid_t	st_gid;
+	compat_dev_t	st_rdev;
+	u16		__pad2;
+	u32		st_size;
+	u32		st_blksize;
+	u32		st_blocks;
+	u32		st_atime;
+	u32		st_atime_nsec;
+	u32		st_mtime;
+	u32		st_mtime_nsec;
+	u32		st_ctime;
+	u32		st_ctime_nsec;
+	u32		__unused4;
+	u32		__unused5;
+};
+
+struct compat_flock {
+	short		l_type;
+	short		l_whence;
+	compat_off_t	l_start;
+	compat_off_t	l_len;
+	compat_pid_t	l_pid;
+};
+
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+/*
+ * IA32 uses 4 byte alignment for 64 bit quantities,
+ * so we need to pack this structure.
+ */
+struct compat_flock64 {
+	short		l_type;
+	short		l_whence;
+	compat_loff_t	l_start;
+	compat_loff_t	l_len;
+	compat_pid_t	l_pid;
+} __attribute__((packed));
+
+struct compat_statfs {
+	int		f_type;
+	int		f_bsize;
+	int		f_blocks;
+	int		f_bfree;
+	int		f_bavail;
+	int		f_files;
+	int		f_ffree;
+	compat_fsid_t	f_fsid;
+	int		f_namelen;	/* SunOS ignores this field. */
+	int		f_frsize;
+	int		f_spare[5];
+};
+
+#define COMPAT_RLIM_OLD_INFINITY	0x7fffffff
+#define COMPAT_RLIM_INFINITY		0xffffffff
+
+typedef u32		compat_old_sigset_t;	/* at least 32 bits */
+
+#define _COMPAT_NSIG		64
+#define _COMPAT_NSIG_BPW	32
+
+typedef u32               compat_sigset_word;
+
+#define COMPAT_OFF_T_MAX	0x7fffffff
+#define COMPAT_LOFF_T_MAX	0x7fffffffffffffffL
+
+struct compat_ipc64_perm {
+	compat_key_t key;
+	__compat_uid32_t uid;
+	__compat_gid32_t gid;
+	__compat_uid32_t cuid;
+	__compat_gid32_t cgid;
+	unsigned short mode;
+	unsigned short __pad1;
+	unsigned short seq;
+	unsigned short __pad2;
+	compat_ulong_t unused1;
+	compat_ulong_t unused2;
+};
+
+struct compat_semid64_ds {
+	struct compat_ipc64_perm sem_perm;
+	compat_time_t  sem_otime;
+	compat_ulong_t __unused1;
+	compat_time_t  sem_ctime;
+	compat_ulong_t __unused2;
+	compat_ulong_t sem_nsems;
+	compat_ulong_t __unused3;
+	compat_ulong_t __unused4;
+};
+
+struct compat_msqid64_ds {
+	struct compat_ipc64_perm msg_perm;
+	compat_time_t  msg_stime;
+	compat_ulong_t __unused1;
+	compat_time_t  msg_rtime;
+	compat_ulong_t __unused2;
+	compat_time_t  msg_ctime;
+	compat_ulong_t __unused3;
+	compat_ulong_t msg_cbytes;
+	compat_ulong_t msg_qnum;
+	compat_ulong_t msg_qbytes;
+	compat_pid_t   msg_lspid;
+	compat_pid_t   msg_lrpid;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+struct compat_shmid64_ds {
+	struct compat_ipc64_perm shm_perm;
+	compat_size_t  shm_segsz;
+	compat_time_t  shm_atime;
+	compat_ulong_t __unused1;
+	compat_time_t  shm_dtime;
+	compat_ulong_t __unused2;
+	compat_time_t  shm_ctime;
+	compat_ulong_t __unused3;
+	compat_pid_t   shm_cpid;
+	compat_pid_t   shm_lpid;
+	compat_ulong_t shm_nattch;
+	compat_ulong_t __unused4;
+	compat_ulong_t __unused5;
+};
+
+/*
+ * A pointer passed in from user mode. This should not
+ * be used for syscall parameters, just declare them
+ * as pointers because the syscall entry code will have
+ * appropriately comverted them already.
+ */
+typedef	u32		compat_uptr_t;
+
+static inline void __user *compat_ptr(compat_uptr_t uptr)
+{
+	return (void __user *)(unsigned long)uptr;
+}
+
+static inline compat_uptr_t ptr_to_compat(void __user *uptr)
+{
+	return (u32)(unsigned long)uptr;
+}
+
+static __inline__ void __user *compat_alloc_user_space(long len)
+{
+	struct pt_regs *regs = task_pt_regs(current);
+	return (void __user *)regs->rsp - len; 
+}
+
+static inline int is_compat_task(void)
+{
+	return current_thread_info()->status & TS_COMPAT;
+}
+
+#endif /* _ASM_X86_64_COMPAT_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/cpufeature.h linux-2.6.20-sabayon-r1/include/asm/cpufeature.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/cpufeature.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/cpufeature.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+ * cpufeature.h
+ *
+ * Defines x86 CPU feature bits
+ */
+
+#ifndef __ASM_X8664_CPUFEATURE_H
+#define __ASM_X8664_CPUFEATURE_H
+
+#define NCAPINTS	7	/* N 32-bit words worth of info */
+
+/* Intel-defined CPU features, CPUID level 0x00000001, word 0 */
+#define X86_FEATURE_FPU		(0*32+ 0) /* Onboard FPU */
+#define X86_FEATURE_VME		(0*32+ 1) /* Virtual Mode Extensions */
+#define X86_FEATURE_DE		(0*32+ 2) /* Debugging Extensions */
+#define X86_FEATURE_PSE 	(0*32+ 3) /* Page Size Extensions */
+#define X86_FEATURE_TSC		(0*32+ 4) /* Time Stamp Counter */
+#define X86_FEATURE_MSR		(0*32+ 5) /* Model-Specific Registers, RDMSR, WRMSR */
+#define X86_FEATURE_PAE		(0*32+ 6) /* Physical Address Extensions */
+#define X86_FEATURE_MCE		(0*32+ 7) /* Machine Check Architecture */
+#define X86_FEATURE_CX8		(0*32+ 8) /* CMPXCHG8 instruction */
+#define X86_FEATURE_APIC	(0*32+ 9) /* Onboard APIC */
+#define X86_FEATURE_SEP		(0*32+11) /* SYSENTER/SYSEXIT */
+#define X86_FEATURE_MTRR	(0*32+12) /* Memory Type Range Registers */
+#define X86_FEATURE_PGE		(0*32+13) /* Page Global Enable */
+#define X86_FEATURE_MCA		(0*32+14) /* Machine Check Architecture */
+#define X86_FEATURE_CMOV	(0*32+15) /* CMOV instruction (FCMOVCC and FCOMI too if FPU present) */
+#define X86_FEATURE_PAT		(0*32+16) /* Page Attribute Table */
+#define X86_FEATURE_PSE36	(0*32+17) /* 36-bit PSEs */
+#define X86_FEATURE_PN		(0*32+18) /* Processor serial number */
+#define X86_FEATURE_CLFLSH	(0*32+19) /* Supports the CLFLUSH instruction */
+#define X86_FEATURE_DS		(0*32+21) /* Debug Store */
+#define X86_FEATURE_ACPI	(0*32+22) /* ACPI via MSR */
+#define X86_FEATURE_MMX		(0*32+23) /* Multimedia Extensions */
+#define X86_FEATURE_FXSR	(0*32+24) /* FXSAVE and FXRSTOR instructions (fast save and restore */
+				          /* of FPU context), and CR4.OSFXSR available */
+#define X86_FEATURE_XMM		(0*32+25) /* Streaming SIMD Extensions */
+#define X86_FEATURE_XMM2	(0*32+26) /* Streaming SIMD Extensions-2 */
+#define X86_FEATURE_SELFSNOOP	(0*32+27) /* CPU self snoop */
+#define X86_FEATURE_HT		(0*32+28) /* Hyper-Threading */
+#define X86_FEATURE_ACC		(0*32+29) /* Automatic clock control */
+#define X86_FEATURE_IA64	(0*32+30) /* IA-64 processor */
+
+/* AMD-defined CPU features, CPUID level 0x80000001, word 1 */
+/* Don't duplicate feature flags which are redundant with Intel! */
+#define X86_FEATURE_SYSCALL	(1*32+11) /* SYSCALL/SYSRET */
+#define X86_FEATURE_MMXEXT	(1*32+22) /* AMD MMX extensions */
+#define X86_FEATURE_FXSR_OPT	(1*32+25) /* FXSR optimizations */
+#define X86_FEATURE_RDTSCP	(1*32+27) /* RDTSCP */
+#define X86_FEATURE_LM		(1*32+29) /* Long Mode (x86-64) */
+#define X86_FEATURE_3DNOWEXT	(1*32+30) /* AMD 3DNow! extensions */
+#define X86_FEATURE_3DNOW	(1*32+31) /* 3DNow! */
+
+/* Transmeta-defined CPU features, CPUID level 0x80860001, word 2 */
+#define X86_FEATURE_RECOVERY	(2*32+ 0) /* CPU in recovery mode */
+#define X86_FEATURE_LONGRUN	(2*32+ 1) /* Longrun power control */
+#define X86_FEATURE_LRTI	(2*32+ 3) /* LongRun table interface */
+
+/* Other features, Linux-defined mapping, word 3 */
+/* This range is used for feature bits which conflict or are synthesized */
+#define X86_FEATURE_CXMMX	(3*32+ 0) /* Cyrix MMX extensions */
+#define X86_FEATURE_K6_MTRR	(3*32+ 1) /* AMD K6 nonstandard MTRRs */
+#define X86_FEATURE_CYRIX_ARR	(3*32+ 2) /* Cyrix ARRs (= MTRRs) */
+#define X86_FEATURE_CENTAUR_MCR	(3*32+ 3) /* Centaur MCRs (= MTRRs) */
+#define X86_FEATURE_REP_GOOD	(3*32+ 4) /* rep microcode works well on this CPU */
+#define X86_FEATURE_CONSTANT_TSC (3*32+5) /* TSC runs at constant rate */
+#define X86_FEATURE_SYNC_RDTSC  (3*32+6)  /* RDTSC syncs CPU core */
+#define X86_FEATURE_FXSAVE_LEAK (3*32+7)  /* FIP/FOP/FDP leaks through FXSAVE */
+#define X86_FEATURE_UP		(3*32+8) /* SMP kernel running on UP */
+#define X86_FEATURE_ARCH_PERFMON (3*32+9) /* Intel Architectural PerfMon */
+#define X86_FEATURE_PEBS	(3*32+10) /* Precise-Event Based Sampling */
+#define X86_FEATURE_BTS		(3*32+11) /* Branch Trace Store */
+
+/* Intel-defined CPU features, CPUID level 0x00000001 (ecx), word 4 */
+#define X86_FEATURE_XMM3	(4*32+ 0) /* Streaming SIMD Extensions-3 */
+#define X86_FEATURE_MWAIT	(4*32+ 3) /* Monitor/Mwait support */
+#define X86_FEATURE_DSCPL	(4*32+ 4) /* CPL Qualified Debug Store */
+#define X86_FEATURE_EST		(4*32+ 7) /* Enhanced SpeedStep */
+#define X86_FEATURE_TM2		(4*32+ 8) /* Thermal Monitor 2 */
+#define X86_FEATURE_CID		(4*32+10) /* Context ID */
+#define X86_FEATURE_CX16	(4*32+13) /* CMPXCHG16B */
+#define X86_FEATURE_XTPR	(4*32+14) /* Send Task Priority Messages */
+
+/* VIA/Cyrix/Centaur-defined CPU features, CPUID level 0xC0000001, word 5 */
+#define X86_FEATURE_XSTORE	(5*32+ 2) /* on-CPU RNG present (xstore insn) */
+#define X86_FEATURE_XSTORE_EN	(5*32+ 3) /* on-CPU RNG enabled */
+#define X86_FEATURE_XCRYPT	(5*32+ 6) /* on-CPU crypto (xcrypt insn) */
+#define X86_FEATURE_XCRYPT_EN	(5*32+ 7) /* on-CPU crypto enabled */
+
+/* More extended AMD flags: CPUID level 0x80000001, ecx, word 6 */
+#define X86_FEATURE_LAHF_LM	(6*32+ 0) /* LAHF/SAHF in long mode */
+#define X86_FEATURE_CMP_LEGACY	(6*32+ 1) /* If yes HyperThreading not valid */
+
+#define cpu_has(c, bit)                test_bit(bit, (c)->x86_capability)
+#define boot_cpu_has(bit)      test_bit(bit, boot_cpu_data.x86_capability)
+
+#define cpu_has_fpu            1
+#define cpu_has_vme            0
+#define cpu_has_de             1
+#define cpu_has_pse            1
+#define cpu_has_tsc            1
+#define cpu_has_pae            ___BUG___
+#define cpu_has_pge            1
+#define cpu_has_apic           boot_cpu_has(X86_FEATURE_APIC)
+#define cpu_has_mtrr           1
+#define cpu_has_mmx            1
+#define cpu_has_fxsr           1
+#define cpu_has_xmm            1
+#define cpu_has_xmm2           1
+#define cpu_has_xmm3           boot_cpu_has(X86_FEATURE_XMM3)
+#define cpu_has_ht             boot_cpu_has(X86_FEATURE_HT)
+#define cpu_has_mp             1 /* XXX */
+#define cpu_has_k6_mtrr        0
+#define cpu_has_cyrix_arr      0
+#define cpu_has_centaur_mcr    0
+#define cpu_has_clflush	       boot_cpu_has(X86_FEATURE_CLFLSH)
+#define cpu_has_ds 	       boot_cpu_has(X86_FEATURE_DS)
+#define cpu_has_pebs 	       boot_cpu_has(X86_FEATURE_PEBS)
+#define cpu_has_bts 	       boot_cpu_has(X86_FEATURE_BTS)
+
+#endif /* __ASM_X8664_CPUFEATURE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/cpu.h linux-2.6.20-sabayon-r1/include/asm/cpu.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/cpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/cpu.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-i386/cpu.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/cputime.h linux-2.6.20-sabayon-r1/include/asm/cputime.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/cputime.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/cputime.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __X86_64_CPUTIME_H
+#define __X86_64_CPUTIME_H
+
+#include <asm-generic/cputime.h>
+
+#endif /* __X86_64_CPUTIME_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/current.h linux-2.6.20-sabayon-r1/include/asm/current.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/current.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/current.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef _X86_64_CURRENT_H
+#define _X86_64_CURRENT_H
+
+#if !defined(__ASSEMBLY__) 
+struct task_struct;
+
+#include <asm/pda.h>
+
+static inline struct task_struct *get_current(void) 
+{ 
+	struct task_struct *t = read_pda(pcurrent); 
+	return t;
+} 
+
+#define current get_current()
+
+#else
+
+#ifndef ASM_OFFSET_H
+#include <asm/asm-offsets.h> 
+#endif
+
+#define GET_CURRENT(reg) movq %gs:(pda_pcurrent),reg
+
+#endif
+
+#endif /* !(_X86_64_CURRENT_H) */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/debugreg.h linux-2.6.20-sabayon-r1/include/asm/debugreg.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/debugreg.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/debugreg.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,65 @@
+#ifndef _X86_64_DEBUGREG_H
+#define _X86_64_DEBUGREG_H
+
+
+/* Indicate the register numbers for a number of the specific
+   debug registers.  Registers 0-3 contain the addresses we wish to trap on */
+#define DR_FIRSTADDR 0        /* u_debugreg[DR_FIRSTADDR] */
+#define DR_LASTADDR 3         /* u_debugreg[DR_LASTADDR]  */
+
+#define DR_STATUS 6           /* u_debugreg[DR_STATUS]     */
+#define DR_CONTROL 7          /* u_debugreg[DR_CONTROL] */
+
+/* Define a few things for the status register.  We can use this to determine
+   which debugging register was responsible for the trap.  The other bits
+   are either reserved or not of interest to us. */
+
+#define DR_TRAP0	(0x1)		/* db0 */
+#define DR_TRAP1	(0x2)		/* db1 */
+#define DR_TRAP2	(0x4)		/* db2 */
+#define DR_TRAP3	(0x8)		/* db3 */
+
+#define DR_STEP		(0x4000)	/* single-step */
+#define DR_SWITCH	(0x8000)	/* task switch */
+
+/* Now define a bunch of things for manipulating the control register.
+   The top two bytes of the control register consist of 4 fields of 4
+   bits - each field corresponds to one of the four debug registers,
+   and indicates what types of access we trap on, and how large the data
+   field is that we are looking at */
+
+#define DR_CONTROL_SHIFT 16 /* Skip this many bits in ctl register */
+#define DR_CONTROL_SIZE 4   /* 4 control bits per register */
+
+#define DR_RW_EXECUTE (0x0)   /* Settings for the access types to trap on */
+#define DR_RW_WRITE (0x1)
+#define DR_RW_READ (0x3)
+
+#define DR_LEN_1 (0x0) /* Settings for data length to trap on */
+#define DR_LEN_2 (0x4)
+#define DR_LEN_4 (0xC)
+#define DR_LEN_8 (0x8)
+
+/* The low byte to the control register determine which registers are
+   enabled.  There are 4 fields of two bits.  One bit is "local", meaning
+   that the processor will reset the bit after a task switch and the other
+   is global meaning that we have to explicitly reset the bit.  With linux,
+   you can use either one, since we explicitly zero the register when we enter
+   kernel mode. */
+
+#define DR_LOCAL_ENABLE_SHIFT 0    /* Extra shift to the local enable bit */
+#define DR_GLOBAL_ENABLE_SHIFT 1   /* Extra shift to the global enable bit */
+#define DR_ENABLE_SIZE 2           /* 2 enable bits per register */
+
+#define DR_LOCAL_ENABLE_MASK (0x55)  /* Set  local bits for all 4 regs */
+#define DR_GLOBAL_ENABLE_MASK (0xAA) /* Set global bits for all 4 regs */
+
+/* The second byte to the control register has a few special things.
+   We can slow the instruction pipeline for instructions coming via the
+   gdt or the ldt if we want to.  I am not sure why this is an advantage */
+
+#define DR_CONTROL_RESERVED (0xFFFFFFFF0000FC00UL) /* Reserved */
+#define DR_LOCAL_SLOWDOWN (0x100)   /* Local slow the pipeline */
+#define DR_GLOBAL_SLOWDOWN (0x200)  /* Global slow the pipeline */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/delay.h linux-2.6.20-sabayon-r1/include/asm/delay.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/delay.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/delay.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,30 @@
+#ifndef _X8664_DELAY_H
+#define _X8664_DELAY_H
+
+/*
+ * Copyright (C) 1993 Linus Torvalds
+ *
+ * Delay routines calling functions in arch/x86_64/lib/delay.c
+ */
+ 
+/* Undefined functions to get compile-time errors */
+extern void __bad_udelay(void);
+extern void __bad_ndelay(void);
+
+extern void __udelay(unsigned long usecs);
+extern void __ndelay(unsigned long nsecs);
+extern void __const_udelay(unsigned long usecs);
+extern void __delay(unsigned long loops);
+
+/* 0x10c7 is 2**32 / 1000000 (rounded up) */
+#define udelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 0x10c7ul)) : \
+	__udelay(n))
+
+/* 0x5 is 2**32 / 1000000000 (rounded up) */
+#define ndelay(n) (__builtin_constant_p(n) ? \
+       ((n) > 20000 ? __bad_ndelay() : __const_udelay((n) * 5ul)) : \
+       __ndelay(n))
+
+
+#endif /* defined(_X8664_DELAY_H) */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/desc_defs.h linux-2.6.20-sabayon-r1/include/asm/desc_defs.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/desc_defs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/desc_defs.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,69 @@
+/* Written 2000 by Andi Kleen */
+#ifndef __ARCH_DESC_DEFS_H
+#define __ARCH_DESC_DEFS_H
+
+/*
+ * Segment descriptor structure definitions, usable from both x86_64 and i386
+ * archs.
+ */
+
+#ifndef __ASSEMBLY__
+
+#include <linux/types.h>
+
+// 8 byte segment descriptor
+struct desc_struct {
+	u16 limit0;
+	u16 base0;
+	unsigned base1 : 8, type : 4, s : 1, dpl : 2, p : 1;
+	unsigned limit : 4, avl : 1, l : 1, d : 1, g : 1, base2 : 8;
+} __attribute__((packed));
+
+struct n_desc_struct {
+	unsigned int a,b;
+};
+
+enum {
+	GATE_INTERRUPT = 0xE,
+	GATE_TRAP = 0xF,
+	GATE_CALL = 0xC,
+};
+
+// 16byte gate
+struct gate_struct {
+	u16 offset_low;
+	u16 segment;
+	unsigned ist : 3, zero0 : 5, type : 5, dpl : 2, p : 1;
+	u16 offset_middle;
+	u32 offset_high;
+	u32 zero1;
+} __attribute__((packed));
+
+#define PTR_LOW(x) ((unsigned long)(x) & 0xFFFF)
+#define PTR_MIDDLE(x) (((unsigned long)(x) >> 16) & 0xFFFF)
+#define PTR_HIGH(x) ((unsigned long)(x) >> 32)
+
+enum {
+	DESC_TSS = 0x9,
+	DESC_LDT = 0x2,
+};
+
+// LDT or TSS descriptor in the GDT. 16 bytes.
+struct ldttss_desc {
+	u16 limit0;
+	u16 base0;
+	unsigned base1 : 8, type : 5, dpl : 2, p : 1;
+	unsigned limit1 : 4, zero0 : 3, g : 1, base2 : 8;
+	u32 base3;
+	u32 zero1;
+} __attribute__((packed));
+
+struct desc_ptr {
+	unsigned short size;
+	unsigned long address;
+} __attribute__((packed)) ;
+
+
+#endif /* !__ASSEMBLY__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/desc.h linux-2.6.20-sabayon-r1/include/asm/desc.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/desc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/desc.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,187 @@
+/* Written 2000 by Andi Kleen */ 
+#ifndef __ARCH_DESC_H
+#define __ARCH_DESC_H
+
+#include <linux/threads.h>
+#include <asm/ldt.h>
+
+#ifndef __ASSEMBLY__
+
+#include <linux/string.h>
+#include <linux/smp.h>
+#include <asm/desc_defs.h>
+
+#include <asm/segment.h>
+#include <asm/mmu.h>
+
+extern struct desc_struct cpu_gdt_table[GDT_ENTRIES];
+
+#define load_TR_desc() asm volatile("ltr %w0"::"r" (GDT_ENTRY_TSS*8))
+#define load_LDT_desc() asm volatile("lldt %w0"::"r" (GDT_ENTRY_LDT*8))
+#define clear_LDT()  asm volatile("lldt %w0"::"r" (0))
+
+/*
+ * This is the ldt that every process will get unless we need
+ * something other than this.
+ */
+extern struct desc_struct default_ldt[];
+extern struct gate_struct idt_table[]; 
+extern struct desc_ptr cpu_gdt_descr[];
+
+/* the cpu gdt accessor */
+#define cpu_gdt(_cpu) ((struct desc_struct *)cpu_gdt_descr[_cpu].address)
+
+static inline void _set_gate(void *adr, unsigned type, unsigned long func, unsigned dpl, unsigned ist)  
+{
+	struct gate_struct s; 	
+	s.offset_low = PTR_LOW(func); 
+	s.segment = __KERNEL_CS;
+	s.ist = ist; 
+	s.p = 1;
+	s.dpl = dpl; 
+	s.zero0 = 0;
+	s.zero1 = 0; 
+	s.type = type; 
+	s.offset_middle = PTR_MIDDLE(func); 
+	s.offset_high = PTR_HIGH(func); 
+	/* does not need to be atomic because it is only done once at setup time */ 
+	memcpy(adr, &s, 16); 
+} 
+
+static inline void set_intr_gate(int nr, void *func) 
+{ 
+	BUG_ON((unsigned)nr > 0xFF);
+	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 0, 0); 
+} 
+
+static inline void set_intr_gate_ist(int nr, void *func, unsigned ist) 
+{ 
+	BUG_ON((unsigned)nr > 0xFF);
+	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 0, ist); 
+} 
+
+static inline void set_system_gate(int nr, void *func) 
+{ 
+	BUG_ON((unsigned)nr > 0xFF);
+	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 3, 0); 
+} 
+
+static inline void set_system_gate_ist(int nr, void *func, unsigned ist)
+{
+	_set_gate(&idt_table[nr], GATE_INTERRUPT, (unsigned long) func, 3, ist);
+}
+
+static inline void set_tssldt_descriptor(void *ptr, unsigned long tss, unsigned type, 
+					 unsigned size) 
+{ 
+	struct ldttss_desc d;
+	memset(&d,0,sizeof(d)); 
+	d.limit0 = size & 0xFFFF;
+	d.base0 = PTR_LOW(tss); 
+	d.base1 = PTR_MIDDLE(tss) & 0xFF; 
+	d.type = type;
+	d.p = 1; 
+	d.limit1 = (size >> 16) & 0xF;
+	d.base2 = (PTR_MIDDLE(tss) >> 8) & 0xFF; 
+	d.base3 = PTR_HIGH(tss); 
+	memcpy(ptr, &d, 16); 
+}
+
+static inline void set_tss_desc(unsigned cpu, void *addr)
+{ 
+	/*
+	 * sizeof(unsigned long) coming from an extra "long" at the end
+	 * of the iobitmap. See tss_struct definition in processor.h
+	 *
+	 * -1? seg base+limit should be pointing to the address of the
+	 * last valid byte
+	 */
+	set_tssldt_descriptor(&cpu_gdt(cpu)[GDT_ENTRY_TSS],
+		(unsigned long)addr, DESC_TSS,
+		IO_BITMAP_OFFSET + IO_BITMAP_BYTES + sizeof(unsigned long) - 1);
+} 
+
+static inline void set_ldt_desc(unsigned cpu, void *addr, int size)
+{ 
+	set_tssldt_descriptor(&cpu_gdt(cpu)[GDT_ENTRY_LDT], (unsigned long)addr,
+			      DESC_LDT, size * 8 - 1);
+}
+
+static inline void set_seg_base(unsigned cpu, int entry, void *base)
+{ 
+	struct desc_struct *d = &cpu_gdt(cpu)[entry];
+	u32 addr = (u32)(u64)base;
+	BUG_ON((u64)base >> 32); 
+	d->base0 = addr & 0xffff;
+	d->base1 = (addr >> 16) & 0xff;
+	d->base2 = (addr >> 24) & 0xff;
+} 
+
+#define LDT_entry_a(info) \
+	((((info)->base_addr & 0x0000ffff) << 16) | ((info)->limit & 0x0ffff))
+/* Don't allow setting of the lm bit. It is useless anyways because 
+   64bit system calls require __USER_CS. */ 
+#define LDT_entry_b(info) \
+	(((info)->base_addr & 0xff000000) | \
+	(((info)->base_addr & 0x00ff0000) >> 16) | \
+	((info)->limit & 0xf0000) | \
+	(((info)->read_exec_only ^ 1) << 9) | \
+	((info)->contents << 10) | \
+	(((info)->seg_not_present ^ 1) << 15) | \
+	((info)->seg_32bit << 22) | \
+	((info)->limit_in_pages << 23) | \
+	((info)->useable << 20) | \
+	/* ((info)->lm << 21) | */ \
+	0x7000)
+
+#define LDT_empty(info) (\
+	(info)->base_addr	== 0	&& \
+	(info)->limit		== 0	&& \
+	(info)->contents	== 0	&& \
+	(info)->read_exec_only	== 1	&& \
+	(info)->seg_32bit	== 0	&& \
+	(info)->limit_in_pages	== 0	&& \
+	(info)->seg_not_present	== 1	&& \
+	(info)->useable		== 0	&& \
+	(info)->lm		== 0)
+
+#if TLS_SIZE != 24
+# error update this code.
+#endif
+
+static inline void load_TLS(struct thread_struct *t, unsigned int cpu)
+{
+	u64 *gdt = (u64 *)(cpu_gdt(cpu) + GDT_ENTRY_TLS_MIN);
+	gdt[0] = t->tls_array[0];
+	gdt[1] = t->tls_array[1];
+	gdt[2] = t->tls_array[2];
+} 
+
+/*
+ * load one particular LDT into the current CPU
+ */
+static inline void load_LDT_nolock (mm_context_t *pc, int cpu)
+{
+	int count = pc->size;
+
+	if (likely(!count)) {
+		clear_LDT();
+		return;
+	}
+		
+	set_ldt_desc(cpu, pc->ldt, count);
+	load_LDT_desc();
+}
+
+static inline void load_LDT(mm_context_t *pc)
+{
+	int cpu = get_cpu();
+	load_LDT_nolock(pc, cpu);
+	put_cpu();
+}
+
+extern struct desc_ptr idt_descr;
+
+#endif /* !__ASSEMBLY__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/device.h linux-2.6.20-sabayon-r1/include/asm/device.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/device.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/device.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,15 @@
+/*
+ * Arch specific extensions to struct device
+ *
+ * This file is released under the GPLv2
+ */
+#ifndef _ASM_X86_64_DEVICE_H
+#define _ASM_X86_64_DEVICE_H
+
+struct dev_archdata {
+#ifdef CONFIG_ACPI
+	void	*acpi_handle;
+#endif
+};
+
+#endif /* _ASM_X86_64_DEVICE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/div64.h linux-2.6.20-sabayon-r1/include/asm/div64.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/div64.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/div64.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-generic/div64.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/dma.h linux-2.6.20-sabayon-r1/include/asm/dma.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/dma.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/dma.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,304 @@
+/*
+ * linux/include/asm/dma.h: Defines for using and allocating dma channels.
+ * Written by Hennus Bergman, 1992.
+ * High DMA channel support & info by Hannu Savolainen
+ * and John Boyd, Nov. 1992.
+ */
+
+#ifndef _ASM_DMA_H
+#define _ASM_DMA_H
+
+#include <linux/spinlock.h>	/* And spinlocks */
+#include <asm/io.h>		/* need byte IO */
+#include <linux/delay.h>
+
+
+#ifdef HAVE_REALLY_SLOW_DMA_CONTROLLER
+#define dma_outb	outb_p
+#else
+#define dma_outb	outb
+#endif
+
+#define dma_inb		inb
+
+/*
+ * NOTES about DMA transfers:
+ *
+ *  controller 1: channels 0-3, byte operations, ports 00-1F
+ *  controller 2: channels 4-7, word operations, ports C0-DF
+ *
+ *  - ALL registers are 8 bits only, regardless of transfer size
+ *  - channel 4 is not used - cascades 1 into 2.
+ *  - channels 0-3 are byte - addresses/counts are for physical bytes
+ *  - channels 5-7 are word - addresses/counts are for physical words
+ *  - transfers must not cross physical 64K (0-3) or 128K (5-7) boundaries
+ *  - transfer count loaded to registers is 1 less than actual count
+ *  - controller 2 offsets are all even (2x offsets for controller 1)
+ *  - page registers for 5-7 don't use data bit 0, represent 128K pages
+ *  - page registers for 0-3 use bit 0, represent 64K pages
+ *
+ * DMA transfers are limited to the lower 16MB of _physical_ memory.  
+ * Note that addresses loaded into registers must be _physical_ addresses,
+ * not logical addresses (which may differ if paging is active).
+ *
+ *  Address mapping for channels 0-3:
+ *
+ *   A23 ... A16 A15 ... A8  A7 ... A0    (Physical addresses)
+ *    |  ...  |   |  ... |   |  ... |
+ *    |  ...  |   |  ... |   |  ... |
+ *    |  ...  |   |  ... |   |  ... |
+ *   P7  ...  P0  A7 ... A0  A7 ... A0   
+ * |    Page    | Addr MSB | Addr LSB |   (DMA registers)
+ *
+ *  Address mapping for channels 5-7:
+ *
+ *   A23 ... A17 A16 A15 ... A9 A8 A7 ... A1 A0    (Physical addresses)
+ *    |  ...  |   \   \   ... \  \  \  ... \  \
+ *    |  ...  |    \   \   ... \  \  \  ... \  (not used)
+ *    |  ...  |     \   \   ... \  \  \  ... \
+ *   P7  ...  P1 (0) A7 A6  ... A0 A7 A6 ... A0   
+ * |      Page      |  Addr MSB   |  Addr LSB  |   (DMA registers)
+ *
+ * Again, channels 5-7 transfer _physical_ words (16 bits), so addresses
+ * and counts _must_ be word-aligned (the lowest address bit is _ignored_ at
+ * the hardware level, so odd-byte transfers aren't possible).
+ *
+ * Transfer count (_not # bytes_) is limited to 64K, represented as actual
+ * count - 1 : 64K => 0xFFFF, 1 => 0x0000.  Thus, count is always 1 or more,
+ * and up to 128K bytes may be transferred on channels 5-7 in one operation. 
+ *
+ */
+
+#define MAX_DMA_CHANNELS	8
+
+
+/* 16MB ISA DMA zone */
+#define MAX_DMA_PFN   ((16*1024*1024) >> PAGE_SHIFT)
+
+/* 4GB broken PCI/AGP hardware bus master zone */
+#define MAX_DMA32_PFN ((4UL*1024*1024*1024) >> PAGE_SHIFT)
+
+/* Compat define for old dma zone */
+#define MAX_DMA_ADDRESS ((unsigned long)__va(MAX_DMA_PFN << PAGE_SHIFT))
+
+/* 8237 DMA controllers */
+#define IO_DMA1_BASE	0x00	/* 8 bit slave DMA, channels 0..3 */
+#define IO_DMA2_BASE	0xC0	/* 16 bit master DMA, ch 4(=slave input)..7 */
+
+/* DMA controller registers */
+#define DMA1_CMD_REG		0x08	/* command register (w) */
+#define DMA1_STAT_REG		0x08	/* status register (r) */
+#define DMA1_REQ_REG            0x09    /* request register (w) */
+#define DMA1_MASK_REG		0x0A	/* single-channel mask (w) */
+#define DMA1_MODE_REG		0x0B	/* mode register (w) */
+#define DMA1_CLEAR_FF_REG	0x0C	/* clear pointer flip-flop (w) */
+#define DMA1_TEMP_REG           0x0D    /* Temporary Register (r) */
+#define DMA1_RESET_REG		0x0D	/* Master Clear (w) */
+#define DMA1_CLR_MASK_REG       0x0E    /* Clear Mask */
+#define DMA1_MASK_ALL_REG       0x0F    /* all-channels mask (w) */
+
+#define DMA2_CMD_REG		0xD0	/* command register (w) */
+#define DMA2_STAT_REG		0xD0	/* status register (r) */
+#define DMA2_REQ_REG            0xD2    /* request register (w) */
+#define DMA2_MASK_REG		0xD4	/* single-channel mask (w) */
+#define DMA2_MODE_REG		0xD6	/* mode register (w) */
+#define DMA2_CLEAR_FF_REG	0xD8	/* clear pointer flip-flop (w) */
+#define DMA2_TEMP_REG           0xDA    /* Temporary Register (r) */
+#define DMA2_RESET_REG		0xDA	/* Master Clear (w) */
+#define DMA2_CLR_MASK_REG       0xDC    /* Clear Mask */
+#define DMA2_MASK_ALL_REG       0xDE    /* all-channels mask (w) */
+
+#define DMA_ADDR_0              0x00    /* DMA address registers */
+#define DMA_ADDR_1              0x02
+#define DMA_ADDR_2              0x04
+#define DMA_ADDR_3              0x06
+#define DMA_ADDR_4              0xC0
+#define DMA_ADDR_5              0xC4
+#define DMA_ADDR_6              0xC8
+#define DMA_ADDR_7              0xCC
+
+#define DMA_CNT_0               0x01    /* DMA count registers */
+#define DMA_CNT_1               0x03
+#define DMA_CNT_2               0x05
+#define DMA_CNT_3               0x07
+#define DMA_CNT_4               0xC2
+#define DMA_CNT_5               0xC6
+#define DMA_CNT_6               0xCA
+#define DMA_CNT_7               0xCE
+
+#define DMA_PAGE_0              0x87    /* DMA page registers */
+#define DMA_PAGE_1              0x83
+#define DMA_PAGE_2              0x81
+#define DMA_PAGE_3              0x82
+#define DMA_PAGE_5              0x8B
+#define DMA_PAGE_6              0x89
+#define DMA_PAGE_7              0x8A
+
+#define DMA_MODE_READ	0x44	/* I/O to memory, no autoinit, increment, single mode */
+#define DMA_MODE_WRITE	0x48	/* memory to I/O, no autoinit, increment, single mode */
+#define DMA_MODE_CASCADE 0xC0   /* pass thru DREQ->HRQ, DACK<-HLDA only */
+
+#define DMA_AUTOINIT	0x10
+
+
+extern spinlock_t  dma_spin_lock;
+
+static __inline__ unsigned long claim_dma_lock(void)
+{
+	unsigned long flags;
+	spin_lock_irqsave(&dma_spin_lock, flags);
+	return flags;
+}
+
+static __inline__ void release_dma_lock(unsigned long flags)
+{
+	spin_unlock_irqrestore(&dma_spin_lock, flags);
+}
+
+/* enable/disable a specific DMA channel */
+static __inline__ void enable_dma(unsigned int dmanr)
+{
+	if (dmanr<=3)
+		dma_outb(dmanr,  DMA1_MASK_REG);
+	else
+		dma_outb(dmanr & 3,  DMA2_MASK_REG);
+}
+
+static __inline__ void disable_dma(unsigned int dmanr)
+{
+	if (dmanr<=3)
+		dma_outb(dmanr | 4,  DMA1_MASK_REG);
+	else
+		dma_outb((dmanr & 3) | 4,  DMA2_MASK_REG);
+}
+
+/* Clear the 'DMA Pointer Flip Flop'.
+ * Write 0 for LSB/MSB, 1 for MSB/LSB access.
+ * Use this once to initialize the FF to a known state.
+ * After that, keep track of it. :-)
+ * --- In order to do that, the DMA routines below should ---
+ * --- only be used while holding the DMA lock ! ---
+ */
+static __inline__ void clear_dma_ff(unsigned int dmanr)
+{
+	if (dmanr<=3)
+		dma_outb(0,  DMA1_CLEAR_FF_REG);
+	else
+		dma_outb(0,  DMA2_CLEAR_FF_REG);
+}
+
+/* set mode (above) for a specific DMA channel */
+static __inline__ void set_dma_mode(unsigned int dmanr, char mode)
+{
+	if (dmanr<=3)
+		dma_outb(mode | dmanr,  DMA1_MODE_REG);
+	else
+		dma_outb(mode | (dmanr&3),  DMA2_MODE_REG);
+}
+
+/* Set only the page register bits of the transfer address.
+ * This is used for successive transfers when we know the contents of
+ * the lower 16 bits of the DMA current address register, but a 64k boundary
+ * may have been crossed.
+ */
+static __inline__ void set_dma_page(unsigned int dmanr, char pagenr)
+{
+	switch(dmanr) {
+		case 0:
+			dma_outb(pagenr, DMA_PAGE_0);
+			break;
+		case 1:
+			dma_outb(pagenr, DMA_PAGE_1);
+			break;
+		case 2:
+			dma_outb(pagenr, DMA_PAGE_2);
+			break;
+		case 3:
+			dma_outb(pagenr, DMA_PAGE_3);
+			break;
+		case 5:
+			dma_outb(pagenr & 0xfe, DMA_PAGE_5);
+			break;
+		case 6:
+			dma_outb(pagenr & 0xfe, DMA_PAGE_6);
+			break;
+		case 7:
+			dma_outb(pagenr & 0xfe, DMA_PAGE_7);
+			break;
+	}
+}
+
+
+/* Set transfer address & page bits for specific DMA channel.
+ * Assumes dma flipflop is clear.
+ */
+static __inline__ void set_dma_addr(unsigned int dmanr, unsigned int a)
+{
+	set_dma_page(dmanr, a>>16);
+	if (dmanr <= 3)  {
+	    dma_outb( a & 0xff, ((dmanr&3)<<1) + IO_DMA1_BASE );
+            dma_outb( (a>>8) & 0xff, ((dmanr&3)<<1) + IO_DMA1_BASE );
+	}  else  {
+	    dma_outb( (a>>1) & 0xff, ((dmanr&3)<<2) + IO_DMA2_BASE );
+	    dma_outb( (a>>9) & 0xff, ((dmanr&3)<<2) + IO_DMA2_BASE );
+	}
+}
+
+
+/* Set transfer size (max 64k for DMA1..3, 128k for DMA5..7) for
+ * a specific DMA channel.
+ * You must ensure the parameters are valid.
+ * NOTE: from a manual: "the number of transfers is one more
+ * than the initial word count"! This is taken into account.
+ * Assumes dma flip-flop is clear.
+ * NOTE 2: "count" represents _bytes_ and must be even for channels 5-7.
+ */
+static __inline__ void set_dma_count(unsigned int dmanr, unsigned int count)
+{
+        count--;
+	if (dmanr <= 3)  {
+	    dma_outb( count & 0xff, ((dmanr&3)<<1) + 1 + IO_DMA1_BASE );
+	    dma_outb( (count>>8) & 0xff, ((dmanr&3)<<1) + 1 + IO_DMA1_BASE );
+        } else {
+	    dma_outb( (count>>1) & 0xff, ((dmanr&3)<<2) + 2 + IO_DMA2_BASE );
+	    dma_outb( (count>>9) & 0xff, ((dmanr&3)<<2) + 2 + IO_DMA2_BASE );
+        }
+}
+
+
+/* Get DMA residue count. After a DMA transfer, this
+ * should return zero. Reading this while a DMA transfer is
+ * still in progress will return unpredictable results.
+ * If called before the channel has been used, it may return 1.
+ * Otherwise, it returns the number of _bytes_ left to transfer.
+ *
+ * Assumes DMA flip-flop is clear.
+ */
+static __inline__ int get_dma_residue(unsigned int dmanr)
+{
+	unsigned int io_port = (dmanr<=3)? ((dmanr&3)<<1) + 1 + IO_DMA1_BASE
+					 : ((dmanr&3)<<2) + 2 + IO_DMA2_BASE;
+
+	/* using short to get 16-bit wrap around */
+	unsigned short count;
+
+	count = 1 + dma_inb(io_port);
+	count += dma_inb(io_port) << 8;
+	
+	return (dmanr<=3)? count : (count<<1);
+}
+
+
+/* These are in kernel/dma.c: */
+extern int request_dma(unsigned int dmanr, const char * device_id);	/* reserve a DMA channel */
+extern void free_dma(unsigned int dmanr);	/* release it again */
+
+/* From PCI */
+
+#ifdef CONFIG_PCI
+extern int isa_dma_bridge_buggy;
+#else
+#define isa_dma_bridge_buggy 	(0)
+#endif
+
+#endif /* _ASM_DMA_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/dma-mapping.h linux-2.6.20-sabayon-r1/include/asm/dma-mapping.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/dma-mapping.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/dma-mapping.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,200 @@
+#ifndef _X8664_DMA_MAPPING_H
+#define _X8664_DMA_MAPPING_H 1
+
+/*
+ * IOMMU interface. See Documentation/DMA-mapping.txt and DMA-API.txt for
+ * documentation.
+ */
+
+
+#include <asm/scatterlist.h>
+#include <asm/io.h>
+#include <asm/swiotlb.h>
+
+struct dma_mapping_ops {
+	int             (*mapping_error)(dma_addr_t dma_addr);
+	void*           (*alloc_coherent)(struct device *dev, size_t size,
+                                dma_addr_t *dma_handle, gfp_t gfp);
+	void            (*free_coherent)(struct device *dev, size_t size,
+                                void *vaddr, dma_addr_t dma_handle);
+	dma_addr_t      (*map_single)(struct device *hwdev, void *ptr,
+                                size_t size, int direction);
+	/* like map_single, but doesn't check the device mask */
+	dma_addr_t      (*map_simple)(struct device *hwdev, char *ptr,
+                                size_t size, int direction);
+	void            (*unmap_single)(struct device *dev, dma_addr_t addr,
+		                size_t size, int direction);
+	void            (*sync_single_for_cpu)(struct device *hwdev,
+		                dma_addr_t dma_handle, size_t size,
+				int direction);
+	void            (*sync_single_for_device)(struct device *hwdev,
+                                dma_addr_t dma_handle, size_t size,
+				int direction);
+	void            (*sync_single_range_for_cpu)(struct device *hwdev,
+                                dma_addr_t dma_handle, unsigned long offset,
+		                size_t size, int direction);
+	void            (*sync_single_range_for_device)(struct device *hwdev,
+				dma_addr_t dma_handle, unsigned long offset,
+		                size_t size, int direction);
+	void            (*sync_sg_for_cpu)(struct device *hwdev,
+                                struct scatterlist *sg, int nelems,
+				int direction);
+	void            (*sync_sg_for_device)(struct device *hwdev,
+				struct scatterlist *sg, int nelems,
+				int direction);
+	int             (*map_sg)(struct device *hwdev, struct scatterlist *sg,
+		                int nents, int direction);
+	void            (*unmap_sg)(struct device *hwdev,
+				struct scatterlist *sg, int nents,
+				int direction);
+	int             (*dma_supported)(struct device *hwdev, u64 mask);
+	int		is_phys;
+};
+
+extern dma_addr_t bad_dma_address;
+extern struct dma_mapping_ops* dma_ops;
+extern int iommu_merge;
+
+static inline int dma_mapping_error(dma_addr_t dma_addr)
+{
+	if (dma_ops->mapping_error)
+		return dma_ops->mapping_error(dma_addr);
+
+	return (dma_addr == bad_dma_address);
+}
+
+#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)
+#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)
+
+extern void *dma_alloc_coherent(struct device *dev, size_t size,
+				dma_addr_t *dma_handle, gfp_t gfp);
+extern void dma_free_coherent(struct device *dev, size_t size, void *vaddr,
+			      dma_addr_t dma_handle);
+
+static inline dma_addr_t
+dma_map_single(struct device *hwdev, void *ptr, size_t size,
+	       int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	return dma_ops->map_single(hwdev, ptr, size, direction);
+}
+
+static inline void
+dma_unmap_single(struct device *dev, dma_addr_t addr,size_t size,
+		 int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	dma_ops->unmap_single(dev, addr, size, direction);
+}
+
+#define dma_map_page(dev,page,offset,size,dir) \
+	dma_map_single((dev), page_address(page)+(offset), (size), (dir))
+
+#define dma_unmap_page dma_unmap_single
+
+static inline void
+dma_sync_single_for_cpu(struct device *hwdev, dma_addr_t dma_handle,
+			size_t size, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_single_for_cpu)
+		dma_ops->sync_single_for_cpu(hwdev, dma_handle, size,
+					     direction);
+	flush_write_buffers();
+}
+
+static inline void
+dma_sync_single_for_device(struct device *hwdev, dma_addr_t dma_handle,
+			   size_t size, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_single_for_device)
+		dma_ops->sync_single_for_device(hwdev, dma_handle, size,
+						direction);
+	flush_write_buffers();
+}
+
+static inline void
+dma_sync_single_range_for_cpu(struct device *hwdev, dma_addr_t dma_handle,
+			      unsigned long offset, size_t size, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_single_range_for_cpu) {
+		dma_ops->sync_single_range_for_cpu(hwdev, dma_handle, offset, size, direction);
+	}
+
+	flush_write_buffers();
+}
+
+static inline void
+dma_sync_single_range_for_device(struct device *hwdev, dma_addr_t dma_handle,
+				 unsigned long offset, size_t size, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_single_range_for_device)
+		dma_ops->sync_single_range_for_device(hwdev, dma_handle,
+						      offset, size, direction);
+
+	flush_write_buffers();
+}
+
+static inline void
+dma_sync_sg_for_cpu(struct device *hwdev, struct scatterlist *sg,
+		    int nelems, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_sg_for_cpu)
+		dma_ops->sync_sg_for_cpu(hwdev, sg, nelems, direction);
+	flush_write_buffers();
+}
+
+static inline void
+dma_sync_sg_for_device(struct device *hwdev, struct scatterlist *sg,
+		       int nelems, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	if (dma_ops->sync_sg_for_device) {
+		dma_ops->sync_sg_for_device(hwdev, sg, nelems, direction);
+	}
+
+	flush_write_buffers();
+}
+
+static inline int
+dma_map_sg(struct device *hwdev, struct scatterlist *sg, int nents, int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	return dma_ops->map_sg(hwdev, sg, nents, direction);
+}
+
+static inline void
+dma_unmap_sg(struct device *hwdev, struct scatterlist *sg, int nents,
+	     int direction)
+{
+	BUG_ON(!valid_dma_direction(direction));
+	dma_ops->unmap_sg(hwdev, sg, nents, direction);
+}
+
+extern int dma_supported(struct device *hwdev, u64 mask);
+
+/* same for gart, swiotlb, and nommu */
+static inline int dma_get_cache_alignment(void)
+{
+	return boot_cpu_data.x86_clflush_size;
+}
+
+#define dma_is_consistent(d, h) 1
+
+extern int dma_set_mask(struct device *dev, u64 mask);
+
+static inline void
+dma_cache_sync(struct device *dev, void *vaddr, size_t size,
+	enum dma_data_direction dir)
+{
+	flush_write_buffers();
+}
+
+extern struct device fallback_dev;
+extern int panic_on_overflow;
+
+#endif /* _X8664_DMA_MAPPING_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/dmi.h linux-2.6.20-sabayon-r1/include/asm/dmi.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/dmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/dmi.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef _ASM_DMI_H
+#define _ASM_DMI_H 1
+
+#include <asm/io.h>
+
+extern void *dmi_ioremap(unsigned long addr, unsigned long size);
+extern void dmi_iounmap(void *addr, unsigned long size);
+
+#define DMI_MAX_DATA 2048
+
+extern int dmi_alloc_index;
+extern char dmi_alloc_data[DMI_MAX_DATA];
+
+/* This is so early that there is no good way to allocate dynamic memory. 
+   Allocate data in an BSS array. */
+static inline void *dmi_alloc(unsigned len)
+{
+	int idx = dmi_alloc_index;
+	if ((dmi_alloc_index += len) > DMI_MAX_DATA)
+		return NULL;
+	return dmi_alloc_data + idx;
+}
+
+#define dmi_ioremap early_ioremap
+#define dmi_iounmap early_iounmap
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/dwarf2.h linux-2.6.20-sabayon-r1/include/asm/dwarf2.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/dwarf2.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/dwarf2.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,57 @@
+#ifndef _DWARF2_H
+#define _DWARF2_H 1
+
+
+#ifndef __ASSEMBLY__
+#warning "asm/dwarf2.h should be only included in pure assembly files"
+#endif
+
+/* 
+   Macros for dwarf2 CFI unwind table entries.
+   See "as.info" for details on these pseudo ops. Unfortunately 
+   they are only supported in very new binutils, so define them 
+   away for older version. 
+ */
+
+#ifdef CONFIG_AS_CFI
+
+#define CFI_STARTPROC .cfi_startproc
+#define CFI_ENDPROC .cfi_endproc
+#define CFI_DEF_CFA .cfi_def_cfa
+#define CFI_DEF_CFA_REGISTER .cfi_def_cfa_register
+#define CFI_DEF_CFA_OFFSET .cfi_def_cfa_offset
+#define CFI_ADJUST_CFA_OFFSET .cfi_adjust_cfa_offset
+#define CFI_OFFSET .cfi_offset
+#define CFI_REL_OFFSET .cfi_rel_offset
+#define CFI_REGISTER .cfi_register
+#define CFI_RESTORE .cfi_restore
+#define CFI_REMEMBER_STATE .cfi_remember_state
+#define CFI_RESTORE_STATE .cfi_restore_state
+#define CFI_UNDEFINED .cfi_undefined
+#ifdef CONFIG_AS_CFI_SIGNAL_FRAME
+#define CFI_SIGNAL_FRAME .cfi_signal_frame
+#else
+#define CFI_SIGNAL_FRAME
+#endif
+
+#else
+
+/* use assembler line comment character # to ignore the arguments. */
+#define CFI_STARTPROC	#
+#define CFI_ENDPROC	#
+#define CFI_DEF_CFA	#
+#define CFI_DEF_CFA_REGISTER	#
+#define CFI_DEF_CFA_OFFSET	#
+#define CFI_ADJUST_CFA_OFFSET	#
+#define CFI_OFFSET	#
+#define CFI_REL_OFFSET	#
+#define CFI_REGISTER	#
+#define CFI_RESTORE	#
+#define CFI_REMEMBER_STATE	#
+#define CFI_RESTORE_STATE	#
+#define CFI_UNDEFINED	#
+#define CFI_SIGNAL_FRAME	#
+
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/e820.h linux-2.6.20-sabayon-r1/include/asm/e820.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/e820.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/e820.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,61 @@
+/*
+ * structures and definitions for the int 15, ax=e820 memory map
+ * scheme.
+ *
+ * In a nutshell, setup.S populates a scratch table in the
+ * empty_zero_block that contains a list of usable address/size
+ * duples.  setup.c, this information is transferred into the e820map,
+ * and in init.c/numa.c, that new information is used to mark pages
+ * reserved or not.
+ */
+#ifndef __E820_HEADER
+#define __E820_HEADER
+
+#include <linux/mmzone.h>
+
+#define E820MAP	0x2d0		/* our map */
+#define E820MAX	128		/* number of entries in E820MAP */
+#define E820NR	0x1e8		/* # entries in E820MAP */
+
+#define E820_RAM	1
+#define E820_RESERVED	2
+#define E820_ACPI	3
+#define E820_NVS	4
+
+#ifndef __ASSEMBLY__
+struct e820entry {
+	u64 addr;	/* start of memory segment */
+	u64 size;	/* size of memory segment */
+	u32 type;	/* type of memory segment */
+} __attribute__((packed));
+
+struct e820map {
+    int nr_map;
+	struct e820entry map[E820MAX];
+};
+
+extern unsigned long find_e820_area(unsigned long start, unsigned long end, 
+				    unsigned size);
+extern void add_memory_region(unsigned long start, unsigned long size, 
+			      int type);
+extern void setup_memory_region(void);
+extern void contig_e820_setup(void); 
+extern unsigned long e820_end_of_ram(void);
+extern void e820_reserve_resources(void);
+extern void e820_mark_nosave_regions(void);
+extern void e820_print_map(char *who);
+extern int e820_any_mapped(unsigned long start, unsigned long end, unsigned type);
+extern int e820_all_mapped(unsigned long start, unsigned long end, unsigned type);
+
+extern void e820_setup_gap(void);
+extern void e820_register_active_regions(int nid,
+				unsigned long start_pfn, unsigned long end_pfn);
+
+extern void finish_e820_parsing(void);
+
+extern struct e820map e820;
+
+extern unsigned ebda_addr, ebda_size;
+#endif/*!__ASSEMBLY__*/
+
+#endif/*__E820_HEADER*/
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/edac.h linux-2.6.20-sabayon-r1/include/asm/edac.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/edac.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/edac.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef ASM_EDAC_H
+#define ASM_EDAC_H
+
+/* ECC atomic, DMA, SMP and interrupt safe scrub function */
+
+static __inline__ void atomic_scrub(void *va, u32 size)
+{
+	unsigned int *virt_addr = va;
+	u32 i;
+
+	for (i = 0; i < size / 4; i++, virt_addr++)
+		/* Very carefully read and write to memory atomically
+		 * so we are interrupt, DMA and SMP safe.
+		 */
+		__asm__ __volatile__("lock; addl $0, %0"::"m"(*virt_addr));
+}
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/elf.h linux-2.6.20-sabayon-r1/include/asm/elf.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/elf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/elf.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,167 @@
+#ifndef __ASM_X86_64_ELF_H
+#define __ASM_X86_64_ELF_H
+
+/*
+ * ELF register definitions..
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+
+/* x86-64 relocation types */
+#define R_X86_64_NONE		0	/* No reloc */
+#define R_X86_64_64		1	/* Direct 64 bit  */
+#define R_X86_64_PC32		2	/* PC relative 32 bit signed */
+#define R_X86_64_GOT32		3	/* 32 bit GOT entry */
+#define R_X86_64_PLT32		4	/* 32 bit PLT address */
+#define R_X86_64_COPY		5	/* Copy symbol at runtime */
+#define R_X86_64_GLOB_DAT	6	/* Create GOT entry */
+#define R_X86_64_JUMP_SLOT	7	/* Create PLT entry */
+#define R_X86_64_RELATIVE	8	/* Adjust by program base */
+#define R_X86_64_GOTPCREL	9	/* 32 bit signed pc relative
+					   offset to GOT */
+#define R_X86_64_32		10	/* Direct 32 bit zero extended */
+#define R_X86_64_32S		11	/* Direct 32 bit sign extended */
+#define R_X86_64_16		12	/* Direct 16 bit zero extended */
+#define R_X86_64_PC16		13	/* 16 bit sign extended pc relative */
+#define R_X86_64_8		14	/* Direct 8 bit sign extended  */
+#define R_X86_64_PC8		15	/* 8 bit sign extended pc relative */
+
+#define R_X86_64_NUM		16
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG (sizeof (struct user_regs_struct) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+typedef struct user_i387_struct elf_fpregset_t;
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS64
+#define ELF_DATA	ELFDATA2LSB
+#define ELF_ARCH	EM_X86_64
+
+#ifdef __KERNEL__
+#include <asm/processor.h>
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) \
+	((x)->e_machine == EM_X86_64)
+
+
+/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program starts %edx
+   contains a pointer to a function which might be registered using `atexit'.
+   This provides a mean for the dynamic linker to call DT_FINI functions for
+   shared libraries that have been loaded before the code runs.
+
+   A value of 0 tells we have no such handler. 
+
+   We might as well make sure everything else is cleared too (except for %esp),
+   just to make things more deterministic.
+ */
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
+	struct task_struct *cur = current; \
+	(_r)->rbx = 0; (_r)->rcx = 0; (_r)->rdx = 0; \
+	(_r)->rsi = 0; (_r)->rdi = 0; (_r)->rbp = 0; \
+	(_r)->rax = 0;				\
+	(_r)->r8 = 0;				\
+	(_r)->r9 = 0;				\
+	(_r)->r10 = 0;				\
+	(_r)->r11 = 0;				\
+	(_r)->r12 = 0;				\
+	(_r)->r13 = 0;				\
+	(_r)->r14 = 0;				\
+	(_r)->r15 = 0;				\
+        cur->thread.fs = 0; cur->thread.gs = 0; \
+	cur->thread.fsindex = 0; cur->thread.gsindex = 0; \
+        cur->thread.ds = 0; cur->thread.es = 0;  \
+	clear_thread_flag(TIF_IA32); \
+} while (0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         (2 * TASK_SIZE / 3)
+
+/* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
+   now struct_user_regs, they are different). Assumes current is the process
+   getting dumped. */
+
+#define ELF_CORE_COPY_REGS(pr_reg, regs)  do { \
+	unsigned v;						\
+	(pr_reg)[0] = (regs)->r15;				\
+	(pr_reg)[1] = (regs)->r14;				\
+	(pr_reg)[2] = (regs)->r13;				\
+	(pr_reg)[3] = (regs)->r12;				\
+	(pr_reg)[4] = (regs)->rbp;				\
+	(pr_reg)[5] = (regs)->rbx;				\
+	(pr_reg)[6] = (regs)->r11;				\
+	(pr_reg)[7] = (regs)->r10;				\
+	(pr_reg)[8] = (regs)->r9;				\
+	(pr_reg)[9] = (regs)->r8;				\
+	(pr_reg)[10] = (regs)->rax;				\
+	(pr_reg)[11] = (regs)->rcx;				\
+	(pr_reg)[12] = (regs)->rdx;				\
+	(pr_reg)[13] = (regs)->rsi;				\
+	(pr_reg)[14] = (regs)->rdi;				\
+	(pr_reg)[15] = (regs)->orig_rax;			\
+	(pr_reg)[16] = (regs)->rip;			\
+	(pr_reg)[17] = (regs)->cs;			\
+	(pr_reg)[18] = (regs)->eflags;			\
+	(pr_reg)[19] = (regs)->rsp;			\
+	(pr_reg)[20] = (regs)->ss;			\
+	(pr_reg)[21] = current->thread.fs;			\
+	(pr_reg)[22] = current->thread.gs;			\
+	asm("movl %%ds,%0" : "=r" (v)); (pr_reg)[23] = v;	\
+	asm("movl %%es,%0" : "=r" (v)); (pr_reg)[24] = v;	\
+	asm("movl %%fs,%0" : "=r" (v)); (pr_reg)[25] = v;	\
+	asm("movl %%gs,%0" : "=r" (v)); (pr_reg)[26] = v;	\
+} while(0);
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this CPU supports.  This could be done in user space,
+   but it's not easy, and we've already done it here.  */
+
+#define ELF_HWCAP	(boot_cpu_data.x86_capability[0])
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.
+
+   For the moment, we have only optimizations for the Intel generations,
+   but that could change... */
+
+/* I'm not sure if we can use '-' here */
+#define ELF_PLATFORM  ("x86_64")
+
+extern void set_personality_64bit(void);
+#define SET_PERSONALITY(ex, ibcs2) set_personality_64bit()
+/*
+ * An executable for which elf_read_implies_exec() returns TRUE will
+ * have the READ_IMPLIES_EXEC personality flag set automatically.
+ */
+#define elf_read_implies_exec(ex, executable_stack)	(executable_stack != EXSTACK_DISABLE_X)
+
+struct task_struct;
+
+extern int dump_task_regs (struct task_struct *, elf_gregset_t *);
+extern int dump_task_fpu (struct task_struct *, elf_fpregset_t *);
+
+#define ELF_CORE_COPY_TASK_REGS(tsk, elf_regs) dump_task_regs(tsk, elf_regs)
+#define ELF_CORE_COPY_FPREGS(tsk, elf_fpregs) dump_task_fpu(tsk, elf_fpregs)
+
+/* 1GB for 64bit, 8MB for 32bit */
+#define STACK_RND_MASK (test_thread_flag(TIF_IA32) ? 0x7ff : 0x3fffff)
+
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/emergency-restart.h linux-2.6.20-sabayon-r1/include/asm/emergency-restart.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/emergency-restart.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/emergency-restart.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _ASM_EMERGENCY_RESTART_H
+#define _ASM_EMERGENCY_RESTART_H
+
+extern void machine_emergency_restart(void);
+
+#endif /* _ASM_EMERGENCY_RESTART_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/errno.h linux-2.6.20-sabayon-r1/include/asm/errno.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/errno.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/errno.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _X8664_ERRNO_H
+#define _X8664_ERRNO_H
+
+#include <asm-generic/errno.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/fcntl.h linux-2.6.20-sabayon-r1/include/asm/fcntl.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/fcntl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/fcntl.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-generic/fcntl.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/fixmap.h linux-2.6.20-sabayon-r1/include/asm/fixmap.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/fixmap.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/fixmap.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,91 @@
+/*
+ * fixmap.h: compile-time virtual memory allocation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1998 Ingo Molnar
+ */
+
+#ifndef _ASM_FIXMAP_H
+#define _ASM_FIXMAP_H
+
+#include <linux/kernel.h>
+#include <asm/apicdef.h>
+#include <asm/page.h>
+#include <asm/vsyscall.h>
+#include <asm/vsyscall32.h>
+
+/*
+ * Here we define all the compile-time 'special' virtual
+ * addresses. The point is to have a constant address at
+ * compile time, but to set the physical address only
+ * in the boot process.
+ *
+ * these 'compile-time allocated' memory buffers are
+ * fixed-size 4k pages. (or larger if used with an increment
+ * highger than 1) use fixmap_set(idx,phys) to associate
+ * physical memory with fixmap indices.
+ *
+ * TLB entries of such buffers will not be flushed across
+ * task switches.
+ */
+
+enum fixed_addresses {
+	VSYSCALL_LAST_PAGE,
+	VSYSCALL_FIRST_PAGE = VSYSCALL_LAST_PAGE + ((VSYSCALL_END-VSYSCALL_START) >> PAGE_SHIFT) - 1,
+	VSYSCALL_HPET,
+	FIX_HPET_BASE,
+	FIX_APIC_BASE,	/* local (CPU) APIC) -- required for SMP or not */
+	FIX_IO_APIC_BASE_0,
+	FIX_IO_APIC_BASE_END = FIX_IO_APIC_BASE_0 + MAX_IO_APICS-1,
+	__end_of_fixed_addresses
+};
+
+extern void __set_fixmap (enum fixed_addresses idx,
+					unsigned long phys, pgprot_t flags);
+
+#define set_fixmap(idx, phys) \
+		__set_fixmap(idx, phys, PAGE_KERNEL)
+/*
+ * Some hardware wants to get fixmapped without caching.
+ */
+#define set_fixmap_nocache(idx, phys) \
+		__set_fixmap(idx, phys, PAGE_KERNEL_NOCACHE)
+
+#define FIXADDR_TOP	(VSYSCALL_END-PAGE_SIZE)
+#define FIXADDR_SIZE	(__end_of_fixed_addresses << PAGE_SHIFT)
+#define FIXADDR_START	(FIXADDR_TOP - FIXADDR_SIZE)
+
+/* Only covers 32bit vsyscalls currently. Need another set for 64bit. */
+#define FIXADDR_USER_START	((unsigned long)VSYSCALL32_VSYSCALL)
+#define FIXADDR_USER_END	(FIXADDR_USER_START + PAGE_SIZE)
+
+#define __fix_to_virt(x)	(FIXADDR_TOP - ((x) << PAGE_SHIFT))
+
+extern void __this_fixmap_does_not_exist(void);
+
+/*
+ * 'index to address' translation. If anyone tries to use the idx
+ * directly without translation, we catch the bug with a NULL-deference
+ * kernel oops. Illegal ranges of incoming indices are caught too.
+ */
+static __always_inline unsigned long fix_to_virt(const unsigned int idx)
+{
+	/*
+	 * this branch gets completely eliminated after inlining,
+	 * except when someone tries to use fixaddr indices in an
+	 * illegal way. (such as mixing up address types or using
+	 * out-of-range indices).
+	 *
+	 * If it doesn't get removed, the linker will complain
+	 * loudly with a reasonably clear error message..
+	 */
+	if (idx >= __end_of_fixed_addresses)
+		__this_fixmap_does_not_exist();
+
+        return __fix_to_virt(idx);
+}
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/floppy.h linux-2.6.20-sabayon-r1/include/asm/floppy.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/floppy.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/floppy.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,283 @@
+/*
+ * Architecture specific parts of the Floppy driver
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995
+ */
+#ifndef __ASM_X86_64_FLOPPY_H
+#define __ASM_X86_64_FLOPPY_H
+
+#include <linux/vmalloc.h>
+
+
+/*
+ * The DMA channel used by the floppy controller cannot access data at
+ * addresses >= 16MB
+ *
+ * Went back to the 1MB limit, as some people had problems with the floppy
+ * driver otherwise. It doesn't matter much for performance anyway, as most
+ * floppy accesses go through the track buffer.
+ */
+#define _CROSS_64KB(a,s,vdma) \
+(!(vdma) && ((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64))
+
+#define CROSS_64KB(a,s) _CROSS_64KB(a,s,use_virtual_dma & 1)
+
+
+#define SW fd_routine[use_virtual_dma&1]
+#define CSW fd_routine[can_use_virtual_dma & 1]
+
+
+#define fd_inb(port)			inb_p(port)
+#define fd_outb(value,port)		outb_p(value,port)
+
+#define fd_request_dma()        CSW._request_dma(FLOPPY_DMA,"floppy")
+#define fd_free_dma()           CSW._free_dma(FLOPPY_DMA)
+#define fd_enable_irq()         enable_irq(FLOPPY_IRQ)
+#define fd_disable_irq()        disable_irq(FLOPPY_IRQ)
+#define fd_free_irq()		free_irq(FLOPPY_IRQ, NULL)
+#define fd_get_dma_residue()    SW._get_dma_residue(FLOPPY_DMA)
+#define fd_dma_mem_alloc(size)	SW._dma_mem_alloc(size)
+#define fd_dma_setup(addr, size, mode, io) SW._dma_setup(addr, size, mode, io)
+
+#define FLOPPY_CAN_FALLBACK_ON_NODMA
+
+static int virtual_dma_count;
+static int virtual_dma_residue;
+static char *virtual_dma_addr;
+static int virtual_dma_mode;
+static int doing_pdma;
+
+static irqreturn_t floppy_hardint(int irq, void *dev_id)
+{
+	register unsigned char st;
+
+#undef TRACE_FLPY_INT
+
+#ifdef TRACE_FLPY_INT
+	static int calls=0;
+	static int bytes=0;
+	static int dma_wait=0;
+#endif
+	if (!doing_pdma)
+		return floppy_interrupt(irq, dev_id);
+
+#ifdef TRACE_FLPY_INT
+	if(!calls)
+		bytes = virtual_dma_count;
+#endif
+
+	{
+		register int lcount;
+		register char *lptr;
+
+		st = 1;
+		for(lcount=virtual_dma_count, lptr=virtual_dma_addr; 
+		    lcount; lcount--, lptr++) {
+			st=inb(virtual_dma_port+4) & 0xa0 ;
+			if(st != 0xa0) 
+				break;
+			if(virtual_dma_mode)
+				outb_p(*lptr, virtual_dma_port+5);
+			else
+				*lptr = inb_p(virtual_dma_port+5);
+		}
+		virtual_dma_count = lcount;
+		virtual_dma_addr = lptr;
+		st = inb(virtual_dma_port+4);
+	}
+
+#ifdef TRACE_FLPY_INT
+	calls++;
+#endif
+	if(st == 0x20)
+		return IRQ_HANDLED;
+	if(!(st & 0x20)) {
+		virtual_dma_residue += virtual_dma_count;
+		virtual_dma_count=0;
+#ifdef TRACE_FLPY_INT
+		printk("count=%x, residue=%x calls=%d bytes=%d dma_wait=%d\n", 
+		       virtual_dma_count, virtual_dma_residue, calls, bytes,
+		       dma_wait);
+		calls = 0;
+		dma_wait=0;
+#endif
+		doing_pdma = 0;
+		floppy_interrupt(irq, dev_id);
+		return IRQ_HANDLED;
+	}
+#ifdef TRACE_FLPY_INT
+	if(!virtual_dma_count)
+		dma_wait++;
+#endif
+	return IRQ_HANDLED;
+}
+
+static void fd_disable_dma(void)
+{
+	if(! (can_use_virtual_dma & 1))
+		disable_dma(FLOPPY_DMA);
+	doing_pdma = 0;
+	virtual_dma_residue += virtual_dma_count;
+	virtual_dma_count=0;
+}
+
+static int vdma_request_dma(unsigned int dmanr, const char * device_id)
+{
+	return 0;
+}
+
+static void vdma_nop(unsigned int dummy)
+{
+}
+
+
+static int vdma_get_dma_residue(unsigned int dummy)
+{
+	return virtual_dma_count + virtual_dma_residue;
+}
+
+
+static int fd_request_irq(void)
+{
+	if(can_use_virtual_dma)
+		return request_irq(FLOPPY_IRQ, floppy_hardint,
+				   IRQF_DISABLED, "floppy", NULL);
+	else
+		return request_irq(FLOPPY_IRQ, floppy_interrupt,
+				   IRQF_DISABLED, "floppy", NULL);
+}
+
+static unsigned long dma_mem_alloc(unsigned long size)
+{
+	return __get_dma_pages(GFP_KERNEL|__GFP_NORETRY,get_order(size));
+}
+
+
+static unsigned long vdma_mem_alloc(unsigned long size)
+{
+	return (unsigned long) vmalloc(size);
+
+}
+
+#define nodma_mem_alloc(size) vdma_mem_alloc(size)
+
+static void _fd_dma_mem_free(unsigned long addr, unsigned long size)
+{
+	if((unsigned long) addr >= (unsigned long) high_memory)
+		vfree((void *)addr);
+	else
+		free_pages(addr, get_order(size));		
+}
+
+#define fd_dma_mem_free(addr, size)  _fd_dma_mem_free(addr, size) 
+
+static void _fd_chose_dma_mode(char *addr, unsigned long size)
+{
+	if(can_use_virtual_dma == 2) {
+		if((unsigned long) addr >= (unsigned long) high_memory ||
+		   isa_virt_to_bus(addr) >= 0x1000000 ||
+		   _CROSS_64KB(addr, size, 0))
+			use_virtual_dma = 1;
+		else
+			use_virtual_dma = 0;
+	} else {
+		use_virtual_dma = can_use_virtual_dma & 1;
+	}
+}
+
+#define fd_chose_dma_mode(addr, size) _fd_chose_dma_mode(addr, size)
+
+
+static int vdma_dma_setup(char *addr, unsigned long size, int mode, int io)
+{
+	doing_pdma = 1;
+	virtual_dma_port = io;
+	virtual_dma_mode = (mode  == DMA_MODE_WRITE);
+	virtual_dma_addr = addr;
+	virtual_dma_count = size;
+	virtual_dma_residue = 0;
+	return 0;
+}
+
+static int hard_dma_setup(char *addr, unsigned long size, int mode, int io)
+{
+#ifdef FLOPPY_SANITY_CHECK
+	if (CROSS_64KB(addr, size)) {
+		printk("DMA crossing 64-K boundary %p-%p\n", addr, addr+size);
+		return -1;
+	}
+#endif
+	/* actual, physical DMA */
+	doing_pdma = 0;
+	clear_dma_ff(FLOPPY_DMA);
+	set_dma_mode(FLOPPY_DMA,mode);
+	set_dma_addr(FLOPPY_DMA,isa_virt_to_bus(addr));
+	set_dma_count(FLOPPY_DMA,size);
+	enable_dma(FLOPPY_DMA);
+	return 0;
+}
+
+static struct fd_routine_l {
+	int (*_request_dma)(unsigned int dmanr, const char * device_id);
+	void (*_free_dma)(unsigned int dmanr);
+	int (*_get_dma_residue)(unsigned int dummy);
+	unsigned long (*_dma_mem_alloc) (unsigned long size);
+	int (*_dma_setup)(char *addr, unsigned long size, int mode, int io);
+} fd_routine[] = {
+	{
+		request_dma,
+		free_dma,
+		get_dma_residue,
+		dma_mem_alloc,
+		hard_dma_setup
+	},
+	{
+		vdma_request_dma,
+		vdma_nop,
+		vdma_get_dma_residue,
+		vdma_mem_alloc,
+		vdma_dma_setup
+	}
+};
+
+
+static int FDC1 = 0x3f0;
+static int FDC2 = -1;
+
+/*
+ * Floppy types are stored in the rtc's CMOS RAM and so rtc_lock
+ * is needed to prevent corrupted CMOS RAM in case "insmod floppy"
+ * coincides with another rtc CMOS user.		Paul G.
+ */
+#define FLOPPY0_TYPE	({				\
+	unsigned long flags;				\
+	unsigned char val;				\
+	spin_lock_irqsave(&rtc_lock, flags);		\
+	val = (CMOS_READ(0x10) >> 4) & 15;		\
+	spin_unlock_irqrestore(&rtc_lock, flags);	\
+	val;						\
+})
+
+#define FLOPPY1_TYPE	({				\
+	unsigned long flags;				\
+	unsigned char val;				\
+	spin_lock_irqsave(&rtc_lock, flags);		\
+	val = CMOS_READ(0x10) & 15;			\
+	spin_unlock_irqrestore(&rtc_lock, flags);	\
+	val;						\
+})
+
+#define N_FDC 2
+#define N_DRIVE 8
+
+#define FLOPPY_MOTOR_MASK 0xf0
+
+#define AUTO_DMA
+
+#define EXTRA_FLOPPY_PARAMS
+
+#endif /* __ASM_X86_64_FLOPPY_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/fpu32.h linux-2.6.20-sabayon-r1/include/asm/fpu32.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/fpu32.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/fpu32.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef _FPU32_H
+#define _FPU32_H 1
+
+struct _fpstate_ia32;
+
+int restore_i387_ia32(struct task_struct *tsk, struct _fpstate_ia32 __user *buf, int fsave);
+int save_i387_ia32(struct task_struct *tsk, struct _fpstate_ia32 __user *buf, 
+		   struct pt_regs *regs, int fsave);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/futex.h linux-2.6.20-sabayon-r1/include/asm/futex.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/futex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/futex.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,125 @@
+#ifndef _ASM_FUTEX_H
+#define _ASM_FUTEX_H
+
+#ifdef __KERNEL__
+
+#include <linux/futex.h>
+#include <asm/errno.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+
+#define __futex_atomic_op1(insn, ret, oldval, uaddr, oparg) \
+  __asm__ __volatile (						\
+"1:	" insn "\n"						\
+"2:	.section .fixup,\"ax\"\n\
+3:	mov	%3, %1\n\
+	jmp	2b\n\
+	.previous\n\
+	.section __ex_table,\"a\"\n\
+	.align	8\n\
+	.quad	1b,3b\n\
+	.previous"						\
+	: "=r" (oldval), "=r" (ret), "=m" (*uaddr)		\
+	: "i" (-EFAULT), "m" (*uaddr), "0" (oparg), "1" (0))
+
+#define __futex_atomic_op2(insn, ret, oldval, uaddr, oparg) \
+  __asm__ __volatile (						\
+"1:	movl	%2, %0\n\
+	movl	%0, %3\n"					\
+	insn "\n"						\
+"2:	" LOCK_PREFIX "cmpxchgl %3, %2\n\
+	jnz	1b\n\
+3:	.section .fixup,\"ax\"\n\
+4:	mov	%5, %1\n\
+	jmp	3b\n\
+	.previous\n\
+	.section __ex_table,\"a\"\n\
+	.align	8\n\
+	.quad	1b,4b,2b,4b\n\
+	.previous"						\
+	: "=&a" (oldval), "=&r" (ret), "=m" (*uaddr),		\
+	  "=&r" (tem)						\
+	: "r" (oparg), "i" (-EFAULT), "m" (*uaddr), "1" (0))
+
+static inline int
+futex_atomic_op_inuser (int encoded_op, int __user *uaddr)
+{
+	int op = (encoded_op >> 28) & 7;
+	int cmp = (encoded_op >> 24) & 15;
+	int oparg = (encoded_op << 8) >> 20;
+	int cmparg = (encoded_op << 20) >> 20;
+	int oldval = 0, ret, tem;
+	if (encoded_op & (FUTEX_OP_OPARG_SHIFT << 28))
+		oparg = 1 << oparg;
+
+	if (! access_ok (VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	pagefault_disable();
+
+	switch (op) {
+	case FUTEX_OP_SET:
+		__futex_atomic_op1("xchgl %0, %2", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_ADD:
+		__futex_atomic_op1(LOCK_PREFIX "xaddl %0, %2", ret, oldval,
+				   uaddr, oparg);
+		break;
+	case FUTEX_OP_OR:
+		__futex_atomic_op2("orl %4, %3", ret, oldval, uaddr, oparg);
+		break;
+	case FUTEX_OP_ANDN:
+		__futex_atomic_op2("andl %4, %3", ret, oldval, uaddr, ~oparg);
+		break;
+	case FUTEX_OP_XOR:
+		__futex_atomic_op2("xorl %4, %3", ret, oldval, uaddr, oparg);
+		break;
+	default:
+		ret = -ENOSYS;
+	}
+
+	pagefault_enable();
+
+	if (!ret) {
+		switch (cmp) {
+		case FUTEX_OP_CMP_EQ: ret = (oldval == cmparg); break;
+		case FUTEX_OP_CMP_NE: ret = (oldval != cmparg); break;
+		case FUTEX_OP_CMP_LT: ret = (oldval < cmparg); break;
+		case FUTEX_OP_CMP_GE: ret = (oldval >= cmparg); break;
+		case FUTEX_OP_CMP_LE: ret = (oldval <= cmparg); break;
+		case FUTEX_OP_CMP_GT: ret = (oldval > cmparg); break;
+		default: ret = -ENOSYS;
+		}
+	}
+	return ret;
+}
+
+static inline int
+futex_atomic_cmpxchg_inatomic(int __user *uaddr, int oldval, int newval)
+{
+	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
+		return -EFAULT;
+
+	__asm__ __volatile__(
+		"1:	" LOCK_PREFIX "cmpxchgl %3, %1		\n"
+
+		"2:	.section .fixup, \"ax\"			\n"
+		"3:	mov     %2, %0				\n"
+		"	jmp     2b				\n"
+		"	.previous				\n"
+
+		"	.section __ex_table, \"a\"		\n"
+		"	.align  8				\n"
+		"	.quad   1b,3b				\n"
+		"	.previous				\n"
+
+		: "=a" (oldval), "=m" (*uaddr)
+		: "i" (-EFAULT), "r" (newval), "0" (oldval)
+		: "memory"
+	);
+
+	return oldval;
+}
+
+#endif
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/genapic.h linux-2.6.20-sabayon-r1/include/asm/genapic.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/genapic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/genapic.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,35 @@
+#ifndef _ASM_GENAPIC_H
+#define _ASM_GENAPIC_H 1
+
+/*
+ * Copyright 2004 James Cleverdon, IBM.
+ * Subject to the GNU Public License, v.2
+ *
+ * Generic APIC sub-arch data struct.
+ *
+ * Hacked for x86-64 by James Cleverdon from i386 architecture code by
+ * Martin Bligh, Andi Kleen, James Bottomley, John Stultz, and
+ * James Cleverdon.
+ */
+
+struct genapic {
+	char *name;
+	u32 int_delivery_mode;
+	u32 int_dest_mode;
+	int (*apic_id_registered)(void);
+	cpumask_t (*target_cpus)(void);
+	cpumask_t (*vector_allocation_domain)(int cpu);
+	void (*init_apic_ldr)(void);
+	/* ipi */
+	void (*send_IPI_mask)(cpumask_t mask, int vector);
+	void (*send_IPI_allbutself)(int vector);
+	void (*send_IPI_all)(int vector);
+	/* */
+	unsigned int (*cpu_mask_to_apicid)(cpumask_t cpumask);
+	unsigned int (*phys_pkg_id)(int index_msb);
+};
+
+
+extern struct genapic *genapic, *genapic_force, apic_flat;
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/hardirq.h linux-2.6.20-sabayon-r1/include/asm/hardirq.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/hardirq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/hardirq.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,23 @@
+#ifndef __ASM_HARDIRQ_H
+#define __ASM_HARDIRQ_H
+
+#include <linux/threads.h>
+#include <linux/irq.h>
+#include <asm/pda.h>
+#include <asm/apic.h>
+
+/* We can have at most NR_VECTORS irqs routed to a cpu at a time */
+#define MAX_HARDIRQS_PER_CPU NR_VECTORS
+
+#define __ARCH_IRQ_STAT 1
+
+#define local_softirq_pending() read_pda(__softirq_pending)
+
+#define __ARCH_SET_SOFTIRQ_PENDING 1
+
+#define set_softirq_pending(x) write_pda(__softirq_pending, (x))
+#define or_softirq_pending(x)  or_pda(__softirq_pending, (x))
+
+extern void ack_bad_irq(unsigned int irq);
+
+#endif /* __ASM_HARDIRQ_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/hpet.h linux-2.6.20-sabayon-r1/include/asm/hpet.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/hpet.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/hpet.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef _ASM_X8664_HPET_H
+#define _ASM_X8664_HPET_H 1
+
+/*
+ * Documentation on HPET can be found at:
+ *      http://www.intel.com/ial/home/sp/pcmmspec.htm
+ *      ftp://download.intel.com/ial/home/sp/mmts098.pdf
+ */
+
+#define HPET_MMAP_SIZE	1024
+
+#define HPET_ID		0x000
+#define HPET_PERIOD	0x004
+#define HPET_CFG	0x010
+#define HPET_STATUS	0x020
+#define HPET_COUNTER	0x0f0
+#define HPET_Tn_OFFSET	0x20
+#define HPET_Tn_CFG(n)	 (0x100 + (n) * HPET_Tn_OFFSET)
+#define HPET_Tn_ROUTE(n) (0x104 + (n) * HPET_Tn_OFFSET)
+#define HPET_Tn_CMP(n)	 (0x108 + (n) * HPET_Tn_OFFSET)
+#define HPET_T0_CFG	HPET_Tn_CFG(0)
+#define HPET_T0_CMP	HPET_Tn_CMP(0)
+#define HPET_T1_CFG	HPET_Tn_CFG(1)
+#define HPET_T1_CMP	HPET_Tn_CMP(1)
+
+#define HPET_ID_VENDOR	0xffff0000
+#define HPET_ID_LEGSUP	0x00008000
+#define HPET_ID_64BIT	0x00002000
+#define HPET_ID_NUMBER	0x00001f00
+#define HPET_ID_REV	0x000000ff
+#define	HPET_ID_NUMBER_SHIFT	8
+
+#define HPET_ID_VENDOR_SHIFT	16
+#define HPET_ID_VENDOR_8086	0x8086
+
+#define HPET_CFG_ENABLE	0x001
+#define HPET_CFG_LEGACY	0x002
+#define	HPET_LEGACY_8254	2
+#define	HPET_LEGACY_RTC		8
+
+#define HPET_TN_LEVEL		0x0002
+#define HPET_TN_ENABLE		0x0004
+#define HPET_TN_PERIODIC	0x0008
+#define HPET_TN_PERIODIC_CAP	0x0010
+#define HPET_TN_64BIT_CAP	0x0020
+#define HPET_TN_SETVAL		0x0040
+#define HPET_TN_32BIT		0x0100
+#define HPET_TN_ROUTE		0x3e00
+#define HPET_TN_FSB		0x4000
+#define HPET_TN_FSB_CAP		0x8000
+
+#define HPET_TN_ROUTE_SHIFT	9
+
+#define HPET_TICK_RATE (HZ * 100000UL)
+
+extern int is_hpet_enabled(void);
+extern int hpet_rtc_timer_init(void);
+extern int apic_is_clustered_box(void);
+
+extern int hpet_use_timer;
+
+#ifdef CONFIG_HPET_EMULATE_RTC
+extern int hpet_mask_rtc_irq_bit(unsigned long bit_mask);
+extern int hpet_set_rtc_irq_bit(unsigned long bit_mask);
+extern int hpet_set_alarm_time(unsigned char hrs, unsigned char min, unsigned char sec);
+extern int hpet_set_periodic_freq(unsigned long freq);
+extern int hpet_rtc_dropped_irq(void);
+extern int hpet_rtc_timer_init(void);
+#endif /* CONFIG_HPET_EMULATE_RTC */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/hw_irq.h linux-2.6.20-sabayon-r1/include/asm/hw_irq.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/hw_irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/hw_irq.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,134 @@
+#ifndef _ASM_HW_IRQ_H
+#define _ASM_HW_IRQ_H
+
+/*
+ *	linux/include/asm/hw_irq.h
+ *
+ *	(C) 1992, 1993 Linus Torvalds, (C) 1997 Ingo Molnar
+ *
+ *	moved some of the old arch/i386/kernel/irq.h to here. VY
+ *
+ *	IRQ/IPI changes taken from work by Thomas Radke
+ *	<tomsoft@informatik.tu-chemnitz.de>
+ *
+ *	hacked by Andi Kleen for x86-64.
+ */
+
+#ifndef __ASSEMBLY__
+#include <asm/atomic.h>
+#include <asm/irq.h>
+#include <linux/profile.h>
+#include <linux/smp.h>
+#include <linux/percpu.h>
+#endif
+
+#define NMI_VECTOR		0x02
+/*
+ * IDT vectors usable for external interrupt sources start
+ * at 0x20:
+ */
+#define FIRST_EXTERNAL_VECTOR	0x20
+
+#define IA32_SYSCALL_VECTOR	0x80
+
+
+/*
+ * Vectors 0x20-0x2f are used for ISA interrupts.
+ */
+
+/*
+ * Special IRQ vectors used by the SMP architecture, 0xf0-0xff
+ *
+ *  some of the following vectors are 'rare', they are merged
+ *  into a single vector (CALL_FUNCTION_VECTOR) to save vector space.
+ *  TLB, reschedule and local APIC vectors are performance-critical.
+ */
+#define SPURIOUS_APIC_VECTOR	0xff
+#define ERROR_APIC_VECTOR	0xfe
+#define RESCHEDULE_VECTOR	0xfd
+#define CALL_FUNCTION_VECTOR	0xfc
+/* fb free - please don't readd KDB here because it's useless
+   (hint - think what a NMI bit does to a vector) */
+#define THERMAL_APIC_VECTOR	0xfa
+#define THRESHOLD_APIC_VECTOR   0xf9
+/* f8 free */
+#define INVALIDATE_TLB_VECTOR_END	0xf7
+#define INVALIDATE_TLB_VECTOR_START	0xf0	/* f0-f7 used for TLB flush */
+
+#define NUM_INVALIDATE_TLB_VECTORS	8
+
+/*
+ * Local APIC timer IRQ vector is on a different priority level,
+ * to work around the 'lost local interrupt if more than 2 IRQ
+ * sources per level' errata.
+ */
+#define LOCAL_TIMER_VECTOR	0xef
+
+/*
+ * First APIC vector available to drivers: (vectors 0x30-0xee)
+ * we start at 0x31 to spread out vectors evenly between priority
+ * levels. (0x80 is the syscall vector)
+ */
+#define FIRST_DEVICE_VECTOR	0x31
+#define FIRST_SYSTEM_VECTOR	0xef   /* duplicated in irq.h */
+
+
+#ifndef __ASSEMBLY__
+typedef int vector_irq_t[NR_VECTORS];
+DECLARE_PER_CPU(vector_irq_t, vector_irq);
+extern void __setup_vector_irq(int cpu);
+extern spinlock_t vector_lock;
+
+/*
+ * Various low-level irq details needed by irq.c, process.c,
+ * time.c, io_apic.c and smp.c
+ *
+ * Interrupt entry/exit code at both C and assembly level
+ */
+
+extern void disable_8259A_irq(unsigned int irq);
+extern void enable_8259A_irq(unsigned int irq);
+extern int i8259A_irq_pending(unsigned int irq);
+extern void make_8259A_irq(unsigned int irq);
+extern void init_8259A(int aeoi);
+extern void FASTCALL(send_IPI_self(int vector));
+extern void init_VISWS_APIC_irqs(void);
+extern void setup_IO_APIC(void);
+extern void disable_IO_APIC(void);
+extern void print_IO_APIC(void);
+extern int IO_APIC_get_PCI_irq_vector(int bus, int slot, int fn);
+extern void send_IPI(int dest, int vector);
+extern void setup_ioapic_dest(void);
+
+extern unsigned long io_apic_irqs;
+
+extern atomic_t irq_err_count;
+extern atomic_t irq_mis_count;
+
+#define IO_APIC_IRQ(x) (((x) >= 16) || ((1<<(x)) & io_apic_irqs))
+
+#define __STR(x) #x
+#define STR(x) __STR(x)
+
+#include <asm/ptrace.h>
+
+#define IRQ_NAME2(nr) nr##_interrupt(void)
+#define IRQ_NAME(nr) IRQ_NAME2(IRQ##nr)
+
+/*
+ *	SMP has a few special interrupts for IPI messages
+ */
+
+#define BUILD_IRQ(nr) \
+asmlinkage void IRQ_NAME(nr); \
+__asm__( \
+"\n.p2align\n" \
+"IRQ" #nr "_interrupt:\n\t" \
+	"push $~(" #nr ") ; " \
+	"jmp common_interrupt");
+
+#define platform_legacy_irq(irq)	((irq) < 16)
+
+#endif
+
+#endif /* _ASM_HW_IRQ_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/hypertransport.h linux-2.6.20-sabayon-r1/include/asm/hypertransport.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/hypertransport.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/hypertransport.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,42 @@
+#ifndef ASM_HYPERTRANSPORT_H
+#define ASM_HYPERTRANSPORT_H
+
+/*
+ * Constants for x86 Hypertransport Interrupts.
+ */
+
+#define HT_IRQ_LOW_BASE			0xf8000000
+
+#define HT_IRQ_LOW_VECTOR_SHIFT		16
+#define  HT_IRQ_LOW_VECTOR_MASK		0x00ff0000
+#define  HT_IRQ_LOW_VECTOR(v)		(((v) << HT_IRQ_LOW_VECTOR_SHIFT) & HT_IRQ_LOW_VECTOR_MASK)
+
+#define HT_IRQ_LOW_DEST_ID_SHIFT	8
+#define  HT_IRQ_LOW_DEST_ID_MASK	0x0000ff00
+#define  HT_IRQ_LOW_DEST_ID(v)		(((v) << HT_IRQ_LOW_DEST_ID_SHIFT) & HT_IRQ_LOW_DEST_ID_MASK)
+
+#define HT_IRQ_LOW_DM_PHYSICAL		0x0000000
+#define HT_IRQ_LOW_DM_LOGICAL		0x0000040
+
+#define HT_IRQ_LOW_RQEOI_EDGE		0x0000000
+#define HT_IRQ_LOW_RQEOI_LEVEL		0x0000020
+
+
+#define HT_IRQ_LOW_MT_FIXED		0x0000000
+#define HT_IRQ_LOW_MT_ARBITRATED	0x0000004
+#define HT_IRQ_LOW_MT_SMI		0x0000008
+#define HT_IRQ_LOW_MT_NMI		0x000000c
+#define HT_IRQ_LOW_MT_INIT		0x0000010
+#define HT_IRQ_LOW_MT_STARTUP		0x0000014
+#define HT_IRQ_LOW_MT_EXTINT		0x0000018
+#define HT_IRQ_LOW_MT_LINT1		0x000008c
+#define HT_IRQ_LOW_MT_LINT0		0x0000098
+
+#define HT_IRQ_LOW_IRQ_MASKED		0x0000001
+
+
+#define HT_IRQ_HIGH_DEST_ID_SHIFT	0
+#define  HT_IRQ_HIGH_DEST_ID_MASK	0x00ffffff
+#define  HT_IRQ_HIGH_DEST_ID(v)		((((v) >> 8) << HT_IRQ_HIGH_DEST_ID_SHIFT) & HT_IRQ_HIGH_DEST_ID_MASK)
+
+#endif /* ASM_HYPERTRANSPORT_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/i387.h linux-2.6.20-sabayon-r1/include/asm/i387.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/i387.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/i387.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,209 @@
+/*
+ * include/asm-x86_64/i387.h
+ *
+ * Copyright (C) 1994 Linus Torvalds
+ *
+ * Pentium III FXSR, SSE support
+ * General FPU state handling cleanups
+ *	Gareth Hughes <gareth@valinux.com>, May 2000
+ * x86-64 work by Andi Kleen 2002
+ */
+
+#ifndef __ASM_X86_64_I387_H
+#define __ASM_X86_64_I387_H
+
+#include <linux/sched.h>
+#include <asm/processor.h>
+#include <asm/sigcontext.h>
+#include <asm/user.h>
+#include <asm/thread_info.h>
+#include <asm/uaccess.h>
+
+extern void fpu_init(void);
+extern unsigned int mxcsr_feature_mask;
+extern void mxcsr_feature_mask_init(void);
+extern void init_fpu(struct task_struct *child);
+extern int save_i387(struct _fpstate __user *buf);
+extern asmlinkage void math_state_restore(void);
+
+/*
+ * FPU lazy state save handling...
+ */
+
+#define unlazy_fpu(tsk) do { \
+	if (task_thread_info(tsk)->status & TS_USEDFPU) \
+		save_init_fpu(tsk); 			\
+	else						\
+		tsk->fpu_counter = 0;			\
+} while (0)
+
+/* Ignore delayed exceptions from user space */
+static inline void tolerant_fwait(void)
+{
+	asm volatile("1: fwait\n"
+		     "2:\n"
+		     "   .section __ex_table,\"a\"\n"
+		     "	.align 8\n"
+		     "	.quad 1b,2b\n"
+		     "	.previous\n");
+}
+
+#define clear_fpu(tsk) do { \
+	if (task_thread_info(tsk)->status & TS_USEDFPU) {	\
+		tolerant_fwait();				\
+		task_thread_info(tsk)->status &= ~TS_USEDFPU;	\
+		stts();						\
+	}							\
+} while (0)
+
+/*
+ * ptrace request handers...
+ */
+extern int get_fpregs(struct user_i387_struct __user *buf,
+		      struct task_struct *tsk);
+extern int set_fpregs(struct task_struct *tsk,
+		      struct user_i387_struct __user *buf);
+
+/*
+ * i387 state interaction
+ */
+#define get_fpu_mxcsr(t) ((t)->thread.i387.fxsave.mxcsr)
+#define get_fpu_cwd(t) ((t)->thread.i387.fxsave.cwd)
+#define get_fpu_fxsr_twd(t) ((t)->thread.i387.fxsave.twd)
+#define get_fpu_swd(t) ((t)->thread.i387.fxsave.swd)
+#define set_fpu_cwd(t,val) ((t)->thread.i387.fxsave.cwd = (val))
+#define set_fpu_swd(t,val) ((t)->thread.i387.fxsave.swd = (val))
+#define set_fpu_fxsr_twd(t,val) ((t)->thread.i387.fxsave.twd = (val))
+
+#define X87_FSW_ES (1 << 7)	/* Exception Summary */
+
+/* AMD CPUs don't save/restore FDP/FIP/FOP unless an exception
+   is pending. Clear the x87 state here by setting it to fixed
+   values. The kernel data segment can be sometimes 0 and sometimes
+   new user value. Both should be ok.
+   Use the PDA as safe address because it should be already in L1. */
+static inline void clear_fpu_state(struct i387_fxsave_struct *fx)
+{
+	if (unlikely(fx->swd & X87_FSW_ES))
+		 asm volatile("fnclex");
+	alternative_input(ASM_NOP8 ASM_NOP2,
+	     	     "    emms\n"		/* clear stack tags */
+	     	     "    fildl %%gs:0",	/* load to clear state */
+		     X86_FEATURE_FXSAVE_LEAK);
+}
+
+static inline int restore_fpu_checking(struct i387_fxsave_struct *fx) 
+{ 
+	int err;
+
+	asm volatile("1:  rex64/fxrstor (%[fx])\n\t"
+		     "2:\n"
+		     ".section .fixup,\"ax\"\n"
+		     "3:  movl $-1,%[err]\n"
+		     "    jmp  2b\n"
+		     ".previous\n"
+		     ".section __ex_table,\"a\"\n"
+		     "   .align 8\n"
+		     "   .quad  1b,3b\n"
+		     ".previous"
+		     : [err] "=r" (err)
+#if 0 /* See comment in __fxsave_clear() below. */
+		     : [fx] "r" (fx), "m" (*fx), "0" (0));
+#else
+		     : [fx] "cdaSDb" (fx), "m" (*fx), "0" (0));
+#endif
+	if (unlikely(err))
+		init_fpu(current);
+	return err;
+} 
+
+static inline int save_i387_checking(struct i387_fxsave_struct __user *fx) 
+{ 
+	int err;
+
+	asm volatile("1:  rex64/fxsave (%[fx])\n\t"
+		     "2:\n"
+		     ".section .fixup,\"ax\"\n"
+		     "3:  movl $-1,%[err]\n"
+		     "    jmp  2b\n"
+		     ".previous\n"
+		     ".section __ex_table,\"a\"\n"
+		     "   .align 8\n"
+		     "   .quad  1b,3b\n"
+		     ".previous"
+		     : [err] "=r" (err), "=m" (*fx)
+#if 0 /* See comment in __fxsave_clear() below. */
+		     : [fx] "r" (fx), "0" (0));
+#else
+		     : [fx] "cdaSDb" (fx), "0" (0));
+#endif
+	if (unlikely(err) && __clear_user(fx, sizeof(struct i387_fxsave_struct)))
+		err = -EFAULT;
+	/* No need to clear here because the caller clears USED_MATH */
+	return err;
+} 
+
+static inline void __fxsave_clear(struct task_struct *tsk)
+{
+	/* Using "rex64; fxsave %0" is broken because, if the memory operand
+	   uses any extended registers for addressing, a second REX prefix
+	   will be generated (to the assembler, rex64 followed by semicolon
+	   is a separate instruction), and hence the 64-bitness is lost. */
+#if 0
+	/* Using "fxsaveq %0" would be the ideal choice, but is only supported
+	   starting with gas 2.16. */
+	__asm__ __volatile__("fxsaveq %0"
+			     : "=m" (tsk->thread.i387.fxsave));
+#elif 0
+	/* Using, as a workaround, the properly prefixed form below isn't
+	   accepted by any binutils version so far released, complaining that
+	   the same type of prefix is used twice if an extended register is
+	   needed for addressing (fix submitted to mainline 2005-11-21). */
+	__asm__ __volatile__("rex64/fxsave %0"
+			     : "=m" (tsk->thread.i387.fxsave));
+#else
+	/* This, however, we can work around by forcing the compiler to select
+	   an addressing mode that doesn't require extended registers. */
+	__asm__ __volatile__("rex64/fxsave %P2(%1)"
+			     : "=m" (tsk->thread.i387.fxsave)
+			     : "cdaSDb" (tsk),
+				"i" (offsetof(__typeof__(*tsk),
+					      thread.i387.fxsave)));
+#endif
+	clear_fpu_state(&tsk->thread.i387.fxsave);
+}
+
+static inline void kernel_fpu_begin(void)
+{
+	struct thread_info *me = current_thread_info();
+	preempt_disable();
+	if (me->status & TS_USEDFPU) {
+		__fxsave_clear(me->task);
+		me->status &= ~TS_USEDFPU;
+		return;
+	}
+	clts();
+}
+
+static inline void kernel_fpu_end(void)
+{
+	stts();
+	preempt_enable();
+}
+
+static inline void save_init_fpu(struct task_struct *tsk)
+{
+ 	__fxsave_clear(tsk);
+	task_thread_info(tsk)->status &= ~TS_USEDFPU;
+	stts();
+}
+
+/* 
+ * This restores directly out of user space. Exceptions are handled.
+ */
+static inline int restore_i387(struct _fpstate __user *buf)
+{
+	return restore_fpu_checking((__force struct i387_fxsave_struct *)buf);
+}
+
+#endif /* __ASM_X86_64_I387_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ia32.h linux-2.6.20-sabayon-r1/include/asm/ia32.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ia32.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ia32.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,178 @@
+#ifndef _ASM_X86_64_IA32_H
+#define _ASM_X86_64_IA32_H
+
+
+#ifdef CONFIG_IA32_EMULATION
+
+#include <linux/compat.h>
+
+/*
+ * 32 bit structures for IA32 support.
+ */
+
+#include <asm/sigcontext32.h>
+
+/* signal.h */
+struct sigaction32 {
+       unsigned int  sa_handler;	/* Really a pointer, but need to deal 
+					     with 32 bits */
+       unsigned int sa_flags;
+       unsigned int sa_restorer;	/* Another 32 bit pointer */
+       compat_sigset_t sa_mask;		/* A 32 bit mask */
+};
+
+struct old_sigaction32 {
+       unsigned int  sa_handler;	/* Really a pointer, but need to deal 
+					     with 32 bits */
+       compat_old_sigset_t sa_mask;		/* A 32 bit mask */
+       unsigned int sa_flags;
+       unsigned int sa_restorer;	/* Another 32 bit pointer */
+};
+
+typedef struct sigaltstack_ia32 {
+	unsigned int	ss_sp;
+	int		ss_flags;
+	unsigned int	ss_size;
+} stack_ia32_t;
+
+struct ucontext_ia32 {
+	unsigned int	  uc_flags;
+	unsigned int 	  uc_link;
+	stack_ia32_t	  uc_stack;
+	struct sigcontext_ia32 uc_mcontext;
+	compat_sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+/* This matches struct stat64 in glibc2.2, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char		__pad0[4];
+
+#define STAT64_HAS_BROKEN_ST_INO	1
+	unsigned int		__st_ino;
+
+	unsigned int		st_mode;
+	unsigned int		st_nlink;
+
+	unsigned int		st_uid;
+	unsigned int		st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char		__pad3[4];
+
+	long long		st_size;
+	unsigned int		st_blksize;
+
+	long long		st_blocks;/* Number 512-byte blocks allocated. */
+
+	unsigned 		st_atime;
+	unsigned 		st_atime_nsec;
+	unsigned 		st_mtime;
+	unsigned 		st_mtime_nsec;
+	unsigned 		st_ctime;
+	unsigned 		st_ctime_nsec;
+
+	unsigned long long	st_ino;
+} __attribute__((packed));
+
+typedef struct compat_siginfo{
+	int si_signo;
+	int si_errno;
+	int si_code;
+
+	union {
+		int _pad[((128/sizeof(int)) - 3)];
+
+		/* kill() */
+		struct {
+			unsigned int _pid;	/* sender's pid */
+			unsigned int _uid;	/* sender's uid */
+		} _kill;
+
+		/* POSIX.1b timers */
+		struct {
+			compat_timer_t _tid;	/* timer id */
+			int _overrun;		/* overrun count */
+			compat_sigval_t _sigval;	/* same as below */
+			int _sys_private;	/* not to be passed to user */
+			int _overrun_incr;	/* amount to add to overrun */
+		} _timer;
+
+		/* POSIX.1b signals */
+		struct {
+			unsigned int _pid;	/* sender's pid */
+			unsigned int _uid;	/* sender's uid */
+			compat_sigval_t _sigval;
+		} _rt;
+
+		/* SIGCHLD */
+		struct {
+			unsigned int _pid;	/* which child */
+			unsigned int _uid;	/* sender's uid */
+			int _status;		/* exit code */
+			compat_clock_t _utime;
+			compat_clock_t _stime;
+		} _sigchld;
+
+		/* SIGILL, SIGFPE, SIGSEGV, SIGBUS */
+		struct {
+			unsigned int _addr;	/* faulting insn/memory ref. */
+		} _sigfault;
+
+		/* SIGPOLL */
+		struct {
+			int _band;	/* POLL_IN, POLL_OUT, POLL_MSG */
+			int _fd;
+		} _sigpoll;
+	} _sifields;
+} compat_siginfo_t;
+
+struct sigframe32
+{
+        u32 pretcode;
+        int sig;
+        struct sigcontext_ia32 sc;
+        struct _fpstate_ia32 fpstate;
+        unsigned int extramask[_COMPAT_NSIG_WORDS-1];
+};
+
+struct rt_sigframe32
+{
+        u32 pretcode;
+        int sig;
+        u32 pinfo;
+        u32 puc;
+        compat_siginfo_t info;
+        struct ucontext_ia32 uc;
+        struct _fpstate_ia32 fpstate;
+};
+
+struct ustat32 {
+	__u32	f_tfree;
+	compat_ino_t		f_tinode;
+	char			f_fname[6];
+	char			f_fpack[6];
+};
+
+#define IA32_STACK_TOP IA32_PAGE_OFFSET
+
+#ifdef __KERNEL__
+struct user_desc;
+struct siginfo_t;
+int do_get_thread_area(struct thread_struct *t, struct user_desc __user *info);
+int do_set_thread_area(struct thread_struct *t, struct user_desc __user *info);
+int ia32_child_tls(struct task_struct *p, struct pt_regs *childregs);
+
+struct linux_binprm;
+extern int ia32_setup_arg_pages(struct linux_binprm *bprm,
+				unsigned long stack_top, int exec_stack);
+struct mm_struct;
+extern void ia32_pick_mmap_layout(struct mm_struct *mm);
+
+#endif
+
+#endif /* !CONFIG_IA32_SUPPORT */
+ 
+#endif 
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ia32_unistd.h linux-2.6.20-sabayon-r1/include/asm/ia32_unistd.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ia32_unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ia32_unistd.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,18 @@
+#ifndef _ASM_X86_64_IA32_UNISTD_H_
+#define _ASM_X86_64_IA32_UNISTD_H_
+
+/*
+ * This file contains the system call numbers of the ia32 port,
+ * this is for the kernel only.
+ * Only add syscalls here where some part of the kernel needs to know
+ * the number. This should be otherwise in sync with asm-i386/unistd.h. -AK
+ */
+
+#define __NR_ia32_restart_syscall 0
+#define __NR_ia32_exit		  1
+#define __NR_ia32_read		  3
+#define __NR_ia32_write		  4
+#define __NR_ia32_sigreturn	119
+#define __NR_ia32_rt_sigreturn	173
+
+#endif /* _ASM_X86_64_IA32_UNISTD_H_ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ide.h linux-2.6.20-sabayon-r1/include/asm/ide.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ide.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ide.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-i386/ide.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/idle.h linux-2.6.20-sabayon-r1/include/asm/idle.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/idle.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/idle.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef _ASM_X86_64_IDLE_H
+#define _ASM_X86_64_IDLE_H 1
+
+#define IDLE_START 1
+#define IDLE_END 2
+
+struct notifier_block;
+void idle_notifier_register(struct notifier_block *n);
+void idle_notifier_unregister(struct notifier_block *n);
+
+void enter_idle(void);
+void exit_idle(void);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/intel_arch_perfmon.h linux-2.6.20-sabayon-r1/include/asm/intel_arch_perfmon.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/intel_arch_perfmon.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/intel_arch_perfmon.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,31 @@
+#ifndef X86_64_INTEL_ARCH_PERFMON_H
+#define X86_64_INTEL_ARCH_PERFMON_H 1
+
+#define MSR_ARCH_PERFMON_PERFCTR0		0xc1
+#define MSR_ARCH_PERFMON_PERFCTR1		0xc2
+
+#define MSR_ARCH_PERFMON_EVENTSEL0		0x186
+#define MSR_ARCH_PERFMON_EVENTSEL1		0x187
+
+#define ARCH_PERFMON_EVENTSEL0_ENABLE      (1 << 22)
+#define ARCH_PERFMON_EVENTSEL_INT          (1 << 20)
+#define ARCH_PERFMON_EVENTSEL_OS           (1 << 17)
+#define ARCH_PERFMON_EVENTSEL_USR          (1 << 16)
+
+#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_SEL	(0x3c)
+#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_UMASK	(0x00 << 8)
+#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX (0)
+#define ARCH_PERFMON_UNHALTED_CORE_CYCLES_PRESENT \
+				(1 << (ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX))
+
+union cpuid10_eax {
+	struct {
+		unsigned int version_id:8;
+		unsigned int num_counters:8;
+		unsigned int bit_width:8;
+		unsigned int mask_length:8;
+	} split;
+	unsigned int full;
+};
+
+#endif	/* X86_64_INTEL_ARCH_PERFMON_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/io_apic.h linux-2.6.20-sabayon-r1/include/asm/io_apic.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/io_apic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/io_apic.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,139 @@
+#ifndef __ASM_IO_APIC_H
+#define __ASM_IO_APIC_H
+
+#include <asm/types.h>
+#include <asm/mpspec.h>
+
+/*
+ * Intel IO-APIC support for SMP and UP systems.
+ *
+ * Copyright (C) 1997, 1998, 1999, 2000 Ingo Molnar
+ */
+
+#define APIC_MISMATCH_DEBUG
+
+/*
+ * The structure of the IO-APIC:
+ */
+union IO_APIC_reg_00 {
+	u32	raw;
+	struct {
+		u32	__reserved_2	: 14,
+			LTS		:  1,
+			delivery_type	:  1,
+			__reserved_1	:  8,
+			ID		:  8;
+	} __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_01 {
+	u32	raw;
+	struct {
+		u32	version		:  8,
+		__reserved_2	:  7,
+		PRQ		:  1,
+		entries		:  8,
+		__reserved_1	:  8;
+	} __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_02 {
+	u32	raw;
+	struct {
+		u32	__reserved_2	: 24,
+		arbitration	:  4,
+		__reserved_1	:  4;
+	} __attribute__ ((packed)) bits;
+};
+
+union IO_APIC_reg_03 {
+	u32	raw;
+	struct {
+		u32	boot_DT		:  1,
+			__reserved_1	: 31;
+	} __attribute__ ((packed)) bits;
+};
+
+/*
+ * # of IO-APICs and # of IRQ routing registers
+ */
+extern int nr_ioapics;
+extern int nr_ioapic_registers[MAX_IO_APICS];
+
+enum ioapic_irq_destination_types {
+	dest_Fixed = 0,
+	dest_LowestPrio = 1,
+	dest_SMI = 2,
+	dest__reserved_1 = 3,
+	dest_NMI = 4,
+	dest_INIT = 5,
+	dest__reserved_2 = 6,
+	dest_ExtINT = 7
+};
+
+struct IO_APIC_route_entry {
+	__u32	vector		:  8,
+		delivery_mode	:  3,	/* 000: FIXED
+					 * 001: lowest prio
+					 * 111: ExtINT
+					 */
+		dest_mode	:  1,	/* 0: physical, 1: logical */
+		delivery_status	:  1,
+		polarity	:  1,
+		irr		:  1,
+		trigger		:  1,	/* 0: edge, 1: level */
+		mask		:  1,	/* 0: enabled, 1: disabled */
+		__reserved_2	: 15;
+
+	union {		struct { __u32
+					__reserved_1	: 24,
+					physical_dest	:  4,
+					__reserved_2	:  4;
+			} physical;
+
+			struct { __u32
+					__reserved_1	: 24,
+					logical_dest	:  8;
+			} logical;
+	} dest;
+
+} __attribute__ ((packed));
+
+/*
+ * MP-BIOS irq configuration table structures:
+ */
+
+/* I/O APIC entries */
+extern struct mpc_config_ioapic mp_ioapics[MAX_IO_APICS];
+
+/* # of MP IRQ source entries */
+extern int mp_irq_entries;
+
+/* MP IRQ source entries */
+extern struct mpc_config_intsrc mp_irqs[MAX_IRQ_SOURCES];
+
+/* non-0 if default (table-less) MP configuration */
+extern int mpc_default_type;
+
+/* 1 if "noapic" boot option passed */
+extern int skip_ioapic_setup;
+
+/*
+ * If we use the IO-APIC for IRQ routing, disable automatic
+ * assignment of PCI IRQ's.
+ */
+#define io_apic_assign_pci_irqs (mp_irq_entries && !skip_ioapic_setup && io_apic_irqs)
+
+#ifdef CONFIG_ACPI
+extern int io_apic_get_version (int ioapic);
+extern int io_apic_get_redir_entries (int ioapic);
+extern int io_apic_set_pci_routing (int ioapic, int pin, int irq, int, int);
+#endif
+
+extern int sis_apic_bug; /* dummy */ 
+
+void enable_NMI_through_LVT0 (void * dummy);
+
+extern spinlock_t i8259A_lock;
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ioctl.h linux-2.6.20-sabayon-r1/include/asm/ioctl.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ioctl.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ioctls.h linux-2.6.20-sabayon-r1/include/asm/ioctls.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ioctls.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ioctls.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,86 @@
+#ifndef __ARCH_X8664_IOCTLS_H__
+#define __ARCH_X8664_IOCTLS_H__
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TCGETS2		_IOR('T',0x2A, struct termios2)
+#define TCSETS2		_IOW('T',0x2B, struct termios2)
+#define TCSETSW2	_IOW('T',0x2C, struct termios2)
+#define TCSETSF2	_IOW('T',0x2D, struct termios2)
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450  /* these numbers need to be adjusted. */
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+#define FIOQSIZE       0x5460
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/io.h linux-2.6.20-sabayon-r1/include/asm/io.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/io.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/io.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,281 @@
+#ifndef _ASM_IO_H
+#define _ASM_IO_H
+
+
+/*
+ * This file contains the definitions for the x86 IO instructions
+ * inb/inw/inl/outb/outw/outl and the "string versions" of the same
+ * (insb/insw/insl/outsb/outsw/outsl). You can also use "pausing"
+ * versions of the single-IO instructions (inb_p/inw_p/..).
+ *
+ * This file is not meant to be obfuscating: it's just complicated
+ * to (a) handle it all in a way that makes gcc able to optimize it
+ * as well as possible and (b) trying to avoid writing the same thing
+ * over and over again with slight variations and possibly making a
+ * mistake somewhere.
+ */
+
+/*
+ * Thanks to James van Artsdalen for a better timing-fix than
+ * the two short jumps: using outb's to a nonexistent port seems
+ * to guarantee better timings even on fast machines.
+ *
+ * On the other hand, I'd like to be sure of a non-existent port:
+ * I feel a bit unsafe about using 0x80 (should be safe, though)
+ *
+ *		Linus
+ */
+
+ /*
+  *  Bit simplified and optimized by Jan Hubicka
+  *  Support of BIGMEM added by Gerhard Wichert, Siemens AG, July 1999.
+  *
+  *  isa_memset_io, isa_memcpy_fromio, isa_memcpy_toio added,
+  *  isa_read[wl] and isa_write[wl] fixed
+  *  - Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+  */
+
+#define __SLOW_DOWN_IO "\noutb %%al,$0x80"
+
+#ifdef REALLY_SLOW_IO
+#define __FULL_SLOW_DOWN_IO __SLOW_DOWN_IO __SLOW_DOWN_IO __SLOW_DOWN_IO __SLOW_DOWN_IO
+#else
+#define __FULL_SLOW_DOWN_IO __SLOW_DOWN_IO
+#endif
+
+/*
+ * Talk about misusing macros..
+ */
+#define __OUT1(s,x) \
+static inline void out##s(unsigned x value, unsigned short port) {
+
+#define __OUT2(s,s1,s2) \
+__asm__ __volatile__ ("out" #s " %" s1 "0,%" s2 "1"
+
+#define __OUT(s,s1,x) \
+__OUT1(s,x) __OUT2(s,s1,"w") : : "a" (value), "Nd" (port)); } \
+__OUT1(s##_p,x) __OUT2(s,s1,"w") __FULL_SLOW_DOWN_IO : : "a" (value), "Nd" (port));} \
+
+#define __IN1(s) \
+static inline RETURN_TYPE in##s(unsigned short port) { RETURN_TYPE _v;
+
+#define __IN2(s,s1,s2) \
+__asm__ __volatile__ ("in" #s " %" s2 "1,%" s1 "0"
+
+#define __IN(s,s1,i...) \
+__IN1(s) __IN2(s,s1,"w") : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
+__IN1(s##_p) __IN2(s,s1,"w") __FULL_SLOW_DOWN_IO : "=a" (_v) : "Nd" (port) ,##i ); return _v; } \
+
+#define __INS(s) \
+static inline void ins##s(unsigned short port, void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("rep ; ins" #s \
+: "=D" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define __OUTS(s) \
+static inline void outs##s(unsigned short port, const void * addr, unsigned long count) \
+{ __asm__ __volatile__ ("rep ; outs" #s \
+: "=S" (addr), "=c" (count) : "d" (port),"0" (addr),"1" (count)); }
+
+#define RETURN_TYPE unsigned char
+__IN(b,"")
+#undef RETURN_TYPE
+#define RETURN_TYPE unsigned short
+__IN(w,"")
+#undef RETURN_TYPE
+#define RETURN_TYPE unsigned int
+__IN(l,"")
+#undef RETURN_TYPE
+
+__OUT(b,"b",char)
+__OUT(w,"w",short)
+__OUT(l,,int)
+
+__INS(b)
+__INS(w)
+__INS(l)
+
+__OUTS(b)
+__OUTS(w)
+__OUTS(l)
+
+#define IO_SPACE_LIMIT 0xffff
+
+#if defined(__KERNEL__) && __x86_64__
+
+#include <linux/vmalloc.h>
+
+#ifndef __i386__
+/*
+ * Change virtual addresses to physical addresses and vv.
+ * These are pretty trivial
+ */
+static inline unsigned long virt_to_phys(volatile void * address)
+{
+	return __pa(address);
+}
+
+static inline void * phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+#endif
+
+/*
+ * Change "struct page" to physical address.
+ */
+#define page_to_phys(page)    ((dma_addr_t)page_to_pfn(page) << PAGE_SHIFT)
+
+#include <asm-generic/iomap.h>
+
+extern void __iomem *__ioremap(unsigned long offset, unsigned long size, unsigned long flags);
+
+static inline void __iomem * ioremap (unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, 0);
+}
+
+extern void *early_ioremap(unsigned long addr, unsigned long size);
+extern void early_iounmap(void *addr, unsigned long size);
+
+/*
+ * This one maps high address device memory and turns off caching for that area.
+ * it's useful if some control registers are in such an area and write combining
+ * or read caching is not desirable:
+ */
+extern void __iomem * ioremap_nocache (unsigned long offset, unsigned long size);
+extern void iounmap(volatile void __iomem *addr);
+
+/*
+ * ISA I/O bus memory addresses are 1:1 with the physical address.
+ */
+#define isa_virt_to_bus virt_to_phys
+#define isa_page_to_bus page_to_phys
+#define isa_bus_to_virt phys_to_virt
+
+/*
+ * However PCI ones are not necessarily 1:1 and therefore these interfaces
+ * are forbidden in portable PCI drivers.
+ *
+ * Allow them on x86 for legacy drivers, though.
+ */
+#define virt_to_bus virt_to_phys
+#define bus_to_virt phys_to_virt
+
+/*
+ * readX/writeX() are used to access memory mapped devices. On some
+ * architectures the memory mapped IO stuff needs to be accessed
+ * differently. On the x86 architecture, we just read/write the
+ * memory location directly.
+ */
+
+static inline __u8 __readb(const volatile void __iomem *addr)
+{
+	return *(__force volatile __u8 *)addr;
+}
+static inline __u16 __readw(const volatile void __iomem *addr)
+{
+	return *(__force volatile __u16 *)addr;
+}
+static __always_inline __u32 __readl(const volatile void __iomem *addr)
+{
+	return *(__force volatile __u32 *)addr;
+}
+static inline __u64 __readq(const volatile void __iomem *addr)
+{
+	return *(__force volatile __u64 *)addr;
+}
+#define readb(x) __readb(x)
+#define readw(x) __readw(x)
+#define readl(x) __readl(x)
+#define readq(x) __readq(x)
+#define readb_relaxed(a) readb(a)
+#define readw_relaxed(a) readw(a)
+#define readl_relaxed(a) readl(a)
+#define readq_relaxed(a) readq(a)
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+#define __raw_readq readq
+
+#define mmiowb()
+
+static inline void __writel(__u32 b, volatile void __iomem *addr)
+{
+	*(__force volatile __u32 *)addr = b;
+}
+static inline void __writeq(__u64 b, volatile void __iomem *addr)
+{
+	*(__force volatile __u64 *)addr = b;
+}
+static inline void __writeb(__u8 b, volatile void __iomem *addr)
+{
+	*(__force volatile __u8 *)addr = b;
+}
+static inline void __writew(__u16 b, volatile void __iomem *addr)
+{
+	*(__force volatile __u16 *)addr = b;
+}
+#define writeq(val,addr) __writeq((val),(addr))
+#define writel(val,addr) __writel((val),(addr))
+#define writew(val,addr) __writew((val),(addr))
+#define writeb(val,addr) __writeb((val),(addr))
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+#define __raw_writeq writeq
+
+void __memcpy_fromio(void*,unsigned long,unsigned);
+void __memcpy_toio(unsigned long,const void*,unsigned);
+
+static inline void memcpy_fromio(void *to, const volatile void __iomem *from, unsigned len)
+{
+	__memcpy_fromio(to,(unsigned long)from,len);
+}
+static inline void memcpy_toio(volatile void __iomem *to, const void *from, unsigned len)
+{
+	__memcpy_toio((unsigned long)to,from,len);
+}
+
+void memset_io(volatile void __iomem *a, int b, size_t c);
+
+/*
+ * ISA space is 'always mapped' on a typical x86 system, no need to
+ * explicitly ioremap() it. The fact that the ISA IO space is mapped
+ * to PAGE_OFFSET is pure coincidence - it does not mean ISA values
+ * are physical addresses. The following constant pointer can be
+ * used as the IO-area pointer (it can be iounmapped as well, so the
+ * analogy with PCI is quite large):
+ */
+#define __ISA_IO_base ((char __iomem *)(PAGE_OFFSET))
+
+/*
+ * Again, x86-64 does not require mem IO specific function.
+ */
+
+#define eth_io_copy_and_sum(a,b,c,d)		eth_copy_and_sum((a),(void *)(b),(c),(d))
+
+/* Nothing to do */
+
+#define dma_cache_inv(_start,_size)		do { } while (0)
+#define dma_cache_wback(_start,_size)		do { } while (0)
+#define dma_cache_wback_inv(_start,_size)	do { } while (0)
+
+#define flush_write_buffers() 
+
+extern int iommu_bio_merge;
+#define BIO_VMERGE_BOUNDARY iommu_bio_merge
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ipcbuf.h linux-2.6.20-sabayon-r1/include/asm/ipcbuf.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ipcbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ipcbuf.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,29 @@
+#ifndef __x86_64_IPCBUF_H__
+#define __x86_64_IPCBUF_H__
+
+/*
+ * The ipc64_perm structure for x86_64 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* __x86_64_IPCBUF_H__ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ipi.h linux-2.6.20-sabayon-r1/include/asm/ipi.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ipi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ipi.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,117 @@
+#ifndef __ASM_IPI_H
+#define __ASM_IPI_H
+
+/*
+ * Copyright 2004 James Cleverdon, IBM.
+ * Subject to the GNU Public License, v.2
+ *
+ * Generic APIC InterProcessor Interrupt code.
+ *
+ * Moved to include file by James Cleverdon from
+ * arch/x86-64/kernel/smp.c
+ *
+ * Copyrights from kernel/smp.c:
+ *
+ * (c) 1995 Alan Cox, Building #3 <alan@redhat.com>
+ * (c) 1998-99, 2000 Ingo Molnar <mingo@redhat.com>
+ * (c) 2002,2003 Andi Kleen, SuSE Labs.
+ * Subject to the GNU Public License, v.2
+ */
+
+#include <asm/fixmap.h>
+#include <asm/hw_irq.h>
+#include <asm/apicdef.h>
+#include <asm/genapic.h>
+
+/*
+ * the following functions deal with sending IPIs between CPUs.
+ *
+ * We use 'broadcast', CPU->CPU IPIs and self-IPIs too.
+ */
+
+static inline unsigned int __prepare_ICR (unsigned int shortcut, int vector, unsigned int dest)
+{
+	unsigned int icr = shortcut | dest;
+
+	switch (vector) {
+	default:
+		icr |= APIC_DM_FIXED | vector;
+		break;
+	case NMI_VECTOR:
+		icr |= APIC_DM_NMI;
+		break;
+	}
+	return icr;
+}
+
+static inline int __prepare_ICR2 (unsigned int mask)
+{
+	return SET_APIC_DEST_FIELD(mask);
+}
+
+static inline void __send_IPI_shortcut(unsigned int shortcut, int vector, unsigned int dest)
+{
+	/*
+	 * Subtle. In the case of the 'never do double writes' workaround
+	 * we have to lock out interrupts to be safe.  As we don't care
+	 * of the value read we use an atomic rmw access to avoid costly
+	 * cli/sti.  Otherwise we use an even cheaper single atomic write
+	 * to the APIC.
+	 */
+	unsigned int cfg;
+
+	/*
+	 * Wait for idle.
+	 */
+	apic_wait_icr_idle();
+
+	/*
+	 * No need to touch the target chip field
+	 */
+	cfg = __prepare_ICR(shortcut, vector, dest);
+
+	/*
+	 * Send the IPI. The write to APIC_ICR fires this off.
+	 */
+	apic_write(APIC_ICR, cfg);
+}
+
+
+static inline void send_IPI_mask_sequence(cpumask_t mask, int vector)
+{
+	unsigned long cfg, flags;
+	unsigned long query_cpu;
+
+	/*
+	 * Hack. The clustered APIC addressing mode doesn't allow us to send
+	 * to an arbitrary mask, so I do a unicast to each CPU instead.
+	 * - mbligh
+	 */
+	local_irq_save(flags);
+
+	for_each_cpu_mask(query_cpu, mask) {
+		/*
+		 * Wait for idle.
+		 */
+		apic_wait_icr_idle();
+
+		/*
+		 * prepare target chip field
+		 */
+		cfg = __prepare_ICR2(x86_cpu_to_apicid[query_cpu]);
+		apic_write(APIC_ICR2, cfg);
+
+		/*
+		 * program the ICR
+		 */
+		cfg = __prepare_ICR(0, vector, APIC_DEST_PHYSICAL);
+
+		/*
+		 * Send the IPI. The write to APIC_ICR fires this off.
+		 */
+		apic_write(APIC_ICR, cfg);
+	}
+	local_irq_restore(flags);
+}
+
+#endif /* __ASM_IPI_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/irqflags.h linux-2.6.20-sabayon-r1/include/asm/irqflags.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/irqflags.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/irqflags.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,141 @@
+/*
+ * include/asm-x86_64/irqflags.h
+ *
+ * IRQ flags handling
+ *
+ * This file gets included from lowlevel asm headers too, to provide
+ * wrapped versions of the local_irq_*() APIs, based on the
+ * raw_local_irq_*() functions from the lowlevel headers.
+ */
+#ifndef _ASM_IRQFLAGS_H
+#define _ASM_IRQFLAGS_H
+
+#ifndef __ASSEMBLY__
+/*
+ * Interrupt control:
+ */
+
+static inline unsigned long __raw_local_save_flags(void)
+{
+	unsigned long flags;
+
+	__asm__ __volatile__(
+		"# __raw_save_flags\n\t"
+		"pushfq ; popq %q0"
+		: "=g" (flags)
+		: /* no input */
+		: "memory"
+	);
+
+	return flags;
+}
+
+#define raw_local_save_flags(flags) \
+		do { (flags) = __raw_local_save_flags(); } while (0)
+
+static inline void raw_local_irq_restore(unsigned long flags)
+{
+	__asm__ __volatile__(
+		"pushq %0 ; popfq"
+		: /* no output */
+		:"g" (flags)
+		:"memory", "cc"
+	);
+}
+
+#ifdef CONFIG_X86_VSMP
+
+/*
+ * Interrupt control for the VSMP architecture:
+ */
+
+static inline void raw_local_irq_disable(void)
+{
+	unsigned long flags = __raw_local_save_flags();
+
+	raw_local_irq_restore((flags & ~(1 << 9)) | (1 << 18));
+}
+
+static inline void raw_local_irq_enable(void)
+{
+	unsigned long flags = __raw_local_save_flags();
+
+	raw_local_irq_restore((flags | (1 << 9)) & ~(1 << 18));
+}
+
+static inline int raw_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & (1<<9)) || (flags & (1 << 18));
+}
+
+#else /* CONFIG_X86_VSMP */
+
+static inline void raw_local_irq_disable(void)
+{
+	__asm__ __volatile__("cli" : : : "memory");
+}
+
+static inline void raw_local_irq_enable(void)
+{
+	__asm__ __volatile__("sti" : : : "memory");
+}
+
+static inline int raw_irqs_disabled_flags(unsigned long flags)
+{
+	return !(flags & (1 << 9));
+}
+
+#endif
+
+/*
+ * For spinlocks, etc.:
+ */
+
+static inline unsigned long __raw_local_irq_save(void)
+{
+	unsigned long flags = __raw_local_save_flags();
+
+	raw_local_irq_disable();
+
+	return flags;
+}
+
+#define raw_local_irq_save(flags) \
+		do { (flags) = __raw_local_irq_save(); } while (0)
+
+static inline int raw_irqs_disabled(void)
+{
+	unsigned long flags = __raw_local_save_flags();
+
+	return raw_irqs_disabled_flags(flags);
+}
+
+/*
+ * Used in the idle loop; sti takes one instruction cycle
+ * to complete:
+ */
+static inline void raw_safe_halt(void)
+{
+	__asm__ __volatile__("sti; hlt" : : : "memory");
+}
+
+/*
+ * Used when interrupts are already enabled or to
+ * shutdown the processor:
+ */
+static inline void halt(void)
+{
+	__asm__ __volatile__("hlt": : :"memory");
+}
+
+#else /* __ASSEMBLY__: */
+# ifdef CONFIG_TRACE_IRQFLAGS
+#  define TRACE_IRQS_ON		call trace_hardirqs_on_thunk
+#  define TRACE_IRQS_OFF	call trace_hardirqs_off_thunk
+# else
+#  define TRACE_IRQS_ON
+#  define TRACE_IRQS_OFF
+# endif
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/irq.h linux-2.6.20-sabayon-r1/include/asm/irq.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/irq.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/irq.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,51 @@
+#ifndef _ASM_IRQ_H
+#define _ASM_IRQ_H
+
+/*
+ *	linux/include/asm/irq.h
+ *
+ *	(C) 1992, 1993 Linus Torvalds, (C) 1997 Ingo Molnar
+ *
+ *	IRQ/IPI changes taken from work by Thomas Radke
+ *	<tomsoft@informatik.tu-chemnitz.de>
+ */
+
+#define TIMER_IRQ 0
+
+/*
+ * 16 8259A IRQ's, 208 potential APIC interrupt sources.
+ * Right now the APIC is mostly only used for SMP.
+ * 256 vectors is an architectural limit. (we can have
+ * more than 256 devices theoretically, but they will
+ * have to use shared interrupts)
+ * Since vectors 0x00-0x1f are used/reserved for the CPU,
+ * the usable vector space is 0x20-0xff (224 vectors)
+ */
+
+/*
+ * The maximum number of vectors supported by x86_64 processors
+ * is limited to 256. For processors other than x86_64, NR_VECTORS
+ * should be changed accordingly.
+ */
+#define NR_VECTORS 256
+
+#define FIRST_SYSTEM_VECTOR	0xef   /* duplicated in hw_irq.h */
+
+#define NR_IRQS (NR_VECTORS + (32 *NR_CPUS))
+#define NR_IRQ_VECTORS NR_IRQS
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return ((irq == 2) ? 9 : irq);
+}
+
+#define ARCH_HAS_NMI_WATCHDOG		/* See include/linux/nmi.h */
+
+#ifdef CONFIG_HOTPLUG_CPU
+#include <linux/cpumask.h>
+extern void fixup_irqs(cpumask_t map);
+#endif
+
+#define __ARCH_HAS_DO_SOFTIRQ 1
+
+#endif /* _ASM_IRQ_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/irq_regs.h linux-2.6.20-sabayon-r1/include/asm/irq_regs.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/irq_regs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/irq_regs.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/k8.h linux-2.6.20-sabayon-r1/include/asm/k8.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/k8.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/k8.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,14 @@
+#ifndef _ASM_K8_H
+#define _ASM_K8_H 1
+
+#include <linux/pci.h>
+
+extern struct pci_device_id k8_nb_ids[];
+
+extern int early_is_k8_nb(u32 value);
+extern struct pci_dev **k8_northbridges;
+extern int num_k8_northbridges;
+extern int cache_k8_northbridges(void);
+extern void k8_flush_garts(void);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/Kbuild linux-2.6.20-sabayon-r1/include/asm/Kbuild
--- linux-2.6.20-sabayon-r1.orig/include/asm/Kbuild	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/Kbuild	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+include include/asm-generic/Kbuild.asm
+
+ALTARCH := i386
+ARCHDEF := defined __x86_64__
+ALTARCHDEF := defined __i386__
+
+header-y += boot.h
+header-y += bootsetup.h
+header-y += debugreg.h
+header-y += ldt.h
+header-y += msr.h
+header-y += prctl.h
+header-y += ptrace-abi.h
+header-y += sigcontext32.h
+header-y += ucontext.h
+header-y += vsyscall32.h
+
+unifdef-y += mce.h
+unifdef-y += mtrr.h
+unifdef-y += vsyscall.h
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/kdebug.h linux-2.6.20-sabayon-r1/include/asm/kdebug.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/kdebug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/kdebug.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,60 @@
+#ifndef _X86_64_KDEBUG_H
+#define _X86_64_KDEBUG_H 1
+
+#include <linux/notifier.h>
+
+struct pt_regs;
+
+struct die_args {
+	struct pt_regs *regs;
+	const char *str;
+	long err;
+	int trapnr;
+	int signr;
+};
+
+extern int register_die_notifier(struct notifier_block *);
+extern int unregister_die_notifier(struct notifier_block *);
+extern int register_page_fault_notifier(struct notifier_block *);
+extern int unregister_page_fault_notifier(struct notifier_block *);
+extern struct atomic_notifier_head die_chain;
+
+/* Grossly misnamed. */
+enum die_val {
+	DIE_OOPS = 1,
+	DIE_INT3,
+	DIE_DEBUG,
+	DIE_PANIC,
+	DIE_NMI,
+	DIE_DIE,
+	DIE_NMIWATCHDOG,
+	DIE_KERNELDEBUG,
+	DIE_TRAP,
+	DIE_GPF,
+	DIE_CALL,
+	DIE_NMI_IPI,
+	DIE_PAGE_FAULT,
+};
+
+static inline int notify_die(enum die_val val, const char *str,
+			struct pt_regs *regs, long err, int trap, int sig)
+{
+	struct die_args args = {
+		.regs = regs,
+		.str = str,
+		.err = err,
+		.trapnr = trap,
+		.signr = sig
+	};
+	return atomic_notifier_call_chain(&die_chain, val, &args);
+} 
+
+extern void printk_address(unsigned long address);
+extern void die(const char *,struct pt_regs *,long);
+extern void __die(const char *,struct pt_regs *,long);
+extern void show_registers(struct pt_regs *regs);
+extern void dump_pagetable(unsigned long);
+extern unsigned long oops_begin(void);
+extern void oops_end(unsigned long);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/kexec.h linux-2.6.20-sabayon-r1/include/asm/kexec.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/kexec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/kexec.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,96 @@
+#ifndef _X86_64_KEXEC_H
+#define _X86_64_KEXEC_H
+
+#define PA_CONTROL_PAGE  0
+#define VA_CONTROL_PAGE  1
+#define PA_PGD           2
+#define VA_PGD           3
+#define PA_PUD_0         4
+#define VA_PUD_0         5
+#define PA_PMD_0         6
+#define VA_PMD_0         7
+#define PA_PTE_0         8
+#define VA_PTE_0         9
+#define PA_PUD_1         10
+#define VA_PUD_1         11
+#define PA_PMD_1         12
+#define VA_PMD_1         13
+#define PA_PTE_1         14
+#define VA_PTE_1         15
+#define PA_TABLE_PAGE    16
+#define PAGES_NR         17
+
+#ifndef __ASSEMBLY__
+
+#include <linux/string.h>
+
+#include <asm/page.h>
+#include <asm/ptrace.h>
+
+/*
+ * KEXEC_SOURCE_MEMORY_LIMIT maximum page get_free_page can return.
+ * I.e. Maximum page that is mapped directly into kernel memory,
+ * and kmap is not required.
+ *
+ * So far x86_64 is limited to 40 physical address bits.
+ */
+
+/* Maximum physical address we can use pages from */
+#define KEXEC_SOURCE_MEMORY_LIMIT      (0xFFFFFFFFFFUL)
+/* Maximum address we can reach in physical address mode */
+#define KEXEC_DESTINATION_MEMORY_LIMIT (0xFFFFFFFFFFUL)
+/* Maximum address we can use for the control pages */
+#define KEXEC_CONTROL_MEMORY_LIMIT     (0xFFFFFFFFFFUL)
+
+/* Allocate one page for the pdp and the second for the code */
+#define KEXEC_CONTROL_CODE_SIZE  (4096UL + 4096UL)
+
+/* The native architecture */
+#define KEXEC_ARCH KEXEC_ARCH_X86_64
+
+#define MAX_NOTE_BYTES 1024
+
+/*
+ * Saving the registers of the cpu on which panic occured in
+ * crash_kexec to save a valid sp. The registers of other cpus
+ * will be saved in machine_crash_shutdown while shooting down them.
+ */
+
+static inline void crash_setup_regs(struct pt_regs *newregs,
+						struct pt_regs *oldregs)
+{
+	if (oldregs)
+		memcpy(newregs, oldregs, sizeof(*newregs));
+	else {
+		__asm__ __volatile__("movq %%rbx,%0" : "=m"(newregs->rbx));
+		__asm__ __volatile__("movq %%rcx,%0" : "=m"(newregs->rcx));
+		__asm__ __volatile__("movq %%rdx,%0" : "=m"(newregs->rdx));
+		__asm__ __volatile__("movq %%rsi,%0" : "=m"(newregs->rsi));
+		__asm__ __volatile__("movq %%rdi,%0" : "=m"(newregs->rdi));
+		__asm__ __volatile__("movq %%rbp,%0" : "=m"(newregs->rbp));
+		__asm__ __volatile__("movq %%rax,%0" : "=m"(newregs->rax));
+		__asm__ __volatile__("movq %%rsp,%0" : "=m"(newregs->rsp));
+		__asm__ __volatile__("movq %%r8,%0" : "=m"(newregs->r8));
+		__asm__ __volatile__("movq %%r9,%0" : "=m"(newregs->r9));
+		__asm__ __volatile__("movq %%r10,%0" : "=m"(newregs->r10));
+		__asm__ __volatile__("movq %%r11,%0" : "=m"(newregs->r11));
+		__asm__ __volatile__("movq %%r12,%0" : "=m"(newregs->r12));
+		__asm__ __volatile__("movq %%r13,%0" : "=m"(newregs->r13));
+		__asm__ __volatile__("movq %%r14,%0" : "=m"(newregs->r14));
+		__asm__ __volatile__("movq %%r15,%0" : "=m"(newregs->r15));
+		__asm__ __volatile__("movl %%ss, %%eax;" :"=a"(newregs->ss));
+		__asm__ __volatile__("movl %%cs, %%eax;" :"=a"(newregs->cs));
+		__asm__ __volatile__("pushfq; popq %0" :"=m"(newregs->eflags));
+
+		newregs->rip = (unsigned long)current_text_addr();
+	}
+}
+
+NORET_TYPE void
+relocate_kernel(unsigned long indirection_page,
+		unsigned long page_list,
+		unsigned long start_address) ATTRIB_NORET;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* _X86_64_KEXEC_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/kmap_types.h linux-2.6.20-sabayon-r1/include/asm/kmap_types.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/kmap_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/kmap_types.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,19 @@
+#ifndef _ASM_KMAP_TYPES_H
+#define _ASM_KMAP_TYPES_H
+
+enum km_type {
+	KM_BOUNCE_READ,
+	KM_SKB_SUNRPC_DATA,
+	KM_SKB_DATA_SOFTIRQ,
+	KM_USER0,
+	KM_USER1,
+	KM_BIO_SRC_IRQ,
+	KM_BIO_DST_IRQ,
+	KM_IRQ0,
+	KM_IRQ1,
+	KM_SOFTIRQ0,
+	KM_SOFTIRQ1,
+	KM_TYPE_NR
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/kprobes.h linux-2.6.20-sabayon-r1/include/asm/kprobes.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/kprobes.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/kprobes.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,91 @@
+#ifndef _ASM_KPROBES_H
+#define _ASM_KPROBES_H
+/*
+ *  Kernel Probes (KProbes)
+ *  include/asm-x86_64/kprobes.h
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright (C) IBM Corporation, 2002, 2004
+ *
+ * 2004-Oct	Prasanna S Panchamukhi <prasanna@in.ibm.com> and Jim Keniston
+ *		kenistoj@us.ibm.com adopted from i386.
+ */
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/percpu.h>
+
+#define  __ARCH_WANT_KPROBES_INSN_SLOT
+
+struct pt_regs;
+struct kprobe;
+
+typedef u8 kprobe_opcode_t;
+#define BREAKPOINT_INSTRUCTION	0xcc
+#define MAX_INSN_SIZE 15
+#define MAX_STACK_SIZE 64
+#define MIN_STACK_SIZE(ADDR) (((MAX_STACK_SIZE) < \
+	(((unsigned long)current_thread_info()) + THREAD_SIZE - (ADDR))) \
+	? (MAX_STACK_SIZE) \
+	: (((unsigned long)current_thread_info()) + THREAD_SIZE - (ADDR)))
+
+#define JPROBE_ENTRY(pentry)	(kprobe_opcode_t *)pentry
+#define ARCH_SUPPORTS_KRETPROBES
+#define  ARCH_INACTIVE_KPROBE_COUNT 1
+
+void kretprobe_trampoline(void);
+extern void arch_remove_kprobe(struct kprobe *p);
+#define flush_insn_slot(p)	do { } while (0)
+
+/* Architecture specific copy of original instruction*/
+struct arch_specific_insn {
+	/* copy of the original instruction */
+	kprobe_opcode_t *insn;
+};
+
+struct prev_kprobe {
+	struct kprobe *kp;
+	unsigned long status;
+	unsigned long old_rflags;
+	unsigned long saved_rflags;
+};
+
+/* per-cpu kprobe control block */
+struct kprobe_ctlblk {
+	unsigned long kprobe_status;
+	unsigned long kprobe_old_rflags;
+	unsigned long kprobe_saved_rflags;
+	long *jprobe_saved_rsp;
+	struct pt_regs jprobe_saved_regs;
+	kprobe_opcode_t jprobes_stack[MAX_STACK_SIZE];
+	struct prev_kprobe prev_kprobe;
+};
+
+/* trap3/1 are intr gates for kprobes.  So, restore the status of IF,
+ * if necessary, before executing the original int3/1 (trap) handler.
+ */
+static inline void restore_interrupts(struct pt_regs *regs)
+{
+	if (regs->eflags & IF_MASK)
+		local_irq_enable();
+}
+
+extern int post_kprobe_handler(struct pt_regs *regs);
+extern int kprobe_fault_handler(struct pt_regs *regs, int trapnr);
+extern int kprobe_handler(struct pt_regs *regs);
+
+extern int kprobe_exceptions_notify(struct notifier_block *self,
+				    unsigned long val, void *data);
+#endif				/* _ASM_KPROBES_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ldt.h linux-2.6.20-sabayon-r1/include/asm/ldt.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ldt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ldt.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,36 @@
+/*
+ * ldt.h
+ *
+ * Definitions of structures used with the modify_ldt system call.
+ */
+#ifndef _LINUX_LDT_H
+#define _LINUX_LDT_H
+
+/* Maximum number of LDT entries supported. */
+#define LDT_ENTRIES	8192
+/* The size of each LDT entry. */
+#define LDT_ENTRY_SIZE	8
+
+#ifndef __ASSEMBLY__
+/* Note on 64bit base and limit is ignored and you cannot set
+   DS/ES/CS not to the default values if you still want to do syscalls. This
+   call is more for 32bit mode therefore. */
+struct user_desc {
+	unsigned int  entry_number;
+	unsigned int  base_addr;
+	unsigned int  limit;
+	unsigned int  seg_32bit:1;
+	unsigned int  contents:2;
+	unsigned int  read_exec_only:1;
+	unsigned int  limit_in_pages:1;
+	unsigned int  seg_not_present:1;
+	unsigned int  useable:1;
+	unsigned int  lm:1;
+};
+
+#define MODIFY_LDT_CONTENTS_DATA	0
+#define MODIFY_LDT_CONTENTS_STACK	1
+#define MODIFY_LDT_CONTENTS_CODE	2
+
+#endif /* !__ASSEMBLY__ */
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/linkage.h linux-2.6.20-sabayon-r1/include/asm/linkage.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/linkage.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/linkage.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN .p2align 4,,15
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/local.h linux-2.6.20-sabayon-r1/include/asm/local.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/local.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/local.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,88 @@
+#ifndef _ARCH_X8664_LOCAL_H
+#define _ARCH_X8664_LOCAL_H
+
+#include <linux/percpu.h>
+
+typedef struct
+{
+	volatile long counter;
+} local_t;
+
+#define LOCAL_INIT(i)	{ (i) }
+
+#define local_read(v)	((v)->counter)
+#define local_set(v,i)	(((v)->counter) = (i))
+
+static inline void local_inc(local_t *v)
+{
+	__asm__ __volatile__(
+		"incq %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+static inline void local_dec(local_t *v)
+{
+	__asm__ __volatile__(
+		"decq %0"
+		:"=m" (v->counter)
+		:"m" (v->counter));
+}
+
+static inline void local_add(long i, local_t *v)
+{
+	__asm__ __volatile__(
+		"addq %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+static inline void local_sub(long i, local_t *v)
+{
+	__asm__ __volatile__(
+		"subq %1,%0"
+		:"=m" (v->counter)
+		:"ir" (i), "m" (v->counter));
+}
+
+/* On x86-64 these are better than the atomic variants on SMP kernels
+   because they dont use a lock prefix. */
+#define __local_inc(l)		local_inc(l)
+#define __local_dec(l)		local_dec(l)
+#define __local_add(i,l)	local_add((i),(l))
+#define __local_sub(i,l)	local_sub((i),(l))
+
+/* Use these for per-cpu local_t variables: on some archs they are
+ * much more efficient than these naive implementations.  Note they take
+ * a variable, not an address.
+ *
+ * This could be done better if we moved the per cpu data directly
+ * after GS.
+ */
+
+/* Need to disable preemption for the cpu local counters otherwise we could
+   still access a variable of a previous CPU in a non atomic way. */
+#define cpu_local_wrap_v(v)	 	\
+	({ local_t res__;		\
+	   preempt_disable(); 		\
+	   res__ = (v);			\
+	   preempt_enable();		\
+	   res__; })
+#define cpu_local_wrap(v)		\
+	({ preempt_disable();		\
+	   v;				\
+	   preempt_enable(); })		\
+
+#define cpu_local_read(v)    cpu_local_wrap_v(local_read(&__get_cpu_var(v)))
+#define cpu_local_set(v, i)  cpu_local_wrap(local_set(&__get_cpu_var(v), (i)))
+#define cpu_local_inc(v)     cpu_local_wrap(local_inc(&__get_cpu_var(v)))
+#define cpu_local_dec(v)     cpu_local_wrap(local_dec(&__get_cpu_var(v)))
+#define cpu_local_add(i, v)  cpu_local_wrap(local_add((i), &__get_cpu_var(v)))
+#define cpu_local_sub(i, v)  cpu_local_wrap(local_sub((i), &__get_cpu_var(v)))
+
+#define __cpu_local_inc(v)	cpu_local_inc(v)
+#define __cpu_local_dec(v)	cpu_local_dec(v)
+#define __cpu_local_add(i, v)	cpu_local_add((i), (v))
+#define __cpu_local_sub(i, v)	cpu_local_sub((i), (v))
+
+#endif /* _ARCH_I386_LOCAL_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mach_apic.h linux-2.6.20-sabayon-r1/include/asm/mach_apic.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mach_apic.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mach_apic.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,29 @@
+#ifndef __ASM_MACH_APIC_H
+#define __ASM_MACH_APIC_H
+
+/*
+ * Copyright 2004 James Cleverdon, IBM.
+ * Subject to the GNU Public License, v.2
+ *
+ * Generic APIC sub-arch defines.
+ *
+ * Hacked for x86-64 by James Cleverdon from i386 architecture code by
+ * Martin Bligh, Andi Kleen, James Bottomley, John Stultz, and
+ * James Cleverdon.
+ */
+
+#include <asm/genapic.h>
+
+#define INT_DELIVERY_MODE (genapic->int_delivery_mode)
+#define INT_DEST_MODE (genapic->int_dest_mode)
+#define TARGET_CPUS	  (genapic->target_cpus())
+#define vector_allocation_domain	(genapic->vector_allocation_domain)
+#define apic_id_registered (genapic->apic_id_registered)
+#define init_apic_ldr (genapic->init_apic_ldr)
+#define send_IPI_mask (genapic->send_IPI_mask)
+#define send_IPI_allbutself (genapic->send_IPI_allbutself)
+#define send_IPI_all (genapic->send_IPI_all)
+#define cpu_mask_to_apicid (genapic->cpu_mask_to_apicid)
+#define phys_pkg_id	(genapic->phys_pkg_id)
+
+#endif /* __ASM_MACH_APIC_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mc146818rtc.h linux-2.6.20-sabayon-r1/include/asm/mc146818rtc.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mc146818rtc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mc146818rtc.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifndef _ASM_MC146818RTC_H
+#define _ASM_MC146818RTC_H
+
+#include <asm/io.h>
+
+#ifndef RTC_PORT
+#define RTC_PORT(x)	(0x70 + (x))
+#define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#define RTC_IRQ 8
+
+#endif /* _ASM_MC146818RTC_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mce.h linux-2.6.20-sabayon-r1/include/asm/mce.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mce.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mce.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,108 @@
+#ifndef _ASM_MCE_H
+#define _ASM_MCE_H 1
+
+#include <asm/ioctls.h>
+#include <asm/types.h>
+
+/* 
+ * Machine Check support for x86
+ */
+
+#define MCG_CTL_P        (1UL<<8)   /* MCG_CAP register available */
+
+#define MCG_STATUS_RIPV  (1UL<<0)   /* restart ip valid */
+#define MCG_STATUS_EIPV  (1UL<<1)   /* eip points to correct instruction */
+#define MCG_STATUS_MCIP  (1UL<<2)   /* machine check in progress */
+
+#define MCI_STATUS_VAL   (1UL<<63)  /* valid error */
+#define MCI_STATUS_OVER  (1UL<<62)  /* previous errors lost */
+#define MCI_STATUS_UC    (1UL<<61)  /* uncorrected error */
+#define MCI_STATUS_EN    (1UL<<60)  /* error enabled */
+#define MCI_STATUS_MISCV (1UL<<59)  /* misc error reg. valid */
+#define MCI_STATUS_ADDRV (1UL<<58)  /* addr reg. valid */
+#define MCI_STATUS_PCC   (1UL<<57)  /* processor context corrupt */
+
+/* Fields are zero when not available */
+struct mce {
+	__u64 status;
+	__u64 misc;
+	__u64 addr;
+	__u64 mcgstatus;
+	__u64 rip;	
+	__u64 tsc;	/* cpu time stamp counter */
+	__u64 res1;	/* for future extension */	
+	__u64 res2;	/* dito. */
+	__u8  cs;		/* code segment */
+	__u8  bank;	/* machine check bank */
+	__u8  cpu;	/* cpu that raised the error */
+	__u8  finished;   /* entry is valid */
+	__u32 pad;   
+};
+
+/* 
+ * This structure contains all data related to the MCE log.
+ * Also carries a signature to make it easier to find from external debugging tools.
+ * Each entry is only valid when its finished flag is set.
+ */
+
+#define MCE_LOG_LEN 32
+
+struct mce_log { 
+	char signature[12]; /* "MACHINECHECK" */ 
+	unsigned len;  	    /* = MCE_LOG_LEN */ 
+	unsigned next;
+	unsigned flags;
+	unsigned pad0; 
+	struct mce entry[MCE_LOG_LEN];
+};
+
+#define MCE_OVERFLOW 0		/* bit 0 in flags means overflow */
+
+#define MCE_LOG_SIGNATURE 	"MACHINECHECK"
+
+#define MCE_GET_RECORD_LEN   _IOR('M', 1, int)
+#define MCE_GET_LOG_LEN      _IOR('M', 2, int)
+#define MCE_GETCLEAR_FLAGS   _IOR('M', 3, int)
+
+/* Software defined banks */
+#define MCE_EXTENDED_BANK	128
+#define MCE_THERMAL_BANK	MCE_EXTENDED_BANK + 0
+
+#define K8_MCE_THRESHOLD_BASE      (MCE_EXTENDED_BANK + 1)      /* MCE_AMD */
+#define K8_MCE_THRESHOLD_BANK_0    (MCE_THRESHOLD_BASE + 0 * 9)
+#define K8_MCE_THRESHOLD_BANK_1    (MCE_THRESHOLD_BASE + 1 * 9)
+#define K8_MCE_THRESHOLD_BANK_2    (MCE_THRESHOLD_BASE + 2 * 9)
+#define K8_MCE_THRESHOLD_BANK_3    (MCE_THRESHOLD_BASE + 3 * 9)
+#define K8_MCE_THRESHOLD_BANK_4    (MCE_THRESHOLD_BASE + 4 * 9)
+#define K8_MCE_THRESHOLD_BANK_5    (MCE_THRESHOLD_BASE + 5 * 9)
+#define K8_MCE_THRESHOLD_DRAM_ECC  (MCE_THRESHOLD_BANK_4 + 0)
+
+#ifdef __KERNEL__
+#include <asm/atomic.h>
+
+void mce_log(struct mce *m);
+DECLARE_PER_CPU(struct sys_device, device_mce);
+
+#ifdef CONFIG_X86_MCE_INTEL
+void mce_intel_feature_init(struct cpuinfo_x86 *c);
+#else
+static inline void mce_intel_feature_init(struct cpuinfo_x86 *c)
+{
+}
+#endif
+
+#ifdef CONFIG_X86_MCE_AMD
+void mce_amd_feature_init(struct cpuinfo_x86 *c);
+#else
+static inline void mce_amd_feature_init(struct cpuinfo_x86 *c)
+{
+}
+#endif
+
+void mce_log_therm_throt_event(unsigned int cpu, __u64 status);
+
+extern atomic_t mce_entry;
+
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mman.h linux-2.6.20-sabayon-r1/include/asm/mman.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mman.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mman.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,19 @@
+#ifndef __X8664_MMAN_H__
+#define __X8664_MMAN_H__
+
+#include <asm-generic/mman.h>
+
+#define MAP_32BIT	0x40		/* only give out 32bit addresses */
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mmsegment.h linux-2.6.20-sabayon-r1/include/asm/mmsegment.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mmsegment.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mmsegment.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef _ASM_MMSEGMENT_H
+#define _ASM_MMSEGMENT_H 1
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mmu_context.h linux-2.6.20-sabayon-r1/include/asm/mmu_context.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mmu_context.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mmu_context.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,73 @@
+#ifndef __X86_64_MMU_CONTEXT_H
+#define __X86_64_MMU_CONTEXT_H
+
+#include <asm/desc.h>
+#include <asm/atomic.h>
+#include <asm/pgalloc.h>
+#include <asm/pda.h>
+#include <asm/pgtable.h>
+#include <asm/tlbflush.h>
+
+/*
+ * possibly do the LDT unload here?
+ */
+int init_new_context(struct task_struct *tsk, struct mm_struct *mm);
+void destroy_context(struct mm_struct *mm);
+
+static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
+{
+#ifdef CONFIG_SMP
+	if (read_pda(mmu_state) == TLBSTATE_OK) 
+		write_pda(mmu_state, TLBSTATE_LAZY);
+#endif
+}
+
+static inline void load_cr3(pgd_t *pgd)
+{
+	asm volatile("movq %0,%%cr3" :: "r" (__pa(pgd)) : "memory");
+}
+
+static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next, 
+			     struct task_struct *tsk)
+{
+	unsigned cpu = smp_processor_id();
+	if (likely(prev != next)) {
+		/* stop flush ipis for the previous mm */
+		cpu_clear(cpu, prev->cpu_vm_mask);
+#ifdef CONFIG_SMP
+		write_pda(mmu_state, TLBSTATE_OK);
+		write_pda(active_mm, next);
+#endif
+		cpu_set(cpu, next->cpu_vm_mask);
+		load_cr3(next->pgd);
+
+		if (unlikely(next->context.ldt != prev->context.ldt)) 
+			load_LDT_nolock(&next->context, cpu);
+	}
+#ifdef CONFIG_SMP
+	else {
+		write_pda(mmu_state, TLBSTATE_OK);
+		if (read_pda(active_mm) != next)
+			out_of_line_bug();
+		if (!cpu_test_and_set(cpu, next->cpu_vm_mask)) {
+			/* We were in lazy tlb mode and leave_mm disabled 
+			 * tlb flush IPI delivery. We must reload CR3
+			 * to make sure to use no freed page tables.
+			 */
+			load_cr3(next->pgd);
+			load_LDT_nolock(&next->context, cpu);
+		}
+	}
+#endif
+}
+
+#define deactivate_mm(tsk,mm)	do { \
+	load_gs_index(0); \
+	asm volatile("movl %0,%%fs"::"r"(0));  \
+} while(0)
+
+#define activate_mm(prev, next) \
+	switch_mm((prev),(next),NULL)
+
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mmu.h linux-2.6.20-sabayon-r1/include/asm/mmu.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mmu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mmu.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef __x86_64_MMU_H
+#define __x86_64_MMU_H
+
+#include <linux/spinlock.h>
+#include <asm/semaphore.h>
+
+/*
+ * The x86_64 doesn't have a mmu context, but
+ * we put the segment information here.
+ *
+ * cpu_vm_mask is used to optimize ldt flushing.
+ */
+typedef struct { 
+	void *ldt;
+	rwlock_t ldtlock; 
+	int size;
+	struct semaphore sem; 
+} mm_context_t;
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mmzone.h linux-2.6.20-sabayon-r1/include/asm/mmzone.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mmzone.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mmzone.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,50 @@
+/* K8 NUMA support */
+/* Copyright 2002,2003 by Andi Kleen, SuSE Labs */
+/* 2.5 Version loosely based on the NUMAQ Code by Pat Gaughen. */
+#ifndef _ASM_X86_64_MMZONE_H
+#define _ASM_X86_64_MMZONE_H 1
+
+
+#ifdef CONFIG_NUMA
+
+#define VIRTUAL_BUG_ON(x) 
+
+#include <asm/smp.h>
+
+/* Should really switch to dynamic allocation at some point */
+#define NODEMAPSIZE 0x4fff
+
+/* Simple perfect hash to map physical addresses to node numbers */
+struct memnode {
+	int shift;
+	u8 map[NODEMAPSIZE];
+} ____cacheline_aligned;
+extern struct memnode memnode;
+#define memnode_shift memnode.shift
+#define memnodemap memnode.map
+
+extern struct pglist_data *node_data[];
+
+static inline __attribute__((pure)) int phys_to_nid(unsigned long addr) 
+{ 
+	unsigned nid; 
+	VIRTUAL_BUG_ON((addr >> memnode_shift) >= NODEMAPSIZE);
+	nid = memnodemap[addr >> memnode_shift]; 
+	VIRTUAL_BUG_ON(nid >= MAX_NUMNODES || !node_data[nid]); 
+	return nid; 
+} 
+
+#define NODE_DATA(nid)		(node_data[nid])
+
+#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
+#define node_end_pfn(nid)       (NODE_DATA(nid)->node_start_pfn + \
+				 NODE_DATA(nid)->node_spanned_pages)
+
+#ifdef CONFIG_DISCONTIGMEM
+#define pfn_to_nid(pfn) phys_to_nid((unsigned long)(pfn) << PAGE_SHIFT)
+
+extern int pfn_valid(unsigned long pfn);
+#endif
+
+#endif
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/module.h linux-2.6.20-sabayon-r1/include/asm/module.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/module.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/module.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef _ASM_X8664_MODULE_H
+#define _ASM_X8664_MODULE_H
+
+struct mod_arch_specific {}; 
+
+#define Elf_Shdr Elf64_Shdr
+#define Elf_Sym Elf64_Sym
+#define Elf_Ehdr Elf64_Ehdr
+
+#endif 
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mpspec.h linux-2.6.20-sabayon-r1/include/asm/mpspec.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mpspec.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mpspec.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,233 @@
+#ifndef __ASM_MPSPEC_H
+#define __ASM_MPSPEC_H
+
+/*
+ * Structure definitions for SMP machines following the
+ * Intel Multiprocessing Specification 1.1 and 1.4.
+ */
+
+/*
+ * This tag identifies where the SMP configuration
+ * information is. 
+ */
+ 
+#define SMP_MAGIC_IDENT	(('_'<<24)|('P'<<16)|('M'<<8)|'_')
+
+/*
+ * A maximum of 255 APICs with the current APIC ID architecture.
+ */
+#define MAX_APICS 255
+
+struct intel_mp_floating
+{
+	char mpf_signature[4];		/* "_MP_" 			*/
+	unsigned int mpf_physptr;	/* Configuration table address	*/
+	unsigned char mpf_length;	/* Our length (paragraphs)	*/
+	unsigned char mpf_specification;/* Specification version	*/
+	unsigned char mpf_checksum;	/* Checksum (makes sum 0)	*/
+	unsigned char mpf_feature1;	/* Standard or configuration ? 	*/
+	unsigned char mpf_feature2;	/* Bit7 set for IMCR|PIC	*/
+	unsigned char mpf_feature3;	/* Unused (0)			*/
+	unsigned char mpf_feature4;	/* Unused (0)			*/
+	unsigned char mpf_feature5;	/* Unused (0)			*/
+};
+
+struct mp_config_table
+{
+	char mpc_signature[4];
+#define MPC_SIGNATURE "PCMP"
+	unsigned short mpc_length;	/* Size of table */
+	char  mpc_spec;			/* 0x01 */
+	char  mpc_checksum;
+	char  mpc_oem[8];
+	char  mpc_productid[12];
+	unsigned int mpc_oemptr;	/* 0 if not present */
+	unsigned short mpc_oemsize;	/* 0 if not present */
+	unsigned short mpc_oemcount;
+	unsigned int mpc_lapic;	/* APIC address */
+	unsigned int reserved;
+};
+
+/* Followed by entries */
+
+#define	MP_PROCESSOR	0
+#define	MP_BUS		1
+#define	MP_IOAPIC	2
+#define	MP_INTSRC	3
+#define	MP_LINTSRC	4
+
+struct mpc_config_processor
+{
+	unsigned char mpc_type;
+	unsigned char mpc_apicid;	/* Local APIC number */
+	unsigned char mpc_apicver;	/* Its versions */
+	unsigned char mpc_cpuflag;
+#define CPU_ENABLED		1	/* Processor is available */
+#define CPU_BOOTPROCESSOR	2	/* Processor is the BP */
+	unsigned int mpc_cpufeature;		
+#define CPU_STEPPING_MASK 0x0F
+#define CPU_MODEL_MASK	0xF0
+#define CPU_FAMILY_MASK	0xF00
+	unsigned int mpc_featureflag;	/* CPUID feature value */
+	unsigned int mpc_reserved[2];
+};
+
+struct mpc_config_bus
+{
+	unsigned char mpc_type;
+	unsigned char mpc_busid;
+	unsigned char mpc_bustype[6];
+};
+
+/* List of Bus Type string values, Intel MP Spec. */
+#define BUSTYPE_EISA	"EISA"
+#define BUSTYPE_ISA	"ISA"
+#define BUSTYPE_INTERN	"INTERN"	/* Internal BUS */
+#define BUSTYPE_MCA	"MCA"
+#define BUSTYPE_VL	"VL"		/* Local bus */
+#define BUSTYPE_PCI	"PCI"
+#define BUSTYPE_PCMCIA	"PCMCIA"
+#define BUSTYPE_CBUS	"CBUS"
+#define BUSTYPE_CBUSII	"CBUSII"
+#define BUSTYPE_FUTURE	"FUTURE"
+#define BUSTYPE_MBI	"MBI"
+#define BUSTYPE_MBII	"MBII"
+#define BUSTYPE_MPI	"MPI"
+#define BUSTYPE_MPSA	"MPSA"
+#define BUSTYPE_NUBUS	"NUBUS"
+#define BUSTYPE_TC	"TC"
+#define BUSTYPE_VME	"VME"
+#define BUSTYPE_XPRESS	"XPRESS"
+
+struct mpc_config_ioapic
+{
+	unsigned char mpc_type;
+	unsigned char mpc_apicid;
+	unsigned char mpc_apicver;
+	unsigned char mpc_flags;
+#define MPC_APIC_USABLE		0x01
+	unsigned int mpc_apicaddr;
+};
+
+struct mpc_config_intsrc
+{
+	unsigned char mpc_type;
+	unsigned char mpc_irqtype;
+	unsigned short mpc_irqflag;
+	unsigned char mpc_srcbus;
+	unsigned char mpc_srcbusirq;
+	unsigned char mpc_dstapic;
+	unsigned char mpc_dstirq;
+};
+
+enum mp_irq_source_types {
+	mp_INT = 0,
+	mp_NMI = 1,
+	mp_SMI = 2,
+	mp_ExtINT = 3
+};
+
+#define MP_IRQDIR_DEFAULT	0
+#define MP_IRQDIR_HIGH		1
+#define MP_IRQDIR_LOW		3
+
+
+struct mpc_config_lintsrc
+{
+	unsigned char mpc_type;
+	unsigned char mpc_irqtype;
+	unsigned short mpc_irqflag;
+	unsigned char mpc_srcbusid;
+	unsigned char mpc_srcbusirq;
+	unsigned char mpc_destapic;	
+#define MP_APIC_ALL	0xFF
+	unsigned char mpc_destapiclint;
+};
+
+/*
+ *	Default configurations
+ *
+ *	1	2 CPU ISA 82489DX
+ *	2	2 CPU EISA 82489DX neither IRQ 0 timer nor IRQ 13 DMA chaining
+ *	3	2 CPU EISA 82489DX
+ *	4	2 CPU MCA 82489DX
+ *	5	2 CPU ISA+PCI
+ *	6	2 CPU EISA+PCI
+ *	7	2 CPU MCA+PCI
+ */
+
+#define MAX_MP_BUSSES 256
+/* Each PCI slot may be a combo card with its own bus.  4 IRQ pins per slot. */
+#define MAX_IRQ_SOURCES (MAX_MP_BUSSES * 4)
+extern DECLARE_BITMAP(mp_bus_not_pci, MAX_MP_BUSSES);
+extern int mp_bus_id_to_pci_bus [MAX_MP_BUSSES];
+
+extern unsigned int boot_cpu_physical_apicid;
+extern int smp_found_config;
+extern void find_smp_config (void);
+extern void get_smp_config (void);
+extern int nr_ioapics;
+extern unsigned char apic_version [MAX_APICS];
+extern int mp_irq_entries;
+extern struct mpc_config_intsrc mp_irqs [MAX_IRQ_SOURCES];
+extern int mpc_default_type;
+extern unsigned long mp_lapic_addr;
+
+#ifdef CONFIG_ACPI
+extern void mp_register_lapic (u8 id, u8 enabled);
+extern void mp_register_lapic_address (u64 address);
+
+extern void mp_register_ioapic (u8 id, u32 address, u32 gsi_base);
+extern void mp_override_legacy_irq (u8 bus_irq, u8 polarity, u8 trigger, u32 gsi);
+extern void mp_config_acpi_legacy_irqs (void);
+extern int mp_register_gsi (u32 gsi, int triggering, int polarity);
+#endif
+
+extern int using_apic_timer;
+
+#define PHYSID_ARRAY_SIZE	BITS_TO_LONGS(MAX_APICS)
+
+struct physid_mask
+{
+	unsigned long mask[PHYSID_ARRAY_SIZE];
+};
+
+typedef struct physid_mask physid_mask_t;
+
+#define physid_set(physid, map)			set_bit(physid, (map).mask)
+#define physid_clear(physid, map)		clear_bit(physid, (map).mask)
+#define physid_isset(physid, map)		test_bit(physid, (map).mask)
+#define physid_test_and_set(physid, map)	test_and_set_bit(physid, (map).mask)
+
+#define physids_and(dst, src1, src2)		bitmap_and((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_or(dst, src1, src2)		bitmap_or((dst).mask, (src1).mask, (src2).mask, MAX_APICS)
+#define physids_clear(map)			bitmap_zero((map).mask, MAX_APICS)
+#define physids_complement(dst, src)		bitmap_complement((dst).mask, (src).mask, MAX_APICS)
+#define physids_empty(map)			bitmap_empty((map).mask, MAX_APICS)
+#define physids_equal(map1, map2)		bitmap_equal((map1).mask, (map2).mask, MAX_APICS)
+#define physids_weight(map)			bitmap_weight((map).mask, MAX_APICS)
+#define physids_shift_right(d, s, n)		bitmap_shift_right((d).mask, (s).mask, n, MAX_APICS)
+#define physids_shift_left(d, s, n)		bitmap_shift_left((d).mask, (s).mask, n, MAX_APICS)
+#define physids_coerce(map)			((map).mask[0])
+
+#define physids_promote(physids)						\
+	({									\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;			\
+		__physid_mask.mask[0] = physids;				\
+		__physid_mask;							\
+	})
+
+#define physid_mask_of_physid(physid)						\
+	({									\
+		physid_mask_t __physid_mask = PHYSID_MASK_NONE;			\
+		physid_set(physid, __physid_mask);				\
+		__physid_mask;							\
+	})
+
+#define PHYSID_MASK_ALL		{ {[0 ... PHYSID_ARRAY_SIZE-1] = ~0UL} }
+#define PHYSID_MASK_NONE	{ {[0 ... PHYSID_ARRAY_SIZE-1] = 0UL} }
+
+extern physid_mask_t phys_cpu_present_map;
+
+#endif
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/msgbuf.h linux-2.6.20-sabayon-r1/include/asm/msgbuf.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/msgbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/msgbuf.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef _X8664_MSGBUF_H
+#define _X8664_MSGBUF_H
+
+/* 
+ * The msqid64_ds structure for x86-64 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 2 miscellaneous 64-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/msidef.h linux-2.6.20-sabayon-r1/include/asm/msidef.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/msidef.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/msidef.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,47 @@
+#ifndef ASM_MSIDEF_H
+#define ASM_MSIDEF_H
+
+/*
+ * Constants for Intel APIC based MSI messages.
+ */
+
+/*
+ * Shifts for MSI data
+ */
+
+#define MSI_DATA_VECTOR_SHIFT		0
+#define  MSI_DATA_VECTOR_MASK		0x000000ff
+#define	 MSI_DATA_VECTOR(v)		(((v) << MSI_DATA_VECTOR_SHIFT) & MSI_DATA_VECTOR_MASK)
+
+#define MSI_DATA_DELIVERY_MODE_SHIFT	8
+#define  MSI_DATA_DELIVERY_FIXED	(0 << MSI_DATA_DELIVERY_MODE_SHIFT)
+#define  MSI_DATA_DELIVERY_LOWPRI	(1 << MSI_DATA_DELIVERY_MODE_SHIFT)
+
+#define MSI_DATA_LEVEL_SHIFT		14
+#define	 MSI_DATA_LEVEL_DEASSERT	(0 << MSI_DATA_LEVEL_SHIFT)
+#define	 MSI_DATA_LEVEL_ASSERT		(1 << MSI_DATA_LEVEL_SHIFT)
+
+#define MSI_DATA_TRIGGER_SHIFT		15
+#define  MSI_DATA_TRIGGER_EDGE		(0 << MSI_DATA_TRIGGER_SHIFT)
+#define  MSI_DATA_TRIGGER_LEVEL		(1 << MSI_DATA_TRIGGER_SHIFT)
+
+/*
+ * Shift/mask fields for msi address
+ */
+
+#define MSI_ADDR_BASE_HI		0
+#define MSI_ADDR_BASE_LO		0xfee00000
+
+#define MSI_ADDR_DEST_MODE_SHIFT	2
+#define  MSI_ADDR_DEST_MODE_PHYSICAL	(0 << MSI_ADDR_DEST_MODE_SHIFT)
+#define	 MSI_ADDR_DEST_MODE_LOGICAL	(1 << MSI_ADDR_DEST_MODE_SHIFT)
+
+#define MSI_ADDR_REDIRECTION_SHIFT	3
+#define  MSI_ADDR_REDIRECTION_CPU	(0 << MSI_ADDR_REDIRECTION_SHIFT) /* dedicated cpu */
+#define  MSI_ADDR_REDIRECTION_LOWPRI	(1 << MSI_ADDR_REDIRECTION_SHIFT) /* lowest priority */
+
+#define MSI_ADDR_DEST_ID_SHIFT		12
+#define	 MSI_ADDR_DEST_ID_MASK		0x00ffff0
+#define  MSI_ADDR_DEST_ID(dest)		(((dest) << MSI_ADDR_DEST_ID_SHIFT) & MSI_ADDR_DEST_ID_MASK)
+
+#endif /* ASM_MSIDEF_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/msr.h linux-2.6.20-sabayon-r1/include/asm/msr.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/msr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/msr.h	2007-02-12 12:49:04.000000000 +0100
@@ -0,0 +1,428 @@
+#ifndef X86_64_MSR_H
+#define X86_64_MSR_H 1
+
+#ifndef __ASSEMBLY__
+/*
+ * Access to machine-specific registers (available on 586 and better only)
+ * Note: the rd* operations modify the parameters directly (without using
+ * pointer indirection), this allows gcc to optimize better
+ */
+
+#define rdmsr(msr,val1,val2) \
+       __asm__ __volatile__("rdmsr" \
+			    : "=a" (val1), "=d" (val2) \
+			    : "c" (msr))
+
+
+#define rdmsrl(msr,val) do { unsigned long a__,b__; \
+       __asm__ __volatile__("rdmsr" \
+			    : "=a" (a__), "=d" (b__) \
+			    : "c" (msr)); \
+       val = a__ | (b__<<32); \
+} while(0)
+
+#define wrmsr(msr,val1,val2) \
+     __asm__ __volatile__("wrmsr" \
+			  : /* no outputs */ \
+			  : "c" (msr), "a" (val1), "d" (val2))
+
+#define wrmsrl(msr,val) wrmsr(msr,(__u32)((__u64)(val)),((__u64)(val))>>32) 
+
+/* wrmsr with exception handling */
+#define wrmsr_safe(msr,a,b) ({ int ret__;			\
+	asm volatile("2: wrmsr ; xorl %0,%0\n"			\
+		     "1:\n\t"					\
+		     ".section .fixup,\"ax\"\n\t"		\
+		     "3:  movl %4,%0 ; jmp 1b\n\t"		\
+		     ".previous\n\t"				\
+ 		     ".section __ex_table,\"a\"\n"		\
+		     "   .align 8\n\t"				\
+		     "   .quad 	2b,3b\n\t"			\
+		     ".previous"				\
+		     : "=a" (ret__)				\
+		     : "c" (msr), "0" (a), "d" (b), "i" (-EFAULT)); \
+	ret__; })
+
+#define checking_wrmsrl(msr,val) wrmsr_safe(msr,(u32)(val),(u32)((val)>>32))
+
+#define rdmsr_safe(msr,a,b) \
+	({ int ret__;						\
+	  asm volatile ("1:       rdmsr\n"			\
+                      "2:\n"					\
+                      ".section .fixup,\"ax\"\n"		\
+                      "3:       movl %4,%0\n"			\
+                      " jmp 2b\n"				\
+                      ".previous\n"				\
+                      ".section __ex_table,\"a\"\n"		\
+                      " .align 8\n"				\
+                      " .quad 1b,3b\n"				\
+                      ".previous":"=&bDS" (ret__), "=a"(*(a)), "=d"(*(b))\
+                      :"c"(msr), "i"(-EIO), "0"(0));		\
+	  ret__; })		
+
+#define rdtsc(low,high) \
+     __asm__ __volatile__("rdtsc" : "=a" (low), "=d" (high))
+
+#define rdtscl(low) \
+     __asm__ __volatile__ ("rdtsc" : "=a" (low) : : "edx")
+
+#define rdtscp(low,high,aux) \
+     asm volatile (".byte 0x0f,0x01,0xf9" : "=a" (low), "=d" (high), "=c" (aux))
+
+#define rdtscll(val) do { \
+     unsigned int __a,__d; \
+     asm volatile("rdtsc" : "=a" (__a), "=d" (__d)); \
+     (val) = ((unsigned long)__a) | (((unsigned long)__d)<<32); \
+} while(0)
+
+#define rdtscpll(val, aux) do { \
+     unsigned long __a, __d; \
+     asm volatile (".byte 0x0f,0x01,0xf9" : "=a" (__a), "=d" (__d), "=c" (aux)); \
+     (val) = (__d << 32) | __a; \
+} while (0)
+
+#define write_tsc(val1,val2) wrmsr(0x10, val1, val2)
+
+#define write_rdtscp_aux(val) wrmsr(0xc0000103, val, 0)
+
+#define rdpmc(counter,low,high) \
+     __asm__ __volatile__("rdpmc" \
+			  : "=a" (low), "=d" (high) \
+			  : "c" (counter))
+
+static inline void cpuid(int op, unsigned int *eax, unsigned int *ebx,
+			 unsigned int *ecx, unsigned int *edx)
+{
+	__asm__("cpuid"
+		: "=a" (*eax),
+		  "=b" (*ebx),
+		  "=c" (*ecx),
+		  "=d" (*edx)
+		: "0" (op));
+}
+
+/* Some CPUID calls want 'count' to be placed in ecx */
+static inline void cpuid_count(int op, int count, int *eax, int *ebx, int *ecx,
+	       	int *edx)
+{
+	__asm__("cpuid"
+		: "=a" (*eax),
+		  "=b" (*ebx),
+		  "=c" (*ecx),
+		  "=d" (*edx)
+		: "0" (op), "c" (count));
+}
+
+/*
+ * CPUID functions returning a single datum
+ */
+static inline unsigned int cpuid_eax(unsigned int op)
+{
+	unsigned int eax;
+
+	__asm__("cpuid"
+		: "=a" (eax)
+		: "0" (op)
+		: "bx", "cx", "dx");
+	return eax;
+}
+static inline unsigned int cpuid_ebx(unsigned int op)
+{
+	unsigned int eax, ebx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=b" (ebx)
+		: "0" (op)
+		: "cx", "dx" );
+	return ebx;
+}
+static inline unsigned int cpuid_ecx(unsigned int op)
+{
+	unsigned int eax, ecx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=c" (ecx)
+		: "0" (op)
+		: "bx", "dx" );
+	return ecx;
+}
+static inline unsigned int cpuid_edx(unsigned int op)
+{
+	unsigned int eax, edx;
+
+	__asm__("cpuid"
+		: "=a" (eax), "=d" (edx)
+		: "0" (op)
+		: "bx", "cx");
+	return edx;
+}
+
+#define MSR_IA32_UCODE_WRITE		0x79
+#define MSR_IA32_UCODE_REV		0x8b
+
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx);
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx);
+#endif
+
+/* AMD/K8 specific MSRs */ 
+#define MSR_EFER 0xc0000080		/* extended feature register */
+#define MSR_STAR 0xc0000081		/* legacy mode SYSCALL target */
+#define MSR_LSTAR 0xc0000082 		/* long mode SYSCALL target */
+#define MSR_CSTAR 0xc0000083		/* compatibility mode SYSCALL target */
+#define MSR_SYSCALL_MASK 0xc0000084	/* EFLAGS mask for syscall */
+#define MSR_FS_BASE 0xc0000100		/* 64bit FS base */
+#define MSR_GS_BASE 0xc0000101		/* 64bit GS base */
+#define MSR_KERNEL_GS_BASE  0xc0000102	/* SwapGS GS shadow (or USER_GS from kernel) */ 
+/* EFER bits: */ 
+#define _EFER_SCE 0  /* SYSCALL/SYSRET */
+#define _EFER_LME 8  /* Long mode enable */
+#define _EFER_LMA 10 /* Long mode active (read-only) */
+#define _EFER_NX 11  /* No execute enable */
+
+#define EFER_SCE (1<<_EFER_SCE)
+#define EFER_LME (1<<_EFER_LME)
+#define EFER_LMA (1<<_EFER_LMA)
+#define EFER_NX (1<<_EFER_NX)
+
+/* Intel MSRs. Some also available on other CPUs */
+#define MSR_IA32_TSC		0x10
+#define MSR_IA32_PLATFORM_ID	0x17
+
+#define MSR_IA32_PERFCTR0      0xc1
+#define MSR_IA32_PERFCTR1      0xc2
+#define MSR_FSB_FREQ		0xcd
+
+#define MSR_MTRRcap		0x0fe
+#define MSR_IA32_BBL_CR_CTL        0x119
+
+#define MSR_IA32_SYSENTER_CS	0x174
+#define MSR_IA32_SYSENTER_ESP	0x175
+#define MSR_IA32_SYSENTER_EIP	0x176
+
+#define MSR_IA32_MCG_CAP       0x179
+#define MSR_IA32_MCG_STATUS        0x17a
+#define MSR_IA32_MCG_CTL       0x17b
+
+#define MSR_IA32_EVNTSEL0      0x186
+#define MSR_IA32_EVNTSEL1      0x187
+
+#define MSR_IA32_DEBUGCTLMSR       0x1d9
+#define MSR_IA32_LASTBRANCHFROMIP  0x1db
+#define MSR_IA32_LASTBRANCHTOIP        0x1dc
+#define MSR_IA32_LASTINTFROMIP     0x1dd
+#define MSR_IA32_LASTINTTOIP       0x1de
+
+#define MSR_IA32_PEBS_ENABLE		0x3f1
+#define MSR_IA32_DS_AREA		0x600
+#define MSR_IA32_PERF_CAPABILITIES	0x345
+
+#define MSR_MTRRfix64K_00000	0x250
+#define MSR_MTRRfix16K_80000	0x258
+#define MSR_MTRRfix16K_A0000	0x259
+#define MSR_MTRRfix4K_C0000	0x268
+#define MSR_MTRRfix4K_C8000	0x269
+#define MSR_MTRRfix4K_D0000	0x26a
+#define MSR_MTRRfix4K_D8000	0x26b
+#define MSR_MTRRfix4K_E0000	0x26c
+#define MSR_MTRRfix4K_E8000	0x26d
+#define MSR_MTRRfix4K_F0000	0x26e
+#define MSR_MTRRfix4K_F8000	0x26f
+#define MSR_MTRRdefType		0x2ff
+
+#define MSR_IA32_MC0_CTL       0x400
+#define MSR_IA32_MC0_STATUS        0x401
+#define MSR_IA32_MC0_ADDR      0x402
+#define MSR_IA32_MC0_MISC      0x403
+
+#define MSR_P6_PERFCTR0			0xc1
+#define MSR_P6_PERFCTR1			0xc2
+#define MSR_P6_EVNTSEL0			0x186
+#define MSR_P6_EVNTSEL1			0x187
+
+/* K7/K8 MSRs. Not complete. See the architecture manual for a more complete list. */
+#define MSR_K7_EVNTSEL0            0xC0010000
+#define MSR_K7_PERFCTR0            0xC0010004
+#define MSR_K7_EVNTSEL1            0xC0010001
+#define MSR_K7_PERFCTR1            0xC0010005
+#define MSR_K7_EVNTSEL2            0xC0010002
+#define MSR_K7_PERFCTR2            0xC0010006
+#define MSR_K7_EVNTSEL3            0xC0010003
+#define MSR_K7_PERFCTR3            0xC0010007
+#define MSR_K8_TOP_MEM1		   0xC001001A
+#define MSR_K8_TOP_MEM2		   0xC001001D
+#define MSR_K8_SYSCFG		   0xC0010010
+#define MSR_K8_HWCR		   0xC0010015
+
+/* K6 MSRs */
+#define MSR_K6_EFER			0xC0000080
+#define MSR_K6_STAR			0xC0000081
+#define MSR_K6_WHCR			0xC0000082
+#define MSR_K6_UWCCR			0xC0000085
+#define MSR_K6_PSOR			0xC0000087
+#define MSR_K6_PFIR			0xC0000088
+
+/* Centaur-Hauls/IDT defined MSRs. */
+#define MSR_IDT_FCR1			0x107
+#define MSR_IDT_FCR2			0x108
+#define MSR_IDT_FCR3			0x109
+#define MSR_IDT_FCR4			0x10a
+
+#define MSR_IDT_MCR0			0x110
+#define MSR_IDT_MCR1			0x111
+#define MSR_IDT_MCR2			0x112
+#define MSR_IDT_MCR3			0x113
+#define MSR_IDT_MCR4			0x114
+#define MSR_IDT_MCR5			0x115
+#define MSR_IDT_MCR6			0x116
+#define MSR_IDT_MCR7			0x117
+#define MSR_IDT_MCR_CTRL		0x120
+
+/* VIA Cyrix defined MSRs*/
+#define MSR_VIA_FCR			0x1107
+#define MSR_VIA_LONGHAUL		0x110a
+#define MSR_VIA_RNG			0x110b
+#define MSR_VIA_BCR2			0x1147
+
+/* Intel defined MSRs. */
+#define MSR_IA32_P5_MC_ADDR		0
+#define MSR_IA32_P5_MC_TYPE		1
+#define MSR_IA32_PLATFORM_ID		0x17
+#define MSR_IA32_EBL_CR_POWERON		0x2a
+
+#define MSR_IA32_APICBASE               0x1b
+#define MSR_IA32_APICBASE_BSP           (1<<8)
+#define MSR_IA32_APICBASE_ENABLE        (1<<11)
+#define MSR_IA32_APICBASE_BASE          (0xfffff<<12)
+
+/* P4/Xeon+ specific */
+#define MSR_IA32_MCG_EAX		0x180
+#define MSR_IA32_MCG_EBX		0x181
+#define MSR_IA32_MCG_ECX		0x182
+#define MSR_IA32_MCG_EDX		0x183
+#define MSR_IA32_MCG_ESI		0x184
+#define MSR_IA32_MCG_EDI		0x185
+#define MSR_IA32_MCG_EBP		0x186
+#define MSR_IA32_MCG_ESP		0x187
+#define MSR_IA32_MCG_EFLAGS		0x188
+#define MSR_IA32_MCG_EIP		0x189
+#define MSR_IA32_MCG_RESERVED		0x18A
+
+#define MSR_P6_EVNTSEL0			0x186
+#define MSR_P6_EVNTSEL1			0x187
+
+#define MSR_IA32_PERF_STATUS		0x198
+#define MSR_IA32_PERF_CTL		0x199
+
+#define MSR_IA32_MPERF			0xE7
+#define MSR_IA32_APERF			0xE8
+
+#define MSR_IA32_THERM_CONTROL		0x19a
+#define MSR_IA32_THERM_INTERRUPT	0x19b
+#define MSR_IA32_THERM_STATUS		0x19c
+#define MSR_IA32_MISC_ENABLE		0x1a0
+
+#define MSR_IA32_DEBUGCTLMSR		0x1d9
+#define MSR_IA32_LASTBRANCHFROMIP	0x1db
+#define MSR_IA32_LASTBRANCHTOIP		0x1dc
+#define MSR_IA32_LASTINTFROMIP		0x1dd
+#define MSR_IA32_LASTINTTOIP		0x1de
+
+#define MSR_IA32_MC0_CTL		0x400
+#define MSR_IA32_MC0_STATUS		0x401
+#define MSR_IA32_MC0_ADDR		0x402
+#define MSR_IA32_MC0_MISC		0x403
+
+/* Pentium IV performance counter MSRs */
+#define MSR_P4_BPU_PERFCTR0 		0x300
+#define MSR_P4_BPU_PERFCTR1 		0x301
+#define MSR_P4_BPU_PERFCTR2 		0x302
+#define MSR_P4_BPU_PERFCTR3 		0x303
+#define MSR_P4_MS_PERFCTR0 		0x304
+#define MSR_P4_MS_PERFCTR1 		0x305
+#define MSR_P4_MS_PERFCTR2 		0x306
+#define MSR_P4_MS_PERFCTR3 		0x307
+#define MSR_P4_FLAME_PERFCTR0 		0x308
+#define MSR_P4_FLAME_PERFCTR1 		0x309
+#define MSR_P4_FLAME_PERFCTR2 		0x30a
+#define MSR_P4_FLAME_PERFCTR3 		0x30b
+#define MSR_P4_IQ_PERFCTR0 		0x30c
+#define MSR_P4_IQ_PERFCTR1 		0x30d
+#define MSR_P4_IQ_PERFCTR2 		0x30e
+#define MSR_P4_IQ_PERFCTR3 		0x30f
+#define MSR_P4_IQ_PERFCTR4 		0x310
+#define MSR_P4_IQ_PERFCTR5 		0x311
+#define MSR_P4_BPU_CCCR0 		0x360
+#define MSR_P4_BPU_CCCR1 		0x361
+#define MSR_P4_BPU_CCCR2 		0x362
+#define MSR_P4_BPU_CCCR3 		0x363
+#define MSR_P4_MS_CCCR0 		0x364
+#define MSR_P4_MS_CCCR1 		0x365
+#define MSR_P4_MS_CCCR2 		0x366
+#define MSR_P4_MS_CCCR3 		0x367
+#define MSR_P4_FLAME_CCCR0 		0x368
+#define MSR_P4_FLAME_CCCR1 		0x369
+#define MSR_P4_FLAME_CCCR2 		0x36a
+#define MSR_P4_FLAME_CCCR3 		0x36b
+#define MSR_P4_IQ_CCCR0 		0x36c
+#define MSR_P4_IQ_CCCR1 		0x36d
+#define MSR_P4_IQ_CCCR2 		0x36e
+#define MSR_P4_IQ_CCCR3 		0x36f
+#define MSR_P4_IQ_CCCR4 		0x370
+#define MSR_P4_IQ_CCCR5 		0x371
+#define MSR_P4_ALF_ESCR0 		0x3ca
+#define MSR_P4_ALF_ESCR1 		0x3cb
+#define MSR_P4_BPU_ESCR0 		0x3b2
+#define MSR_P4_BPU_ESCR1 		0x3b3
+#define MSR_P4_BSU_ESCR0 		0x3a0
+#define MSR_P4_BSU_ESCR1 		0x3a1
+#define MSR_P4_CRU_ESCR0 		0x3b8
+#define MSR_P4_CRU_ESCR1 		0x3b9
+#define MSR_P4_CRU_ESCR2 		0x3cc
+#define MSR_P4_CRU_ESCR3 		0x3cd
+#define MSR_P4_CRU_ESCR4 		0x3e0
+#define MSR_P4_CRU_ESCR5 		0x3e1
+#define MSR_P4_DAC_ESCR0 		0x3a8
+#define MSR_P4_DAC_ESCR1 		0x3a9
+#define MSR_P4_FIRM_ESCR0 		0x3a4
+#define MSR_P4_FIRM_ESCR1 		0x3a5
+#define MSR_P4_FLAME_ESCR0 		0x3a6
+#define MSR_P4_FLAME_ESCR1 		0x3a7
+#define MSR_P4_FSB_ESCR0 		0x3a2
+#define MSR_P4_FSB_ESCR1 		0x3a3
+#define MSR_P4_IQ_ESCR0 		0x3ba
+#define MSR_P4_IQ_ESCR1 		0x3bb
+#define MSR_P4_IS_ESCR0 		0x3b4
+#define MSR_P4_IS_ESCR1 		0x3b5
+#define MSR_P4_ITLB_ESCR0 		0x3b6
+#define MSR_P4_ITLB_ESCR1 		0x3b7
+#define MSR_P4_IX_ESCR0 		0x3c8
+#define MSR_P4_IX_ESCR1 		0x3c9
+#define MSR_P4_MOB_ESCR0 		0x3aa
+#define MSR_P4_MOB_ESCR1 		0x3ab
+#define MSR_P4_MS_ESCR0 		0x3c0
+#define MSR_P4_MS_ESCR1 		0x3c1
+#define MSR_P4_PMH_ESCR0 		0x3ac
+#define MSR_P4_PMH_ESCR1 		0x3ad
+#define MSR_P4_RAT_ESCR0 		0x3bc
+#define MSR_P4_RAT_ESCR1 		0x3bd
+#define MSR_P4_SAAT_ESCR0 		0x3ae
+#define MSR_P4_SAAT_ESCR1 		0x3af
+#define MSR_P4_SSU_ESCR0 		0x3be
+#define MSR_P4_SSU_ESCR1 		0x3bf    /* guess: not defined in manual */
+#define MSR_P4_TBPU_ESCR0 		0x3c2
+#define MSR_P4_TBPU_ESCR1 		0x3c3
+#define MSR_P4_TC_ESCR0 		0x3c4
+#define MSR_P4_TC_ESCR1 		0x3c5
+#define MSR_P4_U2L_ESCR0 		0x3b0
+#define MSR_P4_U2L_ESCR1 		0x3b1
+
+/* Intel Core-based CPU performance counters */
+#define MSR_CORE_PERF_FIXED_CTR0	0x309
+#define MSR_CORE_PERF_FIXED_CTR1	0x30a
+#define MSR_CORE_PERF_FIXED_CTR2	0x30b
+#define MSR_CORE_PERF_FIXED_CTR_CTRL	0x38d
+#define MSR_CORE_PERF_GLOBAL_STATUS	0x38e
+#define MSR_CORE_PERF_GLOBAL_CTRL	0x38f
+#define MSR_CORE_PERF_GLOBAL_OVF_CTRL	0x390
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mtrr.h linux-2.6.20-sabayon-r1/include/asm/mtrr.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mtrr.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mtrr.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,140 @@
+/*  Generic MTRR (Memory Type Range Register) ioctls.
+
+    Copyright (C) 1997-1999  Richard Gooch
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public
+    License along with this library; if not, write to the Free
+    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    Richard Gooch may be reached by email at  rgooch@atnf.csiro.au
+    The postal address is:
+      Richard Gooch, c/o ATNF, P. O. Box 76, Epping, N.S.W., 2121, Australia.
+*/
+#ifndef _LINUX_MTRR_H
+#define _LINUX_MTRR_H
+
+#include <linux/ioctl.h>
+
+#define	MTRR_IOCTL_BASE	'M'
+
+struct mtrr_sentry
+{
+    unsigned long base;    /*  Base address     */
+    unsigned int size;    /*  Size of region   */
+    unsigned int type;     /*  Type of region   */
+};
+
+/* Warning: this structure has a different order from i386
+   on x86-64. The 32bit emulation code takes care of that.
+   But you need to use this for 64bit, otherwise your X server
+   will break. */
+struct mtrr_gentry
+{
+    unsigned long base;    /*  Base address     */
+    unsigned int size;    /*  Size of region   */
+    unsigned int regnum;   /*  Register number  */
+    unsigned int type;     /*  Type of region   */
+};
+
+/*  These are the various ioctls  */
+#define MTRRIOC_ADD_ENTRY        _IOW(MTRR_IOCTL_BASE,  0, struct mtrr_sentry)
+#define MTRRIOC_SET_ENTRY        _IOW(MTRR_IOCTL_BASE,  1, struct mtrr_sentry)
+#define MTRRIOC_DEL_ENTRY        _IOW(MTRR_IOCTL_BASE,  2, struct mtrr_sentry)
+#define MTRRIOC_GET_ENTRY        _IOWR(MTRR_IOCTL_BASE, 3, struct mtrr_gentry)
+#define MTRRIOC_KILL_ENTRY       _IOW(MTRR_IOCTL_BASE,  4, struct mtrr_sentry)
+#define MTRRIOC_ADD_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  5, struct mtrr_sentry)
+#define MTRRIOC_SET_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  6, struct mtrr_sentry)
+#define MTRRIOC_DEL_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  7, struct mtrr_sentry)
+#define MTRRIOC_GET_PAGE_ENTRY   _IOWR(MTRR_IOCTL_BASE, 8, struct mtrr_gentry)
+#define MTRRIOC_KILL_PAGE_ENTRY  _IOW(MTRR_IOCTL_BASE,  9, struct mtrr_sentry)
+
+/*  These are the region types  */
+#define MTRR_TYPE_UNCACHABLE 0
+#define MTRR_TYPE_WRCOMB     1
+/*#define MTRR_TYPE_         2*/
+/*#define MTRR_TYPE_         3*/
+#define MTRR_TYPE_WRTHROUGH  4
+#define MTRR_TYPE_WRPROT     5
+#define MTRR_TYPE_WRBACK     6
+#define MTRR_NUM_TYPES       7
+
+#ifdef __KERNEL__
+
+/*  The following functions are for use by other drivers  */
+# ifdef CONFIG_MTRR
+extern int mtrr_add (unsigned long base, unsigned long size,
+		     unsigned int type, char increment);
+extern int mtrr_add_page (unsigned long base, unsigned long size,
+		     unsigned int type, char increment);
+extern int mtrr_del (int reg, unsigned long base, unsigned long size);
+extern int mtrr_del_page (int reg, unsigned long base, unsigned long size);
+#  else
+static __inline__ int mtrr_add (unsigned long base, unsigned long size,
+				unsigned int type, char increment)
+{
+    return -ENODEV;
+}
+static __inline__ int mtrr_add_page (unsigned long base, unsigned long size,
+				unsigned int type, char increment)
+{
+    return -ENODEV;
+}
+static __inline__ int mtrr_del (int reg, unsigned long base,
+				unsigned long size)
+{
+    return -ENODEV;
+}
+static __inline__ int mtrr_del_page (int reg, unsigned long base,
+				unsigned long size)
+{
+    return -ENODEV;
+}
+
+#endif /* CONFIG_MTRR */
+
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+
+struct mtrr_sentry32
+{
+    compat_ulong_t base;    /*  Base address     */
+    compat_uint_t size;    /*  Size of region   */
+    compat_uint_t type;     /*  Type of region   */
+};
+
+struct mtrr_gentry32
+{
+    compat_ulong_t regnum;   /*  Register number  */
+    compat_uint_t base;    /*  Base address     */
+    compat_uint_t size;    /*  Size of region   */
+    compat_uint_t type;     /*  Type of region   */
+};
+
+#define MTRR_IOCTL_BASE 'M'
+
+#define MTRRIOC32_ADD_ENTRY        _IOW(MTRR_IOCTL_BASE,  0, struct mtrr_sentry32)
+#define MTRRIOC32_SET_ENTRY        _IOW(MTRR_IOCTL_BASE,  1, struct mtrr_sentry32)
+#define MTRRIOC32_DEL_ENTRY        _IOW(MTRR_IOCTL_BASE,  2, struct mtrr_sentry32)
+#define MTRRIOC32_GET_ENTRY        _IOWR(MTRR_IOCTL_BASE, 3, struct mtrr_gentry32)
+#define MTRRIOC32_KILL_ENTRY       _IOW(MTRR_IOCTL_BASE,  4, struct mtrr_sentry32)
+#define MTRRIOC32_ADD_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  5, struct mtrr_sentry32)
+#define MTRRIOC32_SET_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  6, struct mtrr_sentry32)
+#define MTRRIOC32_DEL_PAGE_ENTRY   _IOW(MTRR_IOCTL_BASE,  7, struct mtrr_sentry32)
+#define MTRRIOC32_GET_PAGE_ENTRY   _IOWR(MTRR_IOCTL_BASE, 8, struct mtrr_gentry32)
+#define MTRRIOC32_KILL_PAGE_ENTRY  _IOW(MTRR_IOCTL_BASE,  9, struct mtrr_sentry32)
+
+#endif /* CONFIG_COMPAT */
+
+#endif /* __KERNEL__ */
+
+#endif  /*  _LINUX_MTRR_H  */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/mutex.h linux-2.6.20-sabayon-r1/include/asm/mutex.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/mutex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/mutex.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,105 @@
+/*
+ * Assembly implementation of the mutex fastpath, based on atomic
+ * decrement/increment.
+ *
+ * started by Ingo Molnar:
+ *
+ *  Copyright (C) 2004, 2005, 2006 Red Hat, Inc., Ingo Molnar <mingo@redhat.com>
+ */
+#ifndef _ASM_MUTEX_H
+#define _ASM_MUTEX_H
+
+/**
+ * __mutex_fastpath_lock - decrement and call function if negative
+ * @v: pointer of type atomic_t
+ * @fail_fn: function to call if the result is negative
+ *
+ * Atomically decrements @v and calls <fail_fn> if the result is negative.
+ */
+#define __mutex_fastpath_lock(v, fail_fn)				\
+do {									\
+	unsigned long dummy;						\
+									\
+	typecheck(atomic_t *, v);					\
+	typecheck_fn(fastcall void (*)(atomic_t *), fail_fn);		\
+									\
+	__asm__ __volatile__(						\
+		LOCK_PREFIX "   decl (%%rdi)	\n"			\
+			"   jns 1f		\n"			\
+			"   call "#fail_fn"	\n"			\
+			"1:"						\
+									\
+		:"=D" (dummy)						\
+		: "D" (v)						\
+		: "rax", "rsi", "rdx", "rcx",				\
+		  "r8", "r9", "r10", "r11", "memory");			\
+} while (0)
+
+/**
+ *  __mutex_fastpath_lock_retval - try to take the lock by moving the count
+ *                                 from 1 to a 0 value
+ *  @count: pointer of type atomic_t
+ *  @fail_fn: function to call if the original value was not 1
+ *
+ * Change the count from 1 to a value lower than 1, and call <fail_fn> if
+ * it wasn't 1 originally. This function returns 0 if the fastpath succeeds,
+ * or anything the slow path function returns
+ */
+static inline int
+__mutex_fastpath_lock_retval(atomic_t *count,
+			     int fastcall (*fail_fn)(atomic_t *))
+{
+	if (unlikely(atomic_dec_return(count) < 0))
+		return fail_fn(count);
+	else
+		return 0;
+}
+
+/**
+ * __mutex_fastpath_unlock - increment and call function if nonpositive
+ * @v: pointer of type atomic_t
+ * @fail_fn: function to call if the result is nonpositive
+ *
+ * Atomically increments @v and calls <fail_fn> if the result is nonpositive.
+ */
+#define __mutex_fastpath_unlock(v, fail_fn)				\
+do {									\
+	unsigned long dummy;						\
+									\
+	typecheck(atomic_t *, v);					\
+	typecheck_fn(fastcall void (*)(atomic_t *), fail_fn);		\
+									\
+	__asm__ __volatile__(						\
+		LOCK_PREFIX "   incl (%%rdi)	\n"			\
+			"   jg 1f		\n"			\
+			"   call "#fail_fn"	\n"			\
+			"1:			  "			\
+									\
+		:"=D" (dummy)						\
+		: "D" (v)						\
+		: "rax", "rsi", "rdx", "rcx",				\
+		  "r8", "r9", "r10", "r11", "memory");			\
+} while (0)
+
+#define __mutex_slowpath_needs_to_unlock()	1
+
+/**
+ * __mutex_fastpath_trylock - try to acquire the mutex, without waiting
+ *
+ *  @count: pointer of type atomic_t
+ *  @fail_fn: fallback function
+ *
+ * Change the count from 1 to 0 and return 1 (success), or return 0 (failure)
+ * if it wasn't 1 originally. [the fallback function is never used on
+ * x86_64, because all x86_64 CPUs have a CMPXCHG instruction.]
+ */
+static inline int
+__mutex_fastpath_trylock(atomic_t *count, int (*fail_fn)(atomic_t *))
+{
+	if (likely(atomic_cmpxchg(count, 1, 0) == 1))
+		return 1;
+	else
+		return 0;
+}
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/namei.h linux-2.6.20-sabayon-r1/include/asm/namei.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/namei.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/namei.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,11 @@
+#ifndef __X8664_NAMEI_H
+#define __X8664_NAMEI_H
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/nmi.h linux-2.6.20-sabayon-r1/include/asm/nmi.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/nmi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/nmi.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,83 @@
+/*
+ *  linux/include/asm-i386/nmi.h
+ */
+#ifndef ASM_NMI_H
+#define ASM_NMI_H
+
+#include <linux/pm.h>
+#include <asm/io.h>
+ 
+/**
+ * do_nmi_callback
+ *
+ * Check to see if a callback exists and execute it.  Return 1
+ * if the handler exists and was handled successfully.
+ */
+int do_nmi_callback(struct pt_regs *regs, int cpu);
+
+#ifdef CONFIG_PM
+ 
+/** Replace the PM callback routine for NMI. */
+struct pm_dev * set_nmi_pm_callback(pm_callback callback);
+
+/** Unset the PM callback routine back to the default. */
+void unset_nmi_pm_callback(struct pm_dev * dev);
+
+#else
+
+static inline struct pm_dev * set_nmi_pm_callback(pm_callback callback)
+{
+	return 0;
+} 
+ 
+static inline void unset_nmi_pm_callback(struct pm_dev * dev)
+{
+}
+
+#endif /* CONFIG_PM */
+ 
+extern void default_do_nmi(struct pt_regs *);
+extern void die_nmi(char *str, struct pt_regs *regs, int do_panic);
+
+#define get_nmi_reason() inb(0x61)
+
+extern int panic_on_timeout;
+extern int unknown_nmi_panic;
+extern int nmi_watchdog_enabled;
+
+extern int check_nmi_watchdog(void);
+extern int avail_to_resrv_perfctr_nmi_bit(unsigned int);
+extern int avail_to_resrv_perfctr_nmi(unsigned int);
+extern int reserve_perfctr_nmi(unsigned int);
+extern void release_perfctr_nmi(unsigned int);
+extern int reserve_evntsel_nmi(unsigned int);
+extern void release_evntsel_nmi(unsigned int);
+
+extern void setup_apic_nmi_watchdog (void *);
+extern void stop_apic_nmi_watchdog (void *);
+extern void disable_timer_nmi_watchdog(void);
+extern void enable_timer_nmi_watchdog(void);
+extern int nmi_watchdog_tick (struct pt_regs * regs, unsigned reason);
+
+extern void nmi_watchdog_default(void);
+extern int setup_nmi_watchdog(char *);
+
+extern atomic_t nmi_active;
+extern unsigned int nmi_watchdog;
+#define NMI_DEFAULT	-1
+#define NMI_NONE	0
+#define NMI_IO_APIC	1
+#define NMI_LOCAL_APIC	2
+#define NMI_INVALID	3
+
+struct ctl_table;
+struct file;
+extern int proc_nmi_enabled(struct ctl_table *, int , struct file *,
+			void __user *, size_t *, loff_t *);
+
+extern int unknown_nmi_panic;
+
+void __trigger_all_cpu_backtrace(void);
+#define trigger_all_cpu_backtrace() __trigger_all_cpu_backtrace()
+
+#endif /* ASM_NMI_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/node.h linux-2.6.20-sabayon-r1/include/asm/node.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/node.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/node.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-i386/node.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/numa.h linux-2.6.20-sabayon-r1/include/asm/numa.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/numa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/numa.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,38 @@
+#ifndef _ASM_X8664_NUMA_H 
+#define _ASM_X8664_NUMA_H 1
+
+#include <linux/nodemask.h>
+
+struct bootnode {
+	u64 start,end; 
+};
+
+extern int compute_hash_shift(struct bootnode *nodes, int numnodes);
+
+#define ZONE_ALIGN (1UL << (MAX_ORDER+PAGE_SHIFT))
+
+extern void numa_add_cpu(int cpu);
+extern void numa_init_array(void);
+extern int numa_off;
+
+extern void numa_set_node(int cpu, int node);
+extern void srat_reserve_add_area(int nodeid);
+extern int hotadd_percent;
+
+extern unsigned char apicid_to_node[256];
+#ifdef CONFIG_NUMA
+extern void __init init_cpu_to_node(void);
+
+static inline void clear_node_cpumask(int cpu)
+{
+	clear_bit(cpu, &node_to_cpumask[cpu_to_node(cpu)]);
+}
+
+#else
+#define init_cpu_to_node() do {} while (0)
+#define clear_node_cpumask(cpu) do {} while (0)
+#endif
+
+#define NUMA_NO_NODE 0xff
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/page.h linux-2.6.20-sabayon-r1/include/asm/page.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/page.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/page.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,143 @@
+#ifndef _X86_64_PAGE_H
+#define _X86_64_PAGE_H
+
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	12
+#ifdef __ASSEMBLY__
+#define PAGE_SIZE	(0x1 << PAGE_SHIFT)
+#else
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#endif
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+#define PHYSICAL_PAGE_MASK	(~(PAGE_SIZE-1) & __PHYSICAL_MASK)
+
+#define THREAD_ORDER 1 
+#define THREAD_SIZE  (PAGE_SIZE << THREAD_ORDER)
+#define CURRENT_MASK (~(THREAD_SIZE-1))
+
+#define EXCEPTION_STACK_ORDER 0
+#define EXCEPTION_STKSZ (PAGE_SIZE << EXCEPTION_STACK_ORDER)
+
+#define DEBUG_STACK_ORDER (EXCEPTION_STACK_ORDER + 1)
+#define DEBUG_STKSZ (PAGE_SIZE << DEBUG_STACK_ORDER)
+
+#define IRQSTACK_ORDER 2
+#define IRQSTACKSIZE (PAGE_SIZE << IRQSTACK_ORDER)
+
+#define STACKFAULT_STACK 1
+#define DOUBLEFAULT_STACK 2
+#define NMI_STACK 3
+#define DEBUG_STACK 4
+#define MCE_STACK 5
+#define N_EXCEPTION_STACKS 5  /* hw limit: 7 */
+
+#define LARGE_PAGE_MASK (~(LARGE_PAGE_SIZE-1))
+#define LARGE_PAGE_SIZE (1UL << PMD_SHIFT)
+
+#define HPAGE_SHIFT PMD_SHIFT
+#define HPAGE_SIZE	((1UL) << HPAGE_SHIFT)
+#define HPAGE_MASK	(~(HPAGE_SIZE - 1))
+#define HUGETLB_PAGE_ORDER	(HPAGE_SHIFT - PAGE_SHIFT)
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+extern unsigned long end_pfn;
+
+void clear_page(void *);
+void copy_page(void *, void *);
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+#define alloc_zeroed_user_highpage(vma, vaddr) alloc_page_vma(GFP_HIGHUSER | __GFP_ZERO, vma, vaddr)
+#define __HAVE_ARCH_ALLOC_ZEROED_USER_HIGHPAGE
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pud; } pud_t;
+typedef struct { unsigned long pgd; } pgd_t;
+#define PTE_MASK	PHYSICAL_PAGE_MASK
+
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pte_val(x)	((x).pte)
+#define pmd_val(x)	((x).pmd)
+#define pud_val(x)	((x).pud)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x) ((pte_t) { (x) } )
+#define __pmd(x) ((pmd_t) { (x) } )
+#define __pud(x) ((pud_t) { (x) } )
+#define __pgd(x) ((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+#define __PHYSICAL_START	((unsigned long)CONFIG_PHYSICAL_START)
+#define __START_KERNEL		(__START_KERNEL_map + __PHYSICAL_START)
+#define __START_KERNEL_map	0xffffffff80000000UL
+#define __PAGE_OFFSET           0xffff810000000000UL
+
+#else
+#define __PHYSICAL_START	CONFIG_PHYSICAL_START
+#define __START_KERNEL		(__START_KERNEL_map + __PHYSICAL_START)
+#define __START_KERNEL_map	0xffffffff80000000
+#define __PAGE_OFFSET           0xffff810000000000
+#endif /* !__ASSEMBLY__ */
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr)+PAGE_SIZE-1)&PAGE_MASK)
+
+/* See Documentation/x86_64/mm.txt for a description of the memory map. */
+#define __PHYSICAL_MASK_SHIFT	46
+#define __PHYSICAL_MASK		((1UL << __PHYSICAL_MASK_SHIFT) - 1)
+#define __VIRTUAL_MASK_SHIFT	48
+#define __VIRTUAL_MASK		((1UL << __VIRTUAL_MASK_SHIFT) - 1)
+
+#define KERNEL_TEXT_SIZE  (40UL*1024*1024)
+#define KERNEL_TEXT_START 0xffffffff80000000UL 
+
+#ifndef __ASSEMBLY__
+
+#include <asm/bug.h>
+
+#endif /* __ASSEMBLY__ */
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+
+/* Note: __pa(&symbol_visible_to_c) should be always replaced with __pa_symbol.
+   Otherwise you risk miscompilation. */ 
+#define __pa(x)			(((unsigned long)(x)>=__START_KERNEL_map)?(unsigned long)(x) - (unsigned long)__START_KERNEL_map:(unsigned long)(x) - PAGE_OFFSET)
+/* __pa_symbol should be used for C visible symbols.
+   This seems to be the official gcc blessed way to do such arithmetic. */ 
+#define __pa_symbol(x)		\
+	({unsigned long v;  \
+	  asm("" : "=r" (v) : "0" (x)); \
+	  __pa(v); })
+
+#define __va(x)			((void *)((unsigned long)(x)+PAGE_OFFSET))
+#define __boot_va(x)		__va(x)
+#define __boot_pa(x)		__pa(x)
+#ifdef CONFIG_FLATMEM
+#define pfn_valid(pfn)		((pfn) < end_pfn)
+#endif
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+#define pfn_to_kaddr(pfn)      __va((pfn) << PAGE_SHIFT)
+
+#define VM_DATA_DEFAULT_FLAGS \
+	(((current->personality & READ_IMPLIES_EXEC) ? VM_EXEC : 0 ) | \
+	 VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+
+#define __HAVE_ARCH_GATE_AREA 1	
+
+#include <asm-generic/memory_model.h>
+#include <asm-generic/page.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _X86_64_PAGE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/param.h linux-2.6.20-sabayon-r1/include/asm/param.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/param.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/param.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef _ASMx86_64_PARAM_H
+#define _ASMx86_64_PARAM_H
+
+#ifdef __KERNEL__
+# define HZ            CONFIG_HZ	/* Internal kernel timer frequency */
+# define USER_HZ       100		/* .. some user interfaces are in "ticks */
+#define CLOCKS_PER_SEC        (USER_HZ)       /* like times() */
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/parport.h linux-2.6.20-sabayon-r1/include/asm/parport.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/parport.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/parport.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,18 @@
+/*
+ * parport.h: ia32-specific parport initialisation
+ *
+ * Copyright (C) 1999, 2000  Tim Waugh <tim@cyberelk.demon.co.uk>
+ *
+ * This file should only be included by drivers/parport/parport_pc.c.
+ */
+
+#ifndef _ASM_X8664_PARPORT_H
+#define _ASM_X8664_PARPORT_H 1
+
+static int __devinit parport_pc_find_isa_ports (int autoirq, int autodma);
+static int __devinit parport_pc_find_nonpci_ports (int autoirq, int autodma)
+{
+	return parport_pc_find_isa_ports (autoirq, autodma);
+}
+
+#endif 
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/pci-direct.h linux-2.6.20-sabayon-r1/include/asm/pci-direct.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/pci-direct.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/pci-direct.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,17 @@
+#ifndef ASM_PCI_DIRECT_H
+#define ASM_PCI_DIRECT_H 1
+
+#include <linux/types.h>
+
+/* Direct PCI access. This is used for PCI accesses in early boot before
+   the PCI subsystem works. */ 
+
+extern u32 read_pci_config(u8 bus, u8 slot, u8 func, u8 offset);
+extern u8 read_pci_config_byte(u8 bus, u8 slot, u8 func, u8 offset);
+extern u16 read_pci_config_16(u8 bus, u8 slot, u8 func, u8 offset);
+extern void write_pci_config(u8 bus, u8 slot, u8 func, u8 offset, u32 val);
+extern void write_pci_config_byte(u8 bus, u8 slot, u8 func, u8 offset, u8 val);
+
+extern int early_pci_allowed(void);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/pci.h linux-2.6.20-sabayon-r1/include/asm/pci.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/pci.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/pci.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,149 @@
+#ifndef __x8664_PCI_H
+#define __x8664_PCI_H
+
+#include <asm/io.h>
+
+#ifdef __KERNEL__
+
+#include <linux/mm.h> /* for struct page */
+
+/* Can be used to override the logic in pci_scan_bus for skipping
+   already-configured bus numbers - to be used for buggy BIOSes
+   or architectures with incomplete PCI setup by the loader */
+
+#ifdef CONFIG_PCI
+extern unsigned int pcibios_assign_all_busses(void);
+#else
+#define pcibios_assign_all_busses()	0
+#endif
+#define pcibios_scan_all_fns(a, b)	0
+
+extern unsigned long pci_mem_start;
+#define PCIBIOS_MIN_IO		0x1000
+#define PCIBIOS_MIN_MEM		(pci_mem_start)
+
+#define PCIBIOS_MIN_CARDBUS_IO	0x4000
+
+void pcibios_config_init(void);
+struct pci_bus * pcibios_scan_root(int bus);
+extern int (*pci_config_read)(int seg, int bus, int dev, int fn, int reg, int len, u32 *value);
+extern int (*pci_config_write)(int seg, int bus, int dev, int fn, int reg, int len, u32 value);
+
+void pcibios_set_master(struct pci_dev *dev);
+void pcibios_penalize_isa_irq(int irq, int active);
+struct irq_routing_table *pcibios_get_irq_routing_table(void);
+int pcibios_set_irq_routing(struct pci_dev *dev, int pin, int irq);
+
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <asm/scatterlist.h>
+#include <linux/string.h>
+#include <asm/page.h>
+
+extern void pci_iommu_alloc(void);
+extern int iommu_setup(char *opt);
+
+/* The PCI address space does equal the physical memory
+ * address space.  The networking and block device layers use
+ * this boolean for bounce buffer decisions
+ *
+ * On AMD64 it mostly equals, but we set it to zero if a hardware
+ * IOMMU (gart) of sotware IOMMU (swiotlb) is available.
+ */
+#define PCI_DMA_BUS_IS_PHYS (dma_ops->is_phys)
+
+#if defined(CONFIG_IOMMU) || defined(CONFIG_CALGARY_IOMMU)
+
+/*
+ * x86-64 always supports DAC, but sometimes it is useful to force
+ * devices through the IOMMU to get automatic sg list merging.
+ * Optional right now.
+ */
+extern int iommu_sac_force;
+#define pci_dac_dma_supported(pci_dev, mask)	(!iommu_sac_force)
+
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)	\
+	dma_addr_t ADDR_NAME;
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME)		\
+	__u32 LEN_NAME;
+#define pci_unmap_addr(PTR, ADDR_NAME)			\
+	((PTR)->ADDR_NAME)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)		\
+	(((PTR)->ADDR_NAME) = (VAL))
+#define pci_unmap_len(PTR, LEN_NAME)			\
+	((PTR)->LEN_NAME)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)		\
+	(((PTR)->LEN_NAME) = (VAL))
+
+#else
+/* No IOMMU */
+
+#define pci_dac_dma_supported(pci_dev, mask)    1
+
+#define DECLARE_PCI_UNMAP_ADDR(ADDR_NAME)
+#define DECLARE_PCI_UNMAP_LEN(LEN_NAME)
+#define pci_unmap_addr(PTR, ADDR_NAME)		(0)
+#define pci_unmap_addr_set(PTR, ADDR_NAME, VAL)	do { } while (0)
+#define pci_unmap_len(PTR, LEN_NAME)		(0)
+#define pci_unmap_len_set(PTR, LEN_NAME, VAL)	do { } while (0)
+
+#endif
+
+#include <asm-generic/pci-dma-compat.h>
+
+static inline dma64_addr_t
+pci_dac_page_to_dma(struct pci_dev *pdev, struct page *page, unsigned long offset, int direction)
+{
+	return ((dma64_addr_t) page_to_phys(page) +
+		(dma64_addr_t) offset);
+}
+
+static inline struct page *
+pci_dac_dma_to_page(struct pci_dev *pdev, dma64_addr_t dma_addr)
+{
+	return virt_to_page(__va(dma_addr)); 	
+}
+
+static inline unsigned long
+pci_dac_dma_to_offset(struct pci_dev *pdev, dma64_addr_t dma_addr)
+{
+	return (dma_addr & ~PAGE_MASK);
+}
+
+static inline void
+pci_dac_dma_sync_single_for_cpu(struct pci_dev *pdev, dma64_addr_t dma_addr, size_t len, int direction)
+{
+}
+
+static inline void
+pci_dac_dma_sync_single_for_device(struct pci_dev *pdev, dma64_addr_t dma_addr, size_t len, int direction)
+{
+	flush_write_buffers();
+}
+
+#ifdef CONFIG_PCI
+static inline void pci_dma_burst_advice(struct pci_dev *pdev,
+					enum pci_dma_burst_strategy *strat,
+					unsigned long *strategy_parameter)
+{
+	*strat = PCI_DMA_BURST_INFINITY;
+	*strategy_parameter = ~0UL;
+}
+#endif
+
+#define HAVE_PCI_MMAP
+extern int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+			       enum pci_mmap_state mmap_state, int write_combine);
+
+static inline void pcibios_add_platform_entries(struct pci_dev *dev)
+{
+}
+
+#endif /* __KERNEL__ */
+
+/* generic pci stuff */
+#ifdef CONFIG_PCI
+#include <asm-generic/pci.h>
+#endif
+
+#endif /* __x8664_PCI_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/pda.h linux-2.6.20-sabayon-r1/include/asm/pda.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/pda.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/pda.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,125 @@
+#ifndef X86_64_PDA_H
+#define X86_64_PDA_H
+
+#ifndef __ASSEMBLY__
+#include <linux/stddef.h>
+#include <linux/types.h>
+#include <linux/cache.h>
+#include <asm/page.h>
+
+/* Per processor datastructure. %gs points to it while the kernel runs */ 
+struct x8664_pda {
+	struct task_struct *pcurrent;	/* 0  Current process */
+	unsigned long data_offset;	/* 8 Per cpu data offset from linker
+					   address */
+	unsigned long kernelstack;  /* 16 top of kernel stack for current */
+	unsigned long oldrsp; 	    /* 24 user rsp for system call */
+        int irqcount;		    /* 32 Irq nesting counter. Starts with -1 */
+	int cpunumber;		    /* 36 Logical CPU number */
+#ifdef CONFIG_CC_STACKPROTECTOR
+	unsigned long stack_canary;	/* 40 stack canary value */
+					/* gcc-ABI: this canary MUST be at
+					   offset 40!!! */
+#endif
+	char *irqstackptr;
+	int nodenumber;		    /* number of current node */
+	unsigned int __softirq_pending;
+	unsigned int __nmi_count;	/* number of NMI on this CPUs */
+	short mmu_state;
+	short isidle;
+	struct mm_struct *active_mm;
+	unsigned apic_timer_irqs;
+} ____cacheline_aligned_in_smp;
+
+extern struct x8664_pda *_cpu_pda[];
+extern struct x8664_pda boot_cpu_pda[];
+
+#define cpu_pda(i) (_cpu_pda[i])
+
+/* 
+ * There is no fast way to get the base address of the PDA, all the accesses
+ * have to mention %fs/%gs.  So it needs to be done this Torvaldian way.
+ */ 
+extern void __bad_pda_field(void) __attribute__((noreturn));
+
+/*
+ * proxy_pda doesn't actually exist, but tell gcc it is accessed for
+ * all PDA accesses so it gets read/write dependencies right.
+ */
+extern struct x8664_pda _proxy_pda;
+
+#define pda_offset(field) offsetof(struct x8664_pda, field)
+
+#define pda_to_op(op,field,val) do {		\
+	typedef typeof(_proxy_pda.field) T__;	\
+	if (0) { T__ tmp__; tmp__ = (val); }	/* type checking */ \
+	switch (sizeof(_proxy_pda.field)) {	\
+	case 2:					\
+		asm(op "w %1,%%gs:%c2" : 	\
+		    "+m" (_proxy_pda.field) :	\
+		    "ri" ((T__)val),		\
+		    "i"(pda_offset(field))); 	\
+ 		break;				\
+	case 4:					\
+		asm(op "l %1,%%gs:%c2" : 	\
+		    "+m" (_proxy_pda.field) :	\
+		    "ri" ((T__)val),		\
+		    "i" (pda_offset(field))); 	\
+		break;				\
+	case 8:					\
+		asm(op "q %1,%%gs:%c2": 	\
+		    "+m" (_proxy_pda.field) :	\
+		    "ri" ((T__)val),		\
+		    "i"(pda_offset(field))); 	\
+		break;				\
+       default: 				\
+		__bad_pda_field();		\
+       }					\
+       } while (0)
+
+#define pda_from_op(op,field) ({		\
+	typeof(_proxy_pda.field) ret__;		\
+	switch (sizeof(_proxy_pda.field)) {	\
+       	case 2:					\
+		asm(op "w %%gs:%c1,%0" : 	\
+		    "=r" (ret__) :		\
+		    "i" (pda_offset(field)), 	\
+		    "m" (_proxy_pda.field)); 	\
+		 break;				\
+	case 4:					\
+		asm(op "l %%gs:%c1,%0":		\
+		    "=r" (ret__):		\
+		    "i" (pda_offset(field)), 	\
+		    "m" (_proxy_pda.field)); 	\
+		 break;				\
+       case 8:					\
+		asm(op "q %%gs:%c1,%0":		\
+		    "=r" (ret__) :		\
+		    "i" (pda_offset(field)), 	\
+		    "m" (_proxy_pda.field)); 	\
+		 break;				\
+       default: 				\
+		__bad_pda_field();		\
+       }					\
+       ret__; })
+
+#define read_pda(field) pda_from_op("mov",field)
+#define write_pda(field,val) pda_to_op("mov",field,val)
+#define add_pda(field,val) pda_to_op("add",field,val)
+#define sub_pda(field,val) pda_to_op("sub",field,val)
+#define or_pda(field,val) pda_to_op("or",field,val)
+
+/* This is not atomic against other CPUs -- CPU preemption needs to be off */
+#define test_and_clear_bit_pda(bit,field) ({		\
+	int old__;						\
+	asm volatile("btr %2,%%gs:%c3\n\tsbbl %0,%0"		\
+	    : "=r" (old__), "+m" (_proxy_pda.field) 		\
+	    : "dIr" (bit), "i" (pda_offset(field)) : "memory");	\
+	old__;							\
+})
+
+#endif
+
+#define PDA_STACKOFFSET (5*8)
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/percpu.h linux-2.6.20-sabayon-r1/include/asm/percpu.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/percpu.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/percpu.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef _ASM_X8664_PERCPU_H_
+#define _ASM_X8664_PERCPU_H_
+#include <linux/compiler.h>
+
+/* Same as asm-generic/percpu.h, except that we store the per cpu offset
+   in the PDA. Longer term the PDA and every per cpu variable
+   should be just put into a single section and referenced directly
+   from %gs */
+
+#ifdef CONFIG_SMP
+
+#include <asm/pda.h>
+
+#ifdef CONFIG_MODULES
+# define PERCPU_MODULE_RESERVE 8192
+#else
+# define PERCPU_MODULE_RESERVE 0
+#endif
+
+#define PERCPU_ENOUGH_ROOM \
+	(ALIGN(__per_cpu_end - __per_cpu_start, SMP_CACHE_BYTES) + \
+	 PERCPU_MODULE_RESERVE)
+
+#define __per_cpu_offset(cpu) (cpu_pda(cpu)->data_offset)
+#define __my_cpu_offset() read_pda(data_offset)
+
+#define per_cpu_offset(x) (__per_cpu_offset(x))
+
+/* Separate out the type, so (int[3], foo) works. */
+#define DEFINE_PER_CPU(type, name) \
+    __attribute__((__section__(".data.percpu"))) __typeof__(type) per_cpu__##name
+
+/* var is in discarded region: offset to particular copy we want */
+#define per_cpu(var, cpu) (*({				\
+	extern int simple_identifier_##var(void);	\
+	RELOC_HIDE(&per_cpu__##var, __per_cpu_offset(cpu)); }))
+#define __get_cpu_var(var) (*({				\
+	extern int simple_identifier_##var(void);	\
+	RELOC_HIDE(&per_cpu__##var, __my_cpu_offset()); }))
+#define __raw_get_cpu_var(var) (*({			\
+	extern int simple_identifier_##var(void);	\
+	RELOC_HIDE(&per_cpu__##var, __my_cpu_offset()); }))
+
+/* A macro to avoid #include hell... */
+#define percpu_modcopy(pcpudst, src, size)			\
+do {								\
+	unsigned int __i;					\
+	for_each_possible_cpu(__i)				\
+		memcpy((pcpudst)+__per_cpu_offset(__i),		\
+		       (src), (size));				\
+} while (0)
+
+extern void setup_per_cpu_areas(void);
+
+#else /* ! SMP */
+
+#define DEFINE_PER_CPU(type, name) \
+    __typeof__(type) per_cpu__##name
+
+#define per_cpu(var, cpu)			(*((void)(cpu), &per_cpu__##var))
+#define __get_cpu_var(var)			per_cpu__##var
+#define __raw_get_cpu_var(var)			per_cpu__##var
+
+#endif	/* SMP */
+
+#define DECLARE_PER_CPU(type, name) extern __typeof__(type) per_cpu__##name
+
+#define EXPORT_PER_CPU_SYMBOL(var) EXPORT_SYMBOL(per_cpu__##var)
+#define EXPORT_PER_CPU_SYMBOL_GPL(var) EXPORT_SYMBOL_GPL(per_cpu__##var)
+
+#endif /* _ASM_X8664_PERCPU_H_ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/pgalloc.h linux-2.6.20-sabayon-r1/include/asm/pgalloc.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/pgalloc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/pgalloc.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,133 @@
+#ifndef _X86_64_PGALLOC_H
+#define _X86_64_PGALLOC_H
+
+#include <asm/fixmap.h>
+#include <asm/pda.h>
+#include <linux/threads.h>
+#include <linux/mm.h>
+
+#define pmd_populate_kernel(mm, pmd, pte) \
+		set_pmd(pmd, __pmd(_PAGE_TABLE | __pa(pte)))
+#define pud_populate(mm, pud, pmd) \
+		set_pud(pud, __pud(_PAGE_TABLE | __pa(pmd)))
+#define pgd_populate(mm, pgd, pud) \
+		set_pgd(pgd, __pgd(_PAGE_TABLE | __pa(pud)))
+
+static inline void pmd_populate(struct mm_struct *mm, pmd_t *pmd, struct page *pte)
+{
+	set_pmd(pmd, __pmd(_PAGE_TABLE | (page_to_pfn(pte) << PAGE_SHIFT)));
+}
+
+static inline pmd_t *get_pmd(void)
+{
+	return (pmd_t *)get_zeroed_page(GFP_KERNEL);
+}
+
+static inline void pmd_free(pmd_t *pmd)
+{
+	BUG_ON((unsigned long)pmd & (PAGE_SIZE-1));
+	free_page((unsigned long)pmd);
+}
+
+static inline pmd_t *pmd_alloc_one (struct mm_struct *mm, unsigned long addr)
+{
+	return (pmd_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);
+}
+
+static inline pud_t *pud_alloc_one(struct mm_struct *mm, unsigned long addr)
+{
+	return (pud_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);
+}
+
+static inline void pud_free (pud_t *pud)
+{
+	BUG_ON((unsigned long)pud & (PAGE_SIZE-1));
+	free_page((unsigned long)pud);
+}
+
+static inline void pgd_list_add(pgd_t *pgd)
+{
+	struct page *page = virt_to_page(pgd);
+
+	spin_lock(&pgd_lock);
+	page->index = (pgoff_t)pgd_list;
+	if (pgd_list)
+		pgd_list->private = (unsigned long)&page->index;
+	pgd_list = page;
+	page->private = (unsigned long)&pgd_list;
+	spin_unlock(&pgd_lock);
+}
+
+static inline void pgd_list_del(pgd_t *pgd)
+{
+	struct page *next, **pprev, *page = virt_to_page(pgd);
+
+	spin_lock(&pgd_lock);
+	next = (struct page *)page->index;
+	pprev = (struct page **)page->private;
+	*pprev = next;
+	if (next)
+		next->private = (unsigned long)pprev;
+	spin_unlock(&pgd_lock);
+}
+
+static inline pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	unsigned boundary;
+	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT);
+	if (!pgd)
+		return NULL;
+	pgd_list_add(pgd);
+	/*
+	 * Copy kernel pointers in from init.
+	 * Could keep a freelist or slab cache of those because the kernel
+	 * part never changes.
+	 */
+	boundary = pgd_index(__PAGE_OFFSET);
+	memset(pgd, 0, boundary * sizeof(pgd_t));
+	memcpy(pgd + boundary,
+	       init_level4_pgt + boundary,
+	       (PTRS_PER_PGD - boundary) * sizeof(pgd_t));
+	return pgd;
+}
+
+static inline void pgd_free(pgd_t *pgd)
+{
+	BUG_ON((unsigned long)pgd & (PAGE_SIZE-1));
+	pgd_list_del(pgd);
+	free_page((unsigned long)pgd);
+}
+
+static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
+{
+	return (pte_t *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);
+}
+
+static inline struct page *pte_alloc_one(struct mm_struct *mm, unsigned long address)
+{
+	void *p = (void *)get_zeroed_page(GFP_KERNEL|__GFP_REPEAT);
+	if (!p)
+		return NULL;
+	return virt_to_page(p);
+}
+
+/* Should really implement gc for free page table pages. This could be
+   done with a reference count in struct page. */
+
+static inline void pte_free_kernel(pte_t *pte)
+{
+	BUG_ON((unsigned long)pte & (PAGE_SIZE-1));
+	free_page((unsigned long)pte); 
+}
+
+static inline void pte_free(struct page *pte)
+{
+	__free_page(pte);
+} 
+
+#define __pte_free_tlb(tlb,pte) tlb_remove_page((tlb),(pte))
+
+#define __pmd_free_tlb(tlb,x)   tlb_remove_page((tlb),virt_to_page(x))
+#define __pud_free_tlb(tlb,x)   tlb_remove_page((tlb),virt_to_page(x))
+
+#endif /* _X86_64_PGALLOC_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/pgtable.h linux-2.6.20-sabayon-r1/include/asm/pgtable.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/pgtable.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/pgtable.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,450 @@
+#ifndef _X86_64_PGTABLE_H
+#define _X86_64_PGTABLE_H
+
+/*
+ * This file contains the functions and defines necessary to modify and use
+ * the x86-64 page table tree.
+ */
+#include <asm/processor.h>
+#include <asm/fixmap.h>
+#include <asm/bitops.h>
+#include <linux/threads.h>
+#include <asm/pda.h>
+
+extern pud_t level3_kernel_pgt[512];
+extern pud_t level3_physmem_pgt[512];
+extern pud_t level3_ident_pgt[512];
+extern pmd_t level2_kernel_pgt[512];
+extern pgd_t init_level4_pgt[];
+extern pgd_t boot_level4_pgt[];
+extern unsigned long __supported_pte_mask;
+
+#define swapper_pg_dir init_level4_pgt
+
+extern void paging_init(void);
+extern void clear_kernel_mapping(unsigned long addr, unsigned long size);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern unsigned long empty_zero_page[PAGE_SIZE/sizeof(unsigned long)];
+#define ZERO_PAGE(vaddr) (virt_to_page(empty_zero_page))
+
+/*
+ * PGDIR_SHIFT determines what a top-level page table entry can map
+ */
+#define PGDIR_SHIFT	39
+#define PTRS_PER_PGD	512
+
+/*
+ * 3rd level page
+ */
+#define PUD_SHIFT	30
+#define PTRS_PER_PUD	512
+
+/*
+ * PMD_SHIFT determines the size of the area a middle-level
+ * page table can map
+ */
+#define PMD_SHIFT	21
+#define PTRS_PER_PMD	512
+
+/*
+ * entries per page directory level
+ */
+#define PTRS_PER_PTE	512
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %p(%016lx).\n", __FILE__, __LINE__, &(e), pte_val(e))
+#define pmd_ERROR(e) \
+	printk("%s:%d: bad pmd %p(%016lx).\n", __FILE__, __LINE__, &(e), pmd_val(e))
+#define pud_ERROR(e) \
+	printk("%s:%d: bad pud %p(%016lx).\n", __FILE__, __LINE__, &(e), pud_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %p(%016lx).\n", __FILE__, __LINE__, &(e), pgd_val(e))
+
+#define pgd_none(x)	(!pgd_val(x))
+#define pud_none(x)	(!pud_val(x))
+
+static inline void set_pte(pte_t *dst, pte_t val)
+{
+	pte_val(*dst) = pte_val(val);
+} 
+#define set_pte_at(mm,addr,ptep,pteval) set_pte(ptep,pteval)
+
+static inline void set_pmd(pmd_t *dst, pmd_t val)
+{
+        pmd_val(*dst) = pmd_val(val); 
+} 
+
+static inline void set_pud(pud_t *dst, pud_t val)
+{
+	pud_val(*dst) = pud_val(val);
+}
+
+static inline void pud_clear (pud_t *pud)
+{
+	set_pud(pud, __pud(0));
+}
+
+static inline void set_pgd(pgd_t *dst, pgd_t val)
+{
+	pgd_val(*dst) = pgd_val(val); 
+} 
+
+static inline void pgd_clear (pgd_t * pgd)
+{
+	set_pgd(pgd, __pgd(0));
+}
+
+#define ptep_get_and_clear(mm,addr,xp)	__pte(xchg(&(xp)->pte, 0))
+
+struct mm_struct;
+
+static inline pte_t ptep_get_and_clear_full(struct mm_struct *mm, unsigned long addr, pte_t *ptep, int full)
+{
+	pte_t pte;
+	if (full) {
+		pte = *ptep;
+		*ptep = __pte(0);
+	} else {
+		pte = ptep_get_and_clear(mm, addr, ptep);
+	}
+	return pte;
+}
+
+#define pte_same(a, b)		((a).pte == (b).pte)
+
+#define pte_pgprot(a)	(__pgprot((a).pte & ~PHYSICAL_PAGE_MASK))
+
+#define PMD_SIZE	(1UL << PMD_SHIFT)
+#define PMD_MASK	(~(PMD_SIZE-1))
+#define PUD_SIZE	(1UL << PUD_SHIFT)
+#define PUD_MASK	(~(PUD_SIZE-1))
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE-1))
+
+#define USER_PTRS_PER_PGD	((TASK_SIZE-1)/PGDIR_SIZE+1)
+#define FIRST_USER_ADDRESS	0
+
+#ifndef __ASSEMBLY__
+#define MAXMEM		 0x3fffffffffffUL
+#define VMALLOC_START    0xffffc20000000000UL
+#define VMALLOC_END      0xffffe1ffffffffffUL
+#define MODULES_VADDR    0xffffffff88000000UL
+#define MODULES_END      0xfffffffffff00000UL
+#define MODULES_LEN   (MODULES_END - MODULES_VADDR)
+
+#define _PAGE_BIT_PRESENT	0
+#define _PAGE_BIT_RW		1
+#define _PAGE_BIT_USER		2
+#define _PAGE_BIT_PWT		3
+#define _PAGE_BIT_PCD		4
+#define _PAGE_BIT_ACCESSED	5
+#define _PAGE_BIT_DIRTY		6
+#define _PAGE_BIT_PSE		7	/* 4 MB (or 2MB) page */
+#define _PAGE_BIT_GLOBAL	8	/* Global TLB entry PPro+ */
+#define _PAGE_BIT_NX           63       /* No execute: only valid after cpuid check */
+
+#define _PAGE_PRESENT	0x001
+#define _PAGE_RW	0x002
+#define _PAGE_USER	0x004
+#define _PAGE_PWT	0x008
+#define _PAGE_PCD	0x010
+#define _PAGE_ACCESSED	0x020
+#define _PAGE_DIRTY	0x040
+#define _PAGE_PSE	0x080	/* 2MB page */
+#define _PAGE_FILE	0x040	/* nonlinear file mapping, saved PTE; unset:swap */
+#define _PAGE_GLOBAL	0x100	/* Global TLB entry */
+
+#define _PAGE_PROTNONE	0x080	/* If not present */
+#define _PAGE_NX        (1UL<<_PAGE_BIT_NX)
+
+#define _PAGE_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_DIRTY)
+#define _KERNPG_TABLE	(_PAGE_PRESENT | _PAGE_RW | _PAGE_ACCESSED | _PAGE_DIRTY)
+
+#define _PAGE_CHG_MASK	(PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)
+
+#define PAGE_NONE	__pgprot(_PAGE_PROTNONE | _PAGE_ACCESSED)
+#define PAGE_SHARED	__pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
+#define PAGE_SHARED_EXEC __pgprot(_PAGE_PRESENT | _PAGE_RW | _PAGE_USER | _PAGE_ACCESSED)
+#define PAGE_COPY_NOEXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
+#define PAGE_COPY PAGE_COPY_NOEXEC
+#define PAGE_COPY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define PAGE_READONLY	__pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_NX)
+#define PAGE_READONLY_EXEC __pgprot(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define __PAGE_KERNEL \
+	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
+#define __PAGE_KERNEL_EXEC \
+	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_ACCESSED)
+#define __PAGE_KERNEL_NOCACHE \
+	(_PAGE_PRESENT | _PAGE_RW | _PAGE_DIRTY | _PAGE_PCD | _PAGE_ACCESSED | _PAGE_NX)
+#define __PAGE_KERNEL_RO \
+	(_PAGE_PRESENT | _PAGE_DIRTY | _PAGE_ACCESSED | _PAGE_NX)
+#define __PAGE_KERNEL_VSYSCALL \
+	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED)
+#define __PAGE_KERNEL_VSYSCALL_NOCACHE \
+	(_PAGE_PRESENT | _PAGE_USER | _PAGE_ACCESSED | _PAGE_PCD)
+#define __PAGE_KERNEL_LARGE \
+	(__PAGE_KERNEL | _PAGE_PSE)
+#define __PAGE_KERNEL_LARGE_EXEC \
+	(__PAGE_KERNEL_EXEC | _PAGE_PSE)
+
+#define MAKE_GLOBAL(x) __pgprot((x) | _PAGE_GLOBAL)
+
+#define PAGE_KERNEL MAKE_GLOBAL(__PAGE_KERNEL)
+#define PAGE_KERNEL_EXEC MAKE_GLOBAL(__PAGE_KERNEL_EXEC)
+#define PAGE_KERNEL_RO MAKE_GLOBAL(__PAGE_KERNEL_RO)
+#define PAGE_KERNEL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
+#define PAGE_KERNEL_VSYSCALL32 __pgprot(__PAGE_KERNEL_VSYSCALL)
+#define PAGE_KERNEL_VSYSCALL MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL)
+#define PAGE_KERNEL_LARGE MAKE_GLOBAL(__PAGE_KERNEL_LARGE)
+#define PAGE_KERNEL_VSYSCALL_NOCACHE MAKE_GLOBAL(__PAGE_KERNEL_VSYSCALL_NOCACHE)
+
+/*         xwr */
+#define __P000	PAGE_NONE
+#define __P001	PAGE_READONLY
+#define __P010	PAGE_COPY
+#define __P011	PAGE_COPY
+#define __P100	PAGE_READONLY_EXEC
+#define __P101	PAGE_READONLY_EXEC
+#define __P110	PAGE_COPY_EXEC
+#define __P111	PAGE_COPY_EXEC
+
+#define __S000	PAGE_NONE
+#define __S001	PAGE_READONLY
+#define __S010	PAGE_SHARED
+#define __S011	PAGE_SHARED
+#define __S100	PAGE_READONLY_EXEC
+#define __S101	PAGE_READONLY_EXEC
+#define __S110	PAGE_SHARED_EXEC
+#define __S111	PAGE_SHARED_EXEC
+
+static inline unsigned long pgd_bad(pgd_t pgd)
+{
+	return pgd_val(pgd) & ~(PTE_MASK | _KERNPG_TABLE | _PAGE_USER);
+}
+
+static inline unsigned long pud_bad(pud_t pud)
+{
+	return pud_val(pud) & ~(PTE_MASK | _KERNPG_TABLE | _PAGE_USER);
+}
+
+static inline unsigned long pmd_bad(pmd_t pmd)
+{
+	return pmd_val(pmd) & ~(PTE_MASK | _KERNPG_TABLE | _PAGE_USER);
+}
+
+#define pte_none(x)	(!pte_val(x))
+#define pte_present(x)	(pte_val(x) & (_PAGE_PRESENT | _PAGE_PROTNONE))
+#define pte_clear(mm,addr,xp)	do { set_pte_at(mm, addr, xp, __pte(0)); } while (0)
+
+#define pages_to_mb(x) ((x) >> (20-PAGE_SHIFT))	/* FIXME: is this
+						   right? */
+#define pte_page(x)	pfn_to_page(pte_pfn(x))
+#define pte_pfn(x)  ((pte_val(x) & __PHYSICAL_MASK) >> PAGE_SHIFT)
+
+static inline pte_t pfn_pte(unsigned long page_nr, pgprot_t pgprot)
+{
+	pte_t pte;
+	pte_val(pte) = (page_nr << PAGE_SHIFT);
+	pte_val(pte) |= pgprot_val(pgprot);
+	pte_val(pte) &= __supported_pte_mask;
+	return pte;
+}
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+#define __LARGE_PTE (_PAGE_PSE|_PAGE_PRESENT)
+static inline int pte_user(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_read(pte_t pte)		{ return pte_val(pte) & _PAGE_USER; }
+static inline int pte_exec(pte_t pte)		{ return !(pte_val(pte) & _PAGE_NX); }
+static inline int pte_dirty(pte_t pte)		{ return pte_val(pte) & _PAGE_DIRTY; }
+static inline int pte_young(pte_t pte)		{ return pte_val(pte) & _PAGE_ACCESSED; }
+static inline int pte_write(pte_t pte)		{ return pte_val(pte) & _PAGE_RW; }
+static inline int pte_file(pte_t pte)		{ return pte_val(pte) & _PAGE_FILE; }
+static inline int pte_huge(pte_t pte)		{ return pte_val(pte) & _PAGE_PSE; }
+
+static inline pte_t pte_rdprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_exprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_USER)); return pte; }
+static inline pte_t pte_mkclean(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkold(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_wrprotect(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_RW)); return pte; }
+static inline pte_t pte_mkread(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_USER)); return pte; }
+static inline pte_t pte_mkexec(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_NX)); return pte; }
+static inline pte_t pte_mkdirty(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_DIRTY)); return pte; }
+static inline pte_t pte_mkyoung(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_ACCESSED)); return pte; }
+static inline pte_t pte_mkwrite(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_RW)); return pte; }
+static inline pte_t pte_mkhuge(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) | _PAGE_PSE)); return pte; }
+static inline pte_t pte_clrhuge(pte_t pte)	{ set_pte(&pte, __pte(pte_val(pte) & ~_PAGE_PSE)); return pte; }
+
+struct vm_area_struct;
+
+static inline int ptep_test_and_clear_dirty(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)
+{
+	if (!pte_dirty(*ptep))
+		return 0;
+	return test_and_clear_bit(_PAGE_BIT_DIRTY, &ptep->pte);
+}
+
+static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned long addr, pte_t *ptep)
+{
+	if (!pte_young(*ptep))
+		return 0;
+	return test_and_clear_bit(_PAGE_BIT_ACCESSED, &ptep->pte);
+}
+
+static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
+{
+	clear_bit(_PAGE_BIT_RW, &ptep->pte);
+}
+
+/*
+ * Macro to mark a page protection value as "uncacheable".
+ */
+#define pgprot_noncached(prot)	(__pgprot(pgprot_val(prot) | _PAGE_PCD | _PAGE_PWT))
+
+static inline int pmd_large(pmd_t pte) { 
+	return (pmd_val(pte) & __LARGE_PTE) == __LARGE_PTE; 
+} 	
+
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+
+/*
+ * Level 4 access.
+ */
+#define pgd_page_vaddr(pgd) ((unsigned long) __va((unsigned long)pgd_val(pgd) & PTE_MASK))
+#define pgd_page(pgd)		(pfn_to_page(pgd_val(pgd) >> PAGE_SHIFT))
+#define pgd_index(address) (((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD-1))
+#define pgd_offset(mm, addr) ((mm)->pgd + pgd_index(addr))
+#define pgd_offset_k(address) (init_level4_pgt + pgd_index(address))
+#define pgd_present(pgd) (pgd_val(pgd) & _PAGE_PRESENT)
+#define mk_kernel_pgd(address) ((pgd_t){ (address) | _KERNPG_TABLE })
+
+/* PUD - Level3 access */
+/* to find an entry in a page-table-directory. */
+#define pud_page_vaddr(pud) ((unsigned long) __va(pud_val(pud) & PHYSICAL_PAGE_MASK))
+#define pud_page(pud)		(pfn_to_page(pud_val(pud) >> PAGE_SHIFT))
+#define pud_index(address) (((address) >> PUD_SHIFT) & (PTRS_PER_PUD-1))
+#define pud_offset(pgd, address) ((pud_t *) pgd_page_vaddr(*(pgd)) + pud_index(address))
+#define pud_present(pud) (pud_val(pud) & _PAGE_PRESENT)
+
+/* PMD  - Level 2 access */
+#define pmd_page_vaddr(pmd) ((unsigned long) __va(pmd_val(pmd) & PTE_MASK))
+#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+
+#define pmd_index(address) (((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
+#define pmd_offset(dir, address) ((pmd_t *) pud_page_vaddr(*(dir)) + \
+			pmd_index(address))
+#define pmd_none(x)	(!pmd_val(x))
+#define pmd_present(x)	(pmd_val(x) & _PAGE_PRESENT)
+#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
+#define pfn_pmd(nr,prot) (__pmd(((nr) << PAGE_SHIFT) | pgprot_val(prot)))
+#define pmd_pfn(x)  ((pmd_val(x) & __PHYSICAL_MASK) >> PAGE_SHIFT)
+
+#define pte_to_pgoff(pte) ((pte_val(pte) & PHYSICAL_PAGE_MASK) >> PAGE_SHIFT)
+#define pgoff_to_pte(off) ((pte_t) { ((off) << PAGE_SHIFT) | _PAGE_FILE })
+#define PTE_FILE_MAX_BITS __PHYSICAL_MASK_SHIFT
+
+/* PTE - Level 1 access. */
+
+/* page, protection -> pte */
+#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), (pgprot))
+#define mk_pte_huge(entry) (pte_val(entry) |= _PAGE_PRESENT | _PAGE_PSE)
+ 
+/* physical address -> PTE */
+static inline pte_t mk_pte_phys(unsigned long physpage, pgprot_t pgprot)
+{ 
+	pte_t pte;
+	pte_val(pte) = physpage | pgprot_val(pgprot); 
+	pte_val(pte) &= __supported_pte_mask;
+	return pte; 
+}
+ 
+/* Change flags of a PTE */
+static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{ 
+	pte_val(pte) &= _PAGE_CHG_MASK;
+	pte_val(pte) |= pgprot_val(newprot);
+	pte_val(pte) &= __supported_pte_mask;
+       return pte; 
+}
+
+#define pte_index(address) \
+		(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
+#define pte_offset_kernel(dir, address) ((pte_t *) pmd_page_vaddr(*(dir)) + \
+			pte_index(address))
+
+/* x86-64 always has all page tables mapped. */
+#define pte_offset_map(dir,address) pte_offset_kernel(dir,address)
+#define pte_offset_map_nested(dir,address) pte_offset_kernel(dir,address)
+#define pte_unmap(pte) /* NOP */
+#define pte_unmap_nested(pte) /* NOP */ 
+
+#define update_mmu_cache(vma,address,pte) do { } while (0)
+
+/* We only update the dirty/accessed state if we set
+ * the dirty bit by hand in the kernel, since the hardware
+ * will do the accessed bit for us, and we don't want to
+ * race with other CPU's that might be updating the dirty
+ * bit at the same time. */
+#define  __HAVE_ARCH_PTEP_SET_ACCESS_FLAGS
+#define ptep_set_access_flags(__vma, __address, __ptep, __entry, __dirty) \
+	do {								  \
+		if (__dirty) {						  \
+			set_pte(__ptep, __entry);			  \
+			flush_tlb_page(__vma, __address);		  \
+		}							  \
+	} while (0)
+
+/* Encode and de-code a swap entry */
+#define __swp_type(x)			(((x).val >> 1) & 0x3f)
+#define __swp_offset(x)			((x).val >> 8)
+#define __swp_entry(type, offset)	((swp_entry_t) { ((type) << 1) | ((offset) << 8) })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+extern spinlock_t pgd_lock;
+extern struct page *pgd_list;
+void vmalloc_sync_all(void);
+
+#endif /* !__ASSEMBLY__ */
+
+extern int kern_addr_valid(unsigned long addr); 
+
+#define io_remap_pfn_range(vma, vaddr, pfn, size, prot)		\
+		remap_pfn_range(vma, vaddr, pfn, size, prot)
+
+#define MK_IOSPACE_PFN(space, pfn)	(pfn)
+#define GET_IOSPACE(pfn)		0
+#define GET_PFN(pfn)			(pfn)
+
+#define HAVE_ARCH_UNMAPPED_AREA
+
+#define pgtable_cache_init()   do { } while (0)
+#define check_pgt_cache()      do { } while (0)
+
+#define PAGE_AGP    PAGE_KERNEL_NOCACHE
+#define HAVE_PAGE_AGP 1
+
+/* fs/proc/kcore.c */
+#define	kc_vaddr_to_offset(v) ((v) & __VIRTUAL_MASK)
+#define	kc_offset_to_vaddr(o) \
+   (((o) & (1UL << (__VIRTUAL_MASK_SHIFT-1))) ? ((o) | (~__VIRTUAL_MASK)) : (o))
+
+#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
+#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_DIRTY
+#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
+#define __HAVE_ARCH_PTEP_GET_AND_CLEAR_FULL
+#define __HAVE_ARCH_PTEP_SET_WRPROTECT
+#define __HAVE_ARCH_PTE_SAME
+#include <asm-generic/pgtable.h>
+
+#endif /* _X86_64_PGTABLE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/poll.h linux-2.6.20-sabayon-r1/include/asm/poll.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/poll.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/poll.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,27 @@
+#ifndef __x86_64_POLL_H
+#define __x86_64_POLL_H
+
+/* These are specified by iBCS2 */
+#define POLLIN		0x0001
+#define POLLPRI		0x0002
+#define POLLOUT		0x0004
+#define POLLERR		0x0008
+#define POLLHUP		0x0010
+#define POLLNVAL	0x0020
+
+/* The rest seem to be more-or-less nonstandard. Check them! */
+#define POLLRDNORM	0x0040
+#define POLLRDBAND	0x0080
+#define POLLWRNORM	0x0100
+#define POLLWRBAND	0x0200
+#define POLLMSG		0x0400
+#define POLLREMOVE	0x1000
+#define POLLRDHUP       0x2000
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/posix_types.h linux-2.6.20-sabayon-r1/include/asm/posix_types.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/posix_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/posix_types.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,119 @@
+#ifndef _ASM_X86_64_POSIX_TYPES_H
+#define _ASM_X86_64_POSIX_TYPES_H
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned int	__kernel_mode_t;
+typedef unsigned long	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef int		__kernel_ipc_pid_t;
+typedef unsigned int	__kernel_uid_t;
+typedef unsigned int	__kernel_gid_t;
+typedef unsigned long	__kernel_size_t;
+typedef long		__kernel_ssize_t;
+typedef long		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+	int	val[2];
+} __kernel_fsid_t;
+
+typedef unsigned short __kernel_old_uid_t;
+typedef unsigned short __kernel_old_gid_t;
+typedef __kernel_uid_t __kernel_uid32_t;
+typedef __kernel_gid_t __kernel_gid32_t;
+
+typedef unsigned long	__kernel_old_dev_t;
+
+#ifdef __KERNEL__
+
+#undef __FD_SET
+static __inline__ void __FD_SET(unsigned long fd, __kernel_fd_set *fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] |= (1UL<<_rem);
+}
+
+#undef __FD_CLR
+static __inline__ void __FD_CLR(unsigned long fd, __kernel_fd_set *fdsetp)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	fdsetp->fds_bits[_tmp] &= ~(1UL<<_rem);
+}
+
+#undef __FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long fd, __const__ __kernel_fd_set *p)
+{
+	unsigned long _tmp = fd / __NFDBITS;
+	unsigned long _rem = fd % __NFDBITS;
+	return (p->fds_bits[_tmp] & (1UL<<_rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant cases (8 or 32 longs,
+ * for 256 and 1024-bit fd_sets respectively)
+ */
+#undef __FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set *p)
+{
+	unsigned long *tmp = p->fds_bits;
+	int i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+			case 32:
+			  tmp[ 0] = 0; tmp[ 1] = 0; tmp[ 2] = 0; tmp[ 3] = 0;
+			  tmp[ 4] = 0; tmp[ 5] = 0; tmp[ 6] = 0; tmp[ 7] = 0;
+			  tmp[ 8] = 0; tmp[ 9] = 0; tmp[10] = 0; tmp[11] = 0;
+			  tmp[12] = 0; tmp[13] = 0; tmp[14] = 0; tmp[15] = 0;
+			  tmp[16] = 0; tmp[17] = 0; tmp[18] = 0; tmp[19] = 0;
+			  tmp[20] = 0; tmp[21] = 0; tmp[22] = 0; tmp[23] = 0;
+			  tmp[24] = 0; tmp[25] = 0; tmp[26] = 0; tmp[27] = 0;
+			  tmp[28] = 0; tmp[29] = 0; tmp[30] = 0; tmp[31] = 0;
+			  return;
+			case 16:
+			  tmp[ 0] = 0; tmp[ 1] = 0; tmp[ 2] = 0; tmp[ 3] = 0;
+			  tmp[ 4] = 0; tmp[ 5] = 0; tmp[ 6] = 0; tmp[ 7] = 0;
+			  tmp[ 8] = 0; tmp[ 9] = 0; tmp[10] = 0; tmp[11] = 0;
+			  tmp[12] = 0; tmp[13] = 0; tmp[14] = 0; tmp[15] = 0;
+			  return;
+			case 8:
+			  tmp[ 0] = 0; tmp[ 1] = 0; tmp[ 2] = 0; tmp[ 3] = 0;
+			  tmp[ 4] = 0; tmp[ 5] = 0; tmp[ 6] = 0; tmp[ 7] = 0;
+			  return;
+			case 4:
+			  tmp[ 0] = 0; tmp[ 1] = 0; tmp[ 2] = 0; tmp[ 3] = 0;
+			  return;
+		}
+	}
+	i = __FDSET_LONGS;
+	while (i) {
+		i--;
+		*tmp = 0;
+		tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/prctl.h linux-2.6.20-sabayon-r1/include/asm/prctl.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/prctl.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/prctl.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef X86_64_PRCTL_H
+#define X86_64_PRCTL_H 1
+
+#define ARCH_SET_GS 0x1001
+#define ARCH_SET_FS 0x1002
+#define ARCH_GET_FS 0x1003
+#define ARCH_GET_GS 0x1004
+
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/processor.h linux-2.6.20-sabayon-r1/include/asm/processor.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/processor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/processor.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,503 @@
+/*
+ * include/asm-x86_64/processor.h
+ *
+ * Copyright (C) 1994 Linus Torvalds
+ */
+
+#ifndef __ASM_X86_64_PROCESSOR_H
+#define __ASM_X86_64_PROCESSOR_H
+
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/types.h>
+#include <asm/sigcontext.h>
+#include <asm/cpufeature.h>
+#include <linux/threads.h>
+#include <asm/msr.h>
+#include <asm/current.h>
+#include <asm/system.h>
+#include <asm/mmsegment.h>
+#include <asm/percpu.h>
+#include <linux/personality.h>
+#include <linux/cpumask.h>
+
+#define TF_MASK		0x00000100
+#define IF_MASK		0x00000200
+#define IOPL_MASK	0x00003000
+#define NT_MASK		0x00004000
+#define VM_MASK		0x00020000
+#define AC_MASK		0x00040000
+#define VIF_MASK	0x00080000	/* virtual interrupt flag */
+#define VIP_MASK	0x00100000	/* virtual interrupt pending */
+#define ID_MASK		0x00200000
+
+#define desc_empty(desc) \
+               (!((desc)->a | (desc)->b))
+
+#define desc_equal(desc1, desc2) \
+               (((desc1)->a == (desc2)->a) && ((desc1)->b == (desc2)->b))
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ void *pc; asm volatile("leaq 1f(%%rip),%0\n1:":"=r"(pc)); pc; })
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ */
+
+struct cpuinfo_x86 {
+	__u8	x86;		/* CPU family */
+	__u8	x86_vendor;	/* CPU vendor */
+	__u8	x86_model;
+	__u8	x86_mask;
+	int	cpuid_level;	/* Maximum supported CPUID level, -1=no CPUID */
+	__u32	x86_capability[NCAPINTS];
+	char	x86_vendor_id[16];
+	char	x86_model_id[64];
+	int 	x86_cache_size;  /* in KB */
+	int	x86_clflush_size;
+	int	x86_cache_alignment;
+	int	x86_tlbsize;	/* number of 4K pages in DTLB/ITLB combined(in pages)*/
+        __u8    x86_virt_bits, x86_phys_bits;
+	__u8	x86_max_cores;	/* cpuid returned max cores value */
+        __u32   x86_power; 	
+	__u32   extended_cpuid_level;	/* Max extended CPUID function supported */
+	unsigned long loops_per_jiffy;
+#ifdef CONFIG_SMP
+	cpumask_t llc_shared_map;	/* cpus sharing the last level cache */
+#endif
+	__u8	apicid;
+#ifdef CONFIG_SMP
+	__u8	booted_cores;	/* number of cores as seen by OS */
+	__u8	phys_proc_id;	/* Physical Processor id. */
+	__u8	cpu_core_id;	/* Core id. */
+#endif
+} ____cacheline_aligned;
+
+#define X86_VENDOR_INTEL 0
+#define X86_VENDOR_CYRIX 1
+#define X86_VENDOR_AMD 2
+#define X86_VENDOR_UMC 3
+#define X86_VENDOR_NEXGEN 4
+#define X86_VENDOR_CENTAUR 5
+#define X86_VENDOR_RISE 6
+#define X86_VENDOR_TRANSMETA 7
+#define X86_VENDOR_NUM 8
+#define X86_VENDOR_UNKNOWN 0xff
+
+#ifdef CONFIG_SMP
+extern struct cpuinfo_x86 cpu_data[];
+#define current_cpu_data cpu_data[smp_processor_id()]
+#else
+#define cpu_data (&boot_cpu_data)
+#define current_cpu_data boot_cpu_data
+#endif
+
+extern char ignore_irq13;
+
+extern void identify_cpu(struct cpuinfo_x86 *);
+extern void print_cpu_info(struct cpuinfo_x86 *);
+extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
+extern unsigned short num_cache_leaves;
+
+/*
+ * EFLAGS bits
+ */
+#define X86_EFLAGS_CF	0x00000001 /* Carry Flag */
+#define X86_EFLAGS_PF	0x00000004 /* Parity Flag */
+#define X86_EFLAGS_AF	0x00000010 /* Auxillary carry Flag */
+#define X86_EFLAGS_ZF	0x00000040 /* Zero Flag */
+#define X86_EFLAGS_SF	0x00000080 /* Sign Flag */
+#define X86_EFLAGS_TF	0x00000100 /* Trap Flag */
+#define X86_EFLAGS_IF	0x00000200 /* Interrupt Flag */
+#define X86_EFLAGS_DF	0x00000400 /* Direction Flag */
+#define X86_EFLAGS_OF	0x00000800 /* Overflow Flag */
+#define X86_EFLAGS_IOPL	0x00003000 /* IOPL mask */
+#define X86_EFLAGS_NT	0x00004000 /* Nested Task */
+#define X86_EFLAGS_RF	0x00010000 /* Resume Flag */
+#define X86_EFLAGS_VM	0x00020000 /* Virtual Mode */
+#define X86_EFLAGS_AC	0x00040000 /* Alignment Check */
+#define X86_EFLAGS_VIF	0x00080000 /* Virtual Interrupt Flag */
+#define X86_EFLAGS_VIP	0x00100000 /* Virtual Interrupt Pending */
+#define X86_EFLAGS_ID	0x00200000 /* CPUID detection flag */
+
+/*
+ * Intel CPU features in CR4
+ */
+#define X86_CR4_VME		0x0001	/* enable vm86 extensions */
+#define X86_CR4_PVI		0x0002	/* virtual interrupts flag enable */
+#define X86_CR4_TSD		0x0004	/* disable time stamp at ipl 3 */
+#define X86_CR4_DE		0x0008	/* enable debugging extensions */
+#define X86_CR4_PSE		0x0010	/* enable page size extensions */
+#define X86_CR4_PAE		0x0020	/* enable physical address extensions */
+#define X86_CR4_MCE		0x0040	/* Machine check enable */
+#define X86_CR4_PGE		0x0080	/* enable global pages */
+#define X86_CR4_PCE		0x0100	/* enable performance counters at ipl 3 */
+#define X86_CR4_OSFXSR		0x0200	/* enable fast FPU save and restore */
+#define X86_CR4_OSXMMEXCPT	0x0400	/* enable unmasked SSE exceptions */
+
+/*
+ * Save the cr4 feature set we're using (ie
+ * Pentium 4MB enable and PPro Global page
+ * enable), so that any CPU's that boot up
+ * after us can get the correct flags.
+ */
+extern unsigned long mmu_cr4_features;
+
+static inline void set_in_cr4 (unsigned long mask)
+{
+	mmu_cr4_features |= mask;
+	__asm__("movq %%cr4,%%rax\n\t"
+		"orq %0,%%rax\n\t"
+		"movq %%rax,%%cr4\n"
+		: : "irg" (mask)
+		:"ax");
+}
+
+static inline void clear_in_cr4 (unsigned long mask)
+{
+	mmu_cr4_features &= ~mask;
+	__asm__("movq %%cr4,%%rax\n\t"
+		"andq %0,%%rax\n\t"
+		"movq %%rax,%%cr4\n"
+		: : "irg" (~mask)
+		:"ax");
+}
+
+
+/*
+ * User space process size. 47bits minus one guard page.
+ */
+#define TASK_SIZE64	(0x800000000000UL - 4096)
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define IA32_PAGE_OFFSET ((current->personality & ADDR_LIMIT_3GB) ? 0xc0000000 : 0xFFFFe000)
+
+#define TASK_SIZE 		(test_thread_flag(TIF_IA32) ? IA32_PAGE_OFFSET : TASK_SIZE64)
+#define TASK_SIZE_OF(child) 	((test_tsk_thread_flag(child, TIF_IA32)) ? IA32_PAGE_OFFSET : TASK_SIZE64)
+
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE/3)
+
+/*
+ * Size of io_bitmap.
+ */
+#define IO_BITMAP_BITS  65536
+#define IO_BITMAP_BYTES (IO_BITMAP_BITS/8)
+#define IO_BITMAP_LONGS (IO_BITMAP_BYTES/sizeof(long))
+#define IO_BITMAP_OFFSET offsetof(struct tss_struct,io_bitmap)
+#define INVALID_IO_BITMAP_OFFSET 0x8000
+
+struct i387_fxsave_struct {
+	u16	cwd;
+	u16	swd;
+	u16	twd;
+	u16	fop;
+	u64	rip;
+	u64	rdp; 
+	u32	mxcsr;
+	u32	mxcsr_mask;
+	u32	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
+	u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg = 128 bytes */
+	u32	padding[24];
+} __attribute__ ((aligned (16)));
+
+union i387_union {
+	struct i387_fxsave_struct	fxsave;
+};
+
+struct tss_struct {
+	u32 reserved1;
+	u64 rsp0;	
+	u64 rsp1;
+	u64 rsp2;
+	u64 reserved2;
+	u64 ist[7];
+	u32 reserved3;
+	u32 reserved4;
+	u16 reserved5;
+	u16 io_bitmap_base;
+	/*
+	 * The extra 1 is there because the CPU will access an
+	 * additional byte beyond the end of the IO permission
+	 * bitmap. The extra byte must be all 1 bits, and must
+	 * be within the limit. Thus we have:
+	 *
+	 * 128 bytes, the bitmap itself, for ports 0..0x3ff
+	 * 8 bytes, for an extra "long" of ~0UL
+	 */
+	unsigned long io_bitmap[IO_BITMAP_LONGS + 1];
+} __attribute__((packed)) ____cacheline_aligned;
+
+
+extern struct cpuinfo_x86 boot_cpu_data;
+DECLARE_PER_CPU(struct tss_struct,init_tss);
+/* Save the original ist values for checking stack pointers during debugging */
+struct orig_ist {
+	unsigned long ist[7];
+};
+DECLARE_PER_CPU(struct orig_ist, orig_ist);
+
+#ifdef CONFIG_X86_VSMP
+#define ARCH_MIN_TASKALIGN	(1 << INTERNODE_CACHE_SHIFT)
+#define ARCH_MIN_MMSTRUCT_ALIGN	(1 << INTERNODE_CACHE_SHIFT)
+#else
+#define ARCH_MIN_TASKALIGN	16
+#define ARCH_MIN_MMSTRUCT_ALIGN	0
+#endif
+
+struct thread_struct {
+	unsigned long	rsp0;
+	unsigned long	rsp;
+	unsigned long 	userrsp;	/* Copy from PDA */ 
+	unsigned long	fs;
+	unsigned long	gs;
+	unsigned short	es, ds, fsindex, gsindex;	
+/* Hardware debugging registers */
+	unsigned long	debugreg0;  
+	unsigned long	debugreg1;  
+	unsigned long	debugreg2;  
+	unsigned long	debugreg3;  
+	unsigned long	debugreg6;  
+	unsigned long	debugreg7;  
+/* fault info */
+	unsigned long	cr2, trap_no, error_code;
+/* floating point info */
+	union i387_union	i387  __attribute__((aligned(16)));
+/* IO permissions. the bitmap could be moved into the GDT, that would make
+   switch faster for a limited number of ioperm using tasks. -AK */
+	int		ioperm;
+	unsigned long	*io_bitmap_ptr;
+	unsigned io_bitmap_max;
+/* cached TLS descriptors. */
+	u64 tls_array[GDT_ENTRY_TLS_ENTRIES];
+} __attribute__((aligned(16)));
+
+#define INIT_THREAD  { \
+	.rsp0 = (unsigned long)&init_stack + sizeof(init_stack) \
+}
+
+#define INIT_TSS  { \
+	.rsp0 = (unsigned long)&init_stack + sizeof(init_stack) \
+}
+
+#define INIT_MMAP \
+{ &init_mm, 0, 0, NULL, PAGE_SHARED, VM_READ | VM_WRITE | VM_EXEC, 1, NULL, NULL }
+
+#define start_thread(regs,new_rip,new_rsp) do { \
+	asm volatile("movl %0,%%fs; movl %0,%%es; movl %0,%%ds": :"r" (0));	 \
+	load_gs_index(0);							\
+	(regs)->rip = (new_rip);						 \
+	(regs)->rsp = (new_rsp);						 \
+	write_pda(oldrsp, (new_rsp));						 \
+	(regs)->cs = __USER_CS;							 \
+	(regs)->ss = __USER_DS;							 \
+	(regs)->eflags = 0x200;							 \
+	set_fs(USER_DS);							 \
+} while(0) 
+
+#define get_debugreg(var, register)				\
+		__asm__("movq %%db" #register ", %0"		\
+			:"=r" (var))
+#define set_debugreg(value, register)			\
+		__asm__("movq %0,%%db" #register		\
+			: /* no output */			\
+			:"r" (value))
+
+struct task_struct;
+struct mm_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+/* Prepare to copy thread state - unlazy all lazy status */
+extern void prepare_to_copy(struct task_struct *tsk);
+
+/*
+ * create a kernel thread without removing it from tasklists
+ */
+extern long kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/*
+ * Return saved PC of a blocked thread.
+ * What is this good for? it will be always the scheduler or ret_from_fork.
+ */
+#define thread_saved_pc(t) (*(unsigned long *)((t)->thread.rsp - 8))
+
+extern unsigned long get_wchan(struct task_struct *p);
+#define task_pt_regs(tsk) ((struct pt_regs *)(tsk)->thread.rsp0 - 1)
+#define KSTK_EIP(tsk) (task_pt_regs(tsk)->rip)
+#define KSTK_ESP(tsk) -1 /* sorry. doesn't work for syscall. */
+
+
+struct microcode_header {
+	unsigned int hdrver;
+	unsigned int rev;
+	unsigned int date;
+	unsigned int sig;
+	unsigned int cksum;
+	unsigned int ldrver;
+	unsigned int pf;
+	unsigned int datasize;
+	unsigned int totalsize;
+	unsigned int reserved[3];
+};
+
+struct microcode {
+	struct microcode_header hdr;
+	unsigned int bits[0];
+};
+
+typedef struct microcode microcode_t;
+typedef struct microcode_header microcode_header_t;
+
+/* microcode format is extended from prescott processors */
+struct extended_signature {
+	unsigned int sig;
+	unsigned int pf;
+	unsigned int cksum;
+};
+
+struct extended_sigtable {
+	unsigned int count;
+	unsigned int cksum;
+	unsigned int reserved[3];
+	struct extended_signature sigs[0];
+};
+
+
+#define ASM_NOP1 K8_NOP1
+#define ASM_NOP2 K8_NOP2
+#define ASM_NOP3 K8_NOP3
+#define ASM_NOP4 K8_NOP4
+#define ASM_NOP5 K8_NOP5
+#define ASM_NOP6 K8_NOP6
+#define ASM_NOP7 K8_NOP7
+#define ASM_NOP8 K8_NOP8
+
+/* Opteron nops */
+#define K8_NOP1 ".byte 0x90\n"
+#define K8_NOP2	".byte 0x66,0x90\n" 
+#define K8_NOP3	".byte 0x66,0x66,0x90\n" 
+#define K8_NOP4	".byte 0x66,0x66,0x66,0x90\n" 
+#define K8_NOP5	K8_NOP3 K8_NOP2 
+#define K8_NOP6	K8_NOP3 K8_NOP3
+#define K8_NOP7	K8_NOP4 K8_NOP3
+#define K8_NOP8	K8_NOP4 K8_NOP4
+
+#define ASM_NOP_MAX 8
+
+/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
+static inline void rep_nop(void)
+{
+	__asm__ __volatile__("rep;nop": : :"memory");
+}
+
+/* Stop speculative execution */
+static inline void sync_core(void)
+{ 
+	int tmp;
+	asm volatile("cpuid" : "=a" (tmp) : "0" (1) : "ebx","ecx","edx","memory");
+} 
+
+#define cpu_has_fpu 1
+
+#define ARCH_HAS_PREFETCH
+static inline void prefetch(void *x) 
+{ 
+	asm volatile("prefetcht0 %0" :: "m" (*(unsigned long *)x));
+} 
+
+#define ARCH_HAS_PREFETCHW 1
+static inline void prefetchw(void *x) 
+{ 
+	alternative_input("prefetcht0 (%1)",
+			  "prefetchw (%1)",
+			  X86_FEATURE_3DNOW,
+			  "r" (x));
+} 
+
+#define ARCH_HAS_SPINLOCK_PREFETCH 1
+
+#define spin_lock_prefetch(x)  prefetchw(x)
+
+#define cpu_relax()   rep_nop()
+
+/*
+ *      NSC/Cyrix CPU configuration register indexes
+ */
+#define CX86_CCR0 0xc0
+#define CX86_CCR1 0xc1
+#define CX86_CCR2 0xc2
+#define CX86_CCR3 0xc3
+#define CX86_CCR4 0xe8
+#define CX86_CCR5 0xe9
+#define CX86_CCR6 0xea
+#define CX86_CCR7 0xeb
+#define CX86_DIR0 0xfe
+#define CX86_DIR1 0xff
+#define CX86_ARR_BASE 0xc4
+#define CX86_RCR_BASE 0xdc
+
+/*
+ *      NSC/Cyrix CPU indexed register access macros
+ */
+
+#define getCx86(reg) ({ outb((reg), 0x22); inb(0x23); })
+
+#define setCx86(reg, data) do { \
+	outb((reg), 0x22); \
+	outb((data), 0x23); \
+} while (0)
+
+static inline void serialize_cpu(void)
+{
+	__asm__ __volatile__ ("cpuid" : : : "ax", "bx", "cx", "dx");
+}
+
+static inline void __monitor(const void *eax, unsigned long ecx,
+		unsigned long edx)
+{
+	/* "monitor %eax,%ecx,%edx;" */
+	asm volatile(
+		".byte 0x0f,0x01,0xc8;"
+		: :"a" (eax), "c" (ecx), "d"(edx));
+}
+
+static inline void __mwait(unsigned long eax, unsigned long ecx)
+{
+	/* "mwait %eax,%ecx;" */
+	asm volatile(
+		".byte 0x0f,0x01,0xc9;"
+		: :"a" (eax), "c" (ecx));
+}
+
+static inline void __sti_mwait(unsigned long eax, unsigned long ecx)
+{
+	/* "mwait %eax,%ecx;" */
+	asm volatile(
+		"sti; .byte 0x0f,0x01,0xc9;"
+		: :"a" (eax), "c" (ecx));
+}
+
+extern void mwait_idle_with_hints(unsigned long eax, unsigned long ecx);
+
+#define stack_current() \
+({								\
+	struct thread_info *ti;					\
+	asm("andq %%rsp,%0; ":"=r" (ti) : "0" (CURRENT_MASK));	\
+	ti->task;					\
+})
+
+#define cache_line_size() (boot_cpu_data.x86_cache_alignment)
+
+extern unsigned long boot_option_idle_override;
+/* Boot loader type from the setup header */
+extern int bootloader_type;
+
+#define HAVE_ARCH_PICK_MMAP_LAYOUT 1
+
+#endif /* __ASM_X86_64_PROCESSOR_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/proto.h linux-2.6.20-sabayon-r1/include/asm/proto.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/proto.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/proto.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,136 @@
+#ifndef _ASM_X8664_PROTO_H
+#define _ASM_X8664_PROTO_H 1
+
+#include <asm/ldt.h>
+
+/* misc architecture specific prototypes */
+
+struct cpuinfo_x86; 
+struct pt_regs;
+
+extern void start_kernel(void);
+extern void pda_init(int); 
+
+extern void zap_low_mappings(int cpu);
+
+extern void early_idt_handler(void);
+
+extern void mcheck_init(struct cpuinfo_x86 *c);
+#ifdef CONFIG_MTRR
+extern void mtrr_ap_init(void);
+extern void mtrr_bp_init(void);
+#else
+#define mtrr_ap_init() do {} while (0)
+#define mtrr_bp_init() do {} while (0)
+#endif
+extern void init_memory_mapping(unsigned long start, unsigned long end);
+
+extern void system_call(void); 
+extern int kernel_syscall(void);
+extern void syscall_init(void);
+
+extern void ia32_syscall(void);
+extern void ia32_cstar_target(void); 
+extern void ia32_sysenter_target(void); 
+
+extern void config_acpi_tables(void);
+extern void ia32_syscall(void);
+
+extern int pmtimer_mark_offset(void);
+extern void pmtimer_resume(void);
+extern void pmtimer_wait(unsigned);
+extern unsigned int do_gettimeoffset_pm(void);
+#ifdef CONFIG_X86_PM_TIMER
+extern u32 pmtmr_ioport;
+#else
+#define pmtmr_ioport 0
+#endif
+extern unsigned long long monotonic_base;
+extern int sysctl_vsyscall;
+extern int nohpet;
+extern unsigned long vxtime_hz;
+extern void time_init_gtod(void);
+
+extern void early_printk(const char *fmt, ...) __attribute__((format(printf,1,2)));
+
+extern void early_identify_cpu(struct cpuinfo_x86 *c);
+
+extern int k8_scan_nodes(unsigned long start, unsigned long end);
+
+extern void numa_initmem_init(unsigned long start_pfn, unsigned long end_pfn);
+extern unsigned long numa_free_all_bootmem(void);
+
+extern void reserve_bootmem_generic(unsigned long phys, unsigned len);
+
+extern void load_gs_index(unsigned gs);
+
+extern void stop_timer_interrupt(void);
+extern void main_timer_handler(void);
+
+extern unsigned long end_pfn_map; 
+
+extern void show_trace(struct task_struct *, struct pt_regs *, unsigned long * rsp);
+extern void show_registers(struct pt_regs *regs);
+
+extern void exception_table_check(void);
+
+extern void acpi_reserve_bootmem(void);
+
+extern void swap_low_mappings(void);
+
+extern void __show_regs(struct pt_regs * regs);
+extern void show_regs(struct pt_regs * regs);
+
+extern char *syscall32_page;
+extern void syscall32_cpu_init(void);
+
+extern void setup_node_bootmem(int nodeid, unsigned long start, unsigned long end);
+
+extern void early_quirks(void);
+extern void quirk_intel_irqbalance(void);
+extern void check_efer(void);
+
+extern int unhandled_signal(struct task_struct *tsk, int sig);
+
+extern int unsynchronized_tsc(void);
+
+extern void select_idle_routine(const struct cpuinfo_x86 *c);
+
+extern unsigned long table_start, table_end;
+
+extern int exception_trace;
+extern unsigned cpu_khz;
+
+extern void no_iommu_init(void);
+extern int force_iommu, no_iommu;
+extern int iommu_detected;
+#ifdef CONFIG_IOMMU
+extern void gart_iommu_init(void);
+extern void gart_parse_options(char *);
+extern void iommu_hole_init(void);
+extern int fallback_aper_order;
+extern int fallback_aper_force;
+extern int iommu_aperture;
+extern int iommu_aperture_allowed;
+extern int iommu_aperture_disabled;
+extern int fix_aperture;
+#else
+#define iommu_aperture 0
+#define iommu_aperture_allowed 0
+#endif
+
+extern int reboot_force;
+extern int notsc_setup(char *);
+
+extern int timer_over_8254;
+
+extern int gsi_irq_sharing(int gsi);
+
+extern void smp_local_timer_interrupt(void);
+
+long do_arch_prctl(struct task_struct *task, int code, unsigned long addr);
+
+#define round_up(x,y) (((x) + (y) - 1) & ~((y)-1))
+#define round_down(x,y) ((x) & ~((y)-1))
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ptrace-abi.h linux-2.6.20-sabayon-r1/include/asm/ptrace-abi.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ptrace-abi.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ptrace-abi.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,51 @@
+#ifndef _X86_64_PTRACE_ABI_H
+#define _X86_64_PTRACE_ABI_H
+
+#if defined(__ASSEMBLY__) || defined(__FRAME_OFFSETS)
+#define R15 0
+#define R14 8
+#define R13 16
+#define R12 24
+#define RBP 32
+#define RBX 40
+/* arguments: interrupts/non tracing syscalls only save upto here*/
+#define R11 48
+#define R10 56
+#define R9 64
+#define R8 72
+#define RAX 80
+#define RCX 88
+#define RDX 96
+#define RSI 104
+#define RDI 112
+#define ORIG_RAX 120       /* = ERROR */
+/* end of arguments */
+/* cpu exception frame or undefined in case of fast syscall. */
+#define RIP 128
+#define CS 136
+#define EFLAGS 144
+#define RSP 152
+#define SS 160
+#define ARGOFFSET R11
+#endif /* __ASSEMBLY__ */
+
+/* top of stack page */
+#define FRAME_SIZE 168
+
+#define PTRACE_OLDSETOPTIONS         21
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS            12
+#define PTRACE_SETREGS            13
+#define PTRACE_GETFPREGS          14
+#define PTRACE_SETFPREGS          15
+#define PTRACE_GETFPXREGS         18
+#define PTRACE_SETFPXREGS         19
+
+/* only useful for access 32bit programs */
+#define PTRACE_GET_THREAD_AREA    25
+#define PTRACE_SET_THREAD_AREA    26
+
+#define PTRACE_ARCH_PRCTL	  30	/* arch_prctl for child */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ptrace.h linux-2.6.20-sabayon-r1/include/asm/ptrace.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ptrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ptrace.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,77 @@
+#ifndef _X86_64_PTRACE_H
+#define _X86_64_PTRACE_H
+
+#include <asm/ptrace-abi.h>
+
+#ifndef __ASSEMBLY__
+
+struct pt_regs {
+	unsigned long r15;
+	unsigned long r14;
+	unsigned long r13;
+	unsigned long r12;
+	unsigned long rbp;
+	unsigned long rbx;
+/* arguments: non interrupts/non tracing syscalls only save upto here*/
+ 	unsigned long r11;
+	unsigned long r10;
+	unsigned long r9;
+	unsigned long r8;
+	unsigned long rax;
+	unsigned long rcx;
+	unsigned long rdx;
+	unsigned long rsi;
+	unsigned long rdi;
+	unsigned long orig_rax;
+/* end of arguments */
+/* cpu exception frame or undefined */
+	unsigned long rip;
+	unsigned long cs;
+	unsigned long eflags;
+	unsigned long rsp;
+	unsigned long ss;
+/* top of stack page */
+};
+
+#endif
+
+#if defined(__KERNEL__) && !defined(__ASSEMBLY__) 
+#define user_mode(regs) (!!((regs)->cs & 3))
+#define user_mode_vm(regs) user_mode(regs)
+#define instruction_pointer(regs) ((regs)->rip)
+#define regs_return_value(regs) ((regs)->rax)
+
+extern unsigned long profile_pc(struct pt_regs *regs);
+void signal_fault(struct pt_regs *regs, void __user *frame, char *where);
+
+struct task_struct;
+
+extern unsigned long
+convert_rip_to_linear(struct task_struct *child, struct pt_regs *regs);
+
+enum {
+        EF_CF   = 0x00000001,
+        EF_PF   = 0x00000004,
+        EF_AF   = 0x00000010,
+        EF_ZF   = 0x00000040,
+        EF_SF   = 0x00000080,
+        EF_TF   = 0x00000100,
+        EF_IE   = 0x00000200,
+        EF_DF   = 0x00000400,
+        EF_OF   = 0x00000800,
+        EF_IOPL = 0x00003000,
+        EF_IOPL_RING0 = 0x00000000,
+        EF_IOPL_RING1 = 0x00001000,
+        EF_IOPL_RING2 = 0x00002000,
+        EF_NT   = 0x00004000,   /* nested task */
+        EF_RF   = 0x00010000,   /* resume */
+        EF_VM   = 0x00020000,   /* virtual mode */
+        EF_AC   = 0x00040000,   /* alignment */
+        EF_VIF  = 0x00080000,   /* virtual interrupt */
+        EF_VIP  = 0x00100000,   /* virtual interrupt pending */
+        EF_ID   = 0x00200000,   /* id */
+};
+
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/resource.h linux-2.6.20-sabayon-r1/include/asm/resource.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/resource.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/resource.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _X8664_RESOURCE_H
+#define _X8664_RESOURCE_H
+
+#include <asm-generic/resource.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/rio.h linux-2.6.20-sabayon-r1/include/asm/rio.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/rio.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/rio.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,74 @@
+/*
+ * Derived from include/asm-i386/mach-summit/mach_mpparse.h
+ *          and include/asm-i386/mach-default/bios_ebda.h
+ *
+ * Author: Laurent Vivier <Laurent.Vivier@bull.net>
+ */
+
+#ifndef __ASM_RIO_H
+#define __ASM_RIO_H
+
+#define RIO_TABLE_VERSION	3
+
+struct rio_table_hdr {
+	u8 version;      /* Version number of this data structure  */
+	u8 num_scal_dev; /* # of Scalability devices               */
+	u8 num_rio_dev;  /* # of RIO I/O devices                   */
+} __attribute__((packed));
+
+struct scal_detail {
+	u8 node_id;      /* Scalability Node ID                    */
+	u32 CBAR;        /* Address of 1MB register space          */
+	u8 port0node;    /* Node ID port connected to: 0xFF=None   */
+	u8 port0port;    /* Port num port connected to: 0,1,2, or  */
+	                 /* 0xFF=None                              */
+	u8 port1node;    /* Node ID port connected to: 0xFF = None */
+	u8 port1port;    /* Port num port connected to: 0,1,2, or  */
+	                 /* 0xFF=None                              */
+	u8 port2node;    /* Node ID port connected to: 0xFF = None */
+	u8 port2port;    /* Port num port connected to: 0,1,2, or  */
+	                 /* 0xFF=None                              */
+	u8 chassis_num;  /* 1 based Chassis number (1 = boot node) */
+} __attribute__((packed));
+
+struct rio_detail {
+	u8 node_id;      /* RIO Node ID                            */
+	u32 BBAR;        /* Address of 1MB register space          */
+	u8 type;         /* Type of device                         */
+	u8 owner_id;     /* Node ID of Hurricane that owns this    */
+	                 /* node                                   */
+	u8 port0node;    /* Node ID port connected to: 0xFF=None   */
+	u8 port0port;    /* Port num port connected to: 0,1,2, or  */
+	                 /* 0xFF=None                              */
+	u8 port1node;    /* Node ID port connected to: 0xFF=None   */
+	u8 port1port;    /* Port num port connected to: 0,1,2, or  */
+	                 /* 0xFF=None                              */
+	u8 first_slot;   /* Lowest slot number below this Calgary  */
+	u8 status;       /* Bit 0 = 1 : the XAPIC is used          */
+	                 /*       = 0 : the XAPIC is not used, ie: */
+	                 /*            ints fwded to another XAPIC */
+	                 /*           Bits1:7 Reserved             */
+	u8 WP_index;     /* instance index - lower ones have       */
+	                 /*     lower slot numbers/PCI bus numbers */
+	u8 chassis_num;  /* 1 based Chassis number                 */
+} __attribute__((packed));
+
+enum {
+	HURR_SCALABILTY	= 0,  /* Hurricane Scalability info */
+	HURR_RIOIB	= 2,  /* Hurricane RIOIB info       */
+	COMPAT_CALGARY	= 4,  /* Compatibility Calgary      */
+	ALT_CALGARY	= 5,  /* Second Planar Calgary      */
+};
+
+/*
+ * there is a real-mode segmented pointer pointing to the
+ * 4K EBDA area at 0x40E.
+ */
+static inline unsigned long get_bios_ebda(void)
+{
+	unsigned long address = *(unsigned short *)phys_to_virt(0x40EUL);
+	address <<= 4;
+	return address;
+}
+
+#endif /* __ASM_RIO_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/rtc.h linux-2.6.20-sabayon-r1/include/asm/rtc.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/rtc.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/rtc.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,10 @@
+#ifndef _X86_64_RTC_H
+#define _X86_64_RTC_H
+
+/*
+ * x86 uses the default access methods for the RTC.
+ */
+
+#include <asm-generic/rtc.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/rwlock.h linux-2.6.20-sabayon-r1/include/asm/rwlock.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/rwlock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/rwlock.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,26 @@
+/* include/asm-x86_64/rwlock.h
+ *
+ *	Helpers used by both rw spinlocks and rw semaphores.
+ *
+ *	Based in part on code from semaphore.h and
+ *	spinlock.h Copyright 1996 Linus Torvalds.
+ *
+ *	Copyright 1999 Red Hat, Inc.
+ *	Copyright 2001,2002 SuSE labs 
+ *
+ *	Written by Benjamin LaHaise.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+#ifndef _ASM_X86_64_RWLOCK_H
+#define _ASM_X86_64_RWLOCK_H
+
+#define RW_LOCK_BIAS		 0x01000000
+#define RW_LOCK_BIAS_STR	 "0x01000000"
+
+/* Actual code is in asm/spinlock.h or in arch/x86_64/lib/rwlock.S */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/scatterlist.h linux-2.6.20-sabayon-r1/include/asm/scatterlist.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/scatterlist.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/scatterlist.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,22 @@
+#ifndef _X8664_SCATTERLIST_H
+#define _X8664_SCATTERLIST_H
+
+struct scatterlist {
+    struct page		*page;
+    unsigned int	offset;
+    unsigned int	length;
+    dma_addr_t		dma_address;
+    unsigned int        dma_length;
+};
+
+#define ISA_DMA_THRESHOLD (0x00ffffff)
+
+/* These macros should be used after a pci_map_sg call has been done
+ * to get bus addresses of each of the SG entries and their lengths.
+ * You should only work with the number of sg entries pci_map_sg
+ * returns.
+ */
+#define sg_dma_address(sg)     ((sg)->dma_address)
+#define sg_dma_len(sg)         ((sg)->dma_length)
+
+#endif 
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/seccomp.h linux-2.6.20-sabayon-r1/include/asm/seccomp.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/seccomp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/seccomp.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,24 @@
+#ifndef _ASM_SECCOMP_H
+
+#include <linux/thread_info.h>
+
+#ifdef TIF_32BIT
+#error "unexpected TIF_32BIT on x86_64"
+#else
+#define TIF_32BIT TIF_IA32
+#endif
+
+#include <linux/unistd.h>
+#include <asm/ia32_unistd.h>
+
+#define __NR_seccomp_read __NR_read
+#define __NR_seccomp_write __NR_write
+#define __NR_seccomp_exit __NR_exit
+#define __NR_seccomp_sigreturn __NR_rt_sigreturn
+
+#define __NR_seccomp_read_32 __NR_ia32_read
+#define __NR_seccomp_write_32 __NR_ia32_write
+#define __NR_seccomp_exit_32 __NR_ia32_exit
+#define __NR_seccomp_sigreturn_32 __NR_ia32_sigreturn
+
+#endif /* _ASM_SECCOMP_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sections.h linux-2.6.20-sabayon-r1/include/asm/sections.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sections.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sections.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,7 @@
+#ifndef _X8664_SECTIONS_H
+#define _X8664_SECTIONS_H
+
+/* nothing to see, move along */
+#include <asm-generic/sections.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/segment.h linux-2.6.20-sabayon-r1/include/asm/segment.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/segment.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/segment.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,45 @@
+#ifndef _ASM_SEGMENT_H
+#define _ASM_SEGMENT_H
+
+#include <asm/cache.h>
+
+#define __KERNEL_CS	0x10
+#define __KERNEL_DS	0x18
+
+#define __KERNEL32_CS   0x38
+
+/* 
+ * we cannot use the same code segment descriptor for user and kernel
+ * -- not even in the long flat mode, because of different DPL /kkeil 
+ * The segment offset needs to contain a RPL. Grr. -AK
+ * GDT layout to get 64bit syscall right (sysret hardcodes gdt offsets) 
+ */
+
+#define __USER32_CS   0x23   /* 4*8+3 */ 
+#define __USER_DS     0x2b   /* 5*8+3 */ 
+#define __USER_CS     0x33   /* 6*8+3 */ 
+#define __USER32_DS	__USER_DS 
+
+#define GDT_ENTRY_TSS 8	/* needs two entries */
+#define GDT_ENTRY_LDT 10 /* needs two entries */
+#define GDT_ENTRY_TLS_MIN 12
+#define GDT_ENTRY_TLS_MAX 14
+
+#define GDT_ENTRY_TLS_ENTRIES 3
+
+#define GDT_ENTRY_PER_CPU 15	/* Abused to load per CPU data from limit */
+#define __PER_CPU_SEG	(GDT_ENTRY_PER_CPU * 8 + 3)
+
+/* TLS indexes for 64bit - hardcoded in arch_prctl */
+#define FS_TLS 0	
+#define GS_TLS 1	
+
+#define GS_TLS_SEL ((GDT_ENTRY_TLS_MIN+GS_TLS)*8 + 3)
+#define FS_TLS_SEL ((GDT_ENTRY_TLS_MIN+FS_TLS)*8 + 3)
+
+#define IDT_ENTRIES 256
+#define GDT_ENTRIES 16
+#define GDT_SIZE (GDT_ENTRIES * 8)
+#define TLS_SIZE (GDT_ENTRY_TLS_ENTRIES * 8) 
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/semaphore.h linux-2.6.20-sabayon-r1/include/asm/semaphore.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/semaphore.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/semaphore.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,181 @@
+#ifndef _X86_64_SEMAPHORE_H
+#define _X86_64_SEMAPHORE_H
+
+#include <linux/linkage.h>
+
+#ifdef __KERNEL__
+
+/*
+ * SMP- and interrupt-safe semaphores..
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ * Modified 1996-12-23 by Dave Grothe <dave@gcom.com> to fix bugs in
+ *                     the original code and to make semaphore waits
+ *                     interruptible so that processes waiting on
+ *                     semaphores can be killed.
+ * Modified 1999-02-14 by Andrea Arcangeli, split the sched.c helper
+ *		       functions in asm/sempahore-helper.h while fixing a
+ *		       potential and subtle race discovered by Ulrich Schmid
+ *		       in down_interruptible(). Since I started to play here I
+ *		       also implemented the `trylock' semaphore operation.
+ *          1999-07-02 Artur Skawina <skawina@geocities.com>
+ *                     Optimized "0(ecx)" -> "(ecx)" (the assembler does not
+ *                     do this). Changed calling sequences from push/jmp to
+ *                     traditional call/ret.
+ * Modified 2001-01-01 Andreas Franck <afranck@gmx.de>
+ *		       Some hacks to ensure compatibility with recent
+ *		       GCC snapshots, to avoid stack corruption when compiling
+ *		       with -fomit-frame-pointer. It's not sure if this will
+ *		       be fixed in GCC, as our previous implementation was a
+ *		       bit dubious.
+ *
+ * If you would like to see an analysis of this implementation, please
+ * ftp to gcom.com and download the file
+ * /pub/linux/src/semaphore/semaphore-2.0.24.tar.gz.
+ *
+ */
+
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <asm/rwlock.h>
+#include <linux/wait.h>
+#include <linux/rwsem.h>
+#include <linux/stringify.h>
+
+struct semaphore {
+	atomic_t count;
+	int sleepers;
+	wait_queue_head_t wait;
+};
+
+#define __SEMAPHORE_INITIALIZER(name, n)				\
+{									\
+	.count		= ATOMIC_INIT(n),				\
+	.sleepers	= 0,						\
+	.wait		= __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)	\
+}
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+
+#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static inline void sema_init (struct semaphore *sem, int val)
+{
+/*
+ *	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
+ *
+ * i'd rather use the more flexible initialization above, but sadly
+ * GCC 2.7.2.3 emits a bogus warning. EGCS doesn't. Oh well.
+ */
+	atomic_set(&sem->count, val);
+	sem->sleepers = 0;
+	init_waitqueue_head(&sem->wait);
+}
+
+static inline void init_MUTEX (struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static inline void init_MUTEX_LOCKED (struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+asmlinkage void __down_failed(void /* special register calling convention */);
+asmlinkage int  __down_failed_interruptible(void  /* params in registers */);
+asmlinkage int  __down_failed_trylock(void  /* params in registers */);
+asmlinkage void __up_wakeup(void /* special register calling convention */);
+
+asmlinkage void __down(struct semaphore * sem);
+asmlinkage int  __down_interruptible(struct semaphore * sem);
+asmlinkage int  __down_trylock(struct semaphore * sem);
+asmlinkage void __up(struct semaphore * sem);
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "__down_failed" is a special asm handler that calls the C
+ * routine that actually waits. See arch/x86_64/kernel/semaphore.c
+ */
+static inline void down(struct semaphore * sem)
+{
+	might_sleep();
+
+	__asm__ __volatile__(
+		"# atomic down operation\n\t"
+		LOCK_PREFIX "decl %0\n\t"     /* --sem->count */
+		"jns 1f\n\t"
+		"call __down_failed\n"
+		"1:"
+		:"=m" (sem->count)
+		:"D" (sem)
+		:"memory");
+}
+
+/*
+ * Interruptible try to acquire a semaphore.  If we obtained
+ * it, return zero.  If we were interrupted, returns -EINTR
+ */
+static inline int down_interruptible(struct semaphore * sem)
+{
+	int result;
+
+	might_sleep();
+
+	__asm__ __volatile__(
+		"# atomic interruptible down operation\n\t"
+		"xorl %0,%0\n\t"
+		LOCK_PREFIX "decl %1\n\t"     /* --sem->count */
+		"jns 2f\n\t"
+		"call __down_failed_interruptible\n"
+		"2:\n"
+		:"=&a" (result), "=m" (sem->count)
+		:"D" (sem)
+		:"memory");
+	return result;
+}
+
+/*
+ * Non-blockingly attempt to down() a semaphore.
+ * Returns zero if we acquired it
+ */
+static inline int down_trylock(struct semaphore * sem)
+{
+	int result;
+
+	__asm__ __volatile__(
+		"# atomic interruptible down operation\n\t"
+		"xorl %0,%0\n\t"
+		LOCK_PREFIX "decl %1\n\t"     /* --sem->count */
+		"jns 2f\n\t"
+		"call __down_failed_trylock\n\t"
+		"2:\n"
+		:"=&a" (result), "=m" (sem->count)
+		:"D" (sem)
+		:"memory","cc");
+	return result;
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static inline void up(struct semaphore * sem)
+{
+	__asm__ __volatile__(
+		"# atomic up operation\n\t"
+		LOCK_PREFIX "incl %0\n\t"     /* ++sem->count */
+		"jg 1f\n\t"
+		"call __up_wakeup\n"
+		"1:"
+		:"=m" (sem->count)
+		:"D" (sem)
+		:"memory");
+}
+#endif /* __KERNEL__ */
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sembuf.h linux-2.6.20-sabayon-r1/include/asm/sembuf.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sembuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sembuf.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,25 @@
+#ifndef _X86_64_SEMBUF_H
+#define _X86_64_SEMBUF_H
+
+/* 
+ * The semid64_ds structure for x86_64 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _X86_64_SEMBUF_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/serial.h linux-2.6.20-sabayon-r1/include/asm/serial.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/serial.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/serial.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,29 @@
+/*
+ * include/asm-x86_64/serial.h
+ */
+
+
+/*
+ * This assumes you have a 1.8432 MHz clock for your UART.
+ *
+ * It'd be nice if someone built a serial card with a 24.576 MHz
+ * clock, since the 16550A is capable of handling a top speed of 1.5
+ * megabits/second; but this requires the faster clock.
+ */
+#define BASE_BAUD ( 1843200 / 16 )
+
+/* Standard COM flags (except for COM4, because of the 8514 problem) */
+#ifdef CONFIG_SERIAL_DETECT_IRQ
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ)
+#define STD_COM4_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_AUTO_IRQ)
+#else
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF
+#endif
+
+#define SERIAL_PORT_DFNS			\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
+	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
+	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/setup.h linux-2.6.20-sabayon-r1/include/asm/setup.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/setup.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/setup.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _x8664_SETUP_H
+#define _x8664_SETUP_H
+
+#define COMMAND_LINE_SIZE	256
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/shmbuf.h linux-2.6.20-sabayon-r1/include/asm/shmbuf.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/shmbuf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/shmbuf.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,38 @@
+#ifndef _X8664_SHMBUF_H
+#define _X8664_SHMBUF_H
+
+/* 
+ * The shmid64_ds structure for x8664 architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 2 miscellaneous 64-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	__kernel_time_t		shm_ctime;	/* last change time */
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/shmparam.h linux-2.6.20-sabayon-r1/include/asm/shmparam.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/shmparam.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/shmparam.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,6 @@
+#ifndef _ASMX8664_SHMPARAM_H
+#define _ASMX8664_SHMPARAM_H
+
+#define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
+
+#endif /* _ASMX8664_SHMPARAM_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sigcontext32.h linux-2.6.20-sabayon-r1/include/asm/sigcontext32.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sigcontext32.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sigcontext32.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,71 @@
+#ifndef _SIGCONTEXT32_H
+#define _SIGCONTEXT32_H 1
+
+/* signal context for 32bit programs. */
+
+#define X86_FXSR_MAGIC		0x0000
+
+struct _fpreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+};
+
+struct _fpxreg {
+	unsigned short significand[4];
+	unsigned short exponent;
+	unsigned short padding[3];
+};
+
+struct _xmmreg {
+	__u32	element[4];
+};
+
+/* FSAVE frame with extensions */
+struct _fpstate_ia32 {
+	/* Regular FPU environment */
+	__u32 	cw;
+	__u32	sw;
+	__u32	tag;	/* not compatible to 64bit twd */
+	__u32	ipoff;			
+	__u32	cssel;
+	__u32	dataoff;
+	__u32	datasel;
+	struct _fpreg	_st[8];
+	unsigned short	status;
+	unsigned short	magic;		/* 0xffff = regular FPU data only */
+
+	/* FXSR FPU environment */
+	__u32	_fxsr_env[6];
+	__u32	mxcsr;
+	__u32	reserved;
+	struct _fpxreg	_fxsr_st[8];
+	struct _xmmreg	_xmm[8];	/* It's actually 16 */ 
+	__u32	padding[56];
+};
+
+struct sigcontext_ia32 {
+       unsigned short gs, __gsh;
+       unsigned short fs, __fsh;
+       unsigned short es, __esh;
+       unsigned short ds, __dsh;
+       unsigned int edi;
+       unsigned int esi;
+       unsigned int ebp;
+       unsigned int esp;
+       unsigned int ebx;
+       unsigned int edx;
+       unsigned int ecx;
+       unsigned int eax;
+       unsigned int trapno;
+       unsigned int err;
+       unsigned int eip;
+       unsigned short cs, __csh;
+       unsigned int eflags;
+       unsigned int esp_at_signal;
+       unsigned short ss, __ssh;
+       unsigned int fpstate;		/* really (struct _fpstate_ia32 *) */
+       unsigned int oldmask;
+       unsigned int cr2;
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sigcontext.h linux-2.6.20-sabayon-r1/include/asm/sigcontext.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sigcontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sigcontext.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,55 @@
+#ifndef _ASM_X86_64_SIGCONTEXT_H
+#define _ASM_X86_64_SIGCONTEXT_H
+
+#include <asm/types.h>
+#include <linux/compiler.h>
+
+/* FXSAVE frame */
+/* Note: reserved1/2 may someday contain valuable data. Always save/restore
+   them when you change signal frames. */
+struct _fpstate {
+	__u16	cwd;
+	__u16	swd;
+	__u16	twd;	/* Note this is not the same as the 32bit/x87/FSAVE twd */
+	__u16	fop;
+	__u64	rip;
+	__u64	rdp; 
+	__u32	mxcsr;
+	__u32	mxcsr_mask;
+	__u32	st_space[32];	/* 8*16 bytes for each FP-reg */
+	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg  */
+	__u32	reserved2[24];
+};
+
+struct sigcontext { 
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long r10;
+	unsigned long r11;
+	unsigned long r12;
+	unsigned long r13;
+	unsigned long r14;
+	unsigned long r15;
+	unsigned long rdi;
+	unsigned long rsi;
+	unsigned long rbp;
+	unsigned long rbx;
+	unsigned long rdx;
+	unsigned long rax;
+	unsigned long rcx;
+	unsigned long rsp;
+	unsigned long rip;
+	unsigned long eflags;		/* RFLAGS */
+	unsigned short cs;
+	unsigned short gs;
+	unsigned short fs;
+	unsigned short __pad0; 
+	unsigned long err;
+	unsigned long trapno;
+	unsigned long oldmask;
+	unsigned long cr2;
+	struct _fpstate __user *fpstate;	/* zero when no FPU context */
+	unsigned long reserved1[8];
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/siginfo.h linux-2.6.20-sabayon-r1/include/asm/siginfo.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/siginfo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/siginfo.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,8 @@
+#ifndef _X8664_SIGINFO_H
+#define _X8664_SIGINFO_H
+
+#define __ARCH_SI_PREAMBLE_SIZE	(4 * sizeof(int))
+
+#include <asm-generic/siginfo.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/signal.h linux-2.6.20-sabayon-r1/include/asm/signal.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/signal.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,181 @@
+#ifndef _ASMx8664_SIGNAL_H
+#define _ASMx8664_SIGNAL_H
+
+#ifndef __ASSEMBLY__
+#include <linux/types.h>
+#include <linux/time.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+#include <linux/linkage.h>
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	64
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;		/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __KERNEL__ */
+#endif
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001
+#define SA_NOCLDWAIT	0x00000002
+#define SA_SIGINFO	0x00000004
+#define SA_ONSTACK	0x08000000
+#define SA_RESTART	0x10000000
+#define SA_NODEFER	0x40000000
+#define SA_RESETHAND	0x80000000
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+
+#define SA_RESTORER	0x04000000
+
+/*
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#include <asm-generic/signal.h>
+
+#ifndef __ASSEMBLY__
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	__sigrestore_t sa_restorer;
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+
+typedef struct sigaltstack {
+	void __user *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+#include <asm/sigcontext.h>
+
+#undef __HAVE_ARCH_SIG_BITOPS
+#if 0
+
+static inline void sigaddset(sigset_t *set, int _sig)
+{
+	__asm__("btsq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
+}
+
+static inline void sigdelset(sigset_t *set, int _sig)
+{
+	__asm__("btrq %1,%0" : "=m"(*set) : "Ir"(_sig - 1) : "cc");
+}
+
+static inline int __const_sigismember(sigset_t *set, int _sig)
+{
+	unsigned long sig = _sig - 1;
+	return 1 & (set->sig[sig / _NSIG_BPW] >> (sig & ~(_NSIG_BPW-1)));
+}
+
+static inline int __gen_sigismember(sigset_t *set, int _sig)
+{
+	int ret;
+	__asm__("btq %2,%1\n\tsbbq %0,%0"
+		: "=r"(ret) : "m"(*set), "Ir"(_sig-1) : "cc");
+	return ret;
+}
+
+#define sigismember(set,sig)			\
+	(__builtin_constant_p(sig) ?		\
+	 __const_sigismember((set),(sig)) :	\
+	 __gen_sigismember((set),(sig)))
+
+static inline int sigfindinword(unsigned long word)
+{
+	__asm__("bsfq %1,%0" : "=r"(word) : "rm"(word) : "cc");
+	return word;
+}
+#endif
+#endif
+
+#define ptrace_signal_deliver(regs, cookie) do { } while (0)
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/smp.h linux-2.6.20-sabayon-r1/include/asm/smp.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/smp.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/smp.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,118 @@
+#ifndef __ASM_SMP_H
+#define __ASM_SMP_H
+
+/*
+ * We need the APIC definitions automatically as part of 'smp.h'
+ */
+#include <linux/threads.h>
+#include <linux/cpumask.h>
+#include <linux/bitops.h>
+extern int disable_apic;
+
+#include <asm/fixmap.h>
+#include <asm/mpspec.h>
+#include <asm/io_apic.h>
+#include <asm/apic.h>
+#include <asm/thread_info.h>
+
+#ifdef CONFIG_SMP
+
+#include <asm/pda.h>
+
+struct pt_regs;
+
+extern cpumask_t cpu_present_mask;
+extern cpumask_t cpu_possible_map;
+extern cpumask_t cpu_online_map;
+extern cpumask_t cpu_callout_map;
+extern cpumask_t cpu_initialized;
+
+/*
+ * Private routines/data
+ */
+ 
+extern void smp_alloc_memory(void);
+extern volatile unsigned long smp_invalidate_needed;
+extern void lock_ipi_call_lock(void);
+extern void unlock_ipi_call_lock(void);
+extern int smp_num_siblings;
+extern void smp_send_reschedule(int cpu);
+void smp_stop_cpu(void);
+
+extern cpumask_t cpu_sibling_map[NR_CPUS];
+extern cpumask_t cpu_core_map[NR_CPUS];
+extern u8 cpu_llc_id[NR_CPUS];
+
+#define SMP_TRAMPOLINE_BASE 0x6000
+
+/*
+ * On x86 all CPUs are mapped 1:1 to the APIC space.
+ * This simplifies scheduling and IPI sending and
+ * compresses data structures.
+ */
+
+static inline int num_booting_cpus(void)
+{
+	return cpus_weight(cpu_callout_map);
+}
+
+#define raw_smp_processor_id() read_pda(cpunumber)
+
+static inline int hard_smp_processor_id(void)
+{
+	/* we don't want to mark this access volatile - bad code generation */
+	return GET_APIC_ID(*(unsigned int *)(APIC_BASE+APIC_ID));
+}
+
+extern int __cpu_disable(void);
+extern void __cpu_die(unsigned int cpu);
+extern void prefill_possible_map(void);
+extern unsigned num_processors;
+extern unsigned disabled_cpus;
+
+#define NO_PROC_ID		0xFF		/* No processor magic marker */
+
+#endif
+
+/*
+ * Some lowlevel functions might want to know about
+ * the real APIC ID <-> CPU # mapping.
+ */
+extern u8 x86_cpu_to_apicid[NR_CPUS];	/* physical ID */
+extern u8 x86_cpu_to_log_apicid[NR_CPUS];
+extern u8 bios_cpu_apicid[];
+
+static inline int cpu_present_to_apicid(int mps_cpu)
+{
+	if (mps_cpu < NR_CPUS)
+		return (int)bios_cpu_apicid[mps_cpu];
+	else
+		return BAD_APICID;
+}
+
+#ifndef CONFIG_SMP
+#define stack_smp_processor_id() 0
+#define cpu_logical_map(x) (x)
+#else
+#include <asm/thread_info.h>
+#define stack_smp_processor_id() \
+({ 								\
+	struct thread_info *ti;					\
+	__asm__("andq %%rsp,%0; ":"=r" (ti) : "0" (CURRENT_MASK));	\
+	ti->cpu;						\
+})
+#endif
+
+static __inline int logical_smp_processor_id(void)
+{
+	/* we don't want to mark this access volatile - bad code generation */
+	return GET_APIC_LOGICAL_ID(*(unsigned long *)(APIC_BASE+APIC_LDR));
+}
+
+#ifdef CONFIG_SMP
+#define cpu_physical_id(cpu)		x86_cpu_to_apicid[cpu]
+#else
+#define cpu_physical_id(cpu)		boot_cpu_id
+#endif /* !CONFIG_SMP */
+#endif
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/socket.h linux-2.6.20-sabayon-r1/include/asm/socket.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/socket.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,53 @@
+#ifndef _ASM_SOCKET_H
+#define _ASM_SOCKET_H
+
+#include <asm/sockios.h>
+
+/* For setsockopt(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_SNDBUFFORCE	32
+#define SO_RCVBUFFORCE	33
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC             31
+#define SO_PASSSEC		34
+
+#endif /* _ASM_SOCKET_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sockios.h linux-2.6.20-sabayon-r1/include/asm/sockios.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sockios.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sockios.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef __ARCH_X8664_SOCKIOS__
+#define __ARCH_X8664_SOCKIOS__
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN 	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/sparsemem.h linux-2.6.20-sabayon-r1/include/asm/sparsemem.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/sparsemem.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/sparsemem.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,26 @@
+#ifndef _ASM_X86_64_SPARSEMEM_H
+#define _ASM_X86_64_SPARSEMEM_H 1
+
+#ifdef CONFIG_SPARSEMEM
+
+/*
+ * generic non-linear memory support:
+ *
+ * 1) we will not split memory into more chunks than will fit into the flags
+ *    field of the struct page
+ *
+ * SECTION_SIZE_BITS		2^n: size of each section
+ * MAX_PHYSADDR_BITS		2^n: max size of physical address space
+ * MAX_PHYSMEM_BITS		2^n: how much memory we can have in that space
+ *
+ */
+
+#define SECTION_SIZE_BITS	27 /* matt - 128 is convenient right now */
+#define MAX_PHYSADDR_BITS	40
+#define MAX_PHYSMEM_BITS	40
+
+extern int early_pfn_to_nid(unsigned long pfn);
+
+#endif /* CONFIG_SPARSEMEM */
+
+#endif /* _ASM_X86_64_SPARSEMEM_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/spinlock.h linux-2.6.20-sabayon-r1/include/asm/spinlock.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/spinlock.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/spinlock.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,167 @@
+#ifndef __ASM_SPINLOCK_H
+#define __ASM_SPINLOCK_H
+
+#include <asm/atomic.h>
+#include <asm/rwlock.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+
+/*
+ * Your basic SMP spinlocks, allowing only a single CPU anywhere
+ *
+ * Simple spin lock operations.  There are two variants, one clears IRQ's
+ * on the local processor, one does not.
+ *
+ * We make no fairness assumptions. They have a cost.
+ *
+ * (the type definitions are in asm/spinlock_types.h)
+ */
+
+static inline int __raw_spin_is_locked(raw_spinlock_t *lock)
+{
+	return *(volatile signed int *)(&(lock)->slock) <= 0;
+}
+
+static inline void __raw_spin_lock(raw_spinlock_t *lock)
+{
+	asm volatile(
+		"\n1:\t"
+		LOCK_PREFIX " ; decl %0\n\t"
+		"jns 2f\n"
+		"3:\n"
+		"rep;nop\n\t"
+		"cmpl $0,%0\n\t"
+		"jle 3b\n\t"
+		"jmp 1b\n"
+		"2:\t" : "=m" (lock->slock) : : "memory");
+}
+
+/*
+ * Same as __raw_spin_lock, but reenable interrupts during spinning.
+ */
+#ifndef CONFIG_PROVE_LOCKING
+static inline void __raw_spin_lock_flags(raw_spinlock_t *lock, unsigned long flags)
+{
+	asm volatile(
+		"\n1:\t"
+		LOCK_PREFIX " ; decl %0\n\t"
+		"jns 5f\n"
+		"testl $0x200, %1\n\t"	/* interrupts were disabled? */
+		"jz 4f\n\t"
+	        "sti\n"
+		"3:\t"
+		"rep;nop\n\t"
+		"cmpl $0, %0\n\t"
+		"jle 3b\n\t"
+		"cli\n\t"
+		"jmp 1b\n"
+		"4:\t"
+		"rep;nop\n\t"
+		"cmpl $0, %0\n\t"
+		"jg 1b\n\t"
+		"jmp 4b\n"
+		"5:\n\t"
+		: "+m" (lock->slock) : "r" ((unsigned)flags) : "memory");
+}
+#endif
+
+static inline int __raw_spin_trylock(raw_spinlock_t *lock)
+{
+	int oldval;
+
+	asm volatile(
+		"xchgl %0,%1"
+		:"=q" (oldval), "=m" (lock->slock)
+		:"0" (0) : "memory");
+
+	return oldval > 0;
+}
+
+static inline void __raw_spin_unlock(raw_spinlock_t *lock)
+{
+	asm volatile("movl $1,%0" :"=m" (lock->slock) :: "memory");
+}
+
+static inline void __raw_spin_unlock_wait(raw_spinlock_t *lock)
+{
+	while (__raw_spin_is_locked(lock))
+		cpu_relax();
+}
+
+/*
+ * Read-write spinlocks, allowing multiple readers
+ * but only one writer.
+ *
+ * NOTE! it is quite common to have readers in interrupts
+ * but no interrupt writers. For those circumstances we
+ * can "mix" irq-safe locks - any writer needs to get a
+ * irq-safe write-lock, but readers can get non-irqsafe
+ * read-locks.
+ *
+ * On x86, we implement read-write locks as a 32-bit counter
+ * with the high bit (sign) being the "contended" bit.
+ */
+
+static inline int __raw_read_can_lock(raw_rwlock_t *lock)
+{
+	return (int)(lock)->lock > 0;
+}
+
+static inline int __raw_write_can_lock(raw_rwlock_t *lock)
+{
+	return (lock)->lock == RW_LOCK_BIAS;
+}
+
+static inline void __raw_read_lock(raw_rwlock_t *rw)
+{
+	asm volatile(LOCK_PREFIX "subl $1,(%0)\n\t"
+		     "jns 1f\n"
+		     "call __read_lock_failed\n"
+		     "1:\n"
+		     ::"D" (rw), "i" (RW_LOCK_BIAS) : "memory");
+}
+
+static inline void __raw_write_lock(raw_rwlock_t *rw)
+{
+	asm volatile(LOCK_PREFIX "subl %1,(%0)\n\t"
+		     "jz 1f\n"
+		     "\tcall __write_lock_failed\n\t"
+		     "1:\n"
+		     ::"D" (rw), "i" (RW_LOCK_BIAS) : "memory");
+}
+
+static inline int __raw_read_trylock(raw_rwlock_t *lock)
+{
+	atomic_t *count = (atomic_t *)lock;
+	atomic_dec(count);
+	if (atomic_read(count) >= 0)
+		return 1;
+	atomic_inc(count);
+	return 0;
+}
+
+static inline int __raw_write_trylock(raw_rwlock_t *lock)
+{
+	atomic_t *count = (atomic_t *)lock;
+	if (atomic_sub_and_test(RW_LOCK_BIAS, count))
+		return 1;
+	atomic_add(RW_LOCK_BIAS, count);
+	return 0;
+}
+
+static inline void __raw_read_unlock(raw_rwlock_t *rw)
+{
+	asm volatile(LOCK_PREFIX " ; incl %0" :"=m" (rw->lock) : : "memory");
+}
+
+static inline void __raw_write_unlock(raw_rwlock_t *rw)
+{
+	asm volatile(LOCK_PREFIX " ; addl $" RW_LOCK_BIAS_STR ",%0"
+				: "=m" (rw->lock) : : "memory");
+}
+
+#define _raw_spin_relax(lock)	cpu_relax()
+#define _raw_read_relax(lock)	cpu_relax()
+#define _raw_write_relax(lock)	cpu_relax()
+
+#endif /* __ASM_SPINLOCK_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/spinlock_types.h linux-2.6.20-sabayon-r1/include/asm/spinlock_types.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/spinlock_types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/spinlock_types.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef __ASM_SPINLOCK_TYPES_H
+#define __ASM_SPINLOCK_TYPES_H
+
+#ifndef __LINUX_SPINLOCK_TYPES_H
+# error "please don't include this file directly"
+#endif
+
+typedef struct {
+	unsigned int slock;
+} raw_spinlock_t;
+
+#define __RAW_SPIN_LOCK_UNLOCKED	{ 1 }
+
+typedef struct {
+	unsigned int lock;
+} raw_rwlock_t;
+
+#define __RAW_RW_LOCK_UNLOCKED		{ RW_LOCK_BIAS }
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/stacktrace.h linux-2.6.20-sabayon-r1/include/asm/stacktrace.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/stacktrace.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/stacktrace.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef _ASM_STACKTRACE_H
+#define _ASM_STACKTRACE_H 1
+
+extern int kstack_depth_to_print;
+
+/* Generic stack tracer with callbacks */
+
+struct stacktrace_ops {
+	void (*warning)(void *data, char *msg);
+	/* msg must contain %s for the symbol */
+	void (*warning_symbol)(void *data, char *msg, unsigned long symbol);
+	void (*address)(void *data, unsigned long address);
+	/* On negative return stop dumping */
+	int (*stack)(void *data, char *name);
+};
+
+void dump_trace(struct task_struct *tsk, struct pt_regs *regs, unsigned long *stack,
+		struct stacktrace_ops *ops, void *data);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/statfs.h linux-2.6.20-sabayon-r1/include/asm/statfs.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/statfs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/statfs.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,58 @@
+#ifndef _X86_64_STATFS_H
+#define _X86_64_STATFS_H
+
+#ifndef __KERNEL_STRICT_NAMES
+
+#include <linux/types.h>
+
+typedef __kernel_fsid_t	fsid_t;
+
+#endif
+
+/*
+ * This is ugly -- we're already 64-bit clean, so just duplicate the 
+ * definitions.
+ */
+struct statfs {
+	long f_type;
+	long f_bsize;
+	long f_blocks;
+	long f_bfree;
+	long f_bavail;
+	long f_files;
+	long f_ffree;
+	__kernel_fsid_t f_fsid;
+	long f_namelen;
+	long f_frsize;
+	long f_spare[5];
+};
+
+struct statfs64 {
+	long f_type;
+	long f_bsize;
+	long f_blocks;
+	long f_bfree;
+	long f_bavail;
+	long f_files;
+	long f_ffree;
+	__kernel_fsid_t f_fsid;
+	long f_namelen;
+	long f_frsize;
+	long f_spare[5];
+};
+
+struct compat_statfs64 {
+	__u32 f_type;
+	__u32 f_bsize;
+	__u64 f_blocks;
+	__u64 f_bfree;
+	__u64 f_bavail;
+	__u64 f_files;
+	__u64 f_ffree;
+	__kernel_fsid_t f_fsid;
+	__u32 f_namelen;
+	__u32 f_frsize;
+	__u32 f_spare[5];
+} __attribute__((packed));
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/stat.h linux-2.6.20-sabayon-r1/include/asm/stat.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/stat.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,44 @@
+#ifndef _ASM_X86_64_STAT_H
+#define _ASM_X86_64_STAT_H
+
+#define STAT_HAVE_NSEC 1
+
+struct stat {
+	unsigned long	st_dev;
+	unsigned long	st_ino;
+	unsigned long	st_nlink;
+
+	unsigned int	st_mode;
+	unsigned int	st_uid;
+	unsigned int	st_gid;
+	unsigned int	__pad0;
+	unsigned long	st_rdev;
+	long		st_size;
+	long		st_blksize;
+	long		st_blocks;	/* Number 512-byte blocks allocated. */
+
+	unsigned long	st_atime;
+	unsigned long 	st_atime_nsec; 
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+	unsigned long	st_ctime;
+	unsigned long   st_ctime_nsec;
+  	long		__unused[3];
+};
+
+/* For 32bit emulation */
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned int  st_size;
+	unsigned int  st_atime;
+	unsigned int  st_mtime;
+	unsigned int  st_ctime;
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/string.h linux-2.6.20-sabayon-r1/include/asm/string.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/string.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/string.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,57 @@
+#ifndef _X86_64_STRING_H_
+#define _X86_64_STRING_H_
+
+#ifdef __KERNEL__
+
+/* Written 2002 by Andi Kleen */ 
+
+/* Only used for special circumstances. Stolen from i386/string.h */ 
+static __always_inline void *
+__inline_memcpy(void * to, const void * from, size_t n)
+{
+unsigned long d0, d1, d2;
+__asm__ __volatile__(
+	"rep ; movsl\n\t"
+	"testb $2,%b4\n\t"
+	"je 1f\n\t"
+	"movsw\n"
+	"1:\ttestb $1,%b4\n\t"
+	"je 2f\n\t"
+	"movsb\n"
+	"2:"
+	: "=&c" (d0), "=&D" (d1), "=&S" (d2)
+	:"0" (n/4), "q" (n),"1" ((long) to),"2" ((long) from)
+	: "memory");
+return (to);
+}
+
+/* Even with __builtin_ the compiler may decide to use the out of line
+   function. */
+
+#define __HAVE_ARCH_MEMCPY 1
+extern void *__memcpy(void *to, const void *from, size_t len); 
+#define memcpy(dst,src,len) \
+	({ size_t __len = (len);				\
+	   void *__ret;						\
+	   if (__builtin_constant_p(len) && __len >= 64)	\
+		 __ret = __memcpy((dst),(src),__len);		\
+	   else							\
+		 __ret = __builtin_memcpy((dst),(src),__len);	\
+	   __ret; }) 
+
+
+#define __HAVE_ARCH_MEMSET
+void *memset(void *s, int c, size_t n);
+
+#define __HAVE_ARCH_MEMMOVE
+void * memmove(void * dest,const void *src,size_t count);
+
+int memcmp(const void * cs,const void * ct,size_t count);
+size_t strlen(const char * s);
+char *strcpy(char * dest,const char *src);
+char *strcat(char * dest, const char * src);
+int strcmp(const char * cs,const char * ct);
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/suspend.h linux-2.6.20-sabayon-r1/include/asm/suspend.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/suspend.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/suspend.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2001-2003 Pavel Machek <pavel@suse.cz>
+ * Based on code
+ * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+ */
+#include <asm/desc.h>
+#include <asm/i387.h>
+
+static inline int
+arch_prepare_suspend(void)
+{
+	return 0;
+}
+
+/* Image of the saved processor state. If you touch this, fix acpi_wakeup.S. */
+struct saved_context {
+  	u16 ds, es, fs, gs, ss;
+	unsigned long gs_base, gs_kernel_base, fs_base;
+	unsigned long cr0, cr2, cr3, cr4, cr8;
+	u16 gdt_pad;
+	u16 gdt_limit;
+	unsigned long gdt_base;
+	u16 idt_pad;
+	u16 idt_limit;
+	unsigned long idt_base;
+	u16 ldt;
+	u16 tss;
+	unsigned long tr;
+	unsigned long safety;
+	unsigned long return_address;
+	unsigned long eflags;
+} __attribute__((packed));
+
+/* We'll access these from assembly, so we'd better have them outside struct */
+extern unsigned long saved_context_eax, saved_context_ebx, saved_context_ecx, saved_context_edx;
+extern unsigned long saved_context_esp, saved_context_ebp, saved_context_esi, saved_context_edi;
+extern unsigned long saved_context_r08, saved_context_r09, saved_context_r10, saved_context_r11;
+extern unsigned long saved_context_r12, saved_context_r13, saved_context_r14, saved_context_r15;
+extern unsigned long saved_context_eflags;
+
+#define loaddebug(thread,register) \
+	set_debugreg((thread)->debugreg##register, register)
+
+extern void fix_processor_context(void);
+
+#ifdef CONFIG_ACPI_SLEEP
+extern unsigned long saved_eip;
+extern unsigned long saved_esp;
+extern unsigned long saved_ebp;
+extern unsigned long saved_ebx;
+extern unsigned long saved_esi;
+extern unsigned long saved_edi;
+
+/* routines for saving/restoring kernel state */
+extern int acpi_save_state_mem(void);
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/swiotlb.h linux-2.6.20-sabayon-r1/include/asm/swiotlb.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/swiotlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/swiotlb.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,55 @@
+#ifndef _ASM_SWIOTLB_H
+#define _ASM_SWTIOLB_H 1
+
+
+#include <asm/dma-mapping.h>
+
+/* SWIOTLB interface */
+
+extern dma_addr_t swiotlb_map_single(struct device *hwdev, void *ptr,
+				     size_t size, int dir);
+extern void *swiotlb_alloc_coherent(struct device *hwdev, size_t size,
+                       dma_addr_t *dma_handle, gfp_t flags);
+extern void swiotlb_unmap_single(struct device *hwdev, dma_addr_t dev_addr,
+				  size_t size, int dir);
+extern void swiotlb_sync_single_for_cpu(struct device *hwdev,
+					 dma_addr_t dev_addr,
+					 size_t size, int dir);
+extern void swiotlb_sync_single_for_device(struct device *hwdev,
+					    dma_addr_t dev_addr,
+					    size_t size, int dir);
+extern void swiotlb_sync_single_range_for_cpu(struct device *hwdev,
+					      dma_addr_t dev_addr,
+					      unsigned long offset,
+					      size_t size, int dir);
+extern void swiotlb_sync_single_range_for_device(struct device *hwdev,
+						 dma_addr_t dev_addr,
+						 unsigned long offset,
+						 size_t size, int dir);
+extern void swiotlb_sync_sg_for_cpu(struct device *hwdev,
+				     struct scatterlist *sg, int nelems,
+				     int dir);
+extern void swiotlb_sync_sg_for_device(struct device *hwdev,
+					struct scatterlist *sg, int nelems,
+					int dir);
+extern int swiotlb_map_sg(struct device *hwdev, struct scatterlist *sg,
+		      int nents, int direction);
+extern void swiotlb_unmap_sg(struct device *hwdev, struct scatterlist *sg,
+			 int nents, int direction);
+extern int swiotlb_dma_mapping_error(dma_addr_t dma_addr);
+extern void swiotlb_free_coherent (struct device *hwdev, size_t size,
+				   void *vaddr, dma_addr_t dma_handle);
+extern int swiotlb_dma_supported(struct device *hwdev, u64 mask);
+extern void swiotlb_init(void);
+
+extern int swiotlb_force;
+
+#ifdef CONFIG_SWIOTLB
+extern int swiotlb;
+#else
+#define swiotlb 0
+#endif
+
+extern void pci_swiotlb_init(void);
+
+#endif /* _ASM_SWTIOLB_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/system.h linux-2.6.20-sabayon-r1/include/asm/system.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/system.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/system.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,254 @@
+#ifndef __ASM_SYSTEM_H
+#define __ASM_SYSTEM_H
+
+#include <linux/kernel.h>
+#include <asm/segment.h>
+#include <asm/alternative.h>
+
+#ifdef __KERNEL__
+
+#define __STR(x) #x
+#define STR(x) __STR(x)
+
+#define __SAVE(reg,offset) "movq %%" #reg ",(14-" #offset ")*8(%%rsp)\n\t"
+#define __RESTORE(reg,offset) "movq (14-" #offset ")*8(%%rsp),%%" #reg "\n\t"
+
+/* frame pointer must be last for get_wchan */
+#define SAVE_CONTEXT    "pushf ; pushq %%rbp ; movq %%rsi,%%rbp\n\t"
+#define RESTORE_CONTEXT "movq %%rbp,%%rsi ; popq %%rbp ; popf\t"
+
+#define __EXTRA_CLOBBER  \
+	,"rcx","rbx","rdx","r8","r9","r10","r11","r12","r13","r14","r15"
+
+/* Save restore flags to clear handle leaking NT */
+#define switch_to(prev,next,last) \
+	asm volatile(SAVE_CONTEXT						    \
+		     "movq %%rsp,%P[threadrsp](%[prev])\n\t" /* save RSP */	  \
+		     "movq %P[threadrsp](%[next]),%%rsp\n\t" /* restore RSP */	  \
+		     "call __switch_to\n\t"					  \
+		     ".globl thread_return\n"					\
+		     "thread_return:\n\t"					    \
+		     "movq %%gs:%P[pda_pcurrent],%%rsi\n\t"			  \
+		     "movq %P[thread_info](%%rsi),%%r8\n\t"			  \
+		     LOCK_PREFIX "btr  %[tif_fork],%P[ti_flags](%%r8)\n\t"	  \
+		     "movq %%rax,%%rdi\n\t" 					  \
+		     "jc   ret_from_fork\n\t"					  \
+		     RESTORE_CONTEXT						    \
+		     : "=a" (last)					  	  \
+		     : [next] "S" (next), [prev] "D" (prev),			  \
+		       [threadrsp] "i" (offsetof(struct task_struct, thread.rsp)), \
+		       [ti_flags] "i" (offsetof(struct thread_info, flags)),\
+		       [tif_fork] "i" (TIF_FORK),			  \
+		       [thread_info] "i" (offsetof(struct task_struct, thread_info)), \
+		       [pda_pcurrent] "i" (offsetof(struct x8664_pda, pcurrent))   \
+		     : "memory", "cc" __EXTRA_CLOBBER)
+    
+extern void load_gs_index(unsigned); 
+
+/*
+ * Load a segment. Fall back on loading the zero
+ * segment if something goes wrong..
+ */
+#define loadsegment(seg,value)	\
+	asm volatile("\n"			\
+		"1:\t"				\
+		"movl %k0,%%" #seg "\n"		\
+		"2:\n"				\
+		".section .fixup,\"ax\"\n"	\
+		"3:\t"				\
+		"movl %1,%%" #seg "\n\t" 	\
+		"jmp 2b\n"			\
+		".previous\n"			\
+		".section __ex_table,\"a\"\n\t"	\
+		".align 8\n\t"			\
+		".quad 1b,3b\n"			\
+		".previous"			\
+		: :"r" (value), "r" (0))
+
+/*
+ * Clear and set 'TS' bit respectively
+ */
+#define clts() __asm__ __volatile__ ("clts")
+
+static inline unsigned long read_cr0(void)
+{ 
+	unsigned long cr0;
+	asm volatile("movq %%cr0,%0" : "=r" (cr0));
+	return cr0;
+} 
+
+static inline void write_cr0(unsigned long val) 
+{ 
+	asm volatile("movq %0,%%cr0" :: "r" (val));
+} 
+
+static inline unsigned long read_cr3(void)
+{ 
+	unsigned long cr3;
+	asm("movq %%cr3,%0" : "=r" (cr3));
+	return cr3;
+} 
+
+static inline unsigned long read_cr4(void)
+{ 
+	unsigned long cr4;
+	asm("movq %%cr4,%0" : "=r" (cr4));
+	return cr4;
+} 
+
+static inline void write_cr4(unsigned long val)
+{ 
+	asm volatile("movq %0,%%cr4" :: "r" (val));
+} 
+
+#define stts() write_cr0(8 | read_cr0())
+
+#define wbinvd() \
+	__asm__ __volatile__ ("wbinvd": : :"memory");
+
+/*
+ * On SMP systems, when the scheduler does migration-cost autodetection,
+ * it needs a way to flush as much of the CPU's caches as possible.
+ */
+static inline void sched_cacheflush(void)
+{
+	wbinvd();
+}
+
+#endif	/* __KERNEL__ */
+
+#define nop() __asm__ __volatile__ ("nop")
+
+#define xchg(ptr,v) ((__typeof__(*(ptr)))__xchg((unsigned long)(v),(ptr),sizeof(*(ptr))))
+
+#define tas(ptr) (xchg((ptr),1))
+
+#define __xg(x) ((volatile long *)(x))
+
+static inline void set_64bit(volatile unsigned long *ptr, unsigned long val)
+{
+	*ptr = val;
+}
+
+#define _set_64bit set_64bit
+
+/*
+ * Note: no "lock" prefix even on SMP: xchg always implies lock anyway
+ * Note 2: xchg has side effect, so that attribute volatile is necessary,
+ *	  but generally the primitive is invalid, *ptr is output argument. --ANK
+ */
+static inline unsigned long __xchg(unsigned long x, volatile void * ptr, int size)
+{
+	switch (size) {
+		case 1:
+			__asm__ __volatile__("xchgb %b0,%1"
+				:"=q" (x)
+				:"m" (*__xg(ptr)), "0" (x)
+				:"memory");
+			break;
+		case 2:
+			__asm__ __volatile__("xchgw %w0,%1"
+				:"=r" (x)
+				:"m" (*__xg(ptr)), "0" (x)
+				:"memory");
+			break;
+		case 4:
+			__asm__ __volatile__("xchgl %k0,%1"
+				:"=r" (x)
+				:"m" (*__xg(ptr)), "0" (x)
+				:"memory");
+			break;
+		case 8:
+			__asm__ __volatile__("xchgq %0,%1"
+				:"=r" (x)
+				:"m" (*__xg(ptr)), "0" (x)
+				:"memory");
+			break;
+	}
+	return x;
+}
+
+/*
+ * Atomic compare and exchange.  Compare OLD with MEM, if identical,
+ * store NEW in MEM.  Return the initial value in MEM.  Success is
+ * indicated by comparing RETURN with OLD.
+ */
+
+#define __HAVE_ARCH_CMPXCHG 1
+
+static inline unsigned long __cmpxchg(volatile void *ptr, unsigned long old,
+				      unsigned long new, int size)
+{
+	unsigned long prev;
+	switch (size) {
+	case 1:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgb %b1,%2"
+				     : "=a"(prev)
+				     : "q"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	case 2:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgw %w1,%2"
+				     : "=a"(prev)
+				     : "r"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	case 4:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgl %k1,%2"
+				     : "=a"(prev)
+				     : "r"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	case 8:
+		__asm__ __volatile__(LOCK_PREFIX "cmpxchgq %1,%2"
+				     : "=a"(prev)
+				     : "r"(new), "m"(*__xg(ptr)), "0"(old)
+				     : "memory");
+		return prev;
+	}
+	return old;
+}
+
+#define cmpxchg(ptr,o,n)\
+	((__typeof__(*(ptr)))__cmpxchg((ptr),(unsigned long)(o),\
+					(unsigned long)(n),sizeof(*(ptr))))
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	do {} while(0)
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#define smp_read_barrier_depends()	do {} while(0)
+#endif
+
+    
+/*
+ * Force strict CPU ordering.
+ * And yes, this is required on UP too when we're talking
+ * to devices.
+ */
+#define mb() 	asm volatile("mfence":::"memory")
+#define rmb()	asm volatile("lfence":::"memory")
+
+#ifdef CONFIG_UNORDERED_IO
+#define wmb()	asm volatile("sfence" ::: "memory")
+#else
+#define wmb()	asm volatile("" ::: "memory")
+#endif
+#define read_barrier_depends()	do {} while(0)
+#define set_mb(var, value) do { (void) xchg(&var, value); } while (0)
+
+#define warn_if_not_ulong(x) do { unsigned long foo; (void) (&(x) == &foo); } while (0)
+
+#include <linux/irqflags.h>
+
+void cpu_idle_wait(void);
+
+extern unsigned long arch_align_stack(unsigned long sp);
+extern void free_init_pages(char *what, unsigned long begin, unsigned long end);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/tce.h linux-2.6.20-sabayon-r1/include/asm/tce.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/tce.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/tce.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * This file is derived from asm-powerpc/tce.h.
+ *
+ * Copyright (C) IBM Corporation, 2006
+ *
+ * Author: Muli Ben-Yehuda <muli@il.ibm.com>
+ * Author: Jon Mason <jdmason@us.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+#ifndef _ASM_X86_64_TCE_H
+#define _ASM_X86_64_TCE_H
+
+extern unsigned int specified_table_size;
+struct iommu_table;
+
+#define TCE_ENTRY_SIZE   8   /* in bytes */
+
+#define TCE_READ_SHIFT   0
+#define TCE_WRITE_SHIFT  1
+#define TCE_HUBID_SHIFT  2   /* unused */
+#define TCE_RSVD_SHIFT   8   /* unused */
+#define TCE_RPN_SHIFT    12
+#define TCE_UNUSED_SHIFT 48  /* unused */
+
+#define TCE_RPN_MASK     0x0000fffffffff000ULL
+
+extern void tce_build(struct iommu_table *tbl, unsigned long index,
+        unsigned int npages, unsigned long uaddr, int direction);
+extern void tce_free(struct iommu_table *tbl, long index, unsigned int npages);
+extern void* alloc_tce_table(void);
+extern void free_tce_table(void *tbl);
+extern int build_tce_table(struct pci_dev *dev, void __iomem *bbar);
+
+#endif /* _ASM_X86_64_TCE_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/termbits.h linux-2.6.20-sabayon-r1/include/asm/termbits.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/termbits.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/termbits.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,198 @@
+#ifndef __ARCH_X8664_TERMBITS_H__
+#define __ARCH_X8664_TERMBITS_H__
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+struct termios2 {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+struct ktermios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+	speed_t c_ispeed;		/* input speed */
+	speed_t c_ospeed;		/* output speed */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8	0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define	   BOTHER 0010000		/* non standard rate */
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+#define IBSHIFT	  8		/* Shift from CBAUD to CIBAUD */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/termios.h linux-2.6.20-sabayon-r1/include/asm/termios.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/termios.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,108 @@
+#ifndef _X8664_TERMIOS_H
+#define _X8664_TERMIOS_H
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async */
+#define N_6PACK		7
+#define N_MASC		8	/* Reserved for Mobitex module <kaz@cafe.net> */
+#define N_R3964		9	/* Reserved for Simatic R3964 module */
+#define N_PROFIBUS_FDL	10	/* Reserved for Profibus <Dave@mvhi.com> */
+#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
+#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
+#define N_HDLC		13	/* synchronous HDLC */
+#define N_SYNC_PPP	14	/* synchronous PPP */
+#define N_HCI		15  /* Bluetooth HCI UART */
+
+#ifdef __KERNEL__
+
+/*	intr=^C		quit=^\		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define SET_LOW_TERMIOS_BITS(termios, termio, x) { \
+	unsigned short __tmp; \
+	get_user(__tmp,&(termio)->x); \
+	*(unsigned short *) &(termios)->x = __tmp; \
+}
+
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios2))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios2))
+#define user_termios_to_kernel_termios_1(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios_1(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _X8664_TERMIOS_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/therm_throt.h linux-2.6.20-sabayon-r1/include/asm/therm_throt.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/therm_throt.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/therm_throt.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1 @@
+#include <asm-i386/therm_throt.h>
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/thread_info.h linux-2.6.20-sabayon-r1/include/asm/thread_info.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/thread_info.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/thread_info.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,169 @@
+/* thread_info.h: x86_64 low-level thread information
+ *
+ * Copyright (C) 2002  David Howells (dhowells@redhat.com)
+ * - Incorporating suggestions made by Linus Torvalds and Dave Miller
+ */
+
+#ifndef _ASM_THREAD_INFO_H
+#define _ASM_THREAD_INFO_H
+
+#ifdef __KERNEL__
+
+#include <asm/page.h>
+#include <asm/types.h>
+#include <asm/pda.h>
+
+/*
+ * low level task data that entry.S needs immediate access to
+ * - this struct should fit entirely inside of one cache line
+ * - this struct shares the supervisor stack pages
+ */
+#ifndef __ASSEMBLY__
+struct task_struct;
+struct exec_domain;
+#include <asm/mmsegment.h>
+
+struct thread_info {
+	struct task_struct	*task;		/* main task structure */
+	struct exec_domain	*exec_domain;	/* execution domain */
+	__u32			flags;		/* low level flags */
+	__u32			status;		/* thread synchronous flags */
+	__u32			cpu;		/* current CPU */
+	int 			preempt_count;	/* 0 => preemptable, <0 => BUG */
+
+	mm_segment_t		addr_limit;	
+	struct restart_block    restart_block;
+};
+#endif
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ * preempt_count needs to be 1 initially, until the scheduler is functional.
+ */
+#ifndef __ASSEMBLY__
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task	       = &tsk,			\
+	.exec_domain   = &default_exec_domain,	\
+	.flags	       = 0,			\
+	.cpu	       = 0,			\
+	.preempt_count = 1,			\
+	.addr_limit     = KERNEL_DS,		\
+	.restart_block = {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+static inline struct thread_info *current_thread_info(void)
+{ 
+	struct thread_info *ti;
+	ti = (void *)(read_pda(kernelstack) + PDA_STACKOFFSET - THREAD_SIZE);
+	return ti; 
+}
+
+/* do not use in interrupt context */
+static inline struct thread_info *stack_thread_info(void)
+{
+	struct thread_info *ti;
+	__asm__("andq %%rsp,%0; ":"=r" (ti) : "0" (~(THREAD_SIZE - 1)));
+	return ti;
+}
+
+/* thread information allocation */
+#ifdef CONFIG_DEBUG_STACK_USAGE
+#define alloc_thread_info(tsk)					\
+    ({								\
+	struct thread_info *ret;				\
+								\
+	ret = ((struct thread_info *) __get_free_pages(GFP_KERNEL,THREAD_ORDER)); \
+	if (ret)						\
+		memset(ret, 0, THREAD_SIZE);			\
+	ret;							\
+    })
+#else
+#define alloc_thread_info(tsk) \
+	((struct thread_info *) __get_free_pages(GFP_KERNEL,THREAD_ORDER))
+#endif
+
+#define free_thread_info(ti) free_pages((unsigned long) (ti), THREAD_ORDER)
+
+#else /* !__ASSEMBLY__ */
+
+/* how to get the thread information struct from ASM */
+#define GET_THREAD_INFO(reg) \
+	movq %gs:pda_kernelstack,reg ; \
+	subq $(THREAD_SIZE-PDA_STACKOFFSET),reg
+
+#endif
+
+/*
+ * thread information flags
+ * - these are process state flags that various assembly files may need to access
+ * - pending work-to-be-done flags are in LSW
+ * - other flags in MSW
+ * Warning: layout of LSW is hardcoded in entry.S
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
+#define TIF_SIGPENDING		2	/* signal pending */
+#define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_SINGLESTEP		4	/* reenable singlestep on user return*/
+#define TIF_IRET		5	/* force IRET */
+#define TIF_SYSCALL_AUDIT	7	/* syscall auditing active */
+#define TIF_SECCOMP		8	/* secure computing */
+#define TIF_RESTORE_SIGMASK	9	/* restore signal mask in do_signal */
+/* 16 free */
+#define TIF_IA32		17	/* 32bit process */ 
+#define TIF_FORK		18	/* ret_from_fork */
+#define TIF_ABI_PENDING		19
+#define TIF_MEMDIE		20
+#define TIF_DEBUG		21	/* uses debug registers */
+#define TIF_IO_BITMAP		22	/* uses I/O bitmap */
+#define TIF_FREEZE		23	/* is freezing for suspend */
+
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_IRET		(1<<TIF_IRET)
+#define _TIF_SYSCALL_AUDIT	(1<<TIF_SYSCALL_AUDIT)
+#define _TIF_SECCOMP		(1<<TIF_SECCOMP)
+#define _TIF_RESTORE_SIGMASK	(1<<TIF_RESTORE_SIGMASK)
+#define _TIF_IA32		(1<<TIF_IA32)
+#define _TIF_FORK		(1<<TIF_FORK)
+#define _TIF_ABI_PENDING	(1<<TIF_ABI_PENDING)
+#define _TIF_DEBUG		(1<<TIF_DEBUG)
+#define _TIF_IO_BITMAP		(1<<TIF_IO_BITMAP)
+#define _TIF_FREEZE		(1<<TIF_FREEZE)
+
+/* work to do on interrupt/exception return */
+#define _TIF_WORK_MASK \
+  (0x0000FFFF & ~(_TIF_SYSCALL_TRACE|_TIF_SYSCALL_AUDIT|_TIF_SINGLESTEP|_TIF_SECCOMP))
+/* work to do on any return to user space */
+#define _TIF_ALLWORK_MASK (0x0000FFFF & ~_TIF_SECCOMP)
+
+/* flags to check in __switch_to() */
+#define _TIF_WORK_CTXSW (_TIF_DEBUG|_TIF_IO_BITMAP)
+
+#define PREEMPT_ACTIVE     0x10000000
+
+/*
+ * Thread-synchronous status.
+ *
+ * This is different from the flags in that nobody else
+ * ever touches our thread-synchronous status, so we don't
+ * have to worry about atomic accesses.
+ */
+#define TS_USEDFPU		0x0001	/* FPU was used by this task this quantum (SMP) */
+#define TS_COMPAT		0x0002	/* 32bit syscall active */
+#define TS_POLLING		0x0004	/* true if in idle loop and not sleeping */
+
+#define tsk_is_polling(t) ((t)->thread_info->status & TS_POLLING)
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_THREAD_INFO_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/timex.h linux-2.6.20-sabayon-r1/include/asm/timex.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/timex.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/timex.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,49 @@
+/*
+ * linux/include/asm-x86_64/timex.h
+ *
+ * x86-64 architecture timex specifications
+ */
+#ifndef _ASMx8664_TIMEX_H
+#define _ASMx8664_TIMEX_H
+
+#include <asm/8253pit.h>
+#include <asm/msr.h>
+#include <asm/vsyscall.h>
+#include <asm/hpet.h>
+#include <asm/system.h>
+#include <asm/processor.h>
+#include <linux/compiler.h>
+
+#define CLOCK_TICK_RATE	PIT_TICK_RATE	/* Underlying HZ */
+
+typedef unsigned long long cycles_t;
+
+static inline cycles_t get_cycles (void)
+{
+	unsigned long long ret;
+
+	rdtscll(ret);
+	return ret;
+}
+
+/* Like get_cycles, but make sure the CPU is synchronized. */
+static __always_inline cycles_t get_cycles_sync(void)
+{
+	unsigned long long ret;
+	unsigned eax;
+	/* Don't do an additional sync on CPUs where we know
+	   RDTSC is already synchronous. */
+	alternative_io("cpuid", ASM_NOP2, X86_FEATURE_SYNC_RDTSC,
+			  "=a" (eax), "0" (1) : "ebx","ecx","edx","memory");
+	rdtscll(ret);
+	return ret;
+}
+
+extern unsigned int cpu_khz;
+
+extern int read_current_timer(unsigned long *timer_value);
+#define ARCH_HAS_READ_CURRENT_TIMER	1
+
+extern struct vxtime_data vxtime;
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/tlbflush.h linux-2.6.20-sabayon-r1/include/asm/tlbflush.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/tlbflush.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/tlbflush.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,127 @@
+#ifndef _X8664_TLBFLUSH_H
+#define _X8664_TLBFLUSH_H
+
+#include <linux/mm.h>
+#include <asm/processor.h>
+
+static inline unsigned long get_cr3(void)
+{
+	unsigned long cr3;
+	asm volatile("mov %%cr3,%0" : "=r" (cr3));
+	return cr3;
+}
+
+static inline void set_cr3(unsigned long cr3)
+{
+	asm volatile("mov %0,%%cr3" :: "r" (cr3) : "memory");
+}
+
+static inline void __flush_tlb(void)
+{
+	set_cr3(get_cr3());
+}
+
+static inline unsigned long get_cr4(void)
+{
+	unsigned long cr4;
+	asm volatile("mov %%cr4,%0" : "=r" (cr4));
+	return cr4;
+}
+
+static inline void set_cr4(unsigned long cr4)
+{
+	asm volatile("mov %0,%%cr4" :: "r" (cr4) : "memory");
+}
+
+static inline void __flush_tlb_all(void)
+{
+	unsigned long cr4 = get_cr4();
+	set_cr4(cr4 & ~X86_CR4_PGE);	/* clear PGE */
+	set_cr4(cr4);			/* write old PGE again and flush TLBs */
+}
+
+#define __flush_tlb_one(addr) \
+	__asm__ __volatile__("invlpg (%0)" :: "r" (addr) : "memory")
+
+
+/*
+ * TLB flushing:
+ *
+ *  - flush_tlb() flushes the current mm struct TLBs
+ *  - flush_tlb_all() flushes all processes TLBs
+ *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
+ *  - flush_tlb_page(vma, vmaddr) flushes one page
+ *  - flush_tlb_range(vma, start, end) flushes a range of pages
+ *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
+ *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
+ *
+ * x86-64 can only flush individual pages or full VMs. For a range flush
+ * we always do the full VM. Might be worth trying if for a small
+ * range a few INVLPGs in a row are a win.
+ */
+
+#ifndef CONFIG_SMP
+
+#define flush_tlb() __flush_tlb()
+#define flush_tlb_all() __flush_tlb_all()
+#define local_flush_tlb() __flush_tlb()
+
+static inline void flush_tlb_mm(struct mm_struct *mm)
+{
+	if (mm == current->active_mm)
+		__flush_tlb();
+}
+
+static inline void flush_tlb_page(struct vm_area_struct *vma,
+	unsigned long addr)
+{
+	if (vma->vm_mm == current->active_mm)
+		__flush_tlb_one(addr);
+}
+
+static inline void flush_tlb_range(struct vm_area_struct *vma,
+	unsigned long start, unsigned long end)
+{
+	if (vma->vm_mm == current->active_mm)
+		__flush_tlb();
+}
+
+#else
+
+#include <asm/smp.h>
+
+#define local_flush_tlb() \
+	__flush_tlb()
+
+extern void flush_tlb_all(void);
+extern void flush_tlb_current_task(void);
+extern void flush_tlb_mm(struct mm_struct *);
+extern void flush_tlb_page(struct vm_area_struct *, unsigned long);
+
+#define flush_tlb()	flush_tlb_current_task()
+
+static inline void flush_tlb_range(struct vm_area_struct * vma, unsigned long start, unsigned long end)
+{
+	flush_tlb_mm(vma->vm_mm);
+}
+
+#define TLBSTATE_OK	1
+#define TLBSTATE_LAZY	2
+
+/* Roughly an IPI every 20MB with 4k pages for freeing page table
+   ranges. Cost is about 42k of memory for each CPU. */
+#define ARCH_FREE_PTE_NR 5350	
+
+#endif
+
+#define flush_tlb_kernel_range(start, end) flush_tlb_all()
+
+static inline void flush_tlb_pgtables(struct mm_struct *mm,
+				      unsigned long start, unsigned long end)
+{
+	/* x86_64 does not keep any page table caches in a software TLB.
+	   The CPUs do in their hardware TLBs, but they are handled
+	   by the normal TLB flushing algorithms. */
+}
+
+#endif /* _X8664_TLBFLUSH_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/tlb.h linux-2.6.20-sabayon-r1/include/asm/tlb.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/tlb.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/tlb.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,13 @@
+#ifndef TLB_H
+#define TLB_H 1
+
+
+#define tlb_start_vma(tlb, vma) do { } while (0)
+#define tlb_end_vma(tlb, vma) do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, ptep, address) do { } while (0)
+
+#define tlb_flush(tlb) flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/topology.h linux-2.6.20-sabayon-r1/include/asm/topology.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/topology.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/topology.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,72 @@
+#ifndef _ASM_X86_64_TOPOLOGY_H
+#define _ASM_X86_64_TOPOLOGY_H
+
+
+#ifdef CONFIG_NUMA
+
+#include <asm/mpspec.h>
+#include <asm/bitops.h>
+
+extern cpumask_t cpu_online_map;
+
+extern unsigned char cpu_to_node[];
+extern cpumask_t     node_to_cpumask[];
+
+#ifdef CONFIG_ACPI_NUMA
+extern int __node_distance(int, int);
+#define node_distance(a,b) __node_distance(a,b)
+/* #else fallback version */
+#endif
+
+#define cpu_to_node(cpu)		(cpu_to_node[cpu])
+#define parent_node(node)		(node)
+#define node_to_first_cpu(node) 	(first_cpu(node_to_cpumask[node]))
+#define node_to_cpumask(node)		(node_to_cpumask[node])
+#define pcibus_to_node(bus)		((long)(bus->sysdata))	
+#define pcibus_to_cpumask(bus)		node_to_cpumask(pcibus_to_node(bus));
+
+#define numa_node_id()			read_pda(nodenumber)
+
+/* sched_domains SD_NODE_INIT for x86_64 machines */
+#define SD_NODE_INIT (struct sched_domain) {		\
+	.span			= CPU_MASK_NONE,	\
+	.parent			= NULL,			\
+	.child			= NULL,			\
+	.groups			= NULL,			\
+	.min_interval		= 8,			\
+	.max_interval		= 32,			\
+	.busy_factor		= 32,			\
+	.imbalance_pct		= 125,			\
+	.cache_nice_tries	= 2,			\
+	.busy_idx		= 3,			\
+	.idle_idx		= 2,			\
+	.newidle_idx		= 0, 			\
+	.wake_idx		= 1,			\
+	.forkexec_idx		= 1,			\
+	.per_cpu_gain		= 100,			\
+	.flags			= SD_LOAD_BALANCE	\
+				| SD_BALANCE_FORK	\
+				| SD_BALANCE_EXEC	\
+				| SD_SERIALIZE		\
+				| SD_WAKE_BALANCE,	\
+	.last_balance		= jiffies,		\
+	.balance_interval	= 1,			\
+	.nr_balance_failed	= 0,			\
+}
+
+#endif
+
+#ifdef CONFIG_SMP
+#define topology_physical_package_id(cpu)	(cpu_data[cpu].phys_proc_id)
+#define topology_core_id(cpu)			(cpu_data[cpu].cpu_core_id)
+#define topology_core_siblings(cpu)		(cpu_core_map[cpu])
+#define topology_thread_siblings(cpu)		(cpu_sibling_map[cpu])
+#define mc_capable()			(boot_cpu_data.x86_max_cores > 1)
+#define smt_capable() 			(smp_num_siblings > 1)
+#endif
+
+#include <asm-generic/topology.h>
+
+extern cpumask_t cpu_coregroup_map(int cpu);
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/types.h linux-2.6.20-sabayon-r1/include/asm/types.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/types.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,55 @@
+#ifndef _X86_64_TYPES_H
+#define _X86_64_TYPES_H
+
+#ifndef __ASSEMBLY__
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+typedef __signed__ long long __s64;
+typedef unsigned long long  __u64;
+
+#endif /* __ASSEMBLY__ */
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+#define BITS_PER_LONG 64
+
+#ifndef __ASSEMBLY__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+typedef u64 dma64_addr_t;
+typedef u64 dma_addr_t;
+
+#endif /* __ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/uaccess.h linux-2.6.20-sabayon-r1/include/asm/uaccess.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/uaccess.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/uaccess.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,370 @@
+#ifndef __X86_64_UACCESS_H
+#define __X86_64_UACCESS_H
+
+/*
+ * User space memory access functions
+ */
+#include <linux/compiler.h>
+#include <linux/errno.h>
+#include <linux/prefetch.h>
+#include <asm/page.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons, these macros are grossly misnamed.
+ */
+
+#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
+
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFFFFFFFFFFUL)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+
+#define get_ds()	(KERNEL_DS)
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#define __addr_ok(addr) (!((unsigned long)(addr) & (current_thread_info()->addr_limit.seg)))
+
+/*
+ * Uhhuh, this needs 65-bit arithmetic. We have a carry..
+ */
+#define __range_not_ok(addr,size) ({ \
+	unsigned long flag,sum; \
+	__chk_user_ptr(addr); \
+	asm("# range_ok\n\r" \
+		"addq %3,%1 ; sbbq %0,%0 ; cmpq %1,%4 ; sbbq $0,%0"  \
+		:"=&r" (flag), "=r" (sum) \
+		:"1" (addr),"g" ((long)(size)),"g" (current_thread_info()->addr_limit.seg)); \
+	flag; })
+
+#define access_ok(type, addr, size) (__range_not_ok(addr,size) == 0)
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+#define ARCH_HAS_SEARCH_EXTABLE
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ *
+ * This gets kind of ugly. We want to return _two_ values in "get_user()"
+ * and yet we don't want to do any pointers, because that is too much
+ * of a performance impact. Thus we have a few rather ugly macros here,
+ * and hide all the ugliness from the user.
+ *
+ * The "__xxx" versions of the user access functions are versions that
+ * do not verify the address space, that must have been done previously
+ * with a separate "access_ok()" call (this is used when we do multiple
+ * accesses to the same area of user memory).
+ */
+
+#define __get_user_x(size,ret,x,ptr) \
+	asm volatile("call __get_user_" #size \
+		:"=a" (ret),"=d" (x) \
+		:"c" (ptr) \
+		:"r8")
+
+/* Careful: we have to cast the result to the type of the pointer for sign reasons */
+#define get_user(x,ptr)							\
+({	unsigned long __val_gu;						\
+	int __ret_gu; 							\
+	__chk_user_ptr(ptr);						\
+	switch(sizeof (*(ptr))) {					\
+	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
+	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
+	case 4:  __get_user_x(4,__ret_gu,__val_gu,ptr); break;		\
+	case 8:  __get_user_x(8,__ret_gu,__val_gu,ptr); break;		\
+	default: __get_user_bad(); break;				\
+	}								\
+	(x) = (typeof(*(ptr)))__val_gu;				\
+	__ret_gu;							\
+})
+
+extern void __put_user_1(void);
+extern void __put_user_2(void);
+extern void __put_user_4(void);
+extern void __put_user_8(void);
+extern void __put_user_bad(void);
+
+#define __put_user_x(size,ret,x,ptr)					\
+	asm volatile("call __put_user_" #size			\
+		:"=a" (ret)						\
+		:"c" (ptr),"d" (x)					\
+		:"r8")
+
+#define put_user(x,ptr)							\
+  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+#define __get_user(x,ptr) \
+  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))
+#define __put_user(x,ptr) \
+  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+#define __get_user_unaligned __get_user
+#define __put_user_unaligned __put_user
+
+#define __put_user_nocheck(x,ptr,size)			\
+({							\
+	int __pu_err;					\
+	__put_user_size((x),(ptr),(size),__pu_err);	\
+	__pu_err;					\
+})
+
+
+#define __put_user_check(x,ptr,size)			\
+({							\
+	int __pu_err;					\
+	typeof(*(ptr)) __user *__pu_addr = (ptr);	\
+	switch (size) { 				\
+	case 1: __put_user_x(1,__pu_err,x,__pu_addr); break;	\
+	case 2: __put_user_x(2,__pu_err,x,__pu_addr); break;	\
+	case 4: __put_user_x(4,__pu_err,x,__pu_addr); break;	\
+	case 8: __put_user_x(8,__pu_err,x,__pu_addr); break;	\
+	default: __put_user_bad();			\
+	}						\
+	__pu_err;					\
+})
+
+#define __put_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __put_user_asm(x,ptr,retval,"b","b","iq",-EFAULT); break;\
+	  case 2: __put_user_asm(x,ptr,retval,"w","w","ir",-EFAULT); break;\
+	  case 4: __put_user_asm(x,ptr,retval,"l","k","ir",-EFAULT); break;\
+	  case 8: __put_user_asm(x,ptr,retval,"q","","Zr",-EFAULT); break;\
+	  default: __put_user_bad();					\
+	}								\
+} while (0)
+
+/* FIXME: this hack is definitely wrong -AK */
+struct __large_struct { unsigned long buf[100]; };
+#define __m(x) (*(struct __large_struct __user *)(x))
+
+/*
+ * Tell gcc we read from memory instead of writing: this is because
+ * we do not write to any memory gcc knows about, so there are no
+ * aliasing issues.
+ */
+#define __put_user_asm(x, addr, err, itype, rtype, ltype, errno)	\
+	asm volatile(					\
+		"1:	mov"itype" %"rtype"1,%2\n"		\
+		"2:\n"						\
+		".section .fixup,\"ax\"\n"			\
+		"3:	mov %3,%0\n"				\
+		"	jmp 2b\n"				\
+		".previous\n"					\
+		".section __ex_table,\"a\"\n"			\
+		"	.align 8\n"				\
+		"	.quad 1b,3b\n"				\
+		".previous"					\
+		: "=r"(err)					\
+		: ltype (x), "m"(__m(addr)), "i"(errno), "0"(err))
+
+
+#define __get_user_nocheck(x,ptr,size)				\
+({								\
+	int __gu_err;						\
+	unsigned long __gu_val;					\
+	__get_user_size(__gu_val,(ptr),(size),__gu_err);	\
+	(x) = (typeof(*(ptr)))__gu_val;			\
+	__gu_err;						\
+})
+
+extern int __get_user_1(void);
+extern int __get_user_2(void);
+extern int __get_user_4(void);
+extern int __get_user_8(void);
+extern int __get_user_bad(void);
+
+#define __get_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __get_user_asm(x,ptr,retval,"b","b","=q",-EFAULT); break;\
+	  case 2: __get_user_asm(x,ptr,retval,"w","w","=r",-EFAULT); break;\
+	  case 4: __get_user_asm(x,ptr,retval,"l","k","=r",-EFAULT); break;\
+	  case 8: __get_user_asm(x,ptr,retval,"q","","=r",-EFAULT); break;\
+	  default: (x) = __get_user_bad();				\
+	}								\
+} while (0)
+
+#define __get_user_asm(x, addr, err, itype, rtype, ltype, errno)	\
+	asm volatile(					\
+		"1:	mov"itype" %2,%"rtype"1\n"		\
+		"2:\n"						\
+		".section .fixup,\"ax\"\n"			\
+		"3:	mov %3,%0\n"				\
+		"	xor"itype" %"rtype"1,%"rtype"1\n"	\
+		"	jmp 2b\n"				\
+		".previous\n"					\
+		".section __ex_table,\"a\"\n"			\
+		"	.align 8\n"				\
+		"	.quad 1b,3b\n"				\
+		".previous"					\
+		: "=r"(err), ltype (x)				\
+		: "m"(__m(addr)), "i"(errno), "0"(err))
+
+/*
+ * Copy To/From Userspace
+ */
+
+/* Handles exceptions in both to and from, but doesn't do access_ok */
+__must_check unsigned long
+copy_user_generic(void *to, const void *from, unsigned len);
+
+__must_check unsigned long
+copy_to_user(void __user *to, const void *from, unsigned len);
+__must_check unsigned long
+copy_from_user(void *to, const void __user *from, unsigned len);
+__must_check unsigned long
+copy_in_user(void __user *to, const void __user *from, unsigned len);
+
+static __always_inline __must_check
+int __copy_from_user(void *dst, const void __user *src, unsigned size)
+{ 
+	int ret = 0;
+	if (!__builtin_constant_p(size))
+		return copy_user_generic(dst,(__force void *)src,size);
+	switch (size) { 
+	case 1:__get_user_asm(*(u8*)dst,(u8 __user *)src,ret,"b","b","=q",1); 
+		return ret;
+	case 2:__get_user_asm(*(u16*)dst,(u16 __user *)src,ret,"w","w","=r",2);
+		return ret;
+	case 4:__get_user_asm(*(u32*)dst,(u32 __user *)src,ret,"l","k","=r",4);
+		return ret;
+	case 8:__get_user_asm(*(u64*)dst,(u64 __user *)src,ret,"q","","=r",8);
+		return ret; 
+	case 10:
+	       	__get_user_asm(*(u64*)dst,(u64 __user *)src,ret,"q","","=r",16);
+		if (unlikely(ret)) return ret;
+		__get_user_asm(*(u16*)(8+(char*)dst),(u16 __user *)(8+(char __user *)src),ret,"w","w","=r",2);
+		return ret; 
+	case 16:
+		__get_user_asm(*(u64*)dst,(u64 __user *)src,ret,"q","","=r",16);
+		if (unlikely(ret)) return ret;
+		__get_user_asm(*(u64*)(8+(char*)dst),(u64 __user *)(8+(char __user *)src),ret,"q","","=r",8);
+		return ret; 
+	default:
+		return copy_user_generic(dst,(__force void *)src,size); 
+	}
+}	
+
+static __always_inline __must_check
+int __copy_to_user(void __user *dst, const void *src, unsigned size)
+{ 
+	int ret = 0;
+	if (!__builtin_constant_p(size))
+		return copy_user_generic((__force void *)dst,src,size);
+	switch (size) { 
+	case 1:__put_user_asm(*(u8*)src,(u8 __user *)dst,ret,"b","b","iq",1); 
+		return ret;
+	case 2:__put_user_asm(*(u16*)src,(u16 __user *)dst,ret,"w","w","ir",2);
+		return ret;
+	case 4:__put_user_asm(*(u32*)src,(u32 __user *)dst,ret,"l","k","ir",4);
+		return ret;
+	case 8:__put_user_asm(*(u64*)src,(u64 __user *)dst,ret,"q","","ir",8);
+		return ret; 
+	case 10:
+		__put_user_asm(*(u64*)src,(u64 __user *)dst,ret,"q","","ir",10);
+		if (unlikely(ret)) return ret;
+		asm("":::"memory");
+		__put_user_asm(4[(u16*)src],4+(u16 __user *)dst,ret,"w","w","ir",2);
+		return ret; 
+	case 16:
+		__put_user_asm(*(u64*)src,(u64 __user *)dst,ret,"q","","ir",16);
+		if (unlikely(ret)) return ret;
+		asm("":::"memory");
+		__put_user_asm(1[(u64*)src],1+(u64 __user *)dst,ret,"q","","ir",8);
+		return ret; 
+	default:
+		return copy_user_generic((__force void *)dst,src,size); 
+	}
+}	
+
+static __always_inline __must_check
+int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
+{ 
+	int ret = 0;
+	if (!__builtin_constant_p(size))
+		return copy_user_generic((__force void *)dst,(__force void *)src,size);
+	switch (size) { 
+	case 1: { 
+		u8 tmp;
+		__get_user_asm(tmp,(u8 __user *)src,ret,"b","b","=q",1); 
+		if (likely(!ret))
+			__put_user_asm(tmp,(u8 __user *)dst,ret,"b","b","iq",1); 
+		return ret;
+	}
+	case 2: { 
+		u16 tmp;
+		__get_user_asm(tmp,(u16 __user *)src,ret,"w","w","=r",2); 
+		if (likely(!ret))
+			__put_user_asm(tmp,(u16 __user *)dst,ret,"w","w","ir",2); 
+		return ret;
+	}
+
+	case 4: { 
+		u32 tmp;
+		__get_user_asm(tmp,(u32 __user *)src,ret,"l","k","=r",4); 
+		if (likely(!ret))
+			__put_user_asm(tmp,(u32 __user *)dst,ret,"l","k","ir",4); 
+		return ret;
+	}
+	case 8: { 
+		u64 tmp;
+		__get_user_asm(tmp,(u64 __user *)src,ret,"q","","=r",8); 
+		if (likely(!ret))
+			__put_user_asm(tmp,(u64 __user *)dst,ret,"q","","ir",8); 
+		return ret;
+	}
+	default:
+		return copy_user_generic((__force void *)dst,(__force void *)src,size); 
+	}
+}	
+
+__must_check long 
+strncpy_from_user(char *dst, const char __user *src, long count);
+__must_check long 
+__strncpy_from_user(char *dst, const char __user *src, long count);
+__must_check long strnlen_user(const char __user *str, long n);
+__must_check long __strnlen_user(const char __user *str, long n);
+__must_check long strlen_user(const char __user *str);
+__must_check unsigned long clear_user(void __user *mem, unsigned long len);
+__must_check unsigned long __clear_user(void __user *mem, unsigned long len);
+
+__must_check long __copy_from_user_inatomic(void *dst, const void __user *src, unsigned size);
+
+static __must_check __always_inline int
+__copy_to_user_inatomic(void __user *dst, const void *src, unsigned size)
+{
+	return copy_user_generic((__force void *)dst, src, size);
+}
+
+#endif /* __X86_64_UACCESS_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/ucontext.h linux-2.6.20-sabayon-r1/include/asm/ucontext.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/ucontext.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef _ASMX8664_UCONTEXT_H
+#define _ASMX8664_UCONTEXT_H
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/unaligned.h linux-2.6.20-sabayon-r1/include/asm/unaligned.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/unaligned.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/unaligned.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,37 @@
+#ifndef __X8664_UNALIGNED_H
+#define __X8664_UNALIGNED_H
+
+/*
+ * The x86-64 can do unaligned accesses itself. 
+ *
+ * The strange macros are there to make sure these can't
+ * be misused in a way that makes them not work on other
+ * architectures where unaligned accesses aren't as simple.
+ */
+
+/**
+ * get_unaligned - get value from possibly mis-aligned location
+ * @ptr: pointer to value
+ *
+ * This macro should be used for accessing values larger in size than 
+ * single bytes at locations that are expected to be improperly aligned, 
+ * e.g. retrieving a u16 value from a location not u16-aligned.
+ *
+ * Note that unaligned accesses can be very expensive on some architectures.
+ */
+#define get_unaligned(ptr) (*(ptr))
+
+/**
+ * put_unaligned - put value to a possibly mis-aligned location
+ * @val: value to place
+ * @ptr: pointer to location
+ *
+ * This macro should be used for placing values larger in size than 
+ * single bytes at locations that are expected to be improperly aligned, 
+ * e.g. writing a u16 value to a location not u16-aligned.
+ *
+ * Note that unaligned accesses can be very expensive on some architectures.
+ */
+#define put_unaligned(val, ptr) ((void)( *(ptr) = (val) ))
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/unistd.h linux-2.6.20-sabayon-r1/include/asm/unistd.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/unistd.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,677 @@
+#ifndef _ASM_X86_64_UNISTD_H_
+#define _ASM_X86_64_UNISTD_H_
+
+#ifndef __SYSCALL
+#define __SYSCALL(a,b) 
+#endif
+
+/*
+ * This file contains the system call numbers.
+ * 
+ * Note: holes are not allowed.
+ */
+
+/* at least 8 syscall per cacheline */
+#define __NR_read                                0
+__SYSCALL(__NR_read, sys_read)
+#define __NR_write                               1
+__SYSCALL(__NR_write, sys_write)
+#define __NR_open                                2
+__SYSCALL(__NR_open, sys_open)
+#define __NR_close                               3
+__SYSCALL(__NR_close, sys_close)
+#define __NR_stat                                4
+__SYSCALL(__NR_stat, sys_newstat)
+#define __NR_fstat                               5
+__SYSCALL(__NR_fstat, sys_newfstat)
+#define __NR_lstat                               6
+__SYSCALL(__NR_lstat, sys_newlstat)
+#define __NR_poll                                7
+__SYSCALL(__NR_poll, sys_poll)
+
+#define __NR_lseek                               8
+__SYSCALL(__NR_lseek, sys_lseek)
+#define __NR_mmap                                9
+__SYSCALL(__NR_mmap, sys_mmap)
+#define __NR_mprotect                           10
+__SYSCALL(__NR_mprotect, sys_mprotect)
+#define __NR_munmap                             11
+__SYSCALL(__NR_munmap, sys_munmap)
+#define __NR_brk                                12
+__SYSCALL(__NR_brk, sys_brk)
+#define __NR_rt_sigaction                       13
+__SYSCALL(__NR_rt_sigaction, sys_rt_sigaction)
+#define __NR_rt_sigprocmask                     14
+__SYSCALL(__NR_rt_sigprocmask, sys_rt_sigprocmask)
+#define __NR_rt_sigreturn                       15
+__SYSCALL(__NR_rt_sigreturn, stub_rt_sigreturn)
+
+#define __NR_ioctl                              16
+__SYSCALL(__NR_ioctl, sys_ioctl)
+#define __NR_pread64                            17
+__SYSCALL(__NR_pread64, sys_pread64)
+#define __NR_pwrite64                           18
+__SYSCALL(__NR_pwrite64, sys_pwrite64)
+#define __NR_readv                              19
+__SYSCALL(__NR_readv, sys_readv)
+#define __NR_writev                             20
+__SYSCALL(__NR_writev, sys_writev)
+#define __NR_access                             21
+__SYSCALL(__NR_access, sys_access)
+#define __NR_pipe                               22
+__SYSCALL(__NR_pipe, sys_pipe)
+#define __NR_select                             23
+__SYSCALL(__NR_select, sys_select)
+
+#define __NR_sched_yield                        24
+__SYSCALL(__NR_sched_yield, sys_sched_yield)
+#define __NR_mremap                             25
+__SYSCALL(__NR_mremap, sys_mremap)
+#define __NR_msync                              26
+__SYSCALL(__NR_msync, sys_msync)
+#define __NR_mincore                            27
+__SYSCALL(__NR_mincore, sys_mincore)
+#define __NR_madvise                            28
+__SYSCALL(__NR_madvise, sys_madvise)
+#define __NR_shmget                             29
+__SYSCALL(__NR_shmget, sys_shmget)
+#define __NR_shmat                              30
+__SYSCALL(__NR_shmat, sys_shmat)
+#define __NR_shmctl                             31
+__SYSCALL(__NR_shmctl, sys_shmctl)
+
+#define __NR_dup                                32
+__SYSCALL(__NR_dup, sys_dup)
+#define __NR_dup2                               33
+__SYSCALL(__NR_dup2, sys_dup2)
+#define __NR_pause                              34
+__SYSCALL(__NR_pause, sys_pause)
+#define __NR_nanosleep                          35
+__SYSCALL(__NR_nanosleep, sys_nanosleep)
+#define __NR_getitimer                          36
+__SYSCALL(__NR_getitimer, sys_getitimer)
+#define __NR_alarm                              37
+__SYSCALL(__NR_alarm, sys_alarm)
+#define __NR_setitimer                          38
+__SYSCALL(__NR_setitimer, sys_setitimer)
+#define __NR_getpid                             39
+__SYSCALL(__NR_getpid, sys_getpid)
+
+#define __NR_sendfile                           40
+__SYSCALL(__NR_sendfile, sys_sendfile64)
+#define __NR_socket                             41
+__SYSCALL(__NR_socket, sys_socket)
+#define __NR_connect                            42
+__SYSCALL(__NR_connect, sys_connect)
+#define __NR_accept                             43
+__SYSCALL(__NR_accept, sys_accept)
+#define __NR_sendto                             44
+__SYSCALL(__NR_sendto, sys_sendto)
+#define __NR_recvfrom                           45
+__SYSCALL(__NR_recvfrom, sys_recvfrom)
+#define __NR_sendmsg                            46
+__SYSCALL(__NR_sendmsg, sys_sendmsg)
+#define __NR_recvmsg                            47
+__SYSCALL(__NR_recvmsg, sys_recvmsg)
+
+#define __NR_shutdown                           48
+__SYSCALL(__NR_shutdown, sys_shutdown)
+#define __NR_bind                               49
+__SYSCALL(__NR_bind, sys_bind)
+#define __NR_listen                             50
+__SYSCALL(__NR_listen, sys_listen)
+#define __NR_getsockname                        51
+__SYSCALL(__NR_getsockname, sys_getsockname)
+#define __NR_getpeername                        52
+__SYSCALL(__NR_getpeername, sys_getpeername)
+#define __NR_socketpair                         53
+__SYSCALL(__NR_socketpair, sys_socketpair)
+#define __NR_setsockopt                         54
+__SYSCALL(__NR_setsockopt, sys_setsockopt)
+#define __NR_getsockopt                         55
+__SYSCALL(__NR_getsockopt, sys_getsockopt)
+
+#define __NR_clone                              56
+__SYSCALL(__NR_clone, stub_clone)
+#define __NR_fork                               57
+__SYSCALL(__NR_fork, stub_fork) 
+#define __NR_vfork                              58
+__SYSCALL(__NR_vfork, stub_vfork)
+#define __NR_execve                             59
+__SYSCALL(__NR_execve, stub_execve)
+#define __NR_exit                               60
+__SYSCALL(__NR_exit, sys_exit)
+#define __NR_wait4                              61
+__SYSCALL(__NR_wait4, sys_wait4)
+#define __NR_kill                               62
+__SYSCALL(__NR_kill, sys_kill)
+#define __NR_uname                              63
+__SYSCALL(__NR_uname, sys_uname)
+
+#define __NR_semget                             64
+__SYSCALL(__NR_semget, sys_semget)
+#define __NR_semop                              65
+__SYSCALL(__NR_semop, sys_semop)
+#define __NR_semctl                             66
+__SYSCALL(__NR_semctl, sys_semctl)
+#define __NR_shmdt                              67
+__SYSCALL(__NR_shmdt, sys_shmdt)
+#define __NR_msgget                             68
+__SYSCALL(__NR_msgget, sys_msgget)
+#define __NR_msgsnd                             69
+__SYSCALL(__NR_msgsnd, sys_msgsnd)
+#define __NR_msgrcv                             70
+__SYSCALL(__NR_msgrcv, sys_msgrcv)
+#define __NR_msgctl                             71
+__SYSCALL(__NR_msgctl, sys_msgctl)
+
+#define __NR_fcntl                              72
+__SYSCALL(__NR_fcntl, sys_fcntl)
+#define __NR_flock                              73
+__SYSCALL(__NR_flock, sys_flock)
+#define __NR_fsync                              74
+__SYSCALL(__NR_fsync, sys_fsync)
+#define __NR_fdatasync                          75
+__SYSCALL(__NR_fdatasync, sys_fdatasync)
+#define __NR_truncate                           76
+__SYSCALL(__NR_truncate, sys_truncate)
+#define __NR_ftruncate                          77
+__SYSCALL(__NR_ftruncate, sys_ftruncate)
+#define __NR_getdents                           78
+__SYSCALL(__NR_getdents, sys_getdents)
+#define __NR_getcwd                             79
+__SYSCALL(__NR_getcwd, sys_getcwd)
+
+#define __NR_chdir                              80
+__SYSCALL(__NR_chdir, sys_chdir)
+#define __NR_fchdir                             81
+__SYSCALL(__NR_fchdir, sys_fchdir)
+#define __NR_rename                             82
+__SYSCALL(__NR_rename, sys_rename)
+#define __NR_mkdir                              83
+__SYSCALL(__NR_mkdir, sys_mkdir)
+#define __NR_rmdir                              84
+__SYSCALL(__NR_rmdir, sys_rmdir)
+#define __NR_creat                              85
+__SYSCALL(__NR_creat, sys_creat)
+#define __NR_link                               86
+__SYSCALL(__NR_link, sys_link)
+#define __NR_unlink                             87
+__SYSCALL(__NR_unlink, sys_unlink)
+
+#define __NR_symlink                            88
+__SYSCALL(__NR_symlink, sys_symlink)
+#define __NR_readlink                           89
+__SYSCALL(__NR_readlink, sys_readlink)
+#define __NR_chmod                              90
+__SYSCALL(__NR_chmod, sys_chmod)
+#define __NR_fchmod                             91
+__SYSCALL(__NR_fchmod, sys_fchmod)
+#define __NR_chown                              92
+__SYSCALL(__NR_chown, sys_chown)
+#define __NR_fchown                             93
+__SYSCALL(__NR_fchown, sys_fchown)
+#define __NR_lchown                             94
+__SYSCALL(__NR_lchown, sys_lchown)
+#define __NR_umask                              95
+__SYSCALL(__NR_umask, sys_umask)
+
+#define __NR_gettimeofday                       96
+__SYSCALL(__NR_gettimeofday, sys_gettimeofday)
+#define __NR_getrlimit                          97
+__SYSCALL(__NR_getrlimit, sys_getrlimit)
+#define __NR_getrusage                          98
+__SYSCALL(__NR_getrusage, sys_getrusage)
+#define __NR_sysinfo                            99
+__SYSCALL(__NR_sysinfo, sys_sysinfo)
+#define __NR_times                             100
+__SYSCALL(__NR_times, sys_times)
+#define __NR_ptrace                            101
+__SYSCALL(__NR_ptrace, sys_ptrace)
+#define __NR_getuid                            102
+__SYSCALL(__NR_getuid, sys_getuid)
+#define __NR_syslog                            103
+__SYSCALL(__NR_syslog, sys_syslog)
+
+/* at the very end the stuff that never runs during the benchmarks */
+#define __NR_getgid                            104
+__SYSCALL(__NR_getgid, sys_getgid)
+#define __NR_setuid                            105
+__SYSCALL(__NR_setuid, sys_setuid)
+#define __NR_setgid                            106
+__SYSCALL(__NR_setgid, sys_setgid)
+#define __NR_geteuid                           107
+__SYSCALL(__NR_geteuid, sys_geteuid)
+#define __NR_getegid                           108
+__SYSCALL(__NR_getegid, sys_getegid)
+#define __NR_setpgid                           109
+__SYSCALL(__NR_setpgid, sys_setpgid)
+#define __NR_getppid                           110
+__SYSCALL(__NR_getppid, sys_getppid)
+#define __NR_getpgrp                           111
+__SYSCALL(__NR_getpgrp, sys_getpgrp)
+
+#define __NR_setsid                            112
+__SYSCALL(__NR_setsid, sys_setsid)
+#define __NR_setreuid                          113
+__SYSCALL(__NR_setreuid, sys_setreuid)
+#define __NR_setregid                          114
+__SYSCALL(__NR_setregid, sys_setregid)
+#define __NR_getgroups                         115
+__SYSCALL(__NR_getgroups, sys_getgroups)
+#define __NR_setgroups                         116
+__SYSCALL(__NR_setgroups, sys_setgroups)
+#define __NR_setresuid                         117
+__SYSCALL(__NR_setresuid, sys_setresuid)
+#define __NR_getresuid                         118
+__SYSCALL(__NR_getresuid, sys_getresuid)
+#define __NR_setresgid                         119
+__SYSCALL(__NR_setresgid, sys_setresgid)
+
+#define __NR_getresgid                         120
+__SYSCALL(__NR_getresgid, sys_getresgid)
+#define __NR_getpgid                           121
+__SYSCALL(__NR_getpgid, sys_getpgid)
+#define __NR_setfsuid                          122
+__SYSCALL(__NR_setfsuid, sys_setfsuid)
+#define __NR_setfsgid                          123
+__SYSCALL(__NR_setfsgid, sys_setfsgid)
+#define __NR_getsid                            124
+__SYSCALL(__NR_getsid, sys_getsid)
+#define __NR_capget                            125
+__SYSCALL(__NR_capget, sys_capget)
+#define __NR_capset                            126
+__SYSCALL(__NR_capset, sys_capset)
+
+#define __NR_rt_sigpending                     127
+__SYSCALL(__NR_rt_sigpending, sys_rt_sigpending)
+#define __NR_rt_sigtimedwait                   128
+__SYSCALL(__NR_rt_sigtimedwait, sys_rt_sigtimedwait)
+#define __NR_rt_sigqueueinfo                   129
+__SYSCALL(__NR_rt_sigqueueinfo, sys_rt_sigqueueinfo)
+#define __NR_rt_sigsuspend                     130
+__SYSCALL(__NR_rt_sigsuspend, stub_rt_sigsuspend)
+#define __NR_sigaltstack                       131
+__SYSCALL(__NR_sigaltstack, stub_sigaltstack)
+#define __NR_utime                             132
+__SYSCALL(__NR_utime, sys_utime)
+#define __NR_mknod                             133
+__SYSCALL(__NR_mknod, sys_mknod)
+
+/* Only needed for a.out */
+#define __NR_uselib                            134
+__SYSCALL(__NR_uselib, sys_ni_syscall)
+#define __NR_personality                       135
+__SYSCALL(__NR_personality, sys_personality)
+
+#define __NR_ustat                             136
+__SYSCALL(__NR_ustat, sys_ustat)
+#define __NR_statfs                            137
+__SYSCALL(__NR_statfs, sys_statfs)
+#define __NR_fstatfs                           138
+__SYSCALL(__NR_fstatfs, sys_fstatfs)
+#define __NR_sysfs                             139
+__SYSCALL(__NR_sysfs, sys_sysfs)
+
+#define __NR_getpriority                       140
+__SYSCALL(__NR_getpriority, sys_getpriority)
+#define __NR_setpriority                       141
+__SYSCALL(__NR_setpriority, sys_setpriority)
+#define __NR_sched_setparam                    142
+__SYSCALL(__NR_sched_setparam, sys_sched_setparam)
+#define __NR_sched_getparam                    143
+__SYSCALL(__NR_sched_getparam, sys_sched_getparam)
+#define __NR_sched_setscheduler                144
+__SYSCALL(__NR_sched_setscheduler, sys_sched_setscheduler)
+#define __NR_sched_getscheduler                145
+__SYSCALL(__NR_sched_getscheduler, sys_sched_getscheduler)
+#define __NR_sched_get_priority_max            146
+__SYSCALL(__NR_sched_get_priority_max, sys_sched_get_priority_max)
+#define __NR_sched_get_priority_min            147
+__SYSCALL(__NR_sched_get_priority_min, sys_sched_get_priority_min)
+#define __NR_sched_rr_get_interval             148
+__SYSCALL(__NR_sched_rr_get_interval, sys_sched_rr_get_interval)
+
+#define __NR_mlock                             149
+__SYSCALL(__NR_mlock, sys_mlock)
+#define __NR_munlock                           150
+__SYSCALL(__NR_munlock, sys_munlock)
+#define __NR_mlockall                          151
+__SYSCALL(__NR_mlockall, sys_mlockall)
+#define __NR_munlockall                        152
+__SYSCALL(__NR_munlockall, sys_munlockall)
+
+#define __NR_vhangup                           153
+__SYSCALL(__NR_vhangup, sys_vhangup)
+
+#define __NR_modify_ldt                        154
+__SYSCALL(__NR_modify_ldt, sys_modify_ldt)
+
+#define __NR_pivot_root                        155
+__SYSCALL(__NR_pivot_root, sys_pivot_root)
+
+#define __NR__sysctl                           156
+__SYSCALL(__NR__sysctl, sys_sysctl)
+
+#define __NR_prctl                             157
+__SYSCALL(__NR_prctl, sys_prctl)
+#define __NR_arch_prctl                        158
+__SYSCALL(__NR_arch_prctl,	sys_arch_prctl) 
+
+#define __NR_adjtimex                          159
+__SYSCALL(__NR_adjtimex, sys_adjtimex)
+
+#define __NR_setrlimit                         160
+__SYSCALL(__NR_setrlimit, sys_setrlimit)
+
+#define __NR_chroot                            161
+__SYSCALL(__NR_chroot, sys_chroot)
+
+#define __NR_sync                              162
+__SYSCALL(__NR_sync, sys_sync)
+
+#define __NR_acct                              163
+__SYSCALL(__NR_acct, sys_acct)
+
+#define __NR_settimeofday                      164
+__SYSCALL(__NR_settimeofday, sys_settimeofday)
+
+#define __NR_mount                             165
+__SYSCALL(__NR_mount, sys_mount)
+#define __NR_umount2                           166
+__SYSCALL(__NR_umount2, sys_umount)
+
+#define __NR_swapon                            167
+__SYSCALL(__NR_swapon, sys_swapon)
+#define __NR_swapoff                           168
+__SYSCALL(__NR_swapoff, sys_swapoff)
+
+#define __NR_reboot                            169
+__SYSCALL(__NR_reboot, sys_reboot)
+
+#define __NR_sethostname                       170
+__SYSCALL(__NR_sethostname, sys_sethostname)
+#define __NR_setdomainname                     171
+__SYSCALL(__NR_setdomainname, sys_setdomainname)
+
+#define __NR_iopl                              172
+__SYSCALL(__NR_iopl, stub_iopl)
+#define __NR_ioperm                            173
+__SYSCALL(__NR_ioperm, sys_ioperm)
+
+#define __NR_create_module                     174
+__SYSCALL(__NR_create_module, sys_ni_syscall)
+#define __NR_init_module                       175
+__SYSCALL(__NR_init_module, sys_init_module)
+#define __NR_delete_module                     176
+__SYSCALL(__NR_delete_module, sys_delete_module)
+#define __NR_get_kernel_syms                   177
+__SYSCALL(__NR_get_kernel_syms, sys_ni_syscall)
+#define __NR_query_module                      178
+__SYSCALL(__NR_query_module, sys_ni_syscall)
+
+#define __NR_quotactl                          179
+__SYSCALL(__NR_quotactl, sys_quotactl)
+
+#define __NR_nfsservctl                        180
+__SYSCALL(__NR_nfsservctl, sys_nfsservctl)
+
+#define __NR_getpmsg                           181	/* reserved for LiS/STREAMS */
+__SYSCALL(__NR_getpmsg, sys_ni_syscall)
+#define __NR_putpmsg                           182	/* reserved for LiS/STREAMS */
+__SYSCALL(__NR_putpmsg, sys_ni_syscall)
+
+#define __NR_afs_syscall                       183	/* reserved for AFS */ 
+__SYSCALL(__NR_afs_syscall, sys_ni_syscall)
+
+#define __NR_tuxcall      		184 /* reserved for tux */
+__SYSCALL(__NR_tuxcall, sys_ni_syscall)
+
+#define __NR_security			185
+__SYSCALL(__NR_security, sys_ni_syscall)
+
+#define __NR_gettid		186
+__SYSCALL(__NR_gettid, sys_gettid)
+
+#define __NR_readahead		187
+__SYSCALL(__NR_readahead, sys_readahead)
+#define __NR_setxattr		188
+__SYSCALL(__NR_setxattr, sys_setxattr)
+#define __NR_lsetxattr		189
+__SYSCALL(__NR_lsetxattr, sys_lsetxattr)
+#define __NR_fsetxattr		190
+__SYSCALL(__NR_fsetxattr, sys_fsetxattr)
+#define __NR_getxattr		191
+__SYSCALL(__NR_getxattr, sys_getxattr)
+#define __NR_lgetxattr		192
+__SYSCALL(__NR_lgetxattr, sys_lgetxattr)
+#define __NR_fgetxattr		193
+__SYSCALL(__NR_fgetxattr, sys_fgetxattr) 
+#define __NR_listxattr		194
+__SYSCALL(__NR_listxattr, sys_listxattr) 
+#define __NR_llistxattr		195
+__SYSCALL(__NR_llistxattr, sys_llistxattr) 
+#define __NR_flistxattr		196
+__SYSCALL(__NR_flistxattr, sys_flistxattr) 
+#define __NR_removexattr	197
+__SYSCALL(__NR_removexattr, sys_removexattr) 
+#define __NR_lremovexattr	198
+__SYSCALL(__NR_lremovexattr, sys_lremovexattr) 
+#define __NR_fremovexattr	199
+__SYSCALL(__NR_fremovexattr, sys_fremovexattr) 
+#define __NR_tkill	200
+__SYSCALL(__NR_tkill, sys_tkill) 
+#define __NR_time      201
+__SYSCALL(__NR_time, sys_time)
+#define __NR_futex     202
+__SYSCALL(__NR_futex, sys_futex)
+#define __NR_sched_setaffinity    203
+__SYSCALL(__NR_sched_setaffinity, sys_sched_setaffinity)
+#define __NR_sched_getaffinity     204
+__SYSCALL(__NR_sched_getaffinity, sys_sched_getaffinity)
+#define __NR_set_thread_area	205
+__SYSCALL(__NR_set_thread_area, sys_ni_syscall)	/* use arch_prctl */
+#define __NR_io_setup	206
+__SYSCALL(__NR_io_setup, sys_io_setup)
+#define __NR_io_destroy	207
+__SYSCALL(__NR_io_destroy, sys_io_destroy)
+#define __NR_io_getevents	208
+__SYSCALL(__NR_io_getevents, sys_io_getevents)
+#define __NR_io_submit	209
+__SYSCALL(__NR_io_submit, sys_io_submit)
+#define __NR_io_cancel	210
+__SYSCALL(__NR_io_cancel, sys_io_cancel)
+#define __NR_get_thread_area	211
+__SYSCALL(__NR_get_thread_area, sys_ni_syscall)	/* use arch_prctl */
+#define __NR_lookup_dcookie	212
+__SYSCALL(__NR_lookup_dcookie, sys_lookup_dcookie)
+#define __NR_epoll_create	213
+__SYSCALL(__NR_epoll_create, sys_epoll_create)
+#define __NR_epoll_ctl_old	214
+__SYSCALL(__NR_epoll_ctl_old, sys_ni_syscall)
+#define __NR_epoll_wait_old	215
+__SYSCALL(__NR_epoll_wait_old, sys_ni_syscall)
+#define __NR_remap_file_pages	216
+__SYSCALL(__NR_remap_file_pages, sys_remap_file_pages)
+#define __NR_getdents64	217
+__SYSCALL(__NR_getdents64, sys_getdents64)
+#define __NR_set_tid_address	218
+__SYSCALL(__NR_set_tid_address, sys_set_tid_address)
+#define __NR_restart_syscall	219
+__SYSCALL(__NR_restart_syscall, sys_restart_syscall)
+#define __NR_semtimedop		220
+__SYSCALL(__NR_semtimedop, sys_semtimedop)
+#define __NR_fadvise64		221
+__SYSCALL(__NR_fadvise64, sys_fadvise64)
+#define __NR_timer_create		222
+__SYSCALL(__NR_timer_create, sys_timer_create)
+#define __NR_timer_settime		223
+__SYSCALL(__NR_timer_settime, sys_timer_settime)
+#define __NR_timer_gettime		224
+__SYSCALL(__NR_timer_gettime, sys_timer_gettime)
+#define __NR_timer_getoverrun		225
+__SYSCALL(__NR_timer_getoverrun, sys_timer_getoverrun)
+#define __NR_timer_delete	226
+__SYSCALL(__NR_timer_delete, sys_timer_delete)
+#define __NR_clock_settime	227
+__SYSCALL(__NR_clock_settime, sys_clock_settime)
+#define __NR_clock_gettime	228
+__SYSCALL(__NR_clock_gettime, sys_clock_gettime)
+#define __NR_clock_getres	229
+__SYSCALL(__NR_clock_getres, sys_clock_getres)
+#define __NR_clock_nanosleep	230
+__SYSCALL(__NR_clock_nanosleep, sys_clock_nanosleep)
+#define __NR_exit_group		231
+__SYSCALL(__NR_exit_group, sys_exit_group)
+#define __NR_epoll_wait		232
+__SYSCALL(__NR_epoll_wait, sys_epoll_wait)
+#define __NR_epoll_ctl		233
+__SYSCALL(__NR_epoll_ctl, sys_epoll_ctl)
+#define __NR_tgkill		234
+__SYSCALL(__NR_tgkill, sys_tgkill)
+#define __NR_utimes		235
+__SYSCALL(__NR_utimes, sys_utimes)
+#define __NR_vserver		236
+__SYSCALL(__NR_vserver, sys_ni_syscall)
+#define __NR_mbind 		237
+__SYSCALL(__NR_mbind, sys_mbind)
+#define __NR_set_mempolicy 	238
+__SYSCALL(__NR_set_mempolicy, sys_set_mempolicy)
+#define __NR_get_mempolicy 	239
+__SYSCALL(__NR_get_mempolicy, sys_get_mempolicy)
+#define __NR_mq_open 		240
+__SYSCALL(__NR_mq_open, sys_mq_open)
+#define __NR_mq_unlink 		241
+__SYSCALL(__NR_mq_unlink, sys_mq_unlink)
+#define __NR_mq_timedsend 	242
+__SYSCALL(__NR_mq_timedsend, sys_mq_timedsend)
+#define __NR_mq_timedreceive	243
+__SYSCALL(__NR_mq_timedreceive, sys_mq_timedreceive)
+#define __NR_mq_notify 		244
+__SYSCALL(__NR_mq_notify, sys_mq_notify)
+#define __NR_mq_getsetattr 	245
+__SYSCALL(__NR_mq_getsetattr, sys_mq_getsetattr)
+#define __NR_kexec_load 	246
+__SYSCALL(__NR_kexec_load, sys_kexec_load)
+#define __NR_waitid		247
+__SYSCALL(__NR_waitid, sys_waitid)
+#define __NR_add_key		248
+__SYSCALL(__NR_add_key, sys_add_key)
+#define __NR_request_key	249
+__SYSCALL(__NR_request_key, sys_request_key)
+#define __NR_keyctl		250
+__SYSCALL(__NR_keyctl, sys_keyctl)
+#define __NR_ioprio_set		251
+__SYSCALL(__NR_ioprio_set, sys_ioprio_set)
+#define __NR_ioprio_get		252
+__SYSCALL(__NR_ioprio_get, sys_ioprio_get)
+#define __NR_inotify_init	253
+__SYSCALL(__NR_inotify_init, sys_inotify_init)
+#define __NR_inotify_add_watch	254
+__SYSCALL(__NR_inotify_add_watch, sys_inotify_add_watch)
+#define __NR_inotify_rm_watch	255
+__SYSCALL(__NR_inotify_rm_watch, sys_inotify_rm_watch)
+#define __NR_migrate_pages	256
+__SYSCALL(__NR_migrate_pages, sys_migrate_pages)
+#define __NR_openat		257
+__SYSCALL(__NR_openat, sys_openat)
+#define __NR_mkdirat		258
+__SYSCALL(__NR_mkdirat, sys_mkdirat)
+#define __NR_mknodat		259
+__SYSCALL(__NR_mknodat, sys_mknodat)
+#define __NR_fchownat		260
+__SYSCALL(__NR_fchownat, sys_fchownat)
+#define __NR_futimesat		261
+__SYSCALL(__NR_futimesat, sys_futimesat)
+#define __NR_newfstatat		262
+__SYSCALL(__NR_newfstatat, sys_newfstatat)
+#define __NR_unlinkat		263
+__SYSCALL(__NR_unlinkat, sys_unlinkat)
+#define __NR_renameat		264
+__SYSCALL(__NR_renameat, sys_renameat)
+#define __NR_linkat		265
+__SYSCALL(__NR_linkat, sys_linkat)
+#define __NR_symlinkat		266
+__SYSCALL(__NR_symlinkat, sys_symlinkat)
+#define __NR_readlinkat		267
+__SYSCALL(__NR_readlinkat, sys_readlinkat)
+#define __NR_fchmodat		268
+__SYSCALL(__NR_fchmodat, sys_fchmodat)
+#define __NR_faccessat		269
+__SYSCALL(__NR_faccessat, sys_faccessat)
+#define __NR_pselect6		270
+__SYSCALL(__NR_pselect6, sys_pselect6)
+#define __NR_ppoll		271
+__SYSCALL(__NR_ppoll,	sys_ppoll)
+#define __NR_unshare		272
+__SYSCALL(__NR_unshare,	sys_unshare)
+#define __NR_set_robust_list	273
+__SYSCALL(__NR_set_robust_list, sys_set_robust_list)
+#define __NR_get_robust_list	274
+__SYSCALL(__NR_get_robust_list, sys_get_robust_list)
+#define __NR_splice		275
+__SYSCALL(__NR_splice, sys_splice)
+#define __NR_tee		276
+__SYSCALL(__NR_tee, sys_tee)
+#define __NR_sync_file_range	277
+__SYSCALL(__NR_sync_file_range, sys_sync_file_range)
+#define __NR_vmsplice		278
+__SYSCALL(__NR_vmsplice, sys_vmsplice)
+#define __NR_move_pages		279
+__SYSCALL(__NR_move_pages, sys_move_pages)
+
+#define __NR_syscall_max __NR_move_pages
+
+#ifndef __NO_STUBS
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#define __ARCH_WANT_SYS_RT_SIGSUSPEND
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_COMPAT_SYS_TIME
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#include <linux/linkage.h>
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <asm/ptrace.h>
+
+asmlinkage long sys_iopl(unsigned int level, struct pt_regs *regs);
+asmlinkage long sys_ioperm(unsigned long from, unsigned long num, int turn_on);
+struct sigaction;
+asmlinkage long sys_rt_sigaction(int sig,
+				const struct sigaction __user *act,
+				struct sigaction __user *oact,
+				size_t sigsetsize);
+
+#endif  /* __ASSEMBLY__ */
+#endif	/* __KERNEL__ */
+#endif	/* __NO_STUBS */
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall")
+
+#endif /* _ASM_X86_64_UNISTD_H_ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/unwind.h linux-2.6.20-sabayon-r1/include/asm/unwind.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/unwind.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/unwind.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef _ASM_X86_64_UNWIND_H
+#define _ASM_X86_64_UNWIND_H
+
+#define UNW_PC(frame) ((void)(frame), 0UL)
+#define UNW_SP(frame) ((void)(frame), 0UL)
+
+static inline int arch_unw_user_mode(const void *info)
+{
+	return 0;
+}
+
+#endif /* _ASM_X86_64_UNWIND_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/user32.h linux-2.6.20-sabayon-r1/include/asm/user32.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/user32.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/user32.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,69 @@
+#ifndef USER32_H
+#define USER32_H 1
+
+/* IA32 compatible user structures for ptrace. These should be used for 32bit coredumps too. */
+
+struct user_i387_ia32_struct {
+	u32	cwd;
+	u32	swd;
+	u32	twd;
+	u32	fip;
+	u32	fcs;
+	u32	foo;
+	u32	fos;
+	u32	st_space[20];   /* 8*10 bytes for each FP-reg = 80 bytes */
+};
+
+/* FSAVE frame with extensions */
+struct user32_fxsr_struct {
+	unsigned short	cwd;
+	unsigned short	swd;
+	unsigned short	twd;	/* not compatible to 64bit twd */
+	unsigned short	fop;
+	int	fip;
+	int	fcs;
+	int	foo;
+	int	fos;
+	int	mxcsr;
+	int	reserved;
+	int	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
+	int	xmm_space[32];	/* 8*16 bytes for each XMM-reg = 128 bytes */
+	int	padding[56];
+};
+
+struct user_regs_struct32 {
+	__u32 ebx, ecx, edx, esi, edi, ebp, eax;
+	unsigned short ds, __ds, es, __es;
+	unsigned short fs, __fs, gs, __gs;
+	__u32 orig_eax, eip;
+	unsigned short cs, __cs;
+	__u32 eflags, esp;
+	unsigned short ss, __ss;
+};
+
+struct user32 {
+  struct user_regs_struct32 regs;		/* Where the registers are actually stored */
+  int u_fpvalid;		/* True if math co-processor being used. */
+                                /* for this mess. Not yet used. */
+  struct user_i387_ia32_struct i387;	/* Math Co-processor registers. */
+/* The rest of this junk is to help gdb figure out what goes where */
+  __u32 u_tsize;	/* Text segment size (pages). */
+  __u32 u_dsize;	/* Data segment size (pages). */
+  __u32 u_ssize;	/* Stack segment size (pages). */
+  __u32 start_code;     /* Starting virtual address of text. */
+  __u32 start_stack;	/* Starting virtual address of stack area.
+				   This is actually the bottom of the stack,
+				   the top of the stack is always found in the
+				   esp register.  */
+  __u32 signal;     		/* Signal that caused the core dump. */
+  int reserved;			/* No __u32er used */
+  __u32 u_ar0;	/* Used by gdb to help find the values for */
+				/* the registers. */
+  __u32 u_fpstate;	/* Math Co-processor pointer. */
+  __u32 magic;		/* To uniquely identify a core file */
+  char u_comm[32];		/* User command that was responsible */
+  int u_debugreg[8];
+};
+
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/user.h linux-2.6.20-sabayon-r1/include/asm/user.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/user.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/user.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,114 @@
+#ifndef _X86_64_USER_H
+#define _X86_64_USER_H
+
+#include <asm/types.h>
+#include <asm/page.h>
+/* Core file format: The core file is written in such a way that gdb
+   can understand it and provide useful information to the user.
+   There are quite a number of obstacles to being able to view the
+   contents of the floating point registers, and until these are
+   solved you will not be able to view the contents of them.
+   Actually, you can read in the core file and look at the contents of
+   the user struct to find out what the floating point registers
+   contain.
+
+   The actual file contents are as follows:
+   UPAGE: 1 page consisting of a user struct that tells gdb what is present
+   in the file.  Directly after this is a copy of the task_struct, which
+   is currently not used by gdb, but it may come in useful at some point.
+   All of the registers are stored as part of the upage.  The upage should
+   always be only one page.
+   DATA: The data area is stored.  We use current->end_text to
+   current->brk to pick up all of the user variables, plus any memory
+   that may have been malloced.  No attempt is made to determine if a page
+   is demand-zero or if a page is totally unused, we just cover the entire
+   range.  All of the addresses are rounded in such a way that an integral
+   number of pages is written.
+   STACK: We need the stack information in order to get a meaningful
+   backtrace.  We need to write the data from (esp) to
+   current->start_stack, so we round each of these off in order to be able
+   to write an integer number of pages.
+   The minimum core file size is 3 pages, or 12288 bytes.  */
+
+/*
+ * Pentium III FXSR, SSE support
+ *	Gareth Hughes <gareth@valinux.com>, May 2000
+ *
+ * Provide support for the GDB 5.0+ PTRACE_{GET|SET}FPXREGS requests for
+ * interacting with the FXSR-format floating point environment.  Floating
+ * point data can be accessed in the regular format in the usual manner,
+ * and both the standard and SIMD floating point data can be accessed via
+ * the new ptrace requests.  In either case, changes to the FPU environment
+ * will be reflected in the task's state as expected.
+ * 
+ * x86-64 support by Andi Kleen.
+ */
+
+/* This matches the 64bit FXSAVE format as defined by AMD. It is the same
+   as the 32bit format defined by Intel, except that the selector:offset pairs for
+   data and eip are replaced with flat 64bit pointers. */ 
+struct user_i387_struct {
+	unsigned short	cwd;
+	unsigned short	swd;
+	unsigned short	twd; /* Note this is not the same as the 32bit/x87/FSAVE twd */
+	unsigned short	fop;
+	__u64	rip;
+	__u64	rdp;
+	__u32	mxcsr;
+	__u32	mxcsr_mask;
+	__u32	st_space[32];	/* 8*16 bytes for each FP-reg = 128 bytes */
+	__u32	xmm_space[64];	/* 16*16 bytes for each XMM-reg = 256 bytes */
+	__u32	padding[24];
+};
+
+/*
+ * Segment register layout in coredumps.
+ */
+struct user_regs_struct {
+	unsigned long r15,r14,r13,r12,rbp,rbx,r11,r10;
+	unsigned long r9,r8,rax,rcx,rdx,rsi,rdi,orig_rax;
+	unsigned long rip,cs,eflags;
+	unsigned long rsp,ss;
+  	unsigned long fs_base, gs_base;
+	unsigned long ds,es,fs,gs; 
+}; 
+
+/* When the kernel dumps core, it starts by dumping the user struct -
+   this will be used by gdb to figure out where the data and stack segments
+   are within the file, and what virtual addresses to use. */
+struct user{
+/* We start with the registers, to mimic the way that "memory" is returned
+   from the ptrace(3,...) function.  */
+  struct user_regs_struct regs;		/* Where the registers are actually stored */
+/* ptrace does not yet supply these.  Someday.... */
+  int u_fpvalid;		/* True if math co-processor being used. */
+                                /* for this mess. Not yet used. */
+  int pad0;
+  struct user_i387_struct i387;	/* Math Co-processor registers. */
+/* The rest of this junk is to help gdb figure out what goes where */
+  unsigned long int u_tsize;	/* Text segment size (pages). */
+  unsigned long int u_dsize;	/* Data segment size (pages). */
+  unsigned long int u_ssize;	/* Stack segment size (pages). */
+  unsigned long start_code;     /* Starting virtual address of text. */
+  unsigned long start_stack;	/* Starting virtual address of stack area.
+				   This is actually the bottom of the stack,
+				   the top of the stack is always found in the
+				   esp register.  */
+  long int signal;     		/* Signal that caused the core dump. */
+  int reserved;			/* No longer used */
+  int pad1;
+  struct user_pt_regs * u_ar0;	/* Used by gdb to help find the values for */
+				/* the registers. */
+  struct user_i387_struct* u_fpstate;	/* Math Co-processor pointer. */
+  unsigned long magic;		/* To uniquely identify a core file */
+  char u_comm[32];		/* User command that was responsible */
+  unsigned long u_debugreg[8];
+  unsigned long error_code; /* CPU error code or 0 */
+  unsigned long fault_address; /* CR3 or 0 */
+};
+#define NBPG PAGE_SIZE
+#define UPAGES 1
+#define HOST_TEXT_START_ADDR (u.start_code)
+#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _X86_64_USER_H */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/vga.h linux-2.6.20-sabayon-r1/include/asm/vga.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/vga.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/vga.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+/*
+ *	Access to VGA videoram
+ *
+ *	(c) 1998 Martin Mares <mj@ucw.cz>
+ */
+
+#ifndef _LINUX_ASM_VGA_H_
+#define _LINUX_ASM_VGA_H_
+
+/*
+ *	On the PC, we can just recalculate addresses and then
+ *	access the videoram directly without any black magic.
+ */
+
+#define VGA_MAP_MEM(x,s) (unsigned long)phys_to_virt(x)
+
+#define vga_readb(x) (*(x))
+#define vga_writeb(x,y) (*(y) = (x))
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/vsyscall32.h linux-2.6.20-sabayon-r1/include/asm/vsyscall32.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/vsyscall32.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/vsyscall32.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,20 @@
+#ifndef _ASM_VSYSCALL32_H
+#define _ASM_VSYSCALL32_H 1
+
+/* Values need to match arch/x86_64/ia32/vsyscall.lds */
+
+#ifdef __ASSEMBLY__
+#define VSYSCALL32_BASE 0xffffe000
+#define VSYSCALL32_SYSEXIT (VSYSCALL32_BASE + 0x410)
+#else
+#define VSYSCALL32_BASE 0xffffe000UL
+#define VSYSCALL32_END (VSYSCALL32_BASE + PAGE_SIZE)
+#define VSYSCALL32_EHDR ((const struct elf32_hdr *) VSYSCALL32_BASE)
+
+#define VSYSCALL32_VSYSCALL ((void *)VSYSCALL32_BASE + 0x400) 
+#define VSYSCALL32_SYSEXIT ((void *)VSYSCALL32_BASE + 0x410)
+#define VSYSCALL32_SIGRETURN ((void __user *)VSYSCALL32_BASE + 0x500) 
+#define VSYSCALL32_RTSIGRETURN ((void __user *)VSYSCALL32_BASE + 0x600) 
+#endif
+
+#endif
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/vsyscall.h linux-2.6.20-sabayon-r1/include/asm/vsyscall.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/vsyscall.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/vsyscall.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,67 @@
+#ifndef _ASM_X86_64_VSYSCALL_H_
+#define _ASM_X86_64_VSYSCALL_H_
+
+enum vsyscall_num {
+	__NR_vgettimeofday,
+	__NR_vtime,
+	__NR_vgetcpu,
+};
+
+#define VSYSCALL_START (-10UL << 20)
+#define VSYSCALL_SIZE 1024
+#define VSYSCALL_END (-2UL << 20)
+#define VSYSCALL_MAPPED_PAGES 1
+#define VSYSCALL_ADDR(vsyscall_nr) (VSYSCALL_START+VSYSCALL_SIZE*(vsyscall_nr))
+
+#ifdef __KERNEL__
+#include <linux/seqlock.h>
+
+#define __section_vxtime __attribute__ ((unused, __section__ (".vxtime"), aligned(16)))
+#define __section_vgetcpu_mode __attribute__ ((unused, __section__ (".vgetcpu_mode"), aligned(16)))
+#define __section_jiffies __attribute__ ((unused, __section__ (".jiffies"), aligned(16)))
+#define __section_sys_tz __attribute__ ((unused, __section__ (".sys_tz"), aligned(16)))
+#define __section_sysctl_vsyscall __attribute__ ((unused, __section__ (".sysctl_vsyscall"), aligned(16)))
+#define __section_xtime __attribute__ ((unused, __section__ (".xtime"), aligned(16)))
+#define __section_xtime_lock __attribute__ ((unused, __section__ (".xtime_lock"), aligned(16)))
+
+#define VXTIME_TSC	1
+#define VXTIME_HPET	2
+#define VXTIME_PMTMR	3
+
+#define VGETCPU_RDTSCP	1
+#define VGETCPU_LSL	2
+
+struct vxtime_data {
+	long hpet_address;	/* HPET base address */
+	int last;
+	unsigned long last_tsc;
+	long quot;
+	long tsc_quot;
+	int mode;
+};
+
+#define hpet_readl(a)           readl((const void __iomem *)fix_to_virt(FIX_HPET_BASE) + a)
+#define hpet_writel(d,a)        writel(d, (void __iomem *)fix_to_virt(FIX_HPET_BASE) + a)
+
+/* vsyscall space (readonly) */
+extern struct vxtime_data __vxtime;
+extern int __vgetcpu_mode;
+extern struct timespec __xtime;
+extern volatile unsigned long __jiffies;
+extern struct timezone __sys_tz;
+extern seqlock_t __xtime_lock;
+
+/* kernel space (writeable) */
+extern struct vxtime_data vxtime;
+extern int vgetcpu_mode;
+extern struct timezone sys_tz;
+extern int sysctl_vsyscall;
+extern seqlock_t xtime_lock;
+
+extern int sysctl_vsyscall;
+
+#define ARCH_HAVE_XTIME_LOCK 1
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_X86_64_VSYSCALL_H_ */
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/asm/xor.h linux-2.6.20-sabayon-r1/include/asm/xor.h
--- linux-2.6.20-sabayon-r1.orig/include/asm/xor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/asm/xor.h	2007-02-04 19:44:54.000000000 +0100
@@ -0,0 +1,354 @@
+/*
+ * include/asm-x86_64/xor.h
+ *
+ * Optimized RAID-5 checksumming functions for MMX and SSE.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * You should have received a copy of the GNU General Public License
+ * (for example /usr/src/linux/COPYING); if not, write to the Free
+ * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+
+/*
+ * Cache avoiding checksumming functions utilizing KNI instructions
+ * Copyright (C) 1999 Zach Brown (with obvious credit due Ingo)
+ */
+
+/*
+ * Based on
+ * High-speed RAID5 checksumming functions utilizing SSE instructions.
+ * Copyright (C) 1998 Ingo Molnar.
+ */
+
+/*
+ * x86-64 changes / gcc fixes from Andi Kleen. 
+ * Copyright 2002 Andi Kleen, SuSE Labs.
+ *
+ * This hasn't been optimized for the hammer yet, but there are likely
+ * no advantages to be gotten from x86-64 here anyways.
+ */
+
+typedef struct { unsigned long a,b; } __attribute__((aligned(16))) xmm_store_t;
+
+/* Doesn't use gcc to save the XMM registers, because there is no easy way to 
+   tell it to do a clts before the register saving. */
+#define XMMS_SAVE do {				\
+	preempt_disable();			\
+	asm volatile (				\
+		"movq %%cr0,%0		;\n\t"	\
+		"clts			;\n\t"	\
+		"movups %%xmm0,(%1)	;\n\t"	\
+		"movups %%xmm1,0x10(%1)	;\n\t"	\
+		"movups %%xmm2,0x20(%1)	;\n\t"	\
+		"movups %%xmm3,0x30(%1)	;\n\t"	\
+		: "=&r" (cr0)			\
+		: "r" (xmm_save) 		\
+		: "memory");			\
+} while(0)
+
+#define XMMS_RESTORE do {			\
+	asm volatile (				\
+		"sfence			;\n\t"	\
+		"movups (%1),%%xmm0	;\n\t"	\
+		"movups 0x10(%1),%%xmm1	;\n\t"	\
+		"movups 0x20(%1),%%xmm2	;\n\t"	\
+		"movups 0x30(%1),%%xmm3	;\n\t"	\
+		"movq 	%0,%%cr0	;\n\t"	\
+		:				\
+		: "r" (cr0), "r" (xmm_save)	\
+		: "memory");			\
+	preempt_enable();			\
+} while(0)
+
+#define OFFS(x)		"16*("#x")"
+#define PF_OFFS(x)	"256+16*("#x")"
+#define	PF0(x)		"	prefetchnta "PF_OFFS(x)"(%[p1])		;\n"
+#define LD(x,y)		"       movaps   "OFFS(x)"(%[p1]), %%xmm"#y"	;\n"
+#define ST(x,y)		"       movaps %%xmm"#y",   "OFFS(x)"(%[p1])	;\n"
+#define PF1(x)		"	prefetchnta "PF_OFFS(x)"(%[p2])		;\n"
+#define PF2(x)		"	prefetchnta "PF_OFFS(x)"(%[p3])		;\n"
+#define PF3(x)		"	prefetchnta "PF_OFFS(x)"(%[p4])		;\n"
+#define PF4(x)		"	prefetchnta "PF_OFFS(x)"(%[p5])		;\n"
+#define PF5(x)		"	prefetchnta "PF_OFFS(x)"(%[p6])		;\n"
+#define XO1(x,y)	"       xorps   "OFFS(x)"(%[p2]), %%xmm"#y"	;\n"
+#define XO2(x,y)	"       xorps   "OFFS(x)"(%[p3]), %%xmm"#y"	;\n"
+#define XO3(x,y)	"       xorps   "OFFS(x)"(%[p4]), %%xmm"#y"	;\n"
+#define XO4(x,y)	"       xorps   "OFFS(x)"(%[p5]), %%xmm"#y"	;\n"
+#define XO5(x,y)	"       xorps   "OFFS(x)"(%[p6]), %%xmm"#y"	;\n"
+
+
+static void
+xor_sse_2(unsigned long bytes, unsigned long *p1, unsigned long *p2)
+{
+        unsigned int lines = bytes >> 8;
+	unsigned long cr0;
+	xmm_store_t xmm_save[4];
+
+	XMMS_SAVE;
+
+        asm volatile (
+#undef BLOCK
+#define BLOCK(i) \
+		LD(i,0)					\
+			LD(i+1,1)			\
+		PF1(i)					\
+				PF1(i+2)		\
+				LD(i+2,2)		\
+					LD(i+3,3)	\
+		PF0(i+4)				\
+				PF0(i+6)		\
+		XO1(i,0)				\
+			XO1(i+1,1)			\
+				XO1(i+2,2)		\
+					XO1(i+3,3)	\
+		ST(i,0)					\
+			ST(i+1,1)			\
+				ST(i+2,2)		\
+					ST(i+3,3)	\
+
+
+		PF0(0)
+				PF0(2)
+
+	" .align 32			;\n"
+        " 1:                            ;\n"
+
+		BLOCK(0)
+		BLOCK(4)
+		BLOCK(8)
+		BLOCK(12)
+
+        "       addq %[inc], %[p1]           ;\n"
+        "       addq %[inc], %[p2]           ;\n"
+		"		decl %[cnt] ; jnz 1b"
+	: [p1] "+r" (p1), [p2] "+r" (p2), [cnt] "+r" (lines)
+	: [inc] "r" (256UL) 
+        : "memory");
+
+	XMMS_RESTORE;
+}
+
+static void
+xor_sse_3(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+	  unsigned long *p3)
+{
+	unsigned int lines = bytes >> 8;
+	xmm_store_t xmm_save[4];
+	unsigned long cr0;
+
+	XMMS_SAVE;
+
+        __asm__ __volatile__ (
+#undef BLOCK
+#define BLOCK(i) \
+		PF1(i)					\
+				PF1(i+2)		\
+		LD(i,0)					\
+			LD(i+1,1)			\
+				LD(i+2,2)		\
+					LD(i+3,3)	\
+		PF2(i)					\
+				PF2(i+2)		\
+		PF0(i+4)				\
+				PF0(i+6)		\
+		XO1(i,0)				\
+			XO1(i+1,1)			\
+				XO1(i+2,2)		\
+					XO1(i+3,3)	\
+		XO2(i,0)				\
+			XO2(i+1,1)			\
+				XO2(i+2,2)		\
+					XO2(i+3,3)	\
+		ST(i,0)					\
+			ST(i+1,1)			\
+				ST(i+2,2)		\
+					ST(i+3,3)	\
+
+
+		PF0(0)
+				PF0(2)
+
+	" .align 32			;\n"
+        " 1:                            ;\n"
+
+		BLOCK(0)
+		BLOCK(4)
+		BLOCK(8)
+		BLOCK(12)
+
+        "       addq %[inc], %[p1]           ;\n"
+        "       addq %[inc], %[p2]          ;\n"
+        "       addq %[inc], %[p3]           ;\n"
+		"		decl %[cnt] ; jnz 1b"
+	: [cnt] "+r" (lines),
+	  [p1] "+r" (p1), [p2] "+r" (p2), [p3] "+r" (p3)
+	: [inc] "r" (256UL)
+	: "memory"); 
+	XMMS_RESTORE;
+}
+
+static void
+xor_sse_4(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+	  unsigned long *p3, unsigned long *p4)
+{
+	unsigned int lines = bytes >> 8;
+	xmm_store_t xmm_save[4]; 
+	unsigned long cr0;
+
+	XMMS_SAVE;
+
+        __asm__ __volatile__ (
+#undef BLOCK
+#define BLOCK(i) \
+		PF1(i)					\
+				PF1(i+2)		\
+		LD(i,0)					\
+			LD(i+1,1)			\
+				LD(i+2,2)		\
+					LD(i+3,3)	\
+		PF2(i)					\
+				PF2(i+2)		\
+		XO1(i,0)				\
+			XO1(i+1,1)			\
+				XO1(i+2,2)		\
+					XO1(i+3,3)	\
+		PF3(i)					\
+				PF3(i+2)		\
+		PF0(i+4)				\
+				PF0(i+6)		\
+		XO2(i,0)				\
+			XO2(i+1,1)			\
+				XO2(i+2,2)		\
+					XO2(i+3,3)	\
+		XO3(i,0)				\
+			XO3(i+1,1)			\
+				XO3(i+2,2)		\
+					XO3(i+3,3)	\
+		ST(i,0)					\
+			ST(i+1,1)			\
+				ST(i+2,2)		\
+					ST(i+3,3)	\
+
+
+		PF0(0)
+				PF0(2)
+
+	" .align 32			;\n"
+        " 1:                            ;\n"
+
+		BLOCK(0)
+		BLOCK(4)
+		BLOCK(8)
+		BLOCK(12)
+
+        "       addq %[inc], %[p1]           ;\n"
+        "       addq %[inc], %[p2]           ;\n"
+        "       addq %[inc], %[p3]           ;\n"
+        "       addq %[inc], %[p4]           ;\n"
+	"	decl %[cnt] ; jnz 1b"
+	: [cnt] "+c" (lines),
+	  [p1] "+r" (p1), [p2] "+r" (p2), [p3] "+r" (p3), [p4] "+r" (p4)
+	: [inc] "r" (256UL)
+        : "memory" );
+
+	XMMS_RESTORE;
+}
+
+static void
+xor_sse_5(unsigned long bytes, unsigned long *p1, unsigned long *p2,
+	  unsigned long *p3, unsigned long *p4, unsigned long *p5)
+{
+        unsigned int lines = bytes >> 8;
+	xmm_store_t xmm_save[4];
+	unsigned long cr0;
+
+	XMMS_SAVE;
+
+        __asm__ __volatile__ (
+#undef BLOCK
+#define BLOCK(i) \
+		PF1(i)					\
+				PF1(i+2)		\
+		LD(i,0)					\
+			LD(i+1,1)			\
+				LD(i+2,2)		\
+					LD(i+3,3)	\
+		PF2(i)					\
+				PF2(i+2)		\
+		XO1(i,0)				\
+			XO1(i+1,1)			\
+				XO1(i+2,2)		\
+					XO1(i+3,3)	\
+		PF3(i)					\
+				PF3(i+2)		\
+		XO2(i,0)				\
+			XO2(i+1,1)			\
+				XO2(i+2,2)		\
+					XO2(i+3,3)	\
+		PF4(i)					\
+				PF4(i+2)		\
+		PF0(i+4)				\
+				PF0(i+6)		\
+		XO3(i,0)				\
+			XO3(i+1,1)			\
+				XO3(i+2,2)		\
+					XO3(i+3,3)	\
+		XO4(i,0)				\
+			XO4(i+1,1)			\
+				XO4(i+2,2)		\
+					XO4(i+3,3)	\
+		ST(i,0)					\
+			ST(i+1,1)			\
+				ST(i+2,2)		\
+					ST(i+3,3)	\
+
+
+		PF0(0)
+				PF0(2)
+
+	" .align 32			;\n"
+        " 1:                            ;\n"
+
+		BLOCK(0)
+		BLOCK(4)
+		BLOCK(8)
+		BLOCK(12)
+
+        "       addq %[inc], %[p1]           ;\n"
+        "       addq %[inc], %[p2]           ;\n"
+        "       addq %[inc], %[p3]           ;\n"
+        "       addq %[inc], %[p4]           ;\n"
+        "       addq %[inc], %[p5]           ;\n"
+	"	decl %[cnt] ; jnz 1b"
+	: [cnt] "+c" (lines),
+  	  [p1] "+r" (p1), [p2] "+r" (p2), [p3] "+r" (p3), [p4] "+r" (p4), 
+	  [p5] "+r" (p5)
+	: [inc] "r" (256UL)
+	: "memory");
+
+	XMMS_RESTORE;
+}
+
+static struct xor_block_template xor_block_sse = {
+        .name = "generic_sse",
+        .do_2 = xor_sse_2,
+        .do_3 = xor_sse_3,
+        .do_4 = xor_sse_4,
+        .do_5 = xor_sse_5,
+};
+
+#undef XOR_TRY_TEMPLATES
+#define XOR_TRY_TEMPLATES				\
+	do {						\
+		xor_speed(&xor_block_sse);	\
+	} while (0)
+
+/* We force the use of the SSE xor block because it can write around L2.
+   We may also be able to load into the L1 only depending on how the cpu
+   deals with a load to a line that is being prefetched.  */
+#define XOR_SELECT_TEMPLATE(FASTEST) (&xor_block_sse)
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/config/auto.conf linux-2.6.20-sabayon-r1/include/config/auto.conf
--- linux-2.6.20-sabayon-r1.orig/include/config/auto.conf	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/config/auto.conf	2007-02-12 15:09:06.000000000 +0100
@@ -0,0 +1,2307 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.20-sabayon-r1
+# Mon Feb 12 15:09:06 2007
+#
+CONFIG_USB_SISUSBVGA=m
+CONFIG_USB_PHIDGETMOTORCONTROL=m
+CONFIG_VIDEO_V4L1_COMPAT=y
+CONFIG_PCMCIA_FMVJ18X=m
+CONFIG_BLK_CPQ_DA=y
+CONFIG_BLK_DEV_FD=y
+CONFIG_AX25=m
+CONFIG_ACPI_AC=y
+CONFIG_PM_STD_PARTITION=""
+CONFIG_SECURITY_NETWORK=y
+CONFIG_ULTRIX_PARTITION=y
+CONFIG_OSF_PARTITION=y
+CONFIG_USB_LEGOTOWER=m
+CONFIG_FB_TRIDENT=m
+CONFIG_DVB_PLUTO2=m
+CONFIG_GAMEPORT_NS558=m
+CONFIG_JOYSTICK_GRIP=m
+CONFIG_BONDING=m
+CONFIG_MTD_ABSENT=m
+CONFIG_INET_XFRM_TUNNEL=m
+CONFIG_CRYPTO_ANUBIS=m
+CONFIG_JBD2=y
+CONFIG_SOUND_TRIDENT=m
+CONFIG_P54_USB=m
+CONFIG_TCP_CONG_ADVANCED=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM=y
+CONFIG_JFFS2_CMODE_PRIORITY=y
+CONFIG_USB_SERIAL_IR=m
+CONFIG_SND_AZT3328=m
+CONFIG_TCP_CONG_SCALABLE=m
+CONFIG_SUSPEND2_REPLACE_SWSUSP=y
+CONFIG_JFS_POSIX_ACL=y
+CONFIG_FONT_MINI_4x6=y
+CONFIG_SENSORS_VT8231=m
+CONFIG_RIO_OLDPCI=y
+CONFIG_ISDN_DIVAS=m
+CONFIG_DLCI_COUNT=24
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_NF_CT_ACCT=y
+CONFIG_TCP_CONG_VENO=m
+CONFIG_CARDBUS=y
+CONFIG_X86_POWERNOW_K8_ACPI=y
+CONFIG_ACPI_EC=y
+CONFIG_CRYPTO_MD4=m
+CONFIG_USB_SERIAL_TI=m
+CONFIG_ISDN_DRV_AVMB1_C4=m
+CONFIG_BT_HCIUART=m
+CONFIG_IP_NF_TARGET_TTL=m
+CONFIG_NETFILTER_NETLINK_QUEUE=m
+CONFIG_INET6_XFRM_MODE_BEET=m
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+CONFIG_IPW2200_QOS=y
+CONFIG_E1000=m
+CONFIG_ARCNET_RAW=m
+CONFIG_I2O_EXT_ADAPTEC_DMA64=y
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH=y
+CONFIG_NF_NAT_PROTO_GRE=m
+CONFIG_NETFILTER_XT_MATCH_PHYSDEV=m
+CONFIG_CRYPTO_MD5=y
+CONFIG_SUSPEND2_CHECKSUM=y
+CONFIG_ARCH_DISCONTIGMEM_ENABLE=y
+CONFIG_CRYPTO_AES_X86_64=m
+CONFIG_PROC_KCORE=y
+CONFIG_USB_GADGET_NET2280=y
+CONFIG_USB_AIPTEK=m
+CONFIG_DVB_TUNER_LGH06XF=m
+CONFIG_VIDEO_BTCX=m
+CONFIG_PCMCIA_SMC91C92=m
+CONFIG_BLK_DEV_DM=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_SCSI_FC_ATTRS=y
+CONFIG_IRDA_ULTRA=y
+CONFIG_IP_NF_TARGET_TOS=m
+CONFIG_SND_EMU10K1=m
+CONFIG_DVB_TDA10021=m
+CONFIG_I2C_SAVAGE4=m
+CONFIG_SYNCLINKMP=m
+CONFIG_PPP_MULTILINK=y
+CONFIG_TMD_HERMES=m
+CONFIG_SCSI_DC390T=y
+CONFIG_NET_CLS_RSVP6=m
+CONFIG_CRYPTO_CBC=y
+CONFIG_ACORN_PARTITION_ADFS=y
+CONFIG_USB_SERIAL=m
+CONFIG_USB_RTL8150=m
+CONFIG_DVB_USB_CXUSB=m
+CONFIG_USB_W9968CF=m
+CONFIG_SERIAL_JSM=m
+CONFIG_MTD_MTDRAM=m
+CONFIG_NF_CONNTRACK_NETBIOS_NS=m
+CONFIG_ACPI_POWER=y
+CONFIG_GFS2_FS=y
+CONFIG_SND_DARLA20=m
+CONFIG_DVB_STV0297=m
+CONFIG_VIDEO_ZORAN_LML33=m
+CONFIG_HOSTAP_PCI=m
+CONFIG_CASSINI=m
+CONFIG_PCMCIA_FDOMAIN=m
+CONFIG_CRYPTO_ECB=y
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_SECCOMP=y
+CONFIG_USB_SERIAL_WHITEHEAT=m
+CONFIG_VIDEO_W9966=m
+CONFIG_X25_ASY=m
+CONFIG_NETXEN_NIC=m
+CONFIG_PATA_SIL680=y
+CONFIG_PATA_ARTOP=y
+CONFIG_PNPACPI=y
+CONFIG_BT_HCIBLUECARD=m
+CONFIG_OLD_BELKIN_DONGLE=m
+CONFIG_IP_DCCP_CCID3_RTO=100
+CONFIG_IP6_NF_RAW=m
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_SND_YMFPCI=m
+CONFIG_DVB_STV0299=m
+CONFIG_DVB_TDA826X=m
+CONFIG_SPI_BUTTERFLY=m
+CONFIG_I2C_NFORCE2=m
+CONFIG_ZD1211RW=m
+CONFIG_NET_POCKET=y
+CONFIG_EEPRO100=m
+CONFIG_WINBOND_840=m
+CONFIG_PATA_MPIIX=y
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_X86_LOCAL_APIC=y
+CONFIG_EXT2_FS_XATTR=y
+CONFIG_USB_KAWETH=m
+CONFIG_ROCKETPORT=m
+CONFIG_DL2K=m
+CONFIG_BLK_DEV_SD=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_LLC2=m
+CONFIG_IP6_NF_MATCH_FRAG=m
+CONFIG_NETFILTER_XT_MATCH_DSCP=m
+CONFIG_EXT3_FS_XATTR=y
+CONFIG_RTC_DRV_M48T86=m
+CONFIG_SND_DARLA24=m
+CONFIG_VIDEO_BT819=m
+CONFIG_FUSION_LAN=y
+CONFIG_NETFILTER_XT_MATCH_MARK=m
+CONFIG_SUN_PARTITION=y
+CONFIG_CODA_FS=y
+CONFIG_NFS_COMMON=y
+CONFIG_USB_CXACRU=m
+CONFIG_SND_VIA82XX_MODEM=m
+CONFIG_VIDEO_BT856=m
+CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_NET_PKTGEN=m
+CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI=y
+CONFIG_X86_TSC=y
+CONFIG_IOMAP_COPY=y
+CONFIG_VIDEO_BT848=m
+CONFIG_VIDEO_BT866=m
+CONFIG_SERIO_SERPORT=y
+CONFIG_JOYSTICK_MAGELLAN=m
+CONFIG_PATA_HPT366=y
+CONFIG_CPU_FREQ_STAT=y
+CONFIG_USB_SERIAL_ARK3116=m
+CONFIG_HID_PID=y
+CONFIG_HW_CONSOLE=y
+CONFIG_ATM_FORE200E_MAYBE=m
+CONFIG_NATSEMI=m
+CONFIG_SCSI_IPR_DUMP=y
+CONFIG_MTD_DOCPROBE_HIGH=y
+CONFIG_NET_EMATCH_U32=m
+CONFIG_HPET_TIMER=y
+CONFIG_CIFS_EXPERIMENTAL=y
+CONFIG_XFS_POSIX_ACL=y
+CONFIG_SENSORS_SMSC47B397=m
+CONFIG_HDLC_FR=m
+CONFIG_IP_DCCP=m
+CONFIG_CIFS_STATS=y
+CONFIG_NFSD_V3=y
+CONFIG_SND_ATIIXP=m
+CONFIG_DVB_TDA10086=m
+CONFIG_TOUCHSCREEN_TOUCHWIN=m
+CONFIG_ATM_IDT77252_USE_SUNI=y
+CONFIG_I2O_BUS=y
+CONFIG_PARIDE_ON20=m
+CONFIG_NF_NAT_IRC=m
+CONFIG_REORDER=y
+CONFIG_K8_NUMA=y
+CONFIG_NFSD_V4=y
+CONFIG_VIDEO_VIVI=m
+CONFIG_I2C_ALGOPCA=m
+CONFIG_IEEE1394_CONFIG_ROM_IP1394=y
+CONFIG_CHR_DEV_SG=y
+CONFIG_IEEE80211=m
+CONFIG_IP_NF_MATCH_ADDRTYPE=m
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=m
+CONFIG_USB_NET_PLUSB=m
+CONFIG_VIDEO_ZORAN_AVS6EYES=m
+CONFIG_PPP_FILTER=y
+CONFIG_PATA_IT821X=y
+CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE=1
+CONFIG_NF_NAT_H323=m
+CONFIG_IP_ROUTE_MULTIPATH_WRANDOM=m
+CONFIG_ADFS_FS=m
+CONFIG_FB_VESA=y
+CONFIG_SENSORS_SMSC47M192=m
+CONFIG_KEYBOARD_ATKBD=y
+CONFIG_FARSYNC=m
+CONFIG_FUSION_CTL=y
+CONFIG_MTD_CFI=m
+CONFIG_ALI_FIR=m
+CONFIG_NET_CLS_ROUTE=y
+CONFIG_NF_CT_PROTO_SCTP=m
+CONFIG_CIFS_POSIX=y
+CONFIG_CIFS_XATTR=y
+CONFIG_SOUND_TVMIXER=m
+CONFIG_MIDI_VIA82CXXX=y
+CONFIG_DRM_MGA=m
+CONFIG_AGP_VIA=m
+CONFIG_PCMCIA_XIRC2PS=m
+CONFIG_BCM43XX_DMA_AND_PIO_MODE=y
+CONFIG_PLX_HERMES=m
+CONFIG_3C359=m
+CONFIG_SPI_MASTER=y
+CONFIG_MTD_JEDECPROBE=m
+CONFIG_BRIDGE_EBT_BROUTE=m
+CONFIG_X86_MSR=y
+CONFIG_NLS_KOI8_R=m
+CONFIG_BEFS_FS=m
+CONFIG_AFFS_FS=m
+CONFIG_NET_DMA=y
+CONFIG_SND_USB_USX2Y=m
+CONFIG_SND_SEQ_DUMMY=m
+CONFIG_TOUCHSCREEN_PENMOUNT=m
+CONFIG_KEYBOARD_LKKBD=y
+CONFIG_MSI_LAPTOP=m
+CONFIG_IBM_ASM=m
+CONFIG_NF_CONNTRACK_IPV4=m
+CONFIG_INET_AH=m
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_SND_MIXART=m
+CONFIG_SND_LAYLA20=m
+CONFIG_I2C_AMD756_S4882=m
+CONFIG_I2C_ALGOPCF=m
+CONFIG_CARDMAN_4000=m
+CONFIG_QLA3XXX=m
+CONFIG_PARIDE_ON26=m
+CONFIG_CRYPTO_AES=y
+CONFIG_BT_RFCOMM_TTY=y
+CONFIG_MODULES=y
+CONFIG_CRYPTO_TEA=m
+CONFIG_USB_USBNET=m
+CONFIG_USB_ACM=m
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_DVB_USB_DIB0700=m
+CONFIG_I2C_CHARDEV=m
+CONFIG_BCM43XX_DMA=y
+CONFIG_PCMCIA_WAVELAN=m
+CONFIG_BNX2=m
+CONFIG_IEEE1394_OUI_DB=y
+CONFIG_FUSION_SAS=y
+CONFIG_PARPORT_PC=y
+CONFIG_MTD_COMPLEX_MAPPINGS=y
+CONFIG_BT_HIDP=m
+CONFIG_BT_BNEP=m
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_SUSPEND2_DEFAULT_RESUME2=""
+CONFIG_NLS_KOI8_U=m
+CONFIG_EXT2_FS=y
+CONFIG_SND_MIA=m
+CONFIG_FB_S1D13XXX=m
+CONFIG_DVB_USB_VP702X=m
+CONFIG_INPUT_MISC=y
+CONFIG_MOUSE_VSXXXAA=m
+CONFIG_HDLC=m
+CONFIG_PATA_CMD64X=y
+CONFIG_BLK_DEV_SR=y
+CONFIG_MTD_SCB2_FLASH=m
+CONFIG_TOIM3232_DONGLE=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_EXT3_FS=y
+CONFIG_USB_LCD=m
+CONFIG_VIDEO_CX88_DVB=m
+CONFIG_I2C_PARPORT_LIGHT=m
+CONFIG_VT_CONSOLE=y
+CONFIG_ISDN_DIVAS_BRIPCI=y
+CONFIG_DLCI=m
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADVANCED=y
+CONFIG_CRYPTO_DES=y
+CONFIG_HFSPLUS_FS=y
+CONFIG_DNOTIFY=y
+CONFIG_EXT4DEV_FS_POSIX_ACL=y
+CONFIG_USB_SERIAL_BELKIN=m
+CONFIG_SND_LAYLA24=m
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SENSORS_F71805F=m
+CONFIG_CARDMAN_4040=m
+CONFIG_ATM_ENI=m
+CONFIG_S2IO=m
+CONFIG_INET_DCCP_DIAG=m
+CONFIG_NETFILTER_XT_MATCH_SCTP=m
+CONFIG_IP_VS_LBLC=m
+CONFIG_ACPI=y
+CONFIG_QFMT_V1=y
+CONFIG_USB_LED=m
+CONFIG_USB_SERIAL_KEYSPAN_USA49WLC=y
+CONFIG_USB_HID=y
+CONFIG_FB_CYBER2000=m
+CONFIG_DVB_DIB7000M=m
+CONFIG_DVB_VES1X93=m
+CONFIG_JOYSTICK_SPACEORB=m
+CONFIG_SLIP_SMART=y
+CONFIG_ATM_AMBASSADOR=m
+CONFIG_IP_DCCP_ACKVEC=y
+CONFIG_ARCH="x86_64"
+CONFIG_QFMT_V2=y
+CONFIG_KVM_AMD=m
+CONFIG_RTC_LIB=y
+CONFIG_DVB_NXT200X=m
+CONFIG_WDT_501_PCI=y
+CONFIG_DE600=m
+CONFIG_I2C_ALGOBIT=m
+CONFIG_FUSION_SPI=y
+CONFIG_LAPB=m
+CONFIG_NF_NAT_FTP=m
+CONFIG_NETFILTER_XTABLES=m
+CONFIG_ACPI_CONTAINER=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_STALDRV=y
+CONFIG_AIRO_CS=m
+CONFIG_MTD_PCI=m
+CONFIG_VIA_FIR=m
+CONFIG_IRDA=m
+CONFIG_IPX_INTERN=y
+CONFIG_NF_CONNTRACK_MARK=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_DVB_DIB7000P=m
+CONFIG_TCG_NSC=m
+CONFIG_PPPOATM=m
+CONFIG_DE620=m
+CONFIG_SATA_QSTOR=y
+CONFIG_CHR_DEV_ST=y
+CONFIG_MTD_DOC2001PLUS=m
+CONFIG_RFD_FTL=m
+CONFIG_NF_NAT_SIP=m
+CONFIG_NETFILTER_NETLINK=m
+CONFIG_INOTIFY=y
+CONFIG_USB_SERIAL_KOBIL_SCT=m
+CONFIG_SENSORS_ADM1021=m
+CONFIG_DRM_VIA=m
+CONFIG_PCMCIA_3C574=m
+CONFIG_HOSTAP_PLX=m
+CONFIG_NET_PCI=y
+CONFIG_SLAB=y
+CONFIG_DLM_TCP=y
+CONFIG_DVB_PLL=m
+CONFIG_SENSORS_ADM1031=m
+CONFIG_MCS_FIR=m
+CONFIG_HOTPLUG=y
+CONFIG_USB_ADUTUX=m
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_SND_PCM=y
+CONFIG_W1_SLAVE_DS2433=m
+CONFIG_DRM_I810=m
+CONFIG_PRINTER=y
+CONFIG_MTD_RAM=m
+CONFIG_NSC_FIR=m
+CONFIG_NET_CLS_FW=m
+CONFIG_BRIDGE_EBT_MARK_T=m
+CONFIG_PCI_MSI=y
+CONFIG_SWIOTLB=y
+CONFIG_CIFS=y
+CONFIG_SOUND_BT878=m
+CONFIG_DVB_USB=m
+CONFIG_VIDEO_CPIA2=m
+CONFIG_IPV6=m
+CONFIG_SECURITY_SELINUX_AVC_STATS=y
+CONFIG_INFINIBAND_SRP=m
+CONFIG_USB_SERIAL_GARMIN=m
+CONFIG_SENSORS_ADM1025=m
+CONFIG_I2C_VOODOO3=m
+CONFIG_DRM_I830=m
+CONFIG_AGP_SIS=m
+CONFIG_PC300=m
+CONFIG_PCMCIA_NETWAVE=m
+CONFIG_PARPORT_PC_PCMCIA=m
+CONFIG_WAN_ROUTER=m
+CONFIG_SPARSEMEM_EXTREME=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_USB_SERIAL_MOS7720=m
+CONFIG_SENSORS_PC87360=m
+CONFIG_SENSORS_ADM1026=m
+CONFIG_MTD_DOCPROBE_ADVANCED=y
+CONFIG_ARPD=y
+CONFIG_CPUSETS=y
+CONFIG_SND_VX_LIB=m
+CONFIG_R3964=m
+CONFIG_ATM_TCP=m
+CONFIG_PCMCIA_3C589=m
+CONFIG_PARPORT=y
+CONFIG_NET_CLS=y
+CONFIG_BRIDGE_EBT_LOG=m
+CONFIG_HPFS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_USB_SERIAL_NAVMAN=m
+CONFIG_USB_STORAGE_KARMA=y
+CONFIG_JOYSTICK_INTERACT=m
+CONFIG_ATM_IDT77252=m
+CONFIG_SKY2=m
+CONFIG_HP100=y
+CONFIG_PARIDE_FIT2=m
+CONFIG_SERIAL_8250_PCI=y
+CONFIG_BT_CMTP=m
+CONFIG_BRIDGE_EBT_ARP=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_JFFS2_FS_SECURITY=y
+CONFIG_USB_ETH=m
+CONFIG_USB_SERIAL_MOS7840=m
+CONFIG_VIDEO_VIDEOBUF=m
+CONFIG_DRM_I915=m
+CONFIG_IPMI_SI=m
+CONFIG_ISDN_DIVAS_PRIPCI=y
+CONFIG_SLHC=m
+CONFIG_IXGB=m
+CONFIG_SKGE=m
+CONFIG_R8169=m
+CONFIG_ARCNET_COM20020_PCI=m
+CONFIG_PATA_NS87410=y
+CONFIG_PARIDE_FIT3=m
+CONFIG_NFSD=y
+CONFIG_UDF_NLS=y
+CONFIG_FUSE_FS=y
+CONFIG_USB_ATM=m
+CONFIG_DVB_USB_DIBUSB_MB=m
+CONFIG_SENSORS_PC87427=m
+CONFIG_TOUCHSCREEN_GUNZE=m
+CONFIG_AIRO=m
+CONFIG_SATA_MV=y
+CONFIG_X86_MCE_AMD=y
+CONFIG_KMOD=y
+CONFIG_CRYPTO_LZF=m
+CONFIG_GENERIC_ACL=y
+CONFIG_FB_KYRO=m
+CONFIG_DVB_USB_DIBUSB_MC=m
+CONFIG_SBNI=m
+CONFIG_SATA_NV=y
+CONFIG_PROC_FS=y
+CONFIG_SND_FM801_TEA575X_BOOL=y
+CONFIG_SENSORS_ADM9240=m
+CONFIG_I2C_PCA_ISA=m
+CONFIG_TCG_TIS=m
+CONFIG_KEYBOARD_XTKBD=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_PARIDE_KBIC=m
+CONFIG_IPDDP_DECAP=y
+CONFIG_TCG_TPM=m
+CONFIG_IPMI_DEVICE_INTERFACE=m
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+CONFIG_ISDN=m
+CONFIG_MYRI10GE=m
+CONFIG_MTDRAM_ERASE_SIZE=128
+CONFIG_BT_BNEP_MC_FILTER=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+CONFIG_SOUND_TRIX=m
+CONFIG_DRM_R128=m
+CONFIG_DTLK=m
+CONFIG_KEYBOARD_STOWAWAY=m
+CONFIG_PATA_HPT3X3=y
+CONFIG_NET_KEY=m
+CONFIG_X86_CMPXCHG=y
+CONFIG_BCM43XX_PIO=y
+CONFIG_DGRS=m
+CONFIG_DM_ZERO=y
+CONFIG_CFG80211_WEXTNL_COMPAT=y
+CONFIG_TIPC=m
+CONFIG_INET=y
+CONFIG_ARCH_SPARSEMEM_ENABLE=y
+CONFIG_RT_MUTEXES=y
+CONFIG_LOGO=y
+CONFIG_DVB_TDA1004X=m
+CONFIG_HPET=y
+CONFIG_DRM_SIS=m
+CONFIG_TYPHOON=m
+CONFIG_SCSI_DC395x=y
+CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK=-1
+CONFIG_NUMA=y
+CONFIG_SYSVIPC=y
+CONFIG_REISERFS_FS_SECURITY=y
+CONFIG_SENSORS_W83781D=m
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_SSB_PCMCIAHOST=y
+CONFIG_PATA_PCMCIA=m
+CONFIG_ATA_GENERIC=y
+CONFIG_SCSI=y
+CONFIG_MTD_ROM=m
+CONFIG_MTD_CFI_AMDSTD=m
+CONFIG_BT_BNEP_PROTO_FILTER=y
+CONFIG_IP_SCTP=m
+CONFIG_NF_CONNTRACK_SUPPORT=y
+CONFIG_DEFAULT_BIC=y
+CONFIG_TCP_CONG_CUBIC=m
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_NTFS_FS=y
+CONFIG_INFINIBAND_ADDR_TRANS=y
+CONFIG_USB_MON=y
+CONFIG_USB_PWC=m
+CONFIG_SENSORS_W83791D=m
+CONFIG_ATM_FIRESTREAM=m
+CONFIG_PATA_HPT37X=y
+CONFIG_PARIDE_EPIA=m
+CONFIG_IP6_NF_MATCH_OPTS=m
+CONFIG_NF_CONNTRACK_TFTP=m
+CONFIG_SENSORS_W83792D=m
+CONFIG_PARIDE_BPCK=m
+CONFIG_NFTL=m
+CONFIG_NF_NAT_SNMP_BASIC=m
+CONFIG_CRYPTO_LRW=m
+CONFIG_CIFS_WEAK_PW_HASH=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28=y
+CONFIG_PLIP=m
+CONFIG_TMS380TR=m
+CONFIG_CRYPTO_DEFLATE=m
+CONFIG_USB_PHIDGETKIT=m
+CONFIG_SC6600_CDROM=4
+CONFIG_DIGIEPCA=m
+CONFIG_JOYSTICK_COBRA=m
+CONFIG_PARPORT_AX88796=m
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_USB_STORAGE_JUMPSHOT=y
+CONFIG_VIDEO_USBVIDEO=m
+CONFIG_NET_EMATCH_CMP=m
+CONFIG_IPDDP_ENCAP=y
+CONFIG_IP_NF_TARGET_SAME=m
+CONFIG_INET6_XFRM_TUNNEL=m
+CONFIG_NCPFS_SMALLDOS=y
+CONFIG_SLIP=m
+CONFIG_REED_SOLOMON_DEC16=y
+CONFIG_ACTISYS_DONGLE=m
+CONFIG_SUSPEND_SHARED=y
+CONFIG_IOSCHED_CFQ=y
+CONFIG_SND_SONICVIBES=m
+CONFIG_USB_ET61X251=m
+CONFIG_HDLC_X25=m
+CONFIG_ROSE=m
+CONFIG_NET_ACT_POLICE=m
+CONFIG_NF_CONNTRACK_PPTP=m
+CONFIG_X86_IO_APIC=y
+CONFIG_JFFS2_RUBIN=y
+CONFIG_USB_SERIAL_XIRCOM=m
+CONFIG_LOGITECH_FF=y
+CONFIG_SENSORS_PCA9539=m
+CONFIG_I6300ESB_WDT=m
+CONFIG_ALIM7101_WDT=m
+CONFIG_IPW2100_MONITOR=y
+CONFIG_IP6_NF_MATCH_EUI64=m
+CONFIG_NR_CPUS=8
+CONFIG_GENERIC_BUG=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_JFFS2_RTIME=y
+CONFIG_VIDEO_CQCAM=m
+CONFIG_SERIAL_8250_PNP=y
+CONFIG_LANMEDIA=m
+CONFIG_IPW2200_MONITOR=y
+CONFIG_BT_HCIBFUSB=m
+CONFIG_X86_L1_CACHE_BYTES=128
+CONFIG_SWAP=y
+CONFIG_KEYS=y
+CONFIG_EXT2_FS_POSIX_ACL=y
+CONFIG_USB_STORAGE_USBAT=y
+CONFIG_VIDEO_CPIA_USB=m
+CONFIG_SENSORS_PCF8591=m
+CONFIG_IEEE1394_OHCI1394=y
+CONFIG_PARIDE_ATEN=m
+CONFIG_PARIDE_PARPORT=y
+CONFIG_NFTL_RW=y
+CONFIG_MTD_REDBOOT_PARTS=m
+CONFIG_MA600_DONGLE=m
+CONFIG_NETFILTER_XT_MATCH_CONNMARK=m
+CONFIG_TCP_CONG_HYBLA=m
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_EXT3_FS_POSIX_ACL=y
+CONFIG_USB_SPEEDTOUCH=m
+CONFIG_SND_KORG1212=m
+CONFIG_SENSORS_PCF8574=m
+CONFIG_W83627HF_WDT=m
+CONFIG_AC97_BUS=m
+CONFIG_CYCLOMX_X25=y
+CONFIG_BRIDGE_EBT_STP=m
+CONFIG_XFRM=y
+CONFIG_CRC32=y
+CONFIG_USB_APPLETOUCH=m
+CONFIG_SND_VIA82XX=m
+CONFIG_VIDEO_KS0127=m
+CONFIG_GAMEPORT_L4=m
+CONFIG_AIC79XX_DEBUG_MASK=0
+CONFIG_BLK_DEV_3W_XXXX_RAID=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_PARIDE_EPAT=m
+CONFIG_MTD_ESB2ROM=m
+CONFIG_DEFAULT_CFQ=y
+CONFIG_VXFS_FS=m
+CONFIG_USB_NET_NET1080=m
+CONFIG_ALIM1535_WDT=m
+CONFIG_CRC16=m
+CONFIG_IP_NF_IPTABLES=m
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_MD_RAID0=y
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_PARIDE_COMM=m
+CONFIG_D80211=y
+CONFIG_NET_ACT_MIRRED=m
+CONFIG_IP_NF_MATCH_AH=m
+CONFIG_TEXTSEARCH_FSM=m
+CONFIG_SECURITY_CAPABILITIES=y
+CONFIG_NFSD_V2_ACL=y
+CONFIG_USB_SERIAL_OPTION=m
+CONFIG_DVB_USB_GP8PSK=m
+CONFIG_W1_SLAVE_THERM=m
+CONFIG_TOUCHSCREEN_UCB1400=m
+CONFIG_MD_RAID1=y
+CONFIG_NET_CLS_U32=m
+CONFIG_BRIDGE_NF_EBTABLES=m
+CONFIG_NFSD_V3_ACL=y
+CONFIG_RTC_DRV_PCF8563=m
+CONFIG_SPI_BITBANG=m
+CONFIG_MTDRAM_TOTAL_SIZE=4096
+CONFIG_IP_NF_MATCH_OWNER=m
+CONFIG_TEXTSEARCH_KMP=m
+CONFIG_TCP_CONG_VEGAS=m
+CONFIG_PACKET_MMAP=y
+CONFIG_NTFS_RW=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SENSORS_MAX1619=m
+CONFIG_SCSI_INIA100=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=m
+CONFIG_RTC_DRV_PCF8583=m
+CONFIG_SENSORS_ABITUGURU=m
+CONFIG_W83697HF_WDT=m
+CONFIG_PPP_DEFLATE=m
+CONFIG_UNIX=y
+CONFIG_GENERIC_CPU=y
+CONFIG_CIFS_UPCALL=y
+CONFIG_CIFS_STATS2=y
+CONFIG_JFFS2_FS_XATTR=y
+CONFIG_SENSORS_K8TEMP=m
+CONFIG_I2C_PARPORT=m
+CONFIG_PCMCIA_SYM53C500=m
+CONFIG_BAYCOM_SER_FDX=m
+CONFIG_HAMRADIO=y
+CONFIG_NET_SCH_DSMARK=m
+CONFIG_MTRR=y
+CONFIG_RTC_DRV_ISL1208=m
+CONFIG_PARIDE_FRIQ=m
+CONFIG_CONFIGFS_FS=m
+CONFIG_SENSORS_FSCHER=m
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_PARPORT_SERIAL=y
+CONFIG_MTD_ONENAND=m
+CONFIG_BT_L2CAP=m
+CONFIG_BAYCOM_SER_HDX=m
+CONFIG_NETLABEL=y
+CONFIG_ISA_DMA_API=y
+CONFIG_DVB_USB_TTUSB2=m
+CONFIG_VIDEO_TVEEPROM=m
+CONFIG_SERIAL_CORE=y
+CONFIG_CYCLADES=m
+CONFIG_RT2400PCI=m
+CONFIG_LXT_PHY=m
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_MTD_SC520CDP=m
+CONFIG_IP_NF_TARGET_ULOG=m
+CONFIG_TCP_CONG_WESTWOOD=m
+CONFIG_SOUND_CS4232=m
+CONFIG_FB_GEODE_GX=m
+CONFIG_RT2500PCI=m
+CONFIG_PDC_ADMA=y
+CONFIG_SCSI_QLA_ISCSI=y
+CONFIG_UID16=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_64BIT=y
+CONFIG_RTC_DRV_MAX6902=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_ISDN_CAPI_CAPIFS_BOOL=y
+CONFIG_DE4X5=m
+CONFIG_SCSI_IPR_TRACE=y
+CONFIG_BLK_DEV_NBD=m
+CONFIG_CRYPTO_ARC4=y
+CONFIG_NET_CLS_ROUTE4=m
+CONFIG_PHYSICAL_START=0x200000
+CONFIG_IKCONFIG=y
+CONFIG_FB_GEODE=y
+CONFIG_DVB_USB_DIGITV=m
+CONFIG_VIDEO_BT848_DVB=y
+CONFIG_INPUT_TSDEV_SCREEN_X=1024
+CONFIG_NE2K_PCI=m
+CONFIG_BINFMT_MISC=y
+CONFIG_RTC_DRV_RS5C372=m
+CONFIG_SOUND_ES1371=m
+CONFIG_SENSORS_MAX6875=m
+CONFIG_INPUT_TSDEV_SCREEN_Y=768
+CONFIG_IPW3945_MONITOR=y
+CONFIG_CISS_SCSI_TAPE=y
+CONFIG_AX25_DAMA_SLAVE=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_FIB_HASH=y
+CONFIG_SYSV_FS=y
+CONFIG_JFS_STATISTICS=y
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_CRYPTO_SHA1=m
+CONFIG_USB_PHIDGET=m
+CONFIG_MEGARAID_LEGACY=y
+CONFIG_INET6_AH=m
+CONFIG_TCP_CONG_HSTCP=m
+CONFIG_I82092=m
+CONFIG_PARTITION_ADVANCED=y
+CONFIG_RTC_DRV_RS5C348=m
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_VIDEO_OV7670=m
+CONFIG_MTD_BLKDEVS=m
+CONFIG_NETFILTER_XT_TARGET_NOTRACK=m
+CONFIG_USB_CYPRESS_CY7C63=m
+CONFIG_FONT_ACORN_8x8=y
+CONFIG_VGA_CONSOLE=y
+CONFIG_CDROM_PKTCDVD_BUFFERS=8
+CONFIG_PARIDE_KTTI=m
+CONFIG_IEEE80211_CRYPT_WEP=m
+CONFIG_PCIEPORTBUS=y
+CONFIG_ACPI_HOTKEY=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_SC6600_CDROMBASE=0
+CONFIG_SND_RAWMIDI=m
+CONFIG_FONT_PEARL_8x8=y
+CONFIG_SENSORS_VIA686A=m
+CONFIG_TELCLOCK=m
+CONFIG_WATCHDOG=y
+CONFIG_DSCC4=m
+CONFIG_SUNDANCE=m
+CONFIG_SGI_IOC4=m
+CONFIG_PARIDE_DSTR=m
+CONFIG_MTD_PARTITIONS=y
+CONFIG_WINBOND_FIR=m
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_ACPI_FAN=y
+CONFIG_CRYPTO_TWOFISH_X86_64=m
+CONFIG_SECURITY_SELINUX_DISABLE=y
+CONFIG_USB_ATI_REMOTE=m
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_SECURITY_ROOTPLUG=m
+CONFIG_JFFS2_FS=m
+CONFIG_USB_STORAGE_SDDR09=y
+CONFIG_USB_ISP116X_HCD=m
+CONFIG_SENSORS_SIS5595=m
+CONFIG_TOUCHSCREEN_ADS7846=m
+CONFIG_DAVICOM_PHY=m
+CONFIG_PARIDE_FRPW=m
+CONFIG_MTD_PHYSMAP_START=0x8000000
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_ACORN_PARTITION_POWERTEC=y
+CONFIG_USB_STORAGE_SDDR55=y
+CONFIG_DVB_LGDT330X=m
+CONFIG_SENSORS_EEPROM=m
+CONFIG_ARCNET_COM90xx=m
+CONFIG_PATA_ATIIXP=y
+CONFIG_NETFILTER_XT_MATCH_REALM=m
+CONFIG_SYSVIPC_COMPAT=y
+CONFIG_ACPI_IBM=y
+CONFIG_SUSPEND2=y
+CONFIG_OCFS2_FS=m
+CONFIG_SND_RIPTIDE=m
+CONFIG_FB_SAVAGE_ACCEL=y
+CONFIG_VIDEO_WM8739=m
+CONFIG_VIDEO_WM8775=m
+CONFIG_APPLICOM=m
+CONFIG_MTD_PLATRAM=m
+CONFIG_BT_HCIBPA10X=m
+CONFIG_6PACK=m
+CONFIG_YENTA_RICOH=y
+CONFIG_PREEMPT_BKL=y
+CONFIG_CRYPTO_GF128MUL=m
+CONFIG_LOCKD_V4=y
+CONFIG_USB_YEALINK=m
+CONFIG_USB_APPLEIR=m
+CONFIG_VIDEO_CAFE_CCIC=m
+CONFIG_SENSORS_GL520SM=m
+CONFIG_JOYSTICK_SPACEBALL=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_PARPORT_1284=y
+CONFIG_NETFILTER_XT_TARGET_NFQUEUE=m
+CONFIG_NODES_SHIFT=6
+CONFIG_SCHED_MC=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_LIBCRC32C=y
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_DVB_USB_DTT200U=m
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_PPP_BSDCOMP=m
+CONFIG_RT2500USB=m
+CONFIG_FUSION_MAX_SGE=128
+CONFIG_PATA_AMD=y
+CONFIG_SCSI_QLA_FC=y
+CONFIG_INET_IPCOMP=m
+CONFIG_USB_SERIAL_IPW=m
+CONFIG_USB_NET_AX8817X=m
+CONFIG_USB_USBNET_MII=m
+CONFIG_SND_VIRMIDI=m
+CONFIG_ACQUIRE_WDT=m
+CONFIG_CHR_DEV_SCH=m
+CONFIG_MTD_NETSC520=m
+CONFIG_ACPI_BUTTON=y
+CONFIG_SMB_NLS_REMOTE="cp437"
+CONFIG_SCSI_ARCMSR=m
+CONFIG_BLK_DEV_SX8=m
+CONFIG_NET_SCH_CBQ=m
+CONFIG_CRYPTO_HMAC=y
+CONFIG_SND_SEQ_RTCTIMER_DEFAULT=y
+CONFIG_SENSORS_FSCPOS=m
+CONFIG_IPV6_TUNNEL=m
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_REISERFS_FS=y
+CONFIG_I2C_STUB=m
+CONFIG_SERIAL_NONSTANDARD=y
+CONFIG_I2O_SCSI=y
+CONFIG_PATA_ALI=y
+CONFIG_BLK_DEV_RAM_BLOCKSIZE=1024
+CONFIG_BPQETHER=m
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_SOUND_YM3812=m
+CONFIG_DVB_DIB3000MB=m
+CONFIG_HANGCHECK_TIMER=m
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_UNIXWARE_DISKLABEL=y
+CONFIG_DVB_DIB3000MC=m
+CONFIG_DVB_USB_A800=m
+CONFIG_SENSORS_GL518SM=m
+CONFIG_DM9102=m
+CONFIG_I2O_PROC=y
+CONFIG_SCSI_INITIO=y
+CONFIG_AIC79XX_REG_PRETTY_PRINT=y
+CONFIG_AIC7XXX_DEBUG_MASK=0
+CONFIG_USB_STORAGE=y
+CONFIG_SND_TRIDENT=m
+CONFIG_MTD_ICHXROM=m
+CONFIG_NET_SCH_RED=m
+CONFIG_USB_IDMOUSE=m
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+CONFIG_GAMEPORT=m
+CONFIG_INPUT_JOYSTICK=y
+CONFIG_IEEE1394_SBP2=y
+CONFIG_NET_CLS_ACT=y
+CONFIG_NET_SCH_TBF=m
+CONFIG_DEBUG_FS=y
+CONFIG_ELF_CORE=y
+CONFIG_CRYPTO_XCBC=m
+CONFIG_SND_EMU10K1X=m
+CONFIG_VIDEO_ZORAN=m
+CONFIG_SYNCLINK_CS=m
+CONFIG_CAPI_AVM=y
+CONFIG_DM_SNAPSHOT=y
+CONFIG_CRYPTO_SERPENT=m
+CONFIG_USB_PEGASUS=m
+CONFIG_SOUND_VMIDI=m
+CONFIG_VIDEO_CX88_ALSA=m
+CONFIG_DLCI_MAX=8
+CONFIG_SSB_PCIHOST=y
+CONFIG_MTD_PHYSMAP_BANKWIDTH=2
+CONFIG_NET_SCH_HTB=m
+CONFIG_ATM_LANE=m
+CONFIG_YENTA_O2=y
+CONFIG_ACPI_SYSTEM=y
+CONFIG_MMC_TIFM_SD=m
+CONFIG_USB_U132_HCD=m
+CONFIG_SC6600=y
+CONFIG_MTD_CHAR=m
+CONFIG_NET_CLS_IND=y
+CONFIG_NETFILTER_XT_MATCH_LIMIT=m
+CONFIG_NETFILTER_NETLINK_LOG=m
+CONFIG_FB_ATY_GENERIC_LCD=y
+CONFIG_FB_INTEL=m
+CONFIG_MARVELL_PHY=m
+CONFIG_IP_NF_TARGET_REDIRECT=m
+CONFIG_RESOURCES_64BIT=y
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_CRYPTO_TWOFISH=m
+CONFIG_CRYPTO_HASH=y
+CONFIG_INFINIBAND_ISER=m
+CONFIG_INFINIBAND_MTHCA_DEBUG=y
+CONFIG_USB_CATC=m
+CONFIG_DVB_CORE=y
+CONFIG_VIDEO_TUNER=m
+CONFIG_60XX_WDT=m
+CONFIG_LEGACY_PTYS=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_HDLC_RAW=m
+CONFIG_EEPROM_93CX6=m
+CONFIG_NETFILTER_XT_MATCH_STATE=m
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_ACPI_SBS=m
+CONFIG_ARCH_DISCONTIGMEM_DEFAULT=y
+CONFIG_USB_CYTHERM=m
+CONFIG_USB_SERIAL_GENERIC=y
+CONFIG_USB_STORAGE_ALAUDA=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_SOUND_PRIME=m
+CONFIG_SYNCLINK_GT=m
+CONFIG_PATA_VIA=y
+CONFIG_SCSI_HPTIOP=y
+CONFIG_SCSI_SAS_ATTRS=y
+CONFIG_MTD_ONENAND_VERIFY_WRITE=y
+CONFIG_MTD_NAND=m
+CONFIG_MTD_DILNETPC_BOOTSIZE=0x80000
+CONFIG_NET_SCH_ATM=m
+CONFIG_IP_PIMSM_V2=y
+CONFIG_INET_TUNNEL=m
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+CONFIG_PRINTK_TIME=y
+CONFIG_SND_MPU401_UART=m
+CONFIG_FRAMEBUFFER_CONSOLE_ROTATION=y
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_MTD_PHYSMAP=m
+CONFIG_SYN_COOKIES=y
+CONFIG_X86_INTERNODE_CACHE_BYTES=128
+CONFIG_SEMAPHORE_SLEEPERS=y
+CONFIG_ISDN_DRV_AVMB1_AVM_CS=m
+CONFIG_ISDN_DRV_AVMB1_B1PCIV4=y
+CONFIG_IPW2200_RADIOTAP=y
+CONFIG_SATA_SX4=y
+CONFIG_ATM_BR2684_IPFILTER=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=m
+CONFIG_PCI200SYN=m
+CONFIG_8139CP=m
+CONFIG_SATA_VIA=y
+CONFIG_PROC_EVENTS=y
+CONFIG_NETFILTER_XT_TARGET_MARK=m
+CONFIG_IP_VS_TAB_BITS=12
+CONFIG_TCP_CONG_LP=m
+CONFIG_DELL_RBU=m
+CONFIG_USB_TOUCHSCREEN_DMC_TSC10=y
+CONFIG_INPUT_EVDEV=y
+CONFIG_USB_IRDA=m
+CONFIG_ATM_CLIP=m
+CONFIG_INFINIBAND_IPOIB_DEBUG=y
+CONFIG_DVB_USB_UMT_010=m
+CONFIG_VIDEO_ZORAN_ZR36060=m
+CONFIG_ATM_HORIZON=m
+CONFIG_HDLC_PPP=m
+CONFIG_SCSI_SPI_ATTRS=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_PARPORT_NOT_PC=y
+CONFIG_NET_ACT_IPT=m
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_EXT2_FS_XIP=y
+CONFIG_USB_TOUCHSCREEN_3M=y
+CONFIG_USB_SUSPEND=y
+CONFIG_CPU5_WDT=m
+CONFIG_SYNCLINK=m
+CONFIG_I2O_EXT_ADAPTEC=y
+CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_BLOCK=y
+CONFIG_MMC_WBSD=m
+CONFIG_SND_OSSEMUL=y
+CONFIG_RADIO_MAXIRADIO=m
+CONFIG_PD6729=m
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_SECURITY_SELINUX_DEVELOP=y
+CONFIG_LOCKD=y
+CONFIG_QUOTACTL=y
+CONFIG_USB_XUSBATM=m
+CONFIG_USB_PRINTER=y
+CONFIG_NET_SCH_SFQ=m
+CONFIG_ATALK=m
+CONFIG_BRIDGE_EBT_DNAT=m
+CONFIG_NETFILTER_XT_MATCH_QUOTA=m
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+CONFIG_SQUASHFS=y
+CONFIG_ATM_MPOA=m
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ACORN_PARTITION_EESOX=y
+CONFIG_USB_TRANCEVIBRATOR=m
+CONFIG_ZEROPLUS_FF=y
+CONFIG_SOUND_MPU401=m
+CONFIG_SND_MONA=m
+CONFIG_IEEE1394_PCILYNX=m
+CONFIG_ATA_PIIX=y
+CONFIG_IP_VS_LBLCR=m
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_SND_FM801=m
+CONFIG_FB_ATY128=m
+CONFIG_VIDEO_OVCAMCHIP=m
+CONFIG_IB700_WDT=m
+CONFIG_SATA_SIL=y
+CONFIG_MTD_NETtel=m
+CONFIG_IP_NF_QUEUE=m
+CONFIG_KALLSYMS=y
+CONFIG_NFSD_TCP=y
+CONFIG_VIDEO_IR=m
+CONFIG_PC8736x_GPIO=m
+CONFIG_MD_RAID10=y
+CONFIG_NEW_LEDS=y
+CONFIG_IPDDP=m
+CONFIG_BRIDGE_EBT_MARK=m
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=m
+CONFIG_SUSPEND_SMP=y
+CONFIG_DVB_MT312=m
+CONFIG_NSC_GPIO=m
+CONFIG_TOUCHSCREEN_MTOUCH=m
+CONFIG_CHELSIO_T1_NAPI=y
+CONFIG_SATA_ULI=y
+CONFIG_SCSI_PPA=m
+CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE=y
+CONFIG_MTD_SBC_GXX=m
+CONFIG_BRIDGE_EBT_802_3=m
+CONFIG_K8_NB=y
+CONFIG_NLS_UTF8=y
+CONFIG_SND_HDSP=m
+CONFIG_ATMEL=m
+CONFIG_IBMOL=m
+CONFIG_VITESSE_PHY=m
+CONFIG_SCSI_EATA_LINKED_COMMANDS=y
+CONFIG_SSFDC=m
+CONFIG_NF_NAT_TFTP=m
+CONFIG_NETFILTER_DEBUG=y
+CONFIG_AGP_AMD64=y
+CONFIG_JFFS2_FS_POSIX_ACL=y
+CONFIG_USB_TOUCHSCREEN_GUNZE=y
+CONFIG_USB_DSBR=m
+CONFIG_VIDEO_CX25840=m
+CONFIG_VIDEO_SAA7110=m
+CONFIG_PATA_SIS=y
+CONFIG_SCSI_IMM=m
+CONFIG_LITELINK_DONGLE=m
+CONFIG_IPV6_SIT=m
+CONFIG_PROC_SYSCTL=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_USB_SERIAL_CYPRESS_M8=m
+CONFIG_VIDEO_SAA7111=m
+CONFIG_INPUT_TSDEV=y
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_CPU_FREQ_STAT_DETAILS=y
+CONFIG_CPU_FREQ=y
+CONFIG_USB_XPAD=m
+CONFIG_USB_SE401=m
+CONFIG_DVB_MT352=m
+CONFIG_I8XX_TCO=m
+CONFIG_SCSI_AACRAID=y
+CONFIG_IRLAN=m
+CONFIG_IP6_NF_MATCH_AH=m
+CONFIG_USB_MIDI_GADGET=m
+CONFIG_USB_SL811_CS=m
+CONFIG_KEYBOARD_SUNKBD=y
+CONFIG_SSB_DRIVER_PCICORE=y
+CONFIG_SATA_SIS=y
+CONFIG_BRIDGE_EBT_VLAN=m
+CONFIG_BRIDGE_EBT_PKTTYPE=m
+CONFIG_INET_ESP=m
+CONFIG_AUDIT=y
+CONFIG_AMIGA_PARTITION=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_VIDEO_SAA7114=m
+CONFIG_W1_MASTER_DS2490=m
+CONFIG_DRM_TDFX=m
+CONFIG_INPUT_MOUSE=y
+CONFIG_ISDN_DIVAS_USERIDI=m
+CONFIG_PCMCIA_WL3501=m
+CONFIG_IP6_NF_MATCH_OWNER=m
+CONFIG_IP_NF_MATCH_RECENT=m
+CONFIG_SECURITY=y
+CONFIG_NET_IPIP=m
+CONFIG_RAMFS=y
+CONFIG_USB_NET_ZAURUS=m
+CONFIG_W1_MASTER_DS2482=m
+CONFIG_NF_NAT_PPTP=m
+CONFIG_FB_GEODE_GX1=m
+CONFIG_VIDEO_SAA7134=m
+CONFIG_PHONE=m
+CONFIG_SCSI_QLOGIC_1280=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_SHMEM=y
+CONFIG_CRYPTO_NULL=m
+CONFIG_EXPORTFS=y
+CONFIG_LEDS_TRIGGER_TIMER=m
+CONFIG_SENSORS_W83627HF=m
+CONFIG_SC520_WDT=m
+CONFIG_SCSI_AIC94XX=m
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_SND_NM256=m
+CONFIG_VIDEO_SAA7127=m
+CONFIG_VIDEO_TEA6420=m
+CONFIG_IPW2200_PROMISCUOUS=y
+CONFIG_PATA_HPT3X2N=y
+CONFIG_SCSI_IPR=y
+CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
+CONFIG_BRIDGE_EBT_SNAT=m
+CONFIG_IP_VS_PROTO_AH=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_EPOLL=y
+CONFIG_MINIX_FS=m
+CONFIG_SOUND_SB=m
+CONFIG_SOUND_VIA82CXXX=m
+CONFIG_VIDEO_SAA7146=m
+CONFIG_VIDEO_SAA7191=m
+CONFIG_ITCO_WDT=m
+CONFIG_JOYSTICK_IFORCE_232=y
+CONFIG_ATM_ZATM=m
+CONFIG_SCSI_IPS=y
+CONFIG_INFTL=m
+CONFIG_BRIDGE_EBT_ULOG=m
+CONFIG_YENTA_TI=y
+CONFIG_RELAY=y
+CONFIG_MSDOS_FS=y
+CONFIG_FONT_8x8=y
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_SCSI_AIC79XX=y
+CONFIG_VLSI_FIR=m
+CONFIG_NET_EMATCH_META=m
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_CRYPTO_WP512=m
+CONFIG_RPCSEC_GSS_KRB5=y
+CONFIG_ROMFS_FS=y
+CONFIG_VIDEO_SAA5249=m
+CONFIG_VIDEO_TDA7432=m
+CONFIG_PPDEV=y
+CONFIG_PCMCIA_ATMEL=m
+CONFIG_PCMCIA_SPECTRUM=m
+CONFIG_PATA_PDC2027X=y
+CONFIG_SCSI_EATA_MAX_TAGS=16
+CONFIG_CRYPTO_TEST=m
+CONFIG_NLS_CODEPAGE_850=m
+CONFIG_SND_INTEL8X0=m
+CONFIG_FB_INTEL_I2C=y
+CONFIG_VIDEO_ADV7170=m
+CONFIG_VIDEO_SAA7185=m
+CONFIG_MWAVE=m
+CONFIG_TIPAR=m
+CONFIG_MEGARAID_SAS=y
+CONFIG_SCSI_TGT=m
+CONFIG_IEEE80211_SOFTMAC=m
+CONFIG_ACPI_SLEEP_PROC_FS=y
+CONFIG_NLS_CODEPAGE_932=m
+CONFIG_NLS_CODEPAGE_950=m
+CONFIG_NLS_CODEPAGE_860=m
+CONFIG_NLS_CODEPAGE_437=m
+CONFIG_9P_FS=m
+CONFIG_UNION_FS=y
+CONFIG_REISERFS_PROC_INFO=y
+CONFIG_INFINIBAND_USER_ACCESS=m
+CONFIG_JOYSTICK_GUILLEMOT=m
+CONFIG_JOYSTICK_ANALOG=m
+CONFIG_PPP_MPPE=m
+CONFIG_IEEE1394_EXTRA_CONFIG_ROMS=y
+CONFIG_IP6_NF_MATCH_HL=m
+CONFIG_YENTA=m
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_NLS_CODEPAGE_861=m
+CONFIG_NLS_CODEPAGE_852=m
+CONFIG_USB_SERIAL_OMNINET=m
+CONFIG_VIDEO_EM28XX=m
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_GAMEPORT_EMU10K1=m
+CONFIG_TOUCHSCREEN_ELO=m
+CONFIG_SERIO=y
+CONFIG_ABYSS=m
+CONFIG_DM_CRYPT=y
+CONFIG_IRNET=m
+CONFIG_NLS_CODEPAGE_862=m
+CONFIG_USB_SERIAL_KEYSPAN=m
+CONFIG_SND_CS46XX_NEW_DSP=y
+CONFIG_SCSI_FUTURE_DOMAIN=m
+CONFIG_MTD_NAND_VERIFY_WRITE=y
+CONFIG_NLS_CODEPAGE_863=m
+CONFIG_NLS_CODEPAGE_737=m
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_USB_ATI_REMOTE2=m
+CONFIG_VIDEO_TDA9840=m
+CONFIG_PPPOE=m
+CONFIG_NLS_CODEPAGE_936=m
+CONFIG_NLS_CODEPAGE_864=m
+CONFIG_NLS_CODEPAGE_855=m
+CONFIG_KARMA_PARTITION=y
+CONFIG_USB_DYNAMIC_MINORS=y
+CONFIG_USB_OV511=m
+CONFIG_VIDEO_ADV7175=m
+CONFIG_ZLIB_DEFLATE=m
+CONFIG_NET_VENDOR_3COM=y
+CONFIG_CLS_U32_MARK=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_NLS_CODEPAGE_874=m
+CONFIG_NLS_CODEPAGE_865=m
+CONFIG_NLS_CODEPAGE_775=m
+CONFIG_VIDEO_SAA6588=m
+CONFIG_PCMCIA_PCNET=m
+CONFIG_SMSC_PHY=m
+CONFIG_SCSI_SRP=m
+CONFIG_NETFILTER_XT_MATCH_HASHLIMIT=m
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=m
+CONFIG_ACPI_TOSHIBA=y
+CONFIG_NLS_CODEPAGE_866=m
+CONFIG_NLS_CODEPAGE_857=m
+CONFIG_HUGETLB_PAGE=y
+CONFIG_USB_SERIAL_SAFE=m
+CONFIG_JOYSTICK_IFORCE=m
+CONFIG_JOYSTICK_A3D=m
+CONFIG_IEEE80211_CRYPT_CCMP=m
+CONFIG_MKISS=m
+CONFIG_CLS_U32_PERF=y
+CONFIG_IA32_AOUT=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_IOMMU=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_USB_SERIAL_SAFE_PADDED=y
+CONFIG_SND_VX222=m
+CONFIG_VIDEO_SAA7146_VV=m
+CONFIG_W1=m
+CONFIG_ISDN_CAPI_CAPI20=m
+CONFIG_BCM43XX_D80211=m
+CONFIG_SIS900=m
+CONFIG_FB=y
+CONFIG_SATA_SVW=y
+CONFIG_BT_HCIBCM203X=m
+CONFIG_X86_POWERNOW_K8=y
+CONFIG_NLS_CODEPAGE_949=m
+CONFIG_USB_ZERO=m
+CONFIG_USB_TEST=m
+CONFIG_SOUND=y
+CONFIG_HWMON=y
+CONFIG_SIS190=m
+CONFIG_IP_NF_ARPTABLES=m
+CONFIG_ACPI_THERMAL=y
+CONFIG_NLS_CODEPAGE_869=m
+CONFIG_ATARI_PARTITION=y
+CONFIG_ROOT_NFS=y
+CONFIG_TMPFS=y
+CONFIG_QUOTA=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=m
+CONFIG_FONTS=y
+CONFIG_WANXL=m
+CONFIG_ASK_IP_FIB_HASH=y
+CONFIG_I2C_PIIX4=m
+CONFIG_KEYBOARD_NEWTON=y
+CONFIG_HOSTAP_FIRMWARE=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_CRYPTO_TWOFISH_COMMON=m
+CONFIG_ACORN_PARTITION=y
+CONFIG_USB_EMI26=m
+CONFIG_USB_EMI62=m
+CONFIG_USB_SERIAL_HP4X=m
+CONFIG_USB_SERIAL_KEYSPAN_USA19W=y
+CONFIG_USB_SERIAL_KEYSPAN_USA18X=y
+CONFIG_USB_TOUCHSCREEN=m
+CONFIG_SND_INDIGODJ=m
+CONFIG_VIDEO_HEXIUM_ORION=m
+CONFIG_VIDEO_TDA9875=m
+CONFIG_SENSORS_LM70=m
+CONFIG_IPMI_HANDLER=m
+CONFIG_SLIP_COMPRESSED=y
+CONFIG_PCMCIA_AXNET=m
+CONFIG_DUMMY=m
+CONFIG_PATA_NETCELL=y
+CONFIG_SCSI_DMX3191D=y
+CONFIG_BT_HCIUART_BCSP=y
+CONFIG_IP_VS_DH=m
+CONFIG_PLIST=y
+CONFIG_FUTEX=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28X=y
+CONFIG_USB_SERIAL_FUNSOFT=m
+CONFIG_SND_RME32=m
+CONFIG_VIDEO_MSP3400=m
+CONFIG_SENSORS_LM80=m
+CONFIG_SERIO_LIBPS2=y
+CONFIG_IPW3945_PROMISCUOUS=y
+CONFIG_IP_NF_MATCH_ECN=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_USB_GADGETFS=m
+CONFIG_USB_NET_CDC_SUBSET=m
+CONFIG_SENSORS_LM90=m
+CONFIG_SENSORS_LM63=m
+CONFIG_JOYSTICK_DB9=m
+CONFIG_PCMCIA_RAYCS=m
+CONFIG_TULIP=m
+CONFIG_EXPERIMENTAL=y
+CONFIG_RXRPC=m
+CONFIG_USB_SERIAL_KEYSPAN_USA49W=y
+CONFIG_USB_KEYSPAN_REMOTE=m
+CONFIG_SND_CA0106=m
+CONFIG_NETWORK_SECMARK=y
+CONFIG_IP_VS_LC=m
+CONFIG_X86_64=y
+CONFIG_OCFS2_DEBUG_MASKLOG=y
+CONFIG_USB_EHCI_HCD=m
+CONFIG_SENSORS_LM92=m
+CONFIG_SENSORS_LM83=m
+CONFIG_RT2X00=y
+CONFIG_IEEE1394_VIDEO1394=m
+CONFIG_INPUT=y
+CONFIG_DVB_TUNER_MT2060=m
+CONFIG_DVB_L64781=m
+CONFIG_VIDEO_BWQCAM=m
+CONFIG_SENSORS_LM75=m
+CONFIG_I2C_AMD756=m
+CONFIG_MD=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+CONFIG_BLK_CPQ_CISS_DA=y
+CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT=y
+CONFIG_LOCALVERSION=""
+CONFIG_SMB_NLS_DEFAULT=y
+CONFIG_USB_DEVICEFS=y
+CONFIG_SND_MAESTRO3=m
+CONFIG_SENSORS_LM85=m
+CONFIG_SERIO_PCIPS2=y
+CONFIG_STRIP=m
+CONFIG_MTD_DOCPROBE=m
+CONFIG_AUDITSYSCALL=y
+CONFIG_USB_SERIAL_IPAQ=m
+CONFIG_VIDEO_CX2341X=m
+CONFIG_SENSORS_LM77=m
+CONFIG_TCG_INFINEON=m
+CONFIG_PATA_OPTIDMA=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_IP6_NF_MATCH_RT=m
+CONFIG_ZLIB_INFLATE=y
+CONFIG_X86_SPEEDSTEP_CENTRINO=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_DVB_B2C2_FLEXCOP=m
+CONFIG_SENSORS_LM87=m
+CONFIG_SENSORS_LM78=m
+CONFIG_FORCEDETH=m
+CONFIG_I2O_BLOCK=y
+CONFIG_IP_NF_ARPFILTER=m
+CONFIG_SUSPEND2_CRYPTO=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_GFS2_FS_LOCKING_NOLOCK=m
+CONFIG_SERIO_PARKBD=y
+CONFIG_SCSI_SAS_LIBSAS=m
+CONFIG_IP_ROUTE_MULTIPATH_CACHED=y
+CONFIG_MICROCODE=m
+CONFIG_SND_INDIGOIO=m
+CONFIG_VIDEO_SELECT=y
+CONFIG_PATA_WINBOND=y
+CONFIG_CFG80211_WEXT_COMPAT=y
+CONFIG_BT=m
+CONFIG_SIGMATEL_FIR=m
+CONFIG_NET_CLS_TCINDEX=m
+CONFIG_NETFILTER_XT_TARGET_CONNMARK=m
+CONFIG_NF_CONNTRACK=m
+CONFIG_JFFS2_COMPRESSION_OPTIONS=y
+CONFIG_USB_SERIAL_MCT_U232=m
+CONFIG_USB_EHCI_SPLIT_ISO=y
+CONFIG_SND_RME96=m
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_LAPBETHER=m
+CONFIG_BROADCOM_PHY=m
+CONFIG_PATA_JMICRON=y
+CONFIG_MTD_DILNETPC=m
+CONFIG_NF_CONNTRACK_AMANDA=m
+CONFIG_ACPI_BATTERY=y
+CONFIG_SND_OPL3_LIB=m
+CONFIG_BACKLIGHT_DEVICE=y
+CONFIG_USB_KONICAWC=m
+CONFIG_VIDEO_USBVISION=m
+CONFIG_SENSORS_IT87=m
+CONFIG_I2O_LCT_NOTIFY_ON_CHANGES=y
+CONFIG_PATA_MARVELL=y
+CONFIG_SCSI_LOGGING=y
+CONFIG_BRIDGE_EBT_REDIRECT=m
+CONFIG_NETFILTER_XT_MATCH_CONNBYTES=m
+CONFIG_SYSFS=y
+CONFIG_NFS_DIRECTIO=y
+CONFIG_MTD_ONENAND_OTP=y
+CONFIG_USB_OHCI_HCD=m
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_PATA_PDC_OLD=y
+CONFIG_TCP_CONG_BIC=y
+CONFIG_SUSPEND2_KEEP_IMAGE=y
+CONFIG_X86_CPUID=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_STOP_MACHINE=y
+CONFIG_USB_SERIAL_KLSI=m
+CONFIG_USB_ALI_M5632=y
+CONFIG_DVB_AV7110=m
+CONFIG_VIDEO_VPX3220=m
+CONFIG_VIDEO_TVP5150=m
+CONFIG_SCSI_EATA_TAGGED_QUEUE=y
+CONFIG_BT_HCIBTUART=m
+CONFIG_NETFILTER_XT_MATCH_STATISTIC=m
+CONFIG_NETFILTER_XT_TARGET_CLASSIFY=m
+CONFIG_INET6_TUNNEL=m
+CONFIG_IP_VS_SH=m
+CONFIG_X86_64_ACPI_NUMA=y
+CONFIG_USB_SERIAL_SIERRAWIRELESS=m
+CONFIG_VIDEO_SAA711X=m
+CONFIG_NET_SB1000=m
+CONFIG_AIC79XX_RESET_DELAY_MS=15000
+CONFIG_IEEE80211_CRYPT_TKIP=m
+CONFIG_NET_ACT_GACT=m
+CONFIG_NET_EMATCH_TEXT=m
+CONFIG_USB_GADGET_SELECTED=y
+CONFIG_USB_TOUCHSCREEN_EGALAX=y
+CONFIG_JOYSTICK_ADI=m
+CONFIG_SATA_AHCI=y
+CONFIG_SCSI_AIC7XXX=y
+CONFIG_PARPORT_PC_FIFO=y
+CONFIG_ACPI_DOCK=y
+CONFIG_PM=y
+CONFIG_CRYPTO_BLOWFISH=m
+CONFIG_INFINIBAND_MTHCA=m
+CONFIG_SOUND_KAHLUA=m
+CONFIG_FB_SAVAGE=m
+CONFIG_ADM8211=m
+CONFIG_PATA_OLDPIIX=y
+CONFIG_MTD_CFI_STAA=m
+CONFIG_NET_SCH_INGRESS=m
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+CONFIG_USB_QUICKCAM_MESSENGER=m
+CONFIG_IP_NF_MANGLE=m
+CONFIG_IP_VS_NQ=m
+CONFIG_ACORN_PARTITION_CUMANA=y
+CONFIG_CRYPTO_CAST5=m
+CONFIG_USB_STORAGE_DATAFAB=y
+CONFIG_USB_UHCI_HCD=m
+CONFIG_FB_RADEON=m
+CONFIG_PARPORT_PC_SUPERIO=y
+CONFIG_IPV6_MIP6=y
+CONFIG_CRYPTO_CAST6=m
+CONFIG_DCDBAS=m
+CONFIG_INFINIBAND_USER_MAD=m
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_SND_BT87X=m
+CONFIG_HAPPYMEAL=m
+CONFIG_IP_VS=m
+CONFIG_IP_ROUTE_MULTIPATH_RR=m
+CONFIG_SND_FM801_TEA575X=m
+CONFIG_SND_MTS64=m
+CONFIG_SPECIALIX=m
+CONFIG_IPV6_PRIVACY=y
+CONFIG_X86_PM_TIMER=y
+CONFIG_HZ=1000
+CONFIG_LDM_DEBUG=y
+CONFIG_USB_AN2720=y
+CONFIG_SND_AD1889=m
+CONFIG_FONT_SUN8x16=y
+CONFIG_TOUCHSCREEN_TOUCHRIGHT=m
+CONFIG_ACENIC=m
+CONFIG_PATA_TRIFLEX=y
+CONFIG_PATA_EFAR=y
+CONFIG_SMC_IRCC_FIR=m
+CONFIG_NETFILTER_XT_MATCH_HELPER=m
+CONFIG_HUGETLBFS=y
+CONFIG_INFINIBAND_IPOIB=m
+CONFIG_ISDN_DIVAS_DIVACAPI=m
+CONFIG_WAN_ROUTER_DRIVERS=m
+CONFIG_HDLC_RAW_ETH=m
+CONFIG_PATA_RADISYS=y
+CONFIG_SATA_INTEL_COMBINED=y
+CONFIG_MTD_NAND_IDS=m
+CONFIG_MTD_PHYSMAP_LEN=0x4000000
+CONFIG_IP_VS_RR=m
+CONFIG_INET_DIAG=y
+CONFIG_NLS_ISO8859_1=m
+CONFIG_I2C_SIS630=m
+CONFIG_NET_ETHERNET=y
+CONFIG_NET_SCH_GRED=m
+CONFIG_NETFILTER_XT_MATCH_LENGTH=m
+CONFIG_ACPI_BLACKLIST_YEAR=0
+CONFIG_NLS_ISO8859_2=m
+CONFIG_FONT_6x11=y
+CONFIG_ATM_LANAI=m
+CONFIG_TR=y
+CONFIG_NS83820=m
+CONFIG_SCSI_NETLINK=y
+CONFIG_REED_SOLOMON=m
+CONFIG_IP6_NF_QUEUE=m
+CONFIG_NLS_ISO8859_3=m
+CONFIG_INFINIBAND_IPATH=m
+CONFIG_MMC_SDHCI=m
+CONFIG_MMC_BLOCK=m
+CONFIG_USB_MICROTEK=m
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_SOUND_SSCAPE=m
+CONFIG_VIDEO_ZORAN_DC10=m
+CONFIG_SC1200_WDT=m
+CONFIG_SATA_PROMISE=y
+CONFIG_TIFM_7XX1=m
+CONFIG_NET_SCH_HFSC=m
+CONFIG_NET_SCH_FIFO=y
+CONFIG_NLS_ISO8859_4=m
+CONFIG_USB_EPSON2888=y
+CONFIG_SND_BT87X_OVERCLOCK=y
+CONFIG_MOUSE_SERIAL=y
+CONFIG_DE2104X=m
+CONFIG_DM_MULTIPATH=m
+CONFIG_MD_MULTIPATH=y
+CONFIG_PARIDE_PD=m
+CONFIG_NLS_ISO8859_5=m
+CONFIG_SND_CS4281=m
+CONFIG_VIDEO_ZORAN_DC30=m
+CONFIG_SBC_EPX_C3_WATCHDOG=m
+CONFIG_ATM_BR2684=m
+CONFIG_NLS_ISO8859_6=m
+CONFIG_USB_LIBUSUAL=y
+CONFIG_FONT_7x14=y
+CONFIG_USB_ZC0301=m
+CONFIG_VT=y
+CONFIG_B44=m
+CONFIG_BLK_DEV_UMEM=y
+CONFIG_PARIDE_PF=m
+CONFIG_ISDN_CAPI=m
+CONFIG_MIGRATION=y
+CONFIG_NLS_ISO8859_7=m
+CONFIG_NLS_CODEPAGE_1250=m
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SND_AU8810=m
+CONFIG_SENSORS_SMSC47M1=m
+CONFIG_SX=m
+CONFIG_ZD1211RW_D80211=m
+CONFIG_USB_ZD1201=m
+CONFIG_MD_LINEAR=y
+CONFIG_SATA_VITESSE=y
+CONFIG_PARIDE_PG=m
+CONFIG_CONNECTOR=y
+CONFIG_IP_NF_MATCH_TTL=m
+CONFIG_NLS_CODEPAGE_1251=m
+CONFIG_NLS_ISO8859_8=m
+CONFIG_GFS2_FS_LOCKING_DLM=m
+CONFIG_USB_NET_RNDIS_HOST=m
+CONFIG_SND_AU8820=m
+CONFIG_ARCNET_RIM_I=m
+CONFIG_MD_RAID5_RESHAPE=y
+CONFIG_SCSI_EATA=m
+CONFIG_VLAN_8021Q=m
+CONFIG_GENERIC_PENDING_IRQ=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_NLS_ISO8859_9=m
+CONFIG_NCPFS_OS2_NS=y
+CONFIG_USB_KBTAB=m
+CONFIG_SND_AU8830=m
+CONFIG_FONT_8x16=y
+CONFIG_VIDEO_DPC=m
+CONFIG_EUROTECH_WDT=m
+CONFIG_NET_SCHED=y
+CONFIG_IP_NF_MATCH_TOS=m
+CONFIG_BRIDGE=m
+CONFIG_INET6_ESP=m
+CONFIG_NETFILTER=y
+CONFIG_PCMCIA=m
+CONFIG_PCCARD=y
+CONFIG_ACPI_NUMA=y
+CONFIG_SPARSEMEM=y
+CONFIG_BASE_FULL=y
+CONFIG_RTC_DRV_V3020=m
+CONFIG_SND_RTCTIMER=m
+CONFIG_ISDN_DRV_AVMB1_B1PCMCIA=m
+CONFIG_PCI_ATMEL=m
+CONFIG_VIA_VELOCITY=m
+CONFIG_PATA_CYPRESS=y
+CONFIG_SCSI_SYM53C8XX_MMIO=y
+CONFIG_SCSI_SYM53C8XX_2=y
+CONFIG_CRC_CCITT=m
+CONFIG_IP_MULTICAST=y
+CONFIG_USB_G_SERIAL=m
+CONFIG_FIXED_MII_10_FDX=y
+CONFIG_MD_RAID456=y
+CONFIG_MTD_BLOCK_RO=m
+CONFIG_MTD_BLOCK=m
+CONFIG_NET_IPGRE_BROADCAST=y
+CONFIG_NCPFS_EXTRAS=y
+CONFIG_USB_SL811_HCD=m
+CONFIG_VIDEO_ZORAN_BUZ=m
+CONFIG_TCG_ATMEL=m
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_MTD_NAND_DISKONCHIP=m
+CONFIG_MTD_M25P80=m
+CONFIG_IRDA_FAST_RR=y
+CONFIG_USB_TOUCHSCREEN_PANJIT=y
+CONFIG_SND_ES1938=m
+CONFIG_ADAPTEC_STARFIRE=m
+CONFIG_ATA_OVER_ETH=m
+CONFIG_GACT_PROB=y
+CONFIG_IP_NF_FILTER=m
+CONFIG_PM_LEGACY=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_SND_AC97_POWER_SAVE=y
+CONFIG_FB_SPLASH=y
+CONFIG_FB_DDC=m
+CONFIG_VIDEO_CX88_VP3054=m
+CONFIG_EPIC100=m
+CONFIG_EQUALIZER=m
+CONFIG_INET6_XFRM_MODE_TRANSPORT=m
+CONFIG_RTC_DRV_X1205=m
+CONFIG_SC6600_JOY=y
+CONFIG_FB_3DFX_ACCEL=y
+CONFIG_VIDEO_BUF=m
+CONFIG_AGP_INTEL=m
+CONFIG_MOXA_SMARTIO=m
+CONFIG_IPW2100=m
+CONFIG_IEEE1394_DV1394=m
+CONFIG_MTD_CFI_UTIL=m
+CONFIG_BT_HCIUSB=m
+CONFIG_DECNET=m
+CONFIG_NETFILTER_XT_MATCH_MULTIPORT=m
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_TARGET_NFLOG=m
+CONFIG_FW_LOADER=y
+CONFIG_CRYPTO_SHA512=m
+CONFIG_SND_ES1968=m
+CONFIG_NET_WIRELESS=y
+CONFIG_IPW2200=m
+CONFIG_TIGON3=m
+CONFIG_MTD_CK804XROM=m
+CONFIG_NETFILTER_XT_MATCH_MAC=m
+CONFIG_EARLY_PRINTK=y
+CONFIG_NLS_ASCII=m
+CONFIG_USB_MDC800=m
+CONFIG_DVB_SP8870=m
+CONFIG_VIDEO_SAA7134_DVB=m
+CONFIG_VIDEO_DEV=m
+CONFIG_VIA_RHINE=m
+CONFIG_PARIDE=y
+CONFIG_MTD_TS5500=m
+CONFIG_NET_RADIO=y
+CONFIG_BRIDGE_EBT_ARPREPLY=m
+CONFIG_XFRM_SUB_POLICY=y
+CONFIG_NCPFS_STRONG=y
+CONFIG_FB_PM2=m
+CONFIG_BCM43XX_D80211_DMA_AND_PIO_MODE=y
+CONFIG_SCSI_LPFC=y
+CONFIG_NET_ACT_SIMP=m
+CONFIG_IP_DCCP_CCID2=m
+CONFIG_MODULE_FORCE_UNLOAD=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_USB_SERIAL_KEYSPAN_PDA=m
+CONFIG_SND_ALS300=m
+CONFIG_LCD_CLASS_DEVICE=m
+CONFIG_FB_HGA=m
+CONFIG_VIDEO_PVRUSB2_24XXX=y
+CONFIG_IP_DCCP_CCID3=m
+CONFIG_X86_ACPI_CPUFREQ=y
+CONFIG_ISO9660_FS=y
+CONFIG_SND_VXPOCKET=m
+CONFIG_FB_TRIDENT_ACCEL=y
+CONFIG_SCSI_GDTH=y
+CONFIG_TIFM_CORE=m
+CONFIG_PARIDE_PT=m
+CONFIG_BRIDGE_EBT_AMONG=m
+CONFIG_PACKET=y
+CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+CONFIG_ACPI_ASUS=y
+CONFIG_X86_PC=y
+CONFIG_CRYPTO_SHA256=m
+CONFIG_USB_ARMLINUX=y
+CONFIG_AEDSP16_SBPRO=y
+CONFIG_SND_SERIAL_U16550=m
+CONFIG_USB_VICAM=m
+CONFIG_TUNER_3036=m
+CONFIG_DVB_BT8XX=m
+CONFIG_BCM43XX_D80211_DMA=y
+CONFIG_YELLOWFIN=m
+CONFIG_AIC79XX_DEBUG_ENABLE=y
+CONFIG_PARIDE_EPATC8=y
+CONFIG_BT_RFCOMM=m
+CONFIG_DONGLE=y
+CONFIG_NET_SCH_TEQL=m
+CONFIG_BRIDGE_NETFILTER=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_NCPFS_IOCTL_LOCKING=y
+CONFIG_JFS_SECURITY=y
+CONFIG_FS_POSIX_ACL=y
+CONFIG_AEDSP16_MPU401=y
+CONFIG_I2C_AMD8111=m
+CONFIG_COMPUTONE=m
+CONFIG_R8169_VLAN=y
+CONFIG_NETFILTER_XT_MATCH_STRING=m
+CONFIG_NF_CT_PROTO_GRE=m
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_SCHED_SMT=y
+CONFIG_FB_SAVAGE_I2C=y
+CONFIG_HPET_MMAP=y
+CONFIG_AIC7XXX_RESET_DELAY_MS=15000
+CONFIG_SCSI_3W_9XXX=y
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_INET6_XFRM_MODE_TUNNEL=m
+CONFIG_FIB_RULES=y
+CONFIG_QNX4FS_FS=y
+CONFIG_CRAMFS=m
+CONFIG_USB_TOUCHSCREEN_ETURBO=y
+CONFIG_SOUND_AEDSP16=m
+CONFIG_SOUND_ICH=m
+CONFIG_SND_HWDEP=m
+CONFIG_VIDEO_PVRUSB2_29XXX=y
+CONFIG_FUSION_FC=y
+CONFIG_MTD_PHRAM=m
+CONFIG_NET_SCH_CLK_JIFFIES=y
+CONFIG_ACORN_PARTITION_RISCIX=y
+CONFIG_FB_RADEON_I2C=y
+CONFIG_FB_ARC=m
+CONFIG_VIDEO_MXB=m
+CONFIG_VIDEO_ZORAN_LML33R10=m
+CONFIG_VIDEO_SAA5246A=m
+CONFIG_SERIO_CT82C710=y
+CONFIG_JOYSTICK_SIDEWINDER=m
+CONFIG_MOUSE_PS2=y
+CONFIG_ARCNET=m
+CONFIG_SCSI_PROC_FS=y
+CONFIG_MCP2120_DONGLE=m
+CONFIG_NET_SCH_PRIO=m
+CONFIG_IP_NF_MATCH_IPRANGE=m
+CONFIG_NETFILTER_XT_MATCH_TCPMSS=m
+CONFIG_NET_IPGRE=m
+CONFIG_RTC_CLASS=y
+CONFIG_USB_SERIAL_EDGEPORT_TI=m
+CONFIG_USB_STORAGE_FREECOM=y
+CONFIG_VIDEO_CX88_BLACKBIRD=m
+CONFIG_VIDEO_HEXIUM_GEMINI=m
+CONFIG_IBMASR=m
+CONFIG_FEALNX=m
+CONFIG_WIRELESS_EXT=y
+CONFIG_ECONET=m
+CONFIG_IP_ROUTE_MULTIPATH_RANDOM=m
+CONFIG_I2C=m
+CONFIG_USB_SERIAL_CP2101=m
+CONFIG_FB_CIRRUS=m
+CONFIG_ISDN_CAPI_CAPIFS=m
+CONFIG_HW_RANDOM=y
+CONFIG_MTD_PMC551=m
+CONFIG_X25=m
+CONFIG_BRIDGE_EBT_T_FILTER=m
+CONFIG_PCCARD_NONSTATIC=m
+CONFIG_NEED_MULTIPLE_NODES=y
+CONFIG_NCPFS_NFS_NS=y
+CONFIG_INOTIFY_USER=y
+CONFIG_USB_WACOM=m
+CONFIG_HID_FF=y
+CONFIG_SND_HDSPM=m
+CONFIG_SENSORS_W83627EHF=m
+CONFIG_PCIPCWATCHDOG=m
+CONFIG_INPUT_JOYDEV=m
+CONFIG_FIXED_PHY=m
+CONFIG_CRYPTO_CRC32C=y
+CONFIG_USB_SERIAL_AIRPRIME=m
+CONFIG_I2C_ALI1535=m
+CONFIG_MACHZ_WDT=m
+CONFIG_PATA_OPTI=y
+CONFIG_ISCSI_TCP=m
+CONFIG_X86_HT=y
+CONFIG_USB_SERIAL_EDGEPORT=m
+CONFIG_I2C_ALI1563=m
+CONFIG_INPUT_PCSPKR=m
+CONFIG_HZ_1000=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_VIDEO_TEA6415C=m
+CONFIG_WAFER_WDT=m
+CONFIG_SHAPER=m
+CONFIG_BCM43XX_D80211_PCI=y
+CONFIG_CHR_DEV_OSST=y
+CONFIG_MTD_SLRAM=m
+CONFIG_MICROCODE_OLD_INTERFACE=y
+CONFIG_VIDEO_UPD64083=m
+CONFIG_PHONE_IXJ=m
+CONFIG_HOSTAP_CS=m
+CONFIG_HERMES=m
+CONFIG_COMPAT=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE=1
+CONFIG_USB_HIDINPUT_POWERBOOK=y
+CONFIG_SND_GINA20=m
+CONFIG_SND_TIMER=y
+CONFIG_DVB_BUDGET_PATCH=m
+CONFIG_I2C_PROSAVAGE=m
+CONFIG_PCMCIA_NMCLAN=m
+CONFIG_IPW3945=m
+CONFIG_MD_FAULTY=y
+CONFIG_BRIDGE_EBT_LIMIT=m
+CONFIG_NCPFS_NLS=y
+CONFIG_USB_SERIAL_DIGI_ACCELEPORT=m
+CONFIG_RADIO_GEMTEK_PCI=m
+CONFIG_VIDEO_CS53L32A=m
+CONFIG_MTD_BLOCK2MTD=m
+CONFIG_X86=y
+CONFIG_JOLIET=y
+CONFIG_W1_CON=y
+CONFIG_8139TOO=m
+CONFIG_MTD_L440GX=m
+CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED=y
+CONFIG_IEEE80211_RADIOTAP=y
+CONFIG_D80211_LEDS=y
+CONFIG_IRCOMM=m
+CONFIG_XFS_SECURITY=y
+CONFIG_USB_RIO500=m
+CONFIG_FB_SIS_300=y
+CONFIG_N_HDLC=m
+CONFIG_PHYLIB=m
+CONFIG_AIC79XX_CMDS_PER_DEVICE=32
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_CRYPTO_TGR192=m
+CONFIG_KVM_INTEL=m
+CONFIG_SND_PCXHR=m
+CONFIG_SND_GINA24=m
+CONFIG_JOYSTICK_GAMECON=m
+CONFIG_MTD_AMD76XROM=m
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_ACORN_PARTITION_ICS=y
+CONFIG_DVB_LNBP21=m
+CONFIG_I2O=y
+CONFIG_IEEE1394_RAWIO=m
+CONFIG_NF_CONNTRACK_EVENTS=y
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_SPARSEMEM_MANUAL=y
+CONFIG_X86_GOOD_APIC=y
+CONFIG_SND_MPU401=m
+CONFIG_FONT_SUN12x22=y
+CONFIG_FB_ATY_CT=y
+CONFIG_HWMON_VID=m
+CONFIG_WDTPCI=m
+CONFIG_SERIO_RAW=m
+CONFIG_DM_MIRROR=y
+CONFIG_PCMCIA_QLOGIC=m
+CONFIG_NETFILTER_XT_MATCH_ESP=m
+CONFIG_USB_SERIAL_PL2303=m
+CONFIG_SOUND_PAS=m
+CONFIG_SND_MTPAV=m
+CONFIG_MTD_DATAFLASH=m
+CONFIG_CFG80211=y
+CONFIG_IP_NF_TARGET_CLUSTERIP=m
+CONFIG_EDD=m
+CONFIG_SND_INTEL8X0M=m
+CONFIG_PPP_ASYNC=m
+CONFIG_NET_EMATCH_STACK=32
+CONFIG_USB_SERIAL_KEYSPAN_USA28XA=y
+CONFIG_FB_SIS_315=y
+CONFIG_DVB_CX24110=m
+CONFIG_VIDEO_SAA7134_OSS=m
+CONFIG_USBPCWATCHDOG=m
+CONFIG_ATM_HE=m
+CONFIG_NET_WIRELESS_RTNETLINK=y
+CONFIG_MTD_NAND_NANDSIM=m
+CONFIG_ACT200L_DONGLE=m
+CONFIG_IP_NF_TARGET_REJECT=m
+CONFIG_NFS_V3=y
+CONFIG_USB_SERIAL_KEYSPAN_USA19QI=y
+CONFIG_USB_SERIAL_KEYSPAN_USA28XB=y
+CONFIG_DVB_B2C2_FLEXCOP_PCI=m
+CONFIG_BCM43XX_D80211_PIO=y
+CONFIG_HOSTAP=m
+CONFIG_SUNGEM=m
+CONFIG_QSEMI_PHY=m
+CONFIG_NET_FC=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_NFS_V4=y
+CONFIG_JBD=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_SND_DUMMY=m
+CONFIG_JOYSTICK_IFORCE_USB=y
+CONFIG_PHONE_IXJ_PCMCIA=m
+CONFIG_PCMCIA_HERMES=m
+CONFIG_TMSPCI=m
+CONFIG_USB_APPLEDISPLAY=m
+CONFIG_USB_SERIAL_KEYSPAN_MPR=y
+CONFIG_USB_NET_CDCETHER=m
+CONFIG_DVB_CX22700=m
+CONFIG_IFB=m
+CONFIG_GIRBIL_DONGLE=m
+CONFIG_DEFAULT_TCP_CONG="bic"
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_AFS_FS=m
+CONFIG_INFINIBAND=m
+CONFIG_USB_EZUSB=y
+CONFIG_FIRMWARE_EDID=y
+CONFIG_DVB_CINERGYT2=m
+CONFIG_DVB_S5H1420=m
+CONFIG_DVB_CX24123=m
+CONFIG_IDE=y
+CONFIG_NET_CLS_RSVP=m
+CONFIG_GENERIC_IOMAP=y
+CONFIG_ZONE_DMA32=y
+CONFIG_BFS_FS=m
+CONFIG_FAT_FS=y
+CONFIG_EXT4DEV_FS_SECURITY=y
+CONFIG_RTC_DRV_TEST=m
+CONFIG_SND_PDAUDIOCF=m
+CONFIG_FB_ATY_GX=y
+CONFIG_DVB_CX22702=m
+CONFIG_I2C_SIS96X=m
+CONFIG_JOYSTICK_TURBOGRAFX=m
+CONFIG_MTD_NAND_CAFE=m
+CONFIG_NF_CONNTRACK_IRC=m
+CONFIG_SUSPEND2_FILE=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_INPUT_UINPUT=m
+CONFIG_TOUCHSCREEN_MK712=m
+CONFIG_NET_TULIP=y
+CONFIG_FUSION=y
+CONFIG_IP_MROUTE=y
+CONFIG_DYN_PAGEFLAGS=y
+CONFIG_USB_TOUCHSCREEN_ITM=y
+CONFIG_HID=y
+CONFIG_FB_ATY=m
+CONFIG_VIDEO_TLV320AIC23B=m
+CONFIG_SCSI_STEX=y
+CONFIG_BT_HCIBT3C=m
+CONFIG_NETROM=m
+CONFIG_IP_NF_RAW=m
+CONFIG_IP6_NF_MANGLE=m
+CONFIG_NF_CONNTRACK_H323=m
+CONFIG_X86_MCE_INTEL=y
+CONFIG_EFS_FS=m
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_ZISOFS_FS=y
+CONFIG_USB_SERIAL_EMPEG=m
+CONFIG_FB_SIS=m
+CONFIG_DVB_OR51211=m
+CONFIG_DVB_BCM3510=m
+CONFIG_SMSC37B787_WDT=m
+CONFIG_E100=m
+CONFIG_SATA_SIL24=y
+CONFIG_ATA=y
+CONFIG_IP_DCCP_TFRC_LIB=m
+CONFIG_IP_NF_TARGET_NETMAP=m
+CONFIG_NF_NAT=m
+CONFIG_UNAME_RELEASE="2.6.20-sabayon-r1"
+CONFIG_UDF_FS=y
+CONFIG_SCTP_HMAC_MD5=y
+CONFIG_NF_NAT_AMANDA=m
+CONFIG_NLS_ISO8859_13=m
+CONFIG_FONT_10x18=y
+CONFIG_DVB_OR51132=m
+CONFIG_AIC7XXX_DEBUG_ENABLE=y
+CONFIG_AGP=y
+CONFIG_PRINTK=y
+CONFIG_NLS_ISO8859_14=m
+CONFIG_NCP_FS=m
+CONFIG_RPCSEC_GSS_SPKM3=m
+CONFIG_HFS_FS=y
+CONFIG_USB_LD=m
+CONFIG_USB_SERIAL_FTDI_SIO=m
+CONFIG_JOYSTICK_GF2K=m
+CONFIG_NET_EMATCH_NBYTE=m
+CONFIG_NLS_ISO8859_15=m
+CONFIG_SMB_FS=y
+CONFIG_XFS_QUOTA=y
+CONFIG_INTEL_IOATDMA=m
+CONFIG_USB_ACECAD=m
+CONFIG_BT_SCO=m
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_VS_PROTO_TCP=y
+CONFIG_DMI=y
+CONFIG_SUNRPC=y
+CONFIG_SQUASHFS_VMALLOC=y
+CONFIG_JFS_FS=y
+CONFIG_FS_MBCACHE=y
+CONFIG_SOUND_MSS=m
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SCSI_AIC7XXX_OLD=y
+CONFIG_LLC=y
+CONFIG_IP6_NF_TARGET_HL=m
+CONFIG_IP_VS_PROTO_ESP=y
+CONFIG_XFRM_USER=m
+CONFIG_CPU_FREQ_GOV_POWERSAVE=y
+CONFIG_DVB=y
+CONFIG_ADVANTECH_WDT=m
+CONFIG_ISDN_DIVAS_MAINT=m
+CONFIG_CRC_ITU_T=m
+CONFIG_DM_MULTIPATH_EMC=m
+CONFIG_MTD_DOC2000=m
+CONFIG_TEKRAM_DONGLE=m
+CONFIG_DEV_APPLETALK=m
+CONFIG_BRIDGE_EBT_T_NAT=m
+CONFIG_IP_VS_SED=m
+CONFIG_IP_VS_PROTO_UDP=y
+CONFIG_SUSPEND2_CORE=y
+CONFIG_HAVE_MEMORY_PRESENT=y
+CONFIG_PCI=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_IPC_NS=y
+CONFIG_DLM=m
+CONFIG_MMC=m
+CONFIG_USB_FILE_STORAGE=m
+CONFIG_USB_PHIDGETSERVO=m
+CONFIG_USB_SERIAL_KEYSPAN_USA19QW=y
+CONFIG_USB_USS720=m
+CONFIG_SOUND_OSS=m
+CONFIG_SND_ECHO3G=m
+CONFIG_DVB_SP887X=m
+CONFIG_DVB_B2C2_FLEXCOP_USB=m
+CONFIG_DVB_ZL10353=m
+CONFIG_VIDEO_V4L1=y
+CONFIG_ISDN_DRV_AVMB1_B1PCI=m
+CONFIG_AMD8111_ETH=m
+CONFIG_BLK_DEV_DAC960=y
+CONFIG_MTD_DOCPROBE_55AA=y
+CONFIG_MTD_DOC2001=m
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_IKCONFIG_PROC=y
+CONFIG_ZISOFS=y
+CONFIG_USB_UEAGLEATM=m
+CONFIG_USB_BANDWIDTH=y
+CONFIG_SOUND_PSS=m
+CONFIG_VIDEO_V4L2=y
+CONFIG_PCMCIA_XIRCOM=m
+CONFIG_PATA_SC1200=y
+CONFIG_BT_HCIDTL1=m
+CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+CONFIG_BUG=y
+CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE=1
+CONFIG_NFS_FS=y
+CONFIG_IPMI_WATCHDOG=m
+CONFIG_PCNET32=m
+CONFIG_ULI526X=m
+CONFIG_MII=y
+CONFIG_FIXED_MII_100_FDX=y
+CONFIG_I2O_CONFIG=y
+CONFIG_BRIDGE_EBT_IP=m
+CONFIG_NF_CONNTRACK_FTP=m
+CONFIG_SND_ICE1712=m
+CONFIG_DVB_AV7110_OSD=y
+CONFIG_ARCNET_1201=m
+CONFIG_BT_HCIUART_H4=y
+CONFIG_NF_CONNTRACK_ENABLED=m
+CONFIG_USB_STORAGE_DPCM=y
+CONFIG_DVB_BUDGET_CI=m
+CONFIG_VIDEO_PVRUSB2_SYSFS=y
+CONFIG_VIDEO_CX88=m
+CONFIG_DVB_FE_CUSTOMISE=y
+CONFIG_P54_COMMON=m
+CONFIG_IP_NF_ARP_MANGLE=m
+CONFIG_NF_CONNTRACK_SIP=m
+CONFIG_CRYPTO=y
+CONFIG_LCD_DEVICE=y
+CONFIG_MTD_CFI_INTELEXT=m
+CONFIG_ATM=m
+CONFIG_SYSCTL=y
+CONFIG_SND_ICE1724=m
+CONFIG_DRM=m
+CONFIG_SERIAL_8250_CS=m
+CONFIG_ARCNET_1051=m
+CONFIG_SND_ATIIXP_MODEM=m
+CONFIG_USB_STV680=m
+CONFIG_I2C_SIS5595=m
+CONFIG_I2C_ALI15X3=m
+CONFIG_SPECIALIX_RTSCTS=y
+CONFIG_CYCLADES_SYNC=m
+CONFIG_ARCNET_COM20020_CS=m
+CONFIG_CDROM_PKTCDVD=y
+CONFIG_ECONET_NATIVE=y
+CONFIG_SND=y
+CONFIG_SENSORS_W83L785TS=m
+CONFIG_ISI=m
+CONFIG_ATP=m
+CONFIG_CICADA_PHY=m
+CONFIG_MTD_DOCECC=m
+CONFIG_MTD=m
+CONFIG_IP_ROUTE_MULTIPATH_DRR=m
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_UFS_FS=y
+CONFIG_DVB_USB_NOVA_T_USB2=m
+CONFIG_WAN=y
+CONFIG_FTL=m
+CONFIG_IP_VS_WLC=m
+CONFIG_IP_PNP=y
+CONFIG_ACPI_HOTPLUG_CPU=y
+CONFIG_DMA_ENGINE=y
+CONFIG_DVB_TTUSB_BUDGET=m
+CONFIG_DVB_TDA8083=m
+CONFIG_ISDN_CAPI_MIDDLEWARE=y
+CONFIG_PATA_CS5520=y
+CONFIG_AIC7XXX_CMDS_PER_DEVICE=32
+CONFIG_MTD_PNC2000=m
+CONFIG_YAM=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP_NF_TARGET_ECN=m
+CONFIG_HT_IRQ=y
+CONFIG_NET=y
+CONFIG_KERNELVERSION="2.6.20-sabayon-r1"
+CONFIG_JFFS2_SUMMARY=y
+CONFIG_SND_ALS4000=m
+CONFIG_I2C_OCORES=m
+CONFIG_SSB=m
+CONFIG_VORTEX=m
+CONFIG_PATA_CS5530=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_XFS_FS=y
+CONFIG_FS_XIP=y
+CONFIG_SND_ALI5451=m
+CONFIG_RADIO_MAESTRO=m
+CONFIG_RT61PCI=m
+CONFIG_BCM43XX=m
+CONFIG_IEEE1394=y
+CONFIG_SCSI_BUSLOGIC=y
+CONFIG_IRTTY_SIR=m
+CONFIG_NET_CLS_BASIC=m
+CONFIG_TEXTSEARCH_BM=m
+CONFIG_CALGARY_IOMMU=y
+CONFIG_RTC=y
+CONFIG_MAC_PARTITION=y
+CONFIG_VIDEO_PVRUSB2=m
+CONFIG_RIO=m
+CONFIG_GAMEPORT_FM801=m
+CONFIG_CAPI_EICON=y
+CONFIG_NETDEVICES=y
+CONFIG_USB=y
+CONFIG_ECONET_AUNUDP=y
+CONFIG_IP_VS_FTP=m
+CONFIG_INET_TCP_DIAG=y
+CONFIG_YENTA_TOSHIBA=y
+CONFIG_JFFS2_ZLIB=y
+CONFIG_USB_GADGET_DUALSPEED=y
+CONFIG_SENSORS_CORETEMP=m
+CONFIG_JOYSTICK_STINGER=m
+CONFIG_HDLC_CISCO=m
+CONFIG_CHELSIO_T1=m
+CONFIG_HAMACHI=m
+CONFIG_PARIDE_PCD=m
+CONFIG_IP_NF_TARGET_TCPMSS=m
+CONFIG_SND_HDA_INTEL=m
+CONFIG_DVB_TUA6100=m
+CONFIG_DVB_BUDGET_AV=m
+CONFIG_SPI=y
+CONFIG_SOFT_WATCHDOG=m
+CONFIG_PPP_SYNC_TTY=m
+CONFIG_ARCNET_COM90xxIO=m
+CONFIG_SCSI_ACARD=y
+CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS=0
+CONFIG_SOFTWARE_SUSPEND=y
+CONFIG_EFI_PARTITION=y
+CONFIG_NLS=y
+CONFIG_SENSORS_DS1621=m
+CONFIG_W1_MASTER_MATROX=m
+CONFIG_ATM_CLIP_NO_ICMP=y
+CONFIG_EXT4DEV_FS_XATTR=y
+CONFIG_KVM=m
+CONFIG_FB_VOODOO1=m
+CONFIG_VIDEO_BUF_DVB=m
+CONFIG_I2C_VIAPRO=m
+CONFIG_SERIAL_8250=y
+CONFIG_CDROM_PKTCDVD_WCACHE=y
+CONFIG_PNP=y
+CONFIG_LEDS_TRIGGERS=y
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_SUSPEND2_SWAP=y
+CONFIG_USB_FTDI_ELAN=m
+CONFIG_SND_SEQUENCER=m
+CONFIG_ISDN_DRV_AVMB1_T1PCI=m
+CONFIG_ARCNET_COM20020=m
+CONFIG_MTD_CFI_I1=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_MMU=y
+CONFIG_DVB_ISL6421=m
+CONFIG_VIDEO_STRADIS=m
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_ARCNET_CAP=m
+CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
+CONFIG_BLK_DEV_RAM_SIZE=16384
+CONFIG_MTD_CFI_I2=y
+CONFIG_PPP=m
+CONFIG_SMP=y
+CONFIG_USB_AUERSWALD=m
+CONFIG_SENSORS_W83793=m
+CONFIG_SENSORS_DS1337=m
+CONFIG_IPX=m
+CONFIG_IPV6_SUBTREES=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_EXT2_FS_SECURITY=y
+CONFIG_USB_IBMCAM=m
+CONFIG_VIDEO_CPIA_PP=m
+CONFIG_VIDEO_TVAUDIO=m
+CONFIG_SENSORS_DS1374=m
+CONFIG_SK98LIN=m
+CONFIG_PATA_SERVERWORKS=y
+CONFIG_PATA_RZ1000=y
+CONFIG_IOSCHED_AS=y
+CONFIG_CRYPTO_KHAZAD=m
+CONFIG_EXT3_FS_SECURITY=y
+CONFIG_VIDEO_CPIA=m
+CONFIG_SENSORS_ASB100=m
+CONFIG_W1_SLAVE_SMEM=m
+CONFIG_NET_PCMCIA=y
+CONFIG_8139TOO_TUNE_TWISTER=y
+CONFIG_BT_HCIVHCI=m
+CONFIG_NET_ACT_PEDIT=m
+CONFIG_DECNET_ROUTER=y
+CONFIG_IP_NF_TARGET_LOG=m
+CONFIG_ACPI_VIDEO=y
+CONFIG_BASE_SMALL=0
+CONFIG_SND_CS46XX=m
+CONFIG_DVB_VES1820=m
+CONFIG_MOXA_INTELLIO=m
+CONFIG_P54_PCI=m
+CONFIG_PRISM54=m
+CONFIG_AUDIT_ARCH=y
+CONFIG_RTC_DRV_DS1307=m
+CONFIG_USB_GADGET=m
+CONFIG_SND_ENS1370=m
+CONFIG_SND_AC97_CODEC=m
+CONFIG_JOYSTICK_WARRIOR=m
+CONFIG_MTD_GEN_PROBE=m
+CONFIG_ACPI_SLEEP=y
+CONFIG_LDM_PARTITION=y
+CONFIG_XFS_RT=y
+CONFIG_USB_SERIAL_CYBERJACK=m
+CONFIG_SND_ENS1371=m
+CONFIG_DVB_BUDGET=m
+CONFIG_IPMI_POWEROFF=m
+CONFIG_NETFILTER_XT_MATCH_COMMENT=m
+CONFIG_BINFMT_ELF=y
+CONFIG_PCI_DIRECT=y
+CONFIG_SQUASHFS_EMBEDDED=y
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_SOUND_UART6850=m
+CONFIG_SBC8360_WDT=m
+CONFIG_JOYSTICK_JOYDUMP=m
+CONFIG_JOYSTICK_TMDC=m
+CONFIG_NORTEL_HERMES=m
+CONFIG_TUN=m
+CONFIG_I2O_CONFIG_OLD_IOCTL=y
+CONFIG_MTD_DOCPROBE_ADDRESS=0x0000
+CONFIG_BT_HCIUSB_SCO=y
+CONFIG_RTC_DRV_DS1742=m
+CONFIG_RTC_DRV_DS1553=m
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_DVB_TTUSB_DEC=m
+CONFIG_SERIO_I8042=y
+CONFIG_NET_EMATCH=y
+CONFIG_DECNET_NF_GRABULATOR=m
+CONFIG_SND_CMIPCI=m
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_USB_SN9C102=m
+CONFIG_DRM_SAVAGE=m
+CONFIG_LEGACY_PTY_COUNT=256
+CONFIG_JOYSTICK_TWIDJOY=m
+CONFIG_SCSI_ISCSI_ATTRS=y
+CONFIG_MTD_REDBOOT_PARTS_READONLY=y
+CONFIG_ESI_DONGLE=m
+CONFIG_IP_NF_TARGET_MASQUERADE=m
+CONFIG_PCIEAER=y
+CONFIG_RTC_DRV_DS1672=m
+CONFIG_DVB_USB_VP7045=m
+CONFIG_VIDEO_SAA7134_ALSA=m
+CONFIG_SENSORS_ATXP1=m
+CONFIG_I2C_ISA=m
+CONFIG_RT73USB=m
+CONFIG_8139TOO_8129=y
+CONFIG_X86_MCE=y
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_USB_SERIAL_VISOR=m
+CONFIG_USB_NET_GL620A=m
+CONFIG_DVB_NXT6000=m
+CONFIG_SENSORS_VT1211=m
+CONFIG_DRM_RADEON=m
+CONFIG_BITREVERSE=y
+CONFIG_TEXTSEARCH=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_IP_VS_WRR=m
+CONFIG_TCP_CONG_HTCP=m
+CONFIG_SGI_PARTITION=y
+CONFIG_EXT4DEV_FS=y
+CONFIG_USB_NET2280=m
+CONFIG_FB_3DFX=m
+CONFIG_SENSORS_HDAPS=m
+CONFIG_W83877F_WDT=m
+CONFIG_MOXA_SMARTIO_NEW=m
+CONFIG_MTD_CONCAT=m
+CONFIG_NET_SCH_NETEM=m
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID=y
+CONFIG_IA32_EMULATION=y
+CONFIG_UTS_NS=y
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+CONFIG_USB_POWERMATE=m
+CONFIG_USB_HIDDEV=y
+CONFIG_I2C_VIA=m
+CONFIG_W83977F_WDT=m
+CONFIG_JOYSTICK_GRIP_MP=m
+CONFIG_LEDS_CLASS=m
+CONFIG_BAYCOM_PAR=m
+CONFIG_NETFILTER_XT_MATCH_DCCP=m
+CONFIG_NFS_V3_ACL=y
+CONFIG_AUTOFS4_FS=y
+CONFIG_USB_BELKIN=y
+CONFIG_SND_RME9652=m
+CONFIG_SND_INDIGO=m
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_VIDEO_UPD64031A=m
+CONFIG_8139_OLD_RX_RESET=y
+CONFIG_NET_ESTIMATOR=y
+CONFIG_NF_CT_NETLINK=m
+CONFIG_NCPFS_PACKET_SIGNING=y
+CONFIG_SND_USB_AUDIO=m
+CONFIG_I2C_I810=m
+CONFIG_I2C_I801=m
+CONFIG_PCI_HERMES=m
+CONFIG_SECURITY_SELINUX=y
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/config/auto.conf.cmd linux-2.6.20-sabayon-r1/include/config/auto.conf.cmd
--- linux-2.6.20-sabayon-r1.orig/include/config/auto.conf.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/config/auto.conf.cmd	2007-02-12 15:09:06.000000000 +0100
@@ -0,0 +1,268 @@
+deps_config := \
+	lib/Kconfig \
+	drivers/crypto/Kconfig \
+	crypto/Kconfig \
+	security/selinux/Kconfig \
+	security/Kconfig \
+	lib/Kconfig.debug \
+	arch/x86_64/Kconfig.debug \
+	arch/x86_64/oprofile/Kconfig \
+	fs/dlm/Kconfig \
+	fs/nls/Kconfig \
+	fs/partitions/Kconfig \
+	fs/ncpfs/Kconfig \
+	fs/gfs2/Kconfig \
+	fs/xfs/Kconfig \
+	fs/Kconfig \
+	drivers/firmware/Kconfig \
+	drivers/kvm/Kconfig \
+	drivers/dma/Kconfig \
+	drivers/rtc/Kconfig \
+	drivers/edac/Kconfig \
+	drivers/infiniband/ulp/iser/Kconfig \
+	drivers/infiniband/ulp/srp/Kconfig \
+	drivers/infiniband/ulp/ipoib/Kconfig \
+	drivers/infiniband/hw/amso1100/Kconfig \
+	drivers/infiniband/hw/ehca/Kconfig \
+	drivers/infiniband/hw/ipath/Kconfig \
+	drivers/infiniband/hw/mthca/Kconfig \
+	drivers/infiniband/Kconfig \
+	drivers/leds/Kconfig \
+	drivers/mmc/Kconfig \
+	drivers/usb/gadget/Kconfig \
+	drivers/usb/atm/Kconfig \
+	drivers/usb/misc/sisusbvga/Kconfig \
+	drivers/usb/misc/Kconfig \
+	drivers/usb/serial/Kconfig \
+	drivers/usb/mon/Kconfig \
+	drivers/usb/net/Kconfig \
+	drivers/usb/image/Kconfig \
+	drivers/usb/input/Kconfig \
+	drivers/usb/storage/Kconfig \
+	drivers/usb/class/Kconfig \
+	drivers/usb/host/Kconfig \
+	drivers/usb/core/Kconfig \
+	drivers/usb/Kconfig \
+	drivers/hid/Kconfig \
+	sound/oss/Kconfig \
+	sound/parisc/Kconfig \
+	sound/sparc/Kconfig \
+	sound/pcmcia/Kconfig \
+	sound/usb/Kconfig \
+	sound/mips/Kconfig \
+	sound/arm/Kconfig \
+	sound/aoa/soundbus/Kconfig \
+	sound/aoa/codecs/Kconfig \
+	sound/aoa/fabrics/Kconfig \
+	sound/aoa/Kconfig \
+	sound/ppc/Kconfig \
+	sound/pci/Kconfig \
+	sound/isa/Kconfig \
+	sound/drivers/Kconfig \
+	sound/core/Kconfig \
+	sound/oss/dmasound/Kconfig \
+	sound/Kconfig \
+	drivers/video/backlight/Kconfig \
+	drivers/video/logo/Kconfig \
+	drivers/video/console/Kconfig \
+	drivers/video/geode/Kconfig \
+	drivers/video/Kconfig \
+	drivers/media/common/Kconfig \
+	drivers/media/dvb/frontends/Kconfig \
+	drivers/media/dvb/pluto2/Kconfig \
+	drivers/media/dvb/bt8xx/Kconfig \
+	drivers/media/dvb/b2c2/Kconfig \
+	drivers/media/dvb/cinergyT2/Kconfig \
+	drivers/media/dvb/ttusb-dec/Kconfig \
+	drivers/media/dvb/ttusb-budget/Kconfig \
+	drivers/media/dvb/dvb-usb/Kconfig \
+	drivers/media/dvb/ttpci/Kconfig \
+	drivers/media/dvb/dvb-core/Kconfig \
+	drivers/media/dvb/Kconfig \
+	drivers/media/radio/Kconfig \
+	drivers/media/video/pwc/Kconfig \
+	drivers/media/video/zc0301/Kconfig \
+	drivers/media/video/sn9c102/Kconfig \
+	drivers/media/video/et61x251/Kconfig \
+	drivers/media/video/usbvideo/Kconfig \
+	drivers/media/video/usbvision/Kconfig \
+	drivers/media/video/em28xx/Kconfig \
+	drivers/media/video/pvrusb2/Kconfig \
+	drivers/media/video/cx88/Kconfig \
+	drivers/media/video/saa7134/Kconfig \
+	drivers/media/video/cpia2/Kconfig \
+	drivers/media/video/bt8xx/Kconfig \
+	drivers/media/video/cx25840/Kconfig \
+	drivers/media/video/Kconfig \
+	drivers/media/Kconfig \
+	drivers/mfd/Kconfig \
+	drivers/ssb/Kconfig \
+	drivers/hwmon/Kconfig \
+	drivers/w1/slaves/Kconfig \
+	drivers/w1/masters/Kconfig \
+	drivers/w1/Kconfig \
+	drivers/spi/Kconfig \
+	drivers/i2c/chips/Kconfig \
+	drivers/i2c/busses/Kconfig \
+	drivers/i2c/algos/Kconfig \
+	drivers/i2c/Kconfig \
+	drivers/char/tpm/Kconfig \
+	drivers/char/pcmcia/Kconfig \
+	drivers/char/drm/Kconfig \
+	drivers/char/agp/Kconfig \
+	drivers/char/hw_random/Kconfig \
+	drivers/char/watchdog/Kconfig \
+	drivers/char/ipmi/Kconfig \
+	drivers/serial/Kconfig \
+	drivers/char/Kconfig \
+	drivers/input/gameport/Kconfig \
+	drivers/input/serio/Kconfig \
+	drivers/input/misc/Kconfig \
+	drivers/input/touchscreen/Kconfig \
+	drivers/input/joystick/iforce/Kconfig \
+	drivers/input/joystick/Kconfig \
+	drivers/input/mouse/Kconfig \
+	drivers/input/keyboard/Kconfig \
+	drivers/input/Kconfig \
+	drivers/telephony/Kconfig \
+	drivers/isdn/hardware/eicon/Kconfig \
+	drivers/isdn/hardware/avm/Kconfig \
+	drivers/isdn/hardware/Kconfig \
+	drivers/isdn/capi/Kconfig \
+	drivers/isdn/gigaset/Kconfig \
+	drivers/isdn/hysdn/Kconfig \
+	drivers/isdn/act2000/Kconfig \
+	drivers/isdn/sc/Kconfig \
+	drivers/isdn/pcbit/Kconfig \
+	drivers/isdn/icn/Kconfig \
+	drivers/isdn/hisax/Kconfig \
+	drivers/isdn/i4l/Kconfig \
+	drivers/isdn/Kconfig \
+	drivers/s390/net/Kconfig \
+	drivers/atm/Kconfig \
+	drivers/net/wan/Kconfig \
+	drivers/net/pcmcia/Kconfig \
+	drivers/net/wireless/Kconfig.ipw3945 \
+	drivers/net/wireless/d80211/zd1211rw/Kconfig \
+	drivers/net/wireless/d80211/p54/Kconfig \
+	drivers/net/wireless/d80211/adm8211/Kconfig \
+	drivers/net/wireless/d80211/rt2x00/Kconfig \
+	drivers/net/wireless/d80211/bcm43xx/Kconfig \
+	drivers/net/wireless/d80211/Kconfig \
+	drivers/net/wireless/zd1211rw/Kconfig \
+	drivers/net/wireless/bcm43xx/Kconfig \
+	drivers/net/wireless/hostap/Kconfig \
+	drivers/net/wireless/Kconfig \
+	drivers/net/tokenring/Kconfig \
+	drivers/net/ixp2000/Kconfig \
+	drivers/net/fs_enet/Kconfig \
+	drivers/net/fec_8xx/Kconfig \
+	drivers/net/tulip/Kconfig \
+	drivers/net/arm/Kconfig \
+	drivers/net/phy/Kconfig \
+	drivers/net/arcnet/Kconfig \
+	drivers/net/Kconfig \
+	drivers/macintosh/Kconfig \
+	drivers/message/i2o/Kconfig \
+	drivers/ieee1394/Kconfig \
+	drivers/message/fusion/Kconfig \
+	drivers/md/Kconfig \
+	drivers/cdrom/Kconfig \
+	drivers/ata/Kconfig \
+	drivers/scsi/pcmcia/Kconfig \
+	drivers/scsi/arm/Kconfig \
+	drivers/scsi/qla4xxx/Kconfig \
+	drivers/scsi/qla2xxx/Kconfig \
+	drivers/scsi/megaraid/Kconfig.megaraid \
+	drivers/scsi/aic94xx/Kconfig \
+	drivers/scsi/aic7xxx/Kconfig.aic79xx \
+	drivers/scsi/aic7xxx/Kconfig.aic7xxx \
+	drivers/scsi/libsas/Kconfig \
+	drivers/scsi/Kconfig \
+	drivers/ide/Kconfig \
+	drivers/misc/Kconfig \
+	drivers/s390/block/Kconfig \
+	drivers/block/paride/Kconfig \
+	drivers/block/Kconfig \
+	drivers/pnp/pnpacpi/Kconfig \
+	drivers/pnp/pnpbios/Kconfig \
+	drivers/pnp/isapnp/Kconfig \
+	drivers/pnp/Kconfig \
+	drivers/parport/Kconfig \
+	drivers/mtd/onenand/Kconfig \
+	drivers/mtd/nand/Kconfig \
+	drivers/mtd/devices/Kconfig \
+	drivers/mtd/maps/Kconfig \
+	drivers/mtd/chips/Kconfig \
+	drivers/mtd/Kconfig \
+	drivers/connector/Kconfig \
+	drivers/base/Kconfig \
+	drivers/Kconfig \
+	net/ieee80211/softmac/Kconfig \
+	net/ieee80211/Kconfig \
+	net/d80211/Kconfig \
+	drivers/bluetooth/Kconfig \
+	net/bluetooth/hidp/Kconfig \
+	net/bluetooth/cmtp/Kconfig \
+	net/bluetooth/bnep/Kconfig \
+	net/bluetooth/rfcomm/Kconfig \
+	net/bluetooth/Kconfig \
+	drivers/net/irda/Kconfig \
+	net/irda/ircomm/Kconfig \
+	net/irda/irnet/Kconfig \
+	net/irda/irlan/Kconfig \
+	net/irda/Kconfig \
+	drivers/net/hamradio/Kconfig \
+	net/ax25/Kconfig \
+	net/sched/Kconfig \
+	net/wanrouter/Kconfig \
+	net/econet/Kconfig \
+	net/lapb/Kconfig \
+	net/x25/Kconfig \
+	drivers/net/appletalk/Kconfig \
+	net/ipx/Kconfig \
+	net/llc/Kconfig \
+	net/decnet/Kconfig \
+	net/8021q/Kconfig \
+	net/bridge/Kconfig \
+	net/atm/Kconfig \
+	net/tipc/Kconfig \
+	net/sctp/Kconfig \
+	net/dccp/ccids/Kconfig \
+	net/dccp/Kconfig \
+	net/bridge/netfilter/Kconfig \
+	net/decnet/netfilter/Kconfig \
+	net/ipv6/netfilter/Kconfig \
+	net/ipv4/netfilter/Kconfig \
+	net/netfilter/Kconfig \
+	net/netlabel/Kconfig \
+	net/ipv6/Kconfig \
+	net/ipv4/ipvs/Kconfig \
+	net/ipv4/Kconfig \
+	net/xfrm/Kconfig \
+	net/unix/Kconfig \
+	net/packet/Kconfig \
+	net/Kconfig \
+	fs/Kconfig.binfmt \
+	drivers/pci/hotplug/Kconfig \
+	drivers/pcmcia/Kconfig \
+	drivers/pci/Kconfig \
+	drivers/pci/pcie/aer/Kconfig \
+	drivers/pci/pcie/Kconfig \
+	drivers/cpufreq/Kconfig \
+	arch/x86_64/kernel/cpufreq/Kconfig \
+	drivers/acpi/Kconfig \
+	kernel/power/Kconfig \
+	kernel/Kconfig.hz \
+	mm/Kconfig \
+	kernel/Kconfig.preempt \
+	block/Kconfig.iosched \
+	block/Kconfig \
+	usr/Kconfig \
+	init/Kconfig \
+	arch/x86_64/Kconfig
+
+include/config/auto.conf: \
+	$(deps_config)
+
+$(deps_config): ;
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/config/kernel.release linux-2.6.20-sabayon-r1/include/config/kernel.release
--- linux-2.6.20-sabayon-r1.orig/include/config/kernel.release	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/config/kernel.release	2007-02-12 15:34:03.000000000 +0100
@@ -0,0 +1 @@
+2.6.20-sabayon-r1
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/linux/autoconf.h linux-2.6.20-sabayon-r1/include/linux/autoconf.h
--- linux-2.6.20-sabayon-r1.orig/include/linux/autoconf.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/linux/autoconf.h	2007-02-12 15:09:06.000000000 +0100
@@ -0,0 +1,2308 @@
+/*
+ * Automatically generated C config: don't edit
+ * Linux kernel version: 2.6.20-sabayon-r1
+ * Mon Feb 12 15:09:06 2007
+ */
+#define AUTOCONF_INCLUDED
+#define CONFIG_USB_SISUSBVGA_MODULE 1
+#define CONFIG_USB_PHIDGETMOTORCONTROL_MODULE 1
+#define CONFIG_VIDEO_V4L1_COMPAT 1
+#define CONFIG_PCMCIA_FMVJ18X_MODULE 1
+#define CONFIG_BLK_CPQ_DA 1
+#define CONFIG_BLK_DEV_FD 1
+#define CONFIG_AX25_MODULE 1
+#define CONFIG_ACPI_AC 1
+#define CONFIG_PM_STD_PARTITION ""
+#define CONFIG_SECURITY_NETWORK 1
+#define CONFIG_ULTRIX_PARTITION 1
+#define CONFIG_OSF_PARTITION 1
+#define CONFIG_USB_LEGOTOWER_MODULE 1
+#define CONFIG_FB_TRIDENT_MODULE 1
+#define CONFIG_DVB_PLUTO2_MODULE 1
+#define CONFIG_GAMEPORT_NS558_MODULE 1
+#define CONFIG_JOYSTICK_GRIP_MODULE 1
+#define CONFIG_BONDING_MODULE 1
+#define CONFIG_MTD_ABSENT_MODULE 1
+#define CONFIG_INET_XFRM_TUNNEL_MODULE 1
+#define CONFIG_CRYPTO_ANUBIS_MODULE 1
+#define CONFIG_JBD2 1
+#define CONFIG_SOUND_TRIDENT_MODULE 1
+#define CONFIG_P54_USB_MODULE 1
+#define CONFIG_TCP_CONG_ADVANCED 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM 1
+#define CONFIG_JFFS2_CMODE_PRIORITY 1
+#define CONFIG_USB_SERIAL_IR_MODULE 1
+#define CONFIG_SND_AZT3328_MODULE 1
+#define CONFIG_TCP_CONG_SCALABLE_MODULE 1
+#define CONFIG_SUSPEND2_REPLACE_SWSUSP 1
+#define CONFIG_JFS_POSIX_ACL 1
+#define CONFIG_FONT_MINI_4x6 1
+#define CONFIG_SENSORS_VT8231_MODULE 1
+#define CONFIG_RIO_OLDPCI 1
+#define CONFIG_ISDN_DIVAS_MODULE 1
+#define CONFIG_DLCI_COUNT 24
+#define CONFIG_IP6_NF_TARGET_REJECT_MODULE 1
+#define CONFIG_NF_CT_ACCT 1
+#define CONFIG_TCP_CONG_VENO_MODULE 1
+#define CONFIG_CARDBUS 1
+#define CONFIG_X86_POWERNOW_K8_ACPI 1
+#define CONFIG_ACPI_EC 1
+#define CONFIG_CRYPTO_MD4_MODULE 1
+#define CONFIG_USB_SERIAL_TI_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_C4_MODULE 1
+#define CONFIG_BT_HCIUART_MODULE 1
+#define CONFIG_IP_NF_TARGET_TTL_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_QUEUE_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_BEET_MODULE 1
+#define CONFIG_ARCH_MAY_HAVE_PC_FDC 1
+#define CONFIG_IPW2200_QOS 1
+#define CONFIG_E1000_MODULE 1
+#define CONFIG_ARCNET_RAW_MODULE 1
+#define CONFIG_I2O_EXT_ADAPTEC_DMA64 1
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_HIGH 1
+#define CONFIG_NF_NAT_PROTO_GRE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_PHYSDEV_MODULE 1
+#define CONFIG_CRYPTO_MD5 1
+#define CONFIG_SUSPEND2_CHECKSUM 1
+#define CONFIG_ARCH_DISCONTIGMEM_ENABLE 1
+#define CONFIG_CRYPTO_AES_X86_64_MODULE 1
+#define CONFIG_PROC_KCORE 1
+#define CONFIG_USB_GADGET_NET2280 1
+#define CONFIG_USB_AIPTEK_MODULE 1
+#define CONFIG_DVB_TUNER_LGH06XF_MODULE 1
+#define CONFIG_VIDEO_BTCX_MODULE 1
+#define CONFIG_PCMCIA_SMC91C92_MODULE 1
+#define CONFIG_BLK_DEV_DM 1
+#define CONFIG_BLK_DEV_MD 1
+#define CONFIG_SCSI_FC_ATTRS 1
+#define CONFIG_IRDA_ULTRA 1
+#define CONFIG_IP_NF_TARGET_TOS_MODULE 1
+#define CONFIG_SND_EMU10K1_MODULE 1
+#define CONFIG_DVB_TDA10021_MODULE 1
+#define CONFIG_I2C_SAVAGE4_MODULE 1
+#define CONFIG_SYNCLINKMP_MODULE 1
+#define CONFIG_PPP_MULTILINK 1
+#define CONFIG_TMD_HERMES_MODULE 1
+#define CONFIG_SCSI_DC390T 1
+#define CONFIG_NET_CLS_RSVP6_MODULE 1
+#define CONFIG_CRYPTO_CBC 1
+#define CONFIG_ACORN_PARTITION_ADFS 1
+#define CONFIG_USB_SERIAL_MODULE 1
+#define CONFIG_USB_RTL8150_MODULE 1
+#define CONFIG_DVB_USB_CXUSB_MODULE 1
+#define CONFIG_USB_W9968CF_MODULE 1
+#define CONFIG_SERIAL_JSM_MODULE 1
+#define CONFIG_MTD_MTDRAM_MODULE 1
+#define CONFIG_NF_CONNTRACK_NETBIOS_NS_MODULE 1
+#define CONFIG_ACPI_POWER 1
+#define CONFIG_GFS2_FS 1
+#define CONFIG_SND_DARLA20_MODULE 1
+#define CONFIG_DVB_STV0297_MODULE 1
+#define CONFIG_VIDEO_ZORAN_LML33_MODULE 1
+#define CONFIG_HOSTAP_PCI_MODULE 1
+#define CONFIG_CASSINI_MODULE 1
+#define CONFIG_PCMCIA_FDOMAIN_MODULE 1
+#define CONFIG_CRYPTO_ECB 1
+#define CONFIG_IPV6_MULTIPLE_TABLES 1
+#define CONFIG_SECCOMP 1
+#define CONFIG_USB_SERIAL_WHITEHEAT_MODULE 1
+#define CONFIG_VIDEO_W9966_MODULE 1
+#define CONFIG_X25_ASY_MODULE 1
+#define CONFIG_NETXEN_NIC_MODULE 1
+#define CONFIG_PATA_SIL680 1
+#define CONFIG_PATA_ARTOP 1
+#define CONFIG_PNPACPI 1
+#define CONFIG_BT_HCIBLUECARD_MODULE 1
+#define CONFIG_OLD_BELKIN_DONGLE_MODULE 1
+#define CONFIG_IP_DCCP_CCID3_RTO 100
+#define CONFIG_IP6_NF_RAW_MODULE 1
+#define CONFIG_ENABLE_MUST_CHECK 1
+#define CONFIG_RTC_INTF_PROC 1
+#define CONFIG_SND_YMFPCI_MODULE 1
+#define CONFIG_DVB_STV0299_MODULE 1
+#define CONFIG_DVB_TDA826X_MODULE 1
+#define CONFIG_SPI_BUTTERFLY_MODULE 1
+#define CONFIG_I2C_NFORCE2_MODULE 1
+#define CONFIG_ZD1211RW_MODULE 1
+#define CONFIG_NET_POCKET 1
+#define CONFIG_EEPRO100_MODULE 1
+#define CONFIG_WINBOND_840_MODULE 1
+#define CONFIG_PATA_MPIIX 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_1 1
+#define CONFIG_X86_LOCAL_APIC 1
+#define CONFIG_EXT2_FS_XATTR 1
+#define CONFIG_USB_KAWETH_MODULE 1
+#define CONFIG_ROCKETPORT_MODULE 1
+#define CONFIG_DL2K_MODULE 1
+#define CONFIG_BLK_DEV_SD 1
+#define CONFIG_MTD_MAP_BANK_WIDTH_2 1
+#define CONFIG_LLC2_MODULE 1
+#define CONFIG_IP6_NF_MATCH_FRAG_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_DSCP_MODULE 1
+#define CONFIG_EXT3_FS_XATTR 1
+#define CONFIG_RTC_DRV_M48T86_MODULE 1
+#define CONFIG_SND_DARLA24_MODULE 1
+#define CONFIG_VIDEO_BT819_MODULE 1
+#define CONFIG_FUSION_LAN 1
+#define CONFIG_NETFILTER_XT_MATCH_MARK_MODULE 1
+#define CONFIG_SUN_PARTITION 1
+#define CONFIG_CODA_FS 1
+#define CONFIG_NFS_COMMON 1
+#define CONFIG_USB_CXACRU_MODULE 1
+#define CONFIG_SND_VIA82XX_MODEM_MODULE 1
+#define CONFIG_VIDEO_BT856_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS 16
+#define CONFIG_MTD_MAP_BANK_WIDTH_4 1
+#define CONFIG_NET_PKTGEN_MODULE 1
+#define CONFIG_X86_SPEEDSTEP_CENTRINO_ACPI 1
+#define CONFIG_X86_TSC 1
+#define CONFIG_IOMAP_COPY 1
+#define CONFIG_VIDEO_BT848_MODULE 1
+#define CONFIG_VIDEO_BT866_MODULE 1
+#define CONFIG_SERIO_SERPORT 1
+#define CONFIG_JOYSTICK_MAGELLAN_MODULE 1
+#define CONFIG_PATA_HPT366 1
+#define CONFIG_CPU_FREQ_STAT 1
+#define CONFIG_USB_SERIAL_ARK3116_MODULE 1
+#define CONFIG_HID_PID 1
+#define CONFIG_HW_CONSOLE 1
+#define CONFIG_ATM_FORE200E_MAYBE_MODULE 1
+#define CONFIG_NATSEMI_MODULE 1
+#define CONFIG_SCSI_IPR_DUMP 1
+#define CONFIG_MTD_DOCPROBE_HIGH 1
+#define CONFIG_NET_EMATCH_U32_MODULE 1
+#define CONFIG_HPET_TIMER 1
+#define CONFIG_CIFS_EXPERIMENTAL 1
+#define CONFIG_XFS_POSIX_ACL 1
+#define CONFIG_SENSORS_SMSC47B397_MODULE 1
+#define CONFIG_HDLC_FR_MODULE 1
+#define CONFIG_IP_DCCP_MODULE 1
+#define CONFIG_CIFS_STATS 1
+#define CONFIG_NFSD_V3 1
+#define CONFIG_SND_ATIIXP_MODULE 1
+#define CONFIG_DVB_TDA10086_MODULE 1
+#define CONFIG_TOUCHSCREEN_TOUCHWIN_MODULE 1
+#define CONFIG_ATM_IDT77252_USE_SUNI 1
+#define CONFIG_I2O_BUS 1
+#define CONFIG_PARIDE_ON20_MODULE 1
+#define CONFIG_NF_NAT_IRC_MODULE 1
+#define CONFIG_REORDER 1
+#define CONFIG_K8_NUMA 1
+#define CONFIG_NFSD_V4 1
+#define CONFIG_VIDEO_VIVI_MODULE 1
+#define CONFIG_I2C_ALGOPCA_MODULE 1
+#define CONFIG_IEEE1394_CONFIG_ROM_IP1394 1
+#define CONFIG_CHR_DEV_SG 1
+#define CONFIG_IEEE80211_MODULE 1
+#define CONFIG_IP_NF_MATCH_ADDRTYPE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_PKTTYPE_MODULE 1
+#define CONFIG_USB_NET_PLUSB_MODULE 1
+#define CONFIG_VIDEO_ZORAN_AVS6EYES_MODULE 1
+#define CONFIG_PPP_FILTER 1
+#define CONFIG_PATA_IT821X 1
+#define CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MODE 1
+#define CONFIG_NF_NAT_H323_MODULE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_WRANDOM_MODULE 1
+#define CONFIG_ADFS_FS_MODULE 1
+#define CONFIG_FB_VESA 1
+#define CONFIG_SENSORS_SMSC47M192_MODULE 1
+#define CONFIG_KEYBOARD_ATKBD 1
+#define CONFIG_FARSYNC_MODULE 1
+#define CONFIG_FUSION_CTL 1
+#define CONFIG_MTD_CFI_MODULE 1
+#define CONFIG_ALI_FIR_MODULE 1
+#define CONFIG_NET_CLS_ROUTE 1
+#define CONFIG_NF_CT_PROTO_SCTP_MODULE 1
+#define CONFIG_CIFS_POSIX 1
+#define CONFIG_CIFS_XATTR 1
+#define CONFIG_SOUND_TVMIXER_MODULE 1
+#define CONFIG_MIDI_VIA82CXXX 1
+#define CONFIG_DRM_MGA_MODULE 1
+#define CONFIG_AGP_VIA_MODULE 1
+#define CONFIG_PCMCIA_XIRC2PS_MODULE 1
+#define CONFIG_BCM43XX_DMA_AND_PIO_MODE 1
+#define CONFIG_PLX_HERMES_MODULE 1
+#define CONFIG_3C359_MODULE 1
+#define CONFIG_SPI_MASTER 1
+#define CONFIG_MTD_JEDECPROBE_MODULE 1
+#define CONFIG_BRIDGE_EBT_BROUTE_MODULE 1
+#define CONFIG_X86_MSR 1
+#define CONFIG_NLS_KOI8_R_MODULE 1
+#define CONFIG_BEFS_FS_MODULE 1
+#define CONFIG_AFFS_FS_MODULE 1
+#define CONFIG_NET_DMA 1
+#define CONFIG_SND_USB_USX2Y_MODULE 1
+#define CONFIG_SND_SEQ_DUMMY_MODULE 1
+#define CONFIG_TOUCHSCREEN_PENMOUNT_MODULE 1
+#define CONFIG_KEYBOARD_LKKBD 1
+#define CONFIG_MSI_LAPTOP_MODULE 1
+#define CONFIG_IBM_ASM_MODULE 1
+#define CONFIG_NF_CONNTRACK_IPV4_MODULE 1
+#define CONFIG_INET_AH_MODULE 1
+#define CONFIG_JFFS2_FS_DEBUG 0
+#define CONFIG_SND_MIXART_MODULE 1
+#define CONFIG_SND_LAYLA20_MODULE 1
+#define CONFIG_I2C_AMD756_S4882_MODULE 1
+#define CONFIG_I2C_ALGOPCF_MODULE 1
+#define CONFIG_CARDMAN_4000_MODULE 1
+#define CONFIG_QLA3XXX_MODULE 1
+#define CONFIG_PARIDE_ON26_MODULE 1
+#define CONFIG_CRYPTO_AES 1
+#define CONFIG_BT_RFCOMM_TTY 1
+#define CONFIG_MODULES 1
+#define CONFIG_CRYPTO_TEA_MODULE 1
+#define CONFIG_USB_USBNET_MODULE 1
+#define CONFIG_USB_ACM_MODULE 1
+#define CONFIG_USB_ARCH_HAS_EHCI 1
+#define CONFIG_DVB_USB_DIB0700_MODULE 1
+#define CONFIG_I2C_CHARDEV_MODULE 1
+#define CONFIG_BCM43XX_DMA 1
+#define CONFIG_PCMCIA_WAVELAN_MODULE 1
+#define CONFIG_BNX2_MODULE 1
+#define CONFIG_IEEE1394_OUI_DB 1
+#define CONFIG_FUSION_SAS 1
+#define CONFIG_PARPORT_PC 1
+#define CONFIG_MTD_COMPLEX_MAPPINGS 1
+#define CONFIG_BT_HIDP_MODULE 1
+#define CONFIG_BT_BNEP_MODULE 1
+#define CONFIG_NF_CONNTRACK_IPV6_MODULE 1
+#define CONFIG_SUSPEND2_DEFAULT_RESUME2 ""
+#define CONFIG_NLS_KOI8_U_MODULE 1
+#define CONFIG_EXT2_FS 1
+#define CONFIG_SND_MIA_MODULE 1
+#define CONFIG_FB_S1D13XXX_MODULE 1
+#define CONFIG_DVB_USB_VP702X_MODULE 1
+#define CONFIG_INPUT_MISC 1
+#define CONFIG_MOUSE_VSXXXAA_MODULE 1
+#define CONFIG_HDLC_MODULE 1
+#define CONFIG_PATA_CMD64X 1
+#define CONFIG_BLK_DEV_SR 1
+#define CONFIG_MTD_SCB2_FLASH_MODULE 1
+#define CONFIG_TOIM3232_DONGLE_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION_MODULE 1
+#define CONFIG_EXT3_FS 1
+#define CONFIG_USB_LCD_MODULE 1
+#define CONFIG_VIDEO_CX88_DVB_MODULE 1
+#define CONFIG_I2C_PARPORT_LIGHT_MODULE 1
+#define CONFIG_VT_CONSOLE 1
+#define CONFIG_ISDN_DIVAS_BRIPCI 1
+#define CONFIG_DLCI_MODULE 1
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADVANCED 1
+#define CONFIG_CRYPTO_DES 1
+#define CONFIG_HFSPLUS_FS 1
+#define CONFIG_DNOTIFY 1
+#define CONFIG_EXT4DEV_FS_POSIX_ACL 1
+#define CONFIG_USB_SERIAL_BELKIN_MODULE 1
+#define CONFIG_SND_LAYLA24_MODULE 1
+#define CONFIG_SND_MIXER_OSS 1
+#define CONFIG_SENSORS_F71805F_MODULE 1
+#define CONFIG_CARDMAN_4040_MODULE 1
+#define CONFIG_ATM_ENI_MODULE 1
+#define CONFIG_S2IO_MODULE 1
+#define CONFIG_INET_DCCP_DIAG_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_SCTP_MODULE 1
+#define CONFIG_IP_VS_LBLC_MODULE 1
+#define CONFIG_ACPI 1
+#define CONFIG_QFMT_V1 1
+#define CONFIG_USB_LED_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA49WLC 1
+#define CONFIG_USB_HID 1
+#define CONFIG_FB_CYBER2000_MODULE 1
+#define CONFIG_DVB_DIB7000M_MODULE 1
+#define CONFIG_DVB_VES1X93_MODULE 1
+#define CONFIG_JOYSTICK_SPACEORB_MODULE 1
+#define CONFIG_SLIP_SMART 1
+#define CONFIG_ATM_AMBASSADOR_MODULE 1
+#define CONFIG_IP_DCCP_ACKVEC 1
+#define CONFIG_ARCH "x86_64"
+#define CONFIG_QFMT_V2 1
+#define CONFIG_KVM_AMD_MODULE 1
+#define CONFIG_RTC_LIB 1
+#define CONFIG_DVB_NXT200X_MODULE 1
+#define CONFIG_WDT_501_PCI 1
+#define CONFIG_DE600_MODULE 1
+#define CONFIG_I2C_ALGOBIT_MODULE 1
+#define CONFIG_FUSION_SPI 1
+#define CONFIG_LAPB_MODULE 1
+#define CONFIG_NF_NAT_FTP_MODULE 1
+#define CONFIG_NETFILTER_XTABLES_MODULE 1
+#define CONFIG_ACPI_CONTAINER 1
+#define CONFIG_GENERIC_IRQ_PROBE 1
+#define CONFIG_STALDRV 1
+#define CONFIG_AIRO_CS_MODULE 1
+#define CONFIG_MTD_PCI_MODULE 1
+#define CONFIG_VIA_FIR_MODULE 1
+#define CONFIG_IRDA_MODULE 1
+#define CONFIG_IPX_INTERN 1
+#define CONFIG_NF_CONNTRACK_MARK 1
+#define CONFIG_DEFCONFIG_LIST "/lib/modules/$UNAME_RELEASE/.config"
+#define CONFIG_DVB_DIB7000P_MODULE 1
+#define CONFIG_TCG_NSC_MODULE 1
+#define CONFIG_PPPOATM_MODULE 1
+#define CONFIG_DE620_MODULE 1
+#define CONFIG_SATA_QSTOR 1
+#define CONFIG_CHR_DEV_ST 1
+#define CONFIG_MTD_DOC2001PLUS_MODULE 1
+#define CONFIG_RFD_FTL_MODULE 1
+#define CONFIG_NF_NAT_SIP_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_MODULE 1
+#define CONFIG_INOTIFY 1
+#define CONFIG_USB_SERIAL_KOBIL_SCT_MODULE 1
+#define CONFIG_SENSORS_ADM1021_MODULE 1
+#define CONFIG_DRM_VIA_MODULE 1
+#define CONFIG_PCMCIA_3C574_MODULE 1
+#define CONFIG_HOSTAP_PLX_MODULE 1
+#define CONFIG_NET_PCI 1
+#define CONFIG_SLAB 1
+#define CONFIG_DLM_TCP 1
+#define CONFIG_DVB_PLL_MODULE 1
+#define CONFIG_SENSORS_ADM1031_MODULE 1
+#define CONFIG_MCS_FIR_MODULE 1
+#define CONFIG_HOTPLUG 1
+#define CONFIG_USB_ADUTUX_MODULE 1
+#define CONFIG_USB_ARCH_HAS_OHCI 1
+#define CONFIG_SND_PCM 1
+#define CONFIG_W1_SLAVE_DS2433_MODULE 1
+#define CONFIG_DRM_I810_MODULE 1
+#define CONFIG_PRINTER 1
+#define CONFIG_MTD_RAM_MODULE 1
+#define CONFIG_NSC_FIR_MODULE 1
+#define CONFIG_NET_CLS_FW_MODULE 1
+#define CONFIG_BRIDGE_EBT_MARK_T_MODULE 1
+#define CONFIG_PCI_MSI 1
+#define CONFIG_SWIOTLB 1
+#define CONFIG_CIFS 1
+#define CONFIG_SOUND_BT878_MODULE 1
+#define CONFIG_DVB_USB_MODULE 1
+#define CONFIG_VIDEO_CPIA2_MODULE 1
+#define CONFIG_IPV6_MODULE 1
+#define CONFIG_SECURITY_SELINUX_AVC_STATS 1
+#define CONFIG_INFINIBAND_SRP_MODULE 1
+#define CONFIG_USB_SERIAL_GARMIN_MODULE 1
+#define CONFIG_SENSORS_ADM1025_MODULE 1
+#define CONFIG_I2C_VOODOO3_MODULE 1
+#define CONFIG_DRM_I830_MODULE 1
+#define CONFIG_AGP_SIS_MODULE 1
+#define CONFIG_PC300_MODULE 1
+#define CONFIG_PCMCIA_NETWAVE_MODULE 1
+#define CONFIG_PARPORT_PC_PCMCIA_MODULE 1
+#define CONFIG_WAN_ROUTER_MODULE 1
+#define CONFIG_SPARSEMEM_EXTREME 1
+#define CONFIG_SUNRPC_GSS 1
+#define CONFIG_USB_SERIAL_MOS7720_MODULE 1
+#define CONFIG_SENSORS_PC87360_MODULE 1
+#define CONFIG_SENSORS_ADM1026_MODULE 1
+#define CONFIG_MTD_DOCPROBE_ADVANCED 1
+#define CONFIG_ARPD 1
+#define CONFIG_CPUSETS 1
+#define CONFIG_SND_VX_LIB_MODULE 1
+#define CONFIG_R3964_MODULE 1
+#define CONFIG_ATM_TCP_MODULE 1
+#define CONFIG_PCMCIA_3C589_MODULE 1
+#define CONFIG_PARPORT 1
+#define CONFIG_NET_CLS 1
+#define CONFIG_BRIDGE_EBT_LOG_MODULE 1
+#define CONFIG_HPFS_FS 1
+#define CONFIG_VFAT_FS 1
+#define CONFIG_USB_SERIAL_NAVMAN_MODULE 1
+#define CONFIG_USB_STORAGE_KARMA 1
+#define CONFIG_JOYSTICK_INTERACT_MODULE 1
+#define CONFIG_ATM_IDT77252_MODULE 1
+#define CONFIG_SKY2_MODULE 1
+#define CONFIG_HP100 1
+#define CONFIG_PARIDE_FIT2_MODULE 1
+#define CONFIG_SERIAL_8250_PCI 1
+#define CONFIG_BT_CMTP_MODULE 1
+#define CONFIG_BRIDGE_EBT_ARP_MODULE 1
+#define CONFIG_IP6_NF_TARGET_LOG_MODULE 1
+#define CONFIG_LOCALVERSION_AUTO 1
+#define CONFIG_JFFS2_FS_SECURITY 1
+#define CONFIG_USB_ETH_MODULE 1
+#define CONFIG_USB_SERIAL_MOS7840_MODULE 1
+#define CONFIG_VIDEO_VIDEOBUF_MODULE 1
+#define CONFIG_DRM_I915_MODULE 1
+#define CONFIG_IPMI_SI_MODULE 1
+#define CONFIG_ISDN_DIVAS_PRIPCI 1
+#define CONFIG_SLHC_MODULE 1
+#define CONFIG_IXGB_MODULE 1
+#define CONFIG_SKGE_MODULE 1
+#define CONFIG_R8169_MODULE 1
+#define CONFIG_ARCNET_COM20020_PCI_MODULE 1
+#define CONFIG_PATA_NS87410 1
+#define CONFIG_PARIDE_FIT3_MODULE 1
+#define CONFIG_NFSD 1
+#define CONFIG_UDF_NLS 1
+#define CONFIG_FUSE_FS 1
+#define CONFIG_USB_ATM_MODULE 1
+#define CONFIG_DVB_USB_DIBUSB_MB_MODULE 1
+#define CONFIG_SENSORS_PC87427_MODULE 1
+#define CONFIG_TOUCHSCREEN_GUNZE_MODULE 1
+#define CONFIG_AIRO_MODULE 1
+#define CONFIG_SATA_MV 1
+#define CONFIG_X86_MCE_AMD 1
+#define CONFIG_KMOD 1
+#define CONFIG_CRYPTO_LZF_MODULE 1
+#define CONFIG_GENERIC_ACL 1
+#define CONFIG_FB_KYRO_MODULE 1
+#define CONFIG_DVB_USB_DIBUSB_MC_MODULE 1
+#define CONFIG_SBNI_MODULE 1
+#define CONFIG_SATA_NV 1
+#define CONFIG_PROC_FS 1
+#define CONFIG_SND_FM801_TEA575X_BOOL 1
+#define CONFIG_SENSORS_ADM9240_MODULE 1
+#define CONFIG_I2C_PCA_ISA_MODULE 1
+#define CONFIG_TCG_TIS_MODULE 1
+#define CONFIG_KEYBOARD_XTKBD 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_X 1024
+#define CONFIG_PARIDE_KBIC_MODULE 1
+#define CONFIG_IPDDP_DECAP 1
+#define CONFIG_TCG_TPM_MODULE 1
+#define CONFIG_IPMI_DEVICE_INTERFACE_MODULE 1
+#define CONFIG_INPUT_MOUSEDEV_SCREEN_Y 768
+#define CONFIG_ISDN_MODULE 1
+#define CONFIG_MYRI10GE_MODULE 1
+#define CONFIG_MTDRAM_ERASE_SIZE 128
+#define CONFIG_BT_BNEP_MC_FILTER 1
+#define CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE 1
+#define CONFIG_SOUND_TRIX_MODULE 1
+#define CONFIG_DRM_R128_MODULE 1
+#define CONFIG_DTLK_MODULE 1
+#define CONFIG_KEYBOARD_STOWAWAY_MODULE 1
+#define CONFIG_PATA_HPT3X3 1
+#define CONFIG_NET_KEY_MODULE 1
+#define CONFIG_X86_CMPXCHG 1
+#define CONFIG_BCM43XX_PIO 1
+#define CONFIG_DGRS_MODULE 1
+#define CONFIG_DM_ZERO 1
+#define CONFIG_CFG80211_WEXTNL_COMPAT 1
+#define CONFIG_TIPC_MODULE 1
+#define CONFIG_INET 1
+#define CONFIG_ARCH_SPARSEMEM_ENABLE 1
+#define CONFIG_RT_MUTEXES 1
+#define CONFIG_LOGO 1
+#define CONFIG_DVB_TDA1004X_MODULE 1
+#define CONFIG_HPET 1
+#define CONFIG_DRM_SIS_MODULE 1
+#define CONFIG_TYPHOON_MODULE 1
+#define CONFIG_SCSI_DC395x 1
+#define CONFIG_MTD_REDBOOT_DIRECTORY_BLOCK -1
+#define CONFIG_NUMA 1
+#define CONFIG_SYSVIPC 1
+#define CONFIG_REISERFS_FS_SECURITY 1
+#define CONFIG_SENSORS_W83781D_MODULE 1
+#define CONFIG_INPUT_TOUCHSCREEN 1
+#define CONFIG_SSB_PCMCIAHOST 1
+#define CONFIG_PATA_PCMCIA_MODULE 1
+#define CONFIG_ATA_GENERIC 1
+#define CONFIG_SCSI 1
+#define CONFIG_MTD_ROM_MODULE 1
+#define CONFIG_MTD_CFI_AMDSTD_MODULE 1
+#define CONFIG_BT_BNEP_PROTO_FILTER 1
+#define CONFIG_IP_SCTP_MODULE 1
+#define CONFIG_NF_CONNTRACK_SUPPORT 1
+#define CONFIG_DEFAULT_BIC 1
+#define CONFIG_TCP_CONG_CUBIC_MODULE 1
+#define CONFIG_X86_L1_CACHE_SHIFT 7
+#define CONFIG_NTFS_FS 1
+#define CONFIG_INFINIBAND_ADDR_TRANS 1
+#define CONFIG_USB_MON 1
+#define CONFIG_USB_PWC_MODULE 1
+#define CONFIG_SENSORS_W83791D_MODULE 1
+#define CONFIG_ATM_FIRESTREAM_MODULE 1
+#define CONFIG_PATA_HPT37X 1
+#define CONFIG_PARIDE_EPIA_MODULE 1
+#define CONFIG_IP6_NF_MATCH_OPTS_MODULE 1
+#define CONFIG_NF_CONNTRACK_TFTP_MODULE 1
+#define CONFIG_SENSORS_W83792D_MODULE 1
+#define CONFIG_PARIDE_BPCK_MODULE 1
+#define CONFIG_NFTL_MODULE 1
+#define CONFIG_NF_NAT_SNMP_BASIC_MODULE 1
+#define CONFIG_CRYPTO_LRW_MODULE 1
+#define CONFIG_CIFS_WEAK_PW_HASH 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA19 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA28 1
+#define CONFIG_PLIP_MODULE 1
+#define CONFIG_TMS380TR_MODULE 1
+#define CONFIG_CRYPTO_DEFLATE_MODULE 1
+#define CONFIG_USB_PHIDGETKIT_MODULE 1
+#define CONFIG_SC6600_CDROM 4
+#define CONFIG_DIGIEPCA_MODULE 1
+#define CONFIG_JOYSTICK_COBRA_MODULE 1
+#define CONFIG_PARPORT_AX88796_MODULE 1
+#define CONFIG_CC_OPTIMIZE_FOR_SIZE 1
+#define CONFIG_USB_STORAGE_JUMPSHOT 1
+#define CONFIG_VIDEO_USBVIDEO_MODULE 1
+#define CONFIG_NET_EMATCH_CMP_MODULE 1
+#define CONFIG_IPDDP_ENCAP 1
+#define CONFIG_IP_NF_TARGET_SAME_MODULE 1
+#define CONFIG_INET6_XFRM_TUNNEL_MODULE 1
+#define CONFIG_NCPFS_SMALLDOS 1
+#define CONFIG_SLIP_MODULE 1
+#define CONFIG_REED_SOLOMON_DEC16 1
+#define CONFIG_ACTISYS_DONGLE_MODULE 1
+#define CONFIG_SUSPEND_SHARED 1
+#define CONFIG_IOSCHED_CFQ 1
+#define CONFIG_SND_SONICVIBES_MODULE 1
+#define CONFIG_USB_ET61X251_MODULE 1
+#define CONFIG_HDLC_X25_MODULE 1
+#define CONFIG_ROSE_MODULE 1
+#define CONFIG_NET_ACT_POLICE_MODULE 1
+#define CONFIG_NF_CONNTRACK_PPTP_MODULE 1
+#define CONFIG_X86_IO_APIC 1
+#define CONFIG_JFFS2_RUBIN 1
+#define CONFIG_USB_SERIAL_XIRCOM_MODULE 1
+#define CONFIG_LOGITECH_FF 1
+#define CONFIG_SENSORS_PCA9539_MODULE 1
+#define CONFIG_I6300ESB_WDT_MODULE 1
+#define CONFIG_ALIM7101_WDT_MODULE 1
+#define CONFIG_IPW2100_MONITOR 1
+#define CONFIG_IP6_NF_MATCH_EUI64_MODULE 1
+#define CONFIG_NR_CPUS 8
+#define CONFIG_GENERIC_BUG 1
+#define CONFIG_CRYPTO_MANAGER 1
+#define CONFIG_JFFS2_RTIME 1
+#define CONFIG_VIDEO_CQCAM_MODULE 1
+#define CONFIG_SERIAL_8250_PNP 1
+#define CONFIG_LANMEDIA_MODULE 1
+#define CONFIG_IPW2200_MONITOR 1
+#define CONFIG_BT_HCIBFUSB_MODULE 1
+#define CONFIG_X86_L1_CACHE_BYTES 128
+#define CONFIG_SWAP 1
+#define CONFIG_KEYS 1
+#define CONFIG_EXT2_FS_POSIX_ACL 1
+#define CONFIG_USB_STORAGE_USBAT 1
+#define CONFIG_VIDEO_CPIA_USB_MODULE 1
+#define CONFIG_SENSORS_PCF8591_MODULE 1
+#define CONFIG_IEEE1394_OHCI1394 1
+#define CONFIG_PARIDE_ATEN_MODULE 1
+#define CONFIG_PARIDE_PARPORT 1
+#define CONFIG_NFTL_RW 1
+#define CONFIG_MTD_REDBOOT_PARTS_MODULE 1
+#define CONFIG_MA600_DONGLE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNMARK_MODULE 1
+#define CONFIG_TCP_CONG_HYBLA_MODULE 1
+#define CONFIG_CPU_FREQ_TABLE 1
+#define CONFIG_ACPI_PROCESSOR 1
+#define CONFIG_EXT3_FS_POSIX_ACL 1
+#define CONFIG_USB_SPEEDTOUCH_MODULE 1
+#define CONFIG_SND_KORG1212_MODULE 1
+#define CONFIG_SENSORS_PCF8574_MODULE 1
+#define CONFIG_W83627HF_WDT_MODULE 1
+#define CONFIG_AC97_BUS_MODULE 1
+#define CONFIG_CYCLOMX_X25 1
+#define CONFIG_BRIDGE_EBT_STP_MODULE 1
+#define CONFIG_XFRM 1
+#define CONFIG_CRC32 1
+#define CONFIG_USB_APPLETOUCH_MODULE 1
+#define CONFIG_SND_VIA82XX_MODULE 1
+#define CONFIG_VIDEO_KS0127_MODULE 1
+#define CONFIG_GAMEPORT_L4_MODULE 1
+#define CONFIG_AIC79XX_DEBUG_MASK 0
+#define CONFIG_BLK_DEV_3W_XXXX_RAID 1
+#define CONFIG_BLK_DEV_RAM_COUNT 16
+#define CONFIG_PARIDE_EPAT_MODULE 1
+#define CONFIG_MTD_ESB2ROM_MODULE 1
+#define CONFIG_DEFAULT_CFQ 1
+#define CONFIG_VXFS_FS_MODULE 1
+#define CONFIG_USB_NET_NET1080_MODULE 1
+#define CONFIG_ALIM1535_WDT_MODULE 1
+#define CONFIG_CRC16_MODULE 1
+#define CONFIG_IP_NF_IPTABLES_MODULE 1
+#define CONFIG_FAT_DEFAULT_IOCHARSET "iso8859-1"
+#define CONFIG_INPUT_KEYBOARD 1
+#define CONFIG_MD_RAID0 1
+#define CONFIG_BLK_DEV_INITRD 1
+#define CONFIG_PARIDE_COMM_MODULE 1
+#define CONFIG_D80211 1
+#define CONFIG_NET_ACT_MIRRED_MODULE 1
+#define CONFIG_IP_NF_MATCH_AH_MODULE 1
+#define CONFIG_TEXTSEARCH_FSM_MODULE 1
+#define CONFIG_SECURITY_CAPABILITIES 1
+#define CONFIG_NFSD_V2_ACL 1
+#define CONFIG_USB_SERIAL_OPTION_MODULE 1
+#define CONFIG_DVB_USB_GP8PSK_MODULE 1
+#define CONFIG_W1_SLAVE_THERM_MODULE 1
+#define CONFIG_TOUCHSCREEN_UCB1400_MODULE 1
+#define CONFIG_MD_RAID1 1
+#define CONFIG_NET_CLS_U32_MODULE 1
+#define CONFIG_BRIDGE_NF_EBTABLES_MODULE 1
+#define CONFIG_NFSD_V3_ACL 1
+#define CONFIG_RTC_DRV_PCF8563_MODULE 1
+#define CONFIG_SPI_BITBANG_MODULE 1
+#define CONFIG_MTDRAM_TOTAL_SIZE 4096
+#define CONFIG_IP_NF_MATCH_OWNER_MODULE 1
+#define CONFIG_TEXTSEARCH_KMP_MODULE 1
+#define CONFIG_TCP_CONG_VEGAS_MODULE 1
+#define CONFIG_PACKET_MMAP 1
+#define CONFIG_NTFS_RW 1
+#define CONFIG_SND_SEQUENCER_OSS 1
+#define CONFIG_SENSORS_MAX1619_MODULE 1
+#define CONFIG_SCSI_INIA100 1
+#define CONFIG_NETFILTER_XT_TARGET_SECMARK_MODULE 1
+#define CONFIG_RTC_DRV_PCF8583_MODULE 1
+#define CONFIG_SENSORS_ABITUGURU_MODULE 1
+#define CONFIG_W83697HF_WDT_MODULE 1
+#define CONFIG_PPP_DEFLATE_MODULE 1
+#define CONFIG_UNIX 1
+#define CONFIG_GENERIC_CPU 1
+#define CONFIG_CIFS_UPCALL 1
+#define CONFIG_CIFS_STATS2 1
+#define CONFIG_JFFS2_FS_XATTR 1
+#define CONFIG_SENSORS_K8TEMP_MODULE 1
+#define CONFIG_I2C_PARPORT_MODULE 1
+#define CONFIG_PCMCIA_SYM53C500_MODULE 1
+#define CONFIG_BAYCOM_SER_FDX_MODULE 1
+#define CONFIG_HAMRADIO 1
+#define CONFIG_NET_SCH_DSMARK_MODULE 1
+#define CONFIG_MTRR 1
+#define CONFIG_RTC_DRV_ISL1208_MODULE 1
+#define CONFIG_PARIDE_FRIQ_MODULE 1
+#define CONFIG_CONFIGFS_FS_MODULE 1
+#define CONFIG_SENSORS_FSCHER_MODULE 1
+#define CONFIG_INPUT_MOUSEDEV_PSAUX 1
+#define CONFIG_PARPORT_SERIAL 1
+#define CONFIG_MTD_ONENAND_MODULE 1
+#define CONFIG_BT_L2CAP_MODULE 1
+#define CONFIG_BAYCOM_SER_HDX_MODULE 1
+#define CONFIG_NETLABEL 1
+#define CONFIG_ISA_DMA_API 1
+#define CONFIG_DVB_USB_TTUSB2_MODULE 1
+#define CONFIG_VIDEO_TVEEPROM_MODULE 1
+#define CONFIG_SERIAL_CORE 1
+#define CONFIG_CYCLADES_MODULE 1
+#define CONFIG_RT2400PCI_MODULE 1
+#define CONFIG_LXT_PHY_MODULE 1
+#define CONFIG_BLK_DEV_SR_VENDOR 1
+#define CONFIG_MTD_SC520CDP_MODULE 1
+#define CONFIG_IP_NF_TARGET_ULOG_MODULE 1
+#define CONFIG_TCP_CONG_WESTWOOD_MODULE 1
+#define CONFIG_SOUND_CS4232_MODULE 1
+#define CONFIG_FB_GEODE_GX_MODULE 1
+#define CONFIG_RT2500PCI_MODULE 1
+#define CONFIG_PDC_ADMA 1
+#define CONFIG_SCSI_QLA_ISCSI 1
+#define CONFIG_UID16 1
+#define CONFIG_LOCK_KERNEL 1
+#define CONFIG_64BIT 1
+#define CONFIG_RTC_DRV_MAX6902_MODULE 1
+#define CONFIG_USB_EHCI_ROOT_HUB_TT 1
+#define CONFIG_ISDN_CAPI_CAPIFS_BOOL 1
+#define CONFIG_DE4X5_MODULE 1
+#define CONFIG_SCSI_IPR_TRACE 1
+#define CONFIG_BLK_DEV_NBD_MODULE 1
+#define CONFIG_CRYPTO_ARC4 1
+#define CONFIG_NET_CLS_ROUTE4_MODULE 1
+#define CONFIG_PHYSICAL_START 0x200000
+#define CONFIG_IKCONFIG 1
+#define CONFIG_FB_GEODE 1
+#define CONFIG_DVB_USB_DIGITV_MODULE 1
+#define CONFIG_VIDEO_BT848_DVB 1
+#define CONFIG_INPUT_TSDEV_SCREEN_X 1024
+#define CONFIG_NE2K_PCI_MODULE 1
+#define CONFIG_BINFMT_MISC 1
+#define CONFIG_RTC_DRV_RS5C372_MODULE 1
+#define CONFIG_SOUND_ES1371_MODULE 1
+#define CONFIG_SENSORS_MAX6875_MODULE 1
+#define CONFIG_INPUT_TSDEV_SCREEN_Y 768
+#define CONFIG_IPW3945_MONITOR 1
+#define CONFIG_CISS_SCSI_TAPE 1
+#define CONFIG_AX25_DAMA_SLAVE 1
+#define CONFIG_NF_CONNTRACK_PROC_COMPAT 1
+#define CONFIG_IP_FIB_HASH 1
+#define CONFIG_SYSV_FS 1
+#define CONFIG_JFS_STATISTICS 1
+#define CONFIG_REISERFS_FS_XATTR 1
+#define CONFIG_CRYPTO_SHA1_MODULE 1
+#define CONFIG_USB_PHIDGET_MODULE 1
+#define CONFIG_MEGARAID_LEGACY 1
+#define CONFIG_INET6_AH_MODULE 1
+#define CONFIG_TCP_CONG_HSTCP_MODULE 1
+#define CONFIG_I82092_MODULE 1
+#define CONFIG_PARTITION_ADVANCED 1
+#define CONFIG_RTC_DRV_RS5C348_MODULE 1
+#define CONFIG_LOGO_LINUX_CLUT224 1
+#define CONFIG_VIDEO_OV7670_MODULE 1
+#define CONFIG_MTD_BLKDEVS_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_NOTRACK_MODULE 1
+#define CONFIG_USB_CYPRESS_CY7C63_MODULE 1
+#define CONFIG_FONT_ACORN_8x8 1
+#define CONFIG_VGA_CONSOLE 1
+#define CONFIG_CDROM_PKTCDVD_BUFFERS 8
+#define CONFIG_PARIDE_KTTI_MODULE 1
+#define CONFIG_IEEE80211_CRYPT_WEP_MODULE 1
+#define CONFIG_PCIEPORTBUS 1
+#define CONFIG_ACPI_HOTKEY 1
+#define CONFIG_PREEMPT_VOLUNTARY 1
+#define CONFIG_NLS_DEFAULT "iso8859-1"
+#define CONFIG_SC6600_CDROMBASE 0x0
+#define CONFIG_SND_RAWMIDI_MODULE 1
+#define CONFIG_FONT_PEARL_8x8 1
+#define CONFIG_SENSORS_VIA686A_MODULE 1
+#define CONFIG_TELCLOCK_MODULE 1
+#define CONFIG_WATCHDOG 1
+#define CONFIG_DSCC4_MODULE 1
+#define CONFIG_SUNDANCE_MODULE 1
+#define CONFIG_SGI_IOC4_MODULE 1
+#define CONFIG_PARIDE_DSTR_MODULE 1
+#define CONFIG_MTD_PARTITIONS 1
+#define CONFIG_WINBOND_FIR_MODULE 1
+#define CONFIG_CPU_FREQ_GOV_PERFORMANCE 1
+#define CONFIG_ACPI_FAN 1
+#define CONFIG_CRYPTO_TWOFISH_X86_64_MODULE 1
+#define CONFIG_SECURITY_SELINUX_DISABLE 1
+#define CONFIG_USB_ATI_REMOTE_MODULE 1
+#define CONFIG_SPLIT_PTLOCK_CPUS 4
+#define CONFIG_SECURITY_ROOTPLUG_MODULE 1
+#define CONFIG_JFFS2_FS_MODULE 1
+#define CONFIG_USB_STORAGE_SDDR09 1
+#define CONFIG_USB_ISP116X_HCD_MODULE 1
+#define CONFIG_SENSORS_SIS5595_MODULE 1
+#define CONFIG_TOUCHSCREEN_ADS7846_MODULE 1
+#define CONFIG_DAVICOM_PHY_MODULE 1
+#define CONFIG_PARIDE_FRPW_MODULE 1
+#define CONFIG_MTD_PHYSMAP_START 0x8000000
+#define CONFIG_YENTA_ENE_TUNE 1
+#define CONFIG_ACORN_PARTITION_POWERTEC 1
+#define CONFIG_USB_STORAGE_SDDR55 1
+#define CONFIG_DVB_LGDT330X_MODULE 1
+#define CONFIG_SENSORS_EEPROM_MODULE 1
+#define CONFIG_ARCNET_COM90xx_MODULE 1
+#define CONFIG_PATA_ATIIXP 1
+#define CONFIG_NETFILTER_XT_MATCH_REALM_MODULE 1
+#define CONFIG_SYSVIPC_COMPAT 1
+#define CONFIG_ACPI_IBM 1
+#define CONFIG_SUSPEND2 1
+#define CONFIG_OCFS2_FS_MODULE 1
+#define CONFIG_SND_RIPTIDE_MODULE 1
+#define CONFIG_FB_SAVAGE_ACCEL 1
+#define CONFIG_VIDEO_WM8739_MODULE 1
+#define CONFIG_VIDEO_WM8775_MODULE 1
+#define CONFIG_APPLICOM_MODULE 1
+#define CONFIG_MTD_PLATRAM_MODULE 1
+#define CONFIG_BT_HCIBPA10X_MODULE 1
+#define CONFIG_6PACK_MODULE 1
+#define CONFIG_YENTA_RICOH 1
+#define CONFIG_PREEMPT_BKL 1
+#define CONFIG_CRYPTO_GF128MUL_MODULE 1
+#define CONFIG_LOCKD_V4 1
+#define CONFIG_USB_YEALINK_MODULE 1
+#define CONFIG_USB_APPLEIR_MODULE 1
+#define CONFIG_VIDEO_CAFE_CCIC_MODULE 1
+#define CONFIG_SENSORS_GL520SM_MODULE 1
+#define CONFIG_JOYSTICK_SPACEBALL_MODULE 1
+#define CONFIG_BLK_DEV_RAM 1
+#define CONFIG_PARPORT_1284 1
+#define CONFIG_NETFILTER_XT_TARGET_NFQUEUE_MODULE 1
+#define CONFIG_NODES_SHIFT 6
+#define CONFIG_SCHED_MC 1
+#define CONFIG_VM_EVENT_COUNTERS 1
+#define CONFIG_LIBCRC32C 1
+#define CONFIG_BACKLIGHT_LCD_SUPPORT 1
+#define CONFIG_DVB_USB_DTT200U_MODULE 1
+#define CONFIG_INPUT_MOUSEDEV 1
+#define CONFIG_PPP_BSDCOMP_MODULE 1
+#define CONFIG_RT2500USB_MODULE 1
+#define CONFIG_FUSION_MAX_SGE 128
+#define CONFIG_PATA_AMD 1
+#define CONFIG_SCSI_QLA_FC 1
+#define CONFIG_INET_IPCOMP_MODULE 1
+#define CONFIG_USB_SERIAL_IPW_MODULE 1
+#define CONFIG_USB_NET_AX8817X_MODULE 1
+#define CONFIG_USB_USBNET_MII_MODULE 1
+#define CONFIG_SND_VIRMIDI_MODULE 1
+#define CONFIG_ACQUIRE_WDT_MODULE 1
+#define CONFIG_CHR_DEV_SCH_MODULE 1
+#define CONFIG_MTD_NETSC520_MODULE 1
+#define CONFIG_ACPI_BUTTON 1
+#define CONFIG_SMB_NLS_REMOTE "cp437"
+#define CONFIG_SCSI_ARCMSR_MODULE 1
+#define CONFIG_BLK_DEV_SX8_MODULE 1
+#define CONFIG_NET_SCH_CBQ_MODULE 1
+#define CONFIG_CRYPTO_HMAC 1
+#define CONFIG_SND_SEQ_RTCTIMER_DEFAULT 1
+#define CONFIG_SENSORS_FSCPOS_MODULE 1
+#define CONFIG_IPV6_TUNNEL_MODULE 1
+#define CONFIG_SOLARIS_X86_PARTITION 1
+#define CONFIG_REISERFS_FS 1
+#define CONFIG_I2C_STUB_MODULE 1
+#define CONFIG_SERIAL_NONSTANDARD 1
+#define CONFIG_I2O_SCSI 1
+#define CONFIG_PATA_ALI 1
+#define CONFIG_BLK_DEV_RAM_BLOCKSIZE 1024
+#define CONFIG_BPQETHER_MODULE 1
+#define CONFIG_UNUSED_SYMBOLS 1
+#define CONFIG_SOUND_YM3812_MODULE 1
+#define CONFIG_DVB_DIB3000MB_MODULE 1
+#define CONFIG_HANGCHECK_TIMER_MODULE 1
+#define CONFIG_SYSCTL_SYSCALL 1
+#define CONFIG_UNIXWARE_DISKLABEL 1
+#define CONFIG_DVB_DIB3000MC_MODULE 1
+#define CONFIG_DVB_USB_A800_MODULE 1
+#define CONFIG_SENSORS_GL518SM_MODULE 1
+#define CONFIG_DM9102_MODULE 1
+#define CONFIG_I2O_PROC 1
+#define CONFIG_SCSI_INITIO 1
+#define CONFIG_AIC79XX_REG_PRETTY_PRINT 1
+#define CONFIG_AIC7XXX_DEBUG_MASK 0
+#define CONFIG_USB_STORAGE 1
+#define CONFIG_SND_TRIDENT_MODULE 1
+#define CONFIG_MTD_ICHXROM_MODULE 1
+#define CONFIG_NET_SCH_RED_MODULE 1
+#define CONFIG_USB_IDMOUSE_MODULE 1
+#define CONFIG_SERIAL_8250_RUNTIME_UARTS 4
+#define CONFIG_GAMEPORT_MODULE 1
+#define CONFIG_INPUT_JOYSTICK 1
+#define CONFIG_IEEE1394_SBP2 1
+#define CONFIG_NET_CLS_ACT 1
+#define CONFIG_NET_SCH_TBF_MODULE 1
+#define CONFIG_DEBUG_FS 1
+#define CONFIG_ELF_CORE 1
+#define CONFIG_CRYPTO_XCBC_MODULE 1
+#define CONFIG_SND_EMU10K1X_MODULE 1
+#define CONFIG_VIDEO_ZORAN_MODULE 1
+#define CONFIG_SYNCLINK_CS_MODULE 1
+#define CONFIG_CAPI_AVM 1
+#define CONFIG_DM_SNAPSHOT 1
+#define CONFIG_CRYPTO_SERPENT_MODULE 1
+#define CONFIG_USB_PEGASUS_MODULE 1
+#define CONFIG_SOUND_VMIDI_MODULE 1
+#define CONFIG_VIDEO_CX88_ALSA_MODULE 1
+#define CONFIG_DLCI_MAX 8
+#define CONFIG_SSB_PCIHOST 1
+#define CONFIG_MTD_PHYSMAP_BANKWIDTH 2
+#define CONFIG_NET_SCH_HTB_MODULE 1
+#define CONFIG_ATM_LANE_MODULE 1
+#define CONFIG_YENTA_O2 1
+#define CONFIG_ACPI_SYSTEM 1
+#define CONFIG_MMC_TIFM_SD_MODULE 1
+#define CONFIG_USB_U132_HCD_MODULE 1
+#define CONFIG_SC6600 1
+#define CONFIG_MTD_CHAR_MODULE 1
+#define CONFIG_NET_CLS_IND 1
+#define CONFIG_NETFILTER_XT_MATCH_LIMIT_MODULE 1
+#define CONFIG_NETFILTER_NETLINK_LOG_MODULE 1
+#define CONFIG_FB_ATY_GENERIC_LCD 1
+#define CONFIG_FB_INTEL_MODULE 1
+#define CONFIG_MARVELL_PHY_MODULE 1
+#define CONFIG_IP_NF_TARGET_REDIRECT_MODULE 1
+#define CONFIG_RESOURCES_64BIT 1
+#define CONFIG_DEFAULT_IOSCHED "cfq"
+#define CONFIG_CRYPTO_TWOFISH_MODULE 1
+#define CONFIG_CRYPTO_HASH 1
+#define CONFIG_INFINIBAND_ISER_MODULE 1
+#define CONFIG_INFINIBAND_MTHCA_DEBUG 1
+#define CONFIG_USB_CATC_MODULE 1
+#define CONFIG_DVB_CORE 1
+#define CONFIG_VIDEO_TUNER_MODULE 1
+#define CONFIG_60XX_WDT_MODULE 1
+#define CONFIG_LEGACY_PTYS 1
+#define CONFIG_UNIX98_PTYS 1
+#define CONFIG_HDLC_RAW_MODULE 1
+#define CONFIG_EEPROM_93CX6_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATE_MODULE 1
+#define CONFIG_IP_PIMSM_V1 1
+#define CONFIG_IP_PNP_DHCP 1
+#define CONFIG_ACPI_SBS_MODULE 1
+#define CONFIG_ARCH_DISCONTIGMEM_DEFAULT 1
+#define CONFIG_USB_CYTHERM_MODULE 1
+#define CONFIG_USB_SERIAL_GENERIC 1
+#define CONFIG_USB_STORAGE_ALAUDA 1
+#define CONFIG_FB_CFB_COPYAREA 1
+#define CONFIG_SOUND_PRIME_MODULE 1
+#define CONFIG_SYNCLINK_GT_MODULE 1
+#define CONFIG_PATA_VIA 1
+#define CONFIG_SCSI_HPTIOP 1
+#define CONFIG_SCSI_SAS_ATTRS 1
+#define CONFIG_MTD_ONENAND_VERIFY_WRITE 1
+#define CONFIG_MTD_NAND_MODULE 1
+#define CONFIG_MTD_DILNETPC_BOOTSIZE 0x80000
+#define CONFIG_NET_SCH_ATM_MODULE 1
+#define CONFIG_IP_PIMSM_V2 1
+#define CONFIG_INET_TUNNEL_MODULE 1
+#define CONFIG_CPU_FREQ_GOV_ONDEMAND 1
+#define CONFIG_PRINTK_TIME 1
+#define CONFIG_SND_MPU401_UART_MODULE 1
+#define CONFIG_FRAMEBUFFER_CONSOLE_ROTATION 1
+#define CONFIG_FB_CFB_FILLRECT 1
+#define CONFIG_MTD_PHYSMAP_MODULE 1
+#define CONFIG_SYN_COOKIES 1
+#define CONFIG_X86_INTERNODE_CACHE_BYTES 128
+#define CONFIG_SEMAPHORE_SLEEPERS 1
+#define CONFIG_ISDN_DRV_AVMB1_AVM_CS_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCIV4 1
+#define CONFIG_IPW2200_RADIOTAP 1
+#define CONFIG_SATA_SX4 1
+#define CONFIG_ATM_BR2684_IPFILTER 1
+#define CONFIG_NETFILTER_XT_TARGET_DSCP_MODULE 1
+#define CONFIG_PCI200SYN_MODULE 1
+#define CONFIG_8139CP_MODULE 1
+#define CONFIG_SATA_VIA 1
+#define CONFIG_PROC_EVENTS 1
+#define CONFIG_NETFILTER_XT_TARGET_MARK_MODULE 1
+#define CONFIG_IP_VS_TAB_BITS 12
+#define CONFIG_TCP_CONG_LP_MODULE 1
+#define CONFIG_DELL_RBU_MODULE 1
+#define CONFIG_USB_TOUCHSCREEN_DMC_TSC10 1
+#define CONFIG_INPUT_EVDEV 1
+#define CONFIG_USB_IRDA_MODULE 1
+#define CONFIG_ATM_CLIP_MODULE 1
+#define CONFIG_INFINIBAND_IPOIB_DEBUG 1
+#define CONFIG_DVB_USB_UMT_010_MODULE 1
+#define CONFIG_VIDEO_ZORAN_ZR36060_MODULE 1
+#define CONFIG_ATM_HORIZON_MODULE 1
+#define CONFIG_HDLC_PPP_MODULE 1
+#define CONFIG_SCSI_SPI_ATTRS 1
+#define CONFIG_SCSI_MULTI_LUN 1
+#define CONFIG_PARPORT_NOT_PC 1
+#define CONFIG_NET_ACT_IPT_MODULE 1
+#define CONFIG_PCMCIA_LOAD_CIS 1
+#define CONFIG_HOTPLUG_CPU 1
+#define CONFIG_GENERIC_ISA_DMA 1
+#define CONFIG_EXT2_FS_XIP 1
+#define CONFIG_USB_TOUCHSCREEN_3M 1
+#define CONFIG_USB_SUSPEND 1
+#define CONFIG_CPU5_WDT_MODULE 1
+#define CONFIG_SYNCLINK_MODULE 1
+#define CONFIG_I2O_EXT_ADAPTEC 1
+#define CONFIG_CRYPTO_MICHAEL_MIC_MODULE 1
+#define CONFIG_BLOCK 1
+#define CONFIG_MMC_WBSD_MODULE 1
+#define CONFIG_SND_OSSEMUL 1
+#define CONFIG_RADIO_MAXIRADIO_MODULE 1
+#define CONFIG_PD6729_MODULE 1
+#define CONFIG_GENERIC_HWEIGHT 1
+#define CONFIG_SECURITY_SELINUX_DEVELOP 1
+#define CONFIG_LOCKD 1
+#define CONFIG_QUOTACTL 1
+#define CONFIG_USB_XUSBATM_MODULE 1
+#define CONFIG_USB_PRINTER 1
+#define CONFIG_NET_SCH_SFQ_MODULE 1
+#define CONFIG_ATALK_MODULE 1
+#define CONFIG_BRIDGE_EBT_DNAT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_QUOTA_MODULE 1
+#define CONFIG_BACKLIGHT_CLASS_DEVICE 1
+#define CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE 3
+#define CONFIG_SQUASHFS 1
+#define CONFIG_ATM_MPOA_MODULE 1
+#define CONFIG_IP_ADVANCED_ROUTER 1
+#define CONFIG_ACORN_PARTITION_EESOX 1
+#define CONFIG_USB_TRANCEVIBRATOR_MODULE 1
+#define CONFIG_ZEROPLUS_FF 1
+#define CONFIG_SOUND_MPU401_MODULE 1
+#define CONFIG_SND_MONA_MODULE 1
+#define CONFIG_IEEE1394_PCILYNX_MODULE 1
+#define CONFIG_ATA_PIIX 1
+#define CONFIG_IP_VS_LBLCR_MODULE 1
+#define CONFIG_RTC_INTF_SYSFS 1
+#define CONFIG_SND_FM801_MODULE 1
+#define CONFIG_FB_ATY128_MODULE 1
+#define CONFIG_VIDEO_OVCAMCHIP_MODULE 1
+#define CONFIG_IB700_WDT_MODULE 1
+#define CONFIG_SATA_SIL 1
+#define CONFIG_MTD_NETtel_MODULE 1
+#define CONFIG_IP_NF_QUEUE_MODULE 1
+#define CONFIG_KALLSYMS 1
+#define CONFIG_NFSD_TCP 1
+#define CONFIG_VIDEO_IR_MODULE 1
+#define CONFIG_PC8736x_GPIO_MODULE 1
+#define CONFIG_MD_RAID10 1
+#define CONFIG_NEW_LEDS 1
+#define CONFIG_IPDDP_MODULE 1
+#define CONFIG_BRIDGE_EBT_MARK_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNSECMARK_MODULE 1
+#define CONFIG_SUSPEND_SMP 1
+#define CONFIG_DVB_MT312_MODULE 1
+#define CONFIG_NSC_GPIO_MODULE 1
+#define CONFIG_TOUCHSCREEN_MTOUCH_MODULE 1
+#define CONFIG_CHELSIO_T1_NAPI 1
+#define CONFIG_SATA_ULI 1
+#define CONFIG_SCSI_PPA_MODULE 1
+#define CONFIG_MTD_NAND_DISKONCHIP_BBTWRITE 1
+#define CONFIG_MTD_SBC_GXX_MODULE 1
+#define CONFIG_BRIDGE_EBT_802_3_MODULE 1
+#define CONFIG_K8_NB 1
+#define CONFIG_NLS_UTF8 1
+#define CONFIG_SND_HDSP_MODULE 1
+#define CONFIG_ATMEL_MODULE 1
+#define CONFIG_IBMOL_MODULE 1
+#define CONFIG_VITESSE_PHY_MODULE 1
+#define CONFIG_SCSI_EATA_LINKED_COMMANDS 1
+#define CONFIG_SSFDC_MODULE 1
+#define CONFIG_NF_NAT_TFTP_MODULE 1
+#define CONFIG_NETFILTER_DEBUG 1
+#define CONFIG_AGP_AMD64 1
+#define CONFIG_JFFS2_FS_POSIX_ACL 1
+#define CONFIG_USB_TOUCHSCREEN_GUNZE 1
+#define CONFIG_USB_DSBR_MODULE 1
+#define CONFIG_VIDEO_CX25840_MODULE 1
+#define CONFIG_VIDEO_SAA7110_MODULE 1
+#define CONFIG_PATA_SIS 1
+#define CONFIG_SCSI_IMM_MODULE 1
+#define CONFIG_LITELINK_DONGLE_MODULE 1
+#define CONFIG_IPV6_SIT_MODULE 1
+#define CONFIG_PROC_SYSCTL 1
+#define CONFIG_RTC_HCTOSYS 1
+#define CONFIG_USB_SERIAL_CYPRESS_M8_MODULE 1
+#define CONFIG_VIDEO_SAA7111_MODULE 1
+#define CONFIG_INPUT_TSDEV 1
+#define CONFIG_IP6_NF_IPTABLES_MODULE 1
+#define CONFIG_CPU_FREQ_STAT_DETAILS 1
+#define CONFIG_CPU_FREQ 1
+#define CONFIG_USB_XPAD_MODULE 1
+#define CONFIG_USB_SE401_MODULE 1
+#define CONFIG_DVB_MT352_MODULE 1
+#define CONFIG_I8XX_TCO_MODULE 1
+#define CONFIG_SCSI_AACRAID 1
+#define CONFIG_IRLAN_MODULE 1
+#define CONFIG_IP6_NF_MATCH_AH_MODULE 1
+#define CONFIG_USB_MIDI_GADGET_MODULE 1
+#define CONFIG_USB_SL811_CS_MODULE 1
+#define CONFIG_KEYBOARD_SUNKBD 1
+#define CONFIG_SSB_DRIVER_PCICORE 1
+#define CONFIG_SATA_SIS 1
+#define CONFIG_BRIDGE_EBT_VLAN_MODULE 1
+#define CONFIG_BRIDGE_EBT_PKTTYPE_MODULE 1
+#define CONFIG_INET_ESP_MODULE 1
+#define CONFIG_AUDIT 1
+#define CONFIG_AMIGA_PARTITION 1
+#define CONFIG_SND_PCM_OSS 1
+#define CONFIG_VIDEO_SAA7114_MODULE 1
+#define CONFIG_W1_MASTER_DS2490_MODULE 1
+#define CONFIG_DRM_TDFX_MODULE 1
+#define CONFIG_INPUT_MOUSE 1
+#define CONFIG_ISDN_DIVAS_USERIDI_MODULE 1
+#define CONFIG_PCMCIA_WL3501_MODULE 1
+#define CONFIG_IP6_NF_MATCH_OWNER_MODULE 1
+#define CONFIG_IP_NF_MATCH_RECENT_MODULE 1
+#define CONFIG_SECURITY 1
+#define CONFIG_NET_IPIP_MODULE 1
+#define CONFIG_RAMFS 1
+#define CONFIG_USB_NET_ZAURUS_MODULE 1
+#define CONFIG_W1_MASTER_DS2482_MODULE 1
+#define CONFIG_NF_NAT_PPTP_MODULE 1
+#define CONFIG_FB_GEODE_GX1_MODULE 1
+#define CONFIG_VIDEO_SAA7134_MODULE 1
+#define CONFIG_PHONE_MODULE 1
+#define CONFIG_SCSI_QLOGIC_1280 1
+#define CONFIG_IP_PNP_RARP 1
+#define CONFIG_SHMEM 1
+#define CONFIG_CRYPTO_NULL_MODULE 1
+#define CONFIG_EXPORTFS 1
+#define CONFIG_LEDS_TRIGGER_TIMER_MODULE 1
+#define CONFIG_SENSORS_W83627HF_MODULE 1
+#define CONFIG_SC520_WDT_MODULE 1
+#define CONFIG_SCSI_AIC94XX_MODULE 1
+#define CONFIG_REISERFS_FS_POSIX_ACL 1
+#define CONFIG_SND_NM256_MODULE 1
+#define CONFIG_VIDEO_SAA7127_MODULE 1
+#define CONFIG_VIDEO_TEA6420_MODULE 1
+#define CONFIG_IPW2200_PROMISCUOUS 1
+#define CONFIG_PATA_HPT3X2N 1
+#define CONFIG_SCSI_IPR 1
+#define CONFIG_AIC7XXX_REG_PRETTY_PRINT 1
+#define CONFIG_BRIDGE_EBT_SNAT_MODULE 1
+#define CONFIG_IP_VS_PROTO_AH 1
+#define CONFIG_INET_XFRM_MODE_TRANSPORT 1
+#define CONFIG_EPOLL 1
+#define CONFIG_MINIX_FS_MODULE 1
+#define CONFIG_SOUND_SB_MODULE 1
+#define CONFIG_SOUND_VIA82CXXX_MODULE 1
+#define CONFIG_VIDEO_SAA7146_MODULE 1
+#define CONFIG_VIDEO_SAA7191_MODULE 1
+#define CONFIG_ITCO_WDT_MODULE 1
+#define CONFIG_JOYSTICK_IFORCE_232 1
+#define CONFIG_ATM_ZATM_MODULE 1
+#define CONFIG_SCSI_IPS 1
+#define CONFIG_INFTL_MODULE 1
+#define CONFIG_BRIDGE_EBT_ULOG_MODULE 1
+#define CONFIG_YENTA_TI 1
+#define CONFIG_RELAY 1
+#define CONFIG_MSDOS_FS 1
+#define CONFIG_FONT_8x8 1
+#define CONFIG_FB_MODE_HELPERS 1
+#define CONFIG_SCSI_AIC79XX 1
+#define CONFIG_VLSI_FIR_MODULE 1
+#define CONFIG_NET_EMATCH_META_MODULE 1
+#define CONFIG_IP_MULTIPLE_TABLES 1
+#define CONFIG_CRYPTO_WP512_MODULE 1
+#define CONFIG_RPCSEC_GSS_KRB5 1
+#define CONFIG_ROMFS_FS 1
+#define CONFIG_VIDEO_SAA5249_MODULE 1
+#define CONFIG_VIDEO_TDA7432_MODULE 1
+#define CONFIG_PPDEV 1
+#define CONFIG_PCMCIA_ATMEL_MODULE 1
+#define CONFIG_PCMCIA_SPECTRUM_MODULE 1
+#define CONFIG_PATA_PDC2027X 1
+#define CONFIG_SCSI_EATA_MAX_TAGS 16
+#define CONFIG_CRYPTO_TEST_MODULE 1
+#define CONFIG_NLS_CODEPAGE_850_MODULE 1
+#define CONFIG_SND_INTEL8X0_MODULE 1
+#define CONFIG_FB_INTEL_I2C 1
+#define CONFIG_VIDEO_ADV7170_MODULE 1
+#define CONFIG_VIDEO_SAA7185_MODULE 1
+#define CONFIG_MWAVE_MODULE 1
+#define CONFIG_TIPAR_MODULE 1
+#define CONFIG_MEGARAID_SAS 1
+#define CONFIG_SCSI_TGT_MODULE 1
+#define CONFIG_IEEE80211_SOFTMAC_MODULE 1
+#define CONFIG_ACPI_SLEEP_PROC_FS 1
+#define CONFIG_NLS_CODEPAGE_932_MODULE 1
+#define CONFIG_NLS_CODEPAGE_950_MODULE 1
+#define CONFIG_NLS_CODEPAGE_860_MODULE 1
+#define CONFIG_NLS_CODEPAGE_437_MODULE 1
+#define CONFIG_9P_FS_MODULE 1
+#define CONFIG_UNION_FS 1
+#define CONFIG_REISERFS_PROC_INFO 1
+#define CONFIG_INFINIBAND_USER_ACCESS_MODULE 1
+#define CONFIG_JOYSTICK_GUILLEMOT_MODULE 1
+#define CONFIG_JOYSTICK_ANALOG_MODULE 1
+#define CONFIG_PPP_MPPE_MODULE 1
+#define CONFIG_IEEE1394_EXTRA_CONFIG_ROMS 1
+#define CONFIG_IP6_NF_MATCH_HL_MODULE 1
+#define CONFIG_YENTA_MODULE 1
+#define CONFIG_STACKTRACE_SUPPORT 1
+#define CONFIG_NLS_CODEPAGE_861_MODULE 1
+#define CONFIG_NLS_CODEPAGE_852_MODULE 1
+#define CONFIG_USB_SERIAL_OMNINET_MODULE 1
+#define CONFIG_VIDEO_EM28XX_MODULE 1
+#define CONFIG_HW_RANDOM_GEODE 1
+#define CONFIG_GAMEPORT_EMU10K1_MODULE 1
+#define CONFIG_TOUCHSCREEN_ELO_MODULE 1
+#define CONFIG_SERIO 1
+#define CONFIG_ABYSS_MODULE 1
+#define CONFIG_DM_CRYPT 1
+#define CONFIG_IRNET_MODULE 1
+#define CONFIG_NLS_CODEPAGE_862_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_MODULE 1
+#define CONFIG_SND_CS46XX_NEW_DSP 1
+#define CONFIG_SCSI_FUTURE_DOMAIN_MODULE 1
+#define CONFIG_MTD_NAND_VERIFY_WRITE 1
+#define CONFIG_NLS_CODEPAGE_863_MODULE 1
+#define CONFIG_NLS_CODEPAGE_737_MODULE 1
+#define CONFIG_RTC_HCTOSYS_DEVICE "rtc0"
+#define CONFIG_USB_ATI_REMOTE2_MODULE 1
+#define CONFIG_VIDEO_TDA9840_MODULE 1
+#define CONFIG_PPPOE_MODULE 1
+#define CONFIG_NLS_CODEPAGE_936_MODULE 1
+#define CONFIG_NLS_CODEPAGE_864_MODULE 1
+#define CONFIG_NLS_CODEPAGE_855_MODULE 1
+#define CONFIG_KARMA_PARTITION 1
+#define CONFIG_USB_DYNAMIC_MINORS 1
+#define CONFIG_USB_OV511_MODULE 1
+#define CONFIG_VIDEO_ADV7175_MODULE 1
+#define CONFIG_ZLIB_DEFLATE_MODULE 1
+#define CONFIG_NET_VENDOR_3COM 1
+#define CONFIG_CLS_U32_MARK 1
+#define CONFIG_INET_XFRM_MODE_TUNNEL 1
+#define CONFIG_NLS_CODEPAGE_874_MODULE 1
+#define CONFIG_NLS_CODEPAGE_865_MODULE 1
+#define CONFIG_NLS_CODEPAGE_775_MODULE 1
+#define CONFIG_VIDEO_SAA6588_MODULE 1
+#define CONFIG_PCMCIA_PCNET_MODULE 1
+#define CONFIG_SMSC_PHY_MODULE 1
+#define CONFIG_SCSI_SRP_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_HASHLIMIT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNTRACK_MODULE 1
+#define CONFIG_ACPI_TOSHIBA 1
+#define CONFIG_NLS_CODEPAGE_866_MODULE 1
+#define CONFIG_NLS_CODEPAGE_857_MODULE 1
+#define CONFIG_HUGETLB_PAGE 1
+#define CONFIG_USB_SERIAL_SAFE_MODULE 1
+#define CONFIG_JOYSTICK_IFORCE_MODULE 1
+#define CONFIG_JOYSTICK_A3D_MODULE 1
+#define CONFIG_IEEE80211_CRYPT_CCMP_MODULE 1
+#define CONFIG_MKISS_MODULE 1
+#define CONFIG_CLS_U32_PERF 1
+#define CONFIG_IA32_AOUT 1
+#define CONFIG_PCMCIA_IOCTL 1
+#define CONFIG_IOMMU 1
+#define CONFIG_MINIX_SUBPARTITION 1
+#define CONFIG_USB_SERIAL_SAFE_PADDED 1
+#define CONFIG_SND_VX222_MODULE 1
+#define CONFIG_VIDEO_SAA7146_VV_MODULE 1
+#define CONFIG_W1_MODULE 1
+#define CONFIG_ISDN_CAPI_CAPI20_MODULE 1
+#define CONFIG_BCM43XX_D80211_MODULE 1
+#define CONFIG_SIS900_MODULE 1
+#define CONFIG_FB 1
+#define CONFIG_SATA_SVW 1
+#define CONFIG_BT_HCIBCM203X_MODULE 1
+#define CONFIG_X86_POWERNOW_K8 1
+#define CONFIG_NLS_CODEPAGE_949_MODULE 1
+#define CONFIG_USB_ZERO_MODULE 1
+#define CONFIG_USB_TEST_MODULE 1
+#define CONFIG_SOUND 1
+#define CONFIG_HWMON 1
+#define CONFIG_SIS190_MODULE 1
+#define CONFIG_IP_NF_ARPTABLES_MODULE 1
+#define CONFIG_ACPI_THERMAL 1
+#define CONFIG_NLS_CODEPAGE_869_MODULE 1
+#define CONFIG_ATARI_PARTITION 1
+#define CONFIG_ROOT_NFS 1
+#define CONFIG_TMPFS 1
+#define CONFIG_QUOTA 1
+#define CONFIG_LEDS_TRIGGER_HEARTBEAT_MODULE 1
+#define CONFIG_FONTS 1
+#define CONFIG_WANXL_MODULE 1
+#define CONFIG_ASK_IP_FIB_HASH 1
+#define CONFIG_I2C_PIIX4_MODULE 1
+#define CONFIG_KEYBOARD_NEWTON 1
+#define CONFIG_HOSTAP_FIRMWARE 1
+#define CONFIG_PCI_MMCONFIG 1
+#define CONFIG_CRYPTO_TWOFISH_COMMON_MODULE 1
+#define CONFIG_ACORN_PARTITION 1
+#define CONFIG_USB_EMI26_MODULE 1
+#define CONFIG_USB_EMI62_MODULE 1
+#define CONFIG_USB_SERIAL_HP4X_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA19W 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA18X 1
+#define CONFIG_USB_TOUCHSCREEN_MODULE 1
+#define CONFIG_SND_INDIGODJ_MODULE 1
+#define CONFIG_VIDEO_HEXIUM_ORION_MODULE 1
+#define CONFIG_VIDEO_TDA9875_MODULE 1
+#define CONFIG_SENSORS_LM70_MODULE 1
+#define CONFIG_IPMI_HANDLER_MODULE 1
+#define CONFIG_SLIP_COMPRESSED 1
+#define CONFIG_PCMCIA_AXNET_MODULE 1
+#define CONFIG_DUMMY_MODULE 1
+#define CONFIG_PATA_NETCELL 1
+#define CONFIG_SCSI_DMX3191D 1
+#define CONFIG_BT_HCIUART_BCSP 1
+#define CONFIG_IP_VS_DH_MODULE 1
+#define CONFIG_PLIST 1
+#define CONFIG_FUTEX 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA28X 1
+#define CONFIG_USB_SERIAL_FUNSOFT_MODULE 1
+#define CONFIG_SND_RME32_MODULE 1
+#define CONFIG_VIDEO_MSP3400_MODULE 1
+#define CONFIG_SENSORS_LM80_MODULE 1
+#define CONFIG_SERIO_LIBPS2 1
+#define CONFIG_IPW3945_PROMISCUOUS 1
+#define CONFIG_IP_NF_MATCH_ECN_MODULE 1
+#define CONFIG_INET6_IPCOMP_MODULE 1
+#define CONFIG_USB_GADGETFS_MODULE 1
+#define CONFIG_USB_NET_CDC_SUBSET_MODULE 1
+#define CONFIG_SENSORS_LM90_MODULE 1
+#define CONFIG_SENSORS_LM63_MODULE 1
+#define CONFIG_JOYSTICK_DB9_MODULE 1
+#define CONFIG_PCMCIA_RAYCS_MODULE 1
+#define CONFIG_TULIP_MODULE 1
+#define CONFIG_EXPERIMENTAL 1
+#define CONFIG_RXRPC_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA49W 1
+#define CONFIG_USB_KEYSPAN_REMOTE_MODULE 1
+#define CONFIG_SND_CA0106_MODULE 1
+#define CONFIG_NETWORK_SECMARK 1
+#define CONFIG_IP_VS_LC_MODULE 1
+#define CONFIG_X86_64 1
+#define CONFIG_OCFS2_DEBUG_MASKLOG 1
+#define CONFIG_USB_EHCI_HCD_MODULE 1
+#define CONFIG_SENSORS_LM92_MODULE 1
+#define CONFIG_SENSORS_LM83_MODULE 1
+#define CONFIG_RT2X00 1
+#define CONFIG_IEEE1394_VIDEO1394_MODULE 1
+#define CONFIG_INPUT 1
+#define CONFIG_DVB_TUNER_MT2060_MODULE 1
+#define CONFIG_DVB_L64781_MODULE 1
+#define CONFIG_VIDEO_BWQCAM_MODULE 1
+#define CONFIG_SENSORS_LM75_MODULE 1
+#define CONFIG_I2C_AMD756_MODULE 1
+#define CONFIG_MD 1
+#define CONFIG_BLK_DEV_CRYPTOLOOP 1
+#define CONFIG_BLK_CPQ_CISS_DA 1
+#define CONFIG_CALGARY_IOMMU_ENABLED_BY_DEFAULT 1
+#define CONFIG_LOCALVERSION ""
+#define CONFIG_SMB_NLS_DEFAULT 1
+#define CONFIG_USB_DEVICEFS 1
+#define CONFIG_SND_MAESTRO3_MODULE 1
+#define CONFIG_SENSORS_LM85_MODULE 1
+#define CONFIG_SERIO_PCIPS2 1
+#define CONFIG_STRIP_MODULE 1
+#define CONFIG_MTD_DOCPROBE_MODULE 1
+#define CONFIG_AUDITSYSCALL 1
+#define CONFIG_USB_SERIAL_IPAQ_MODULE 1
+#define CONFIG_VIDEO_CX2341X_MODULE 1
+#define CONFIG_SENSORS_LM77_MODULE 1
+#define CONFIG_TCG_INFINEON_MODULE 1
+#define CONFIG_PATA_OPTIDMA 1
+#define CONFIG_SCSI_SCAN_ASYNC 1
+#define CONFIG_IP6_NF_MATCH_RT_MODULE 1
+#define CONFIG_ZLIB_INFLATE 1
+#define CONFIG_X86_SPEEDSTEP_CENTRINO 1
+#define CONFIG_INIT_ENV_ARG_LIMIT 32
+#define CONFIG_DVB_B2C2_FLEXCOP_MODULE 1
+#define CONFIG_SENSORS_LM87_MODULE 1
+#define CONFIG_SENSORS_LM78_MODULE 1
+#define CONFIG_FORCEDETH_MODULE 1
+#define CONFIG_I2O_BLOCK 1
+#define CONFIG_IP_NF_ARPFILTER_MODULE 1
+#define CONFIG_SUSPEND2_CRYPTO 1
+#define CONFIG_IOSCHED_DEADLINE 1
+#define CONFIG_GFS2_FS_LOCKING_NOLOCK_MODULE 1
+#define CONFIG_SERIO_PARKBD 1
+#define CONFIG_SCSI_SAS_LIBSAS_MODULE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_CACHED 1
+#define CONFIG_MICROCODE_MODULE 1
+#define CONFIG_SND_INDIGOIO_MODULE 1
+#define CONFIG_VIDEO_SELECT 1
+#define CONFIG_PATA_WINBOND 1
+#define CONFIG_CFG80211_WEXT_COMPAT 1
+#define CONFIG_BT_MODULE 1
+#define CONFIG_SIGMATEL_FIR_MODULE 1
+#define CONFIG_NET_CLS_TCINDEX_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CONNMARK_MODULE 1
+#define CONFIG_NF_CONNTRACK_MODULE 1
+#define CONFIG_JFFS2_COMPRESSION_OPTIONS 1
+#define CONFIG_USB_SERIAL_MCT_U232_MODULE 1
+#define CONFIG_USB_EHCI_SPLIT_ISO 1
+#define CONFIG_SND_RME96_MODULE 1
+#define CONFIG_FRAMEBUFFER_CONSOLE 1
+#define CONFIG_LAPBETHER_MODULE 1
+#define CONFIG_BROADCOM_PHY_MODULE 1
+#define CONFIG_PATA_JMICRON 1
+#define CONFIG_MTD_DILNETPC_MODULE 1
+#define CONFIG_NF_CONNTRACK_AMANDA_MODULE 1
+#define CONFIG_ACPI_BATTERY 1
+#define CONFIG_SND_OPL3_LIB_MODULE 1
+#define CONFIG_BACKLIGHT_DEVICE 1
+#define CONFIG_USB_KONICAWC_MODULE 1
+#define CONFIG_VIDEO_USBVISION_MODULE 1
+#define CONFIG_SENSORS_IT87_MODULE 1
+#define CONFIG_I2O_LCT_NOTIFY_ON_CHANGES 1
+#define CONFIG_PATA_MARVELL 1
+#define CONFIG_SCSI_LOGGING 1
+#define CONFIG_BRIDGE_EBT_REDIRECT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_CONNBYTES_MODULE 1
+#define CONFIG_SYSFS 1
+#define CONFIG_NFS_DIRECTIO 1
+#define CONFIG_MTD_ONENAND_OTP 1
+#define CONFIG_USB_OHCI_HCD_MODULE 1
+#define CONFIG_HW_RANDOM_INTEL 1
+#define CONFIG_PATA_PDC_OLD 1
+#define CONFIG_TCP_CONG_BIC 1
+#define CONFIG_SUSPEND2_KEEP_IMAGE 1
+#define CONFIG_X86_CPUID 1
+#define CONFIG_IOSCHED_NOOP 1
+#define CONFIG_STOP_MACHINE 1
+#define CONFIG_USB_SERIAL_KLSI_MODULE 1
+#define CONFIG_USB_ALI_M5632 1
+#define CONFIG_DVB_AV7110_MODULE 1
+#define CONFIG_VIDEO_VPX3220_MODULE 1
+#define CONFIG_VIDEO_TVP5150_MODULE 1
+#define CONFIG_SCSI_EATA_TAGGED_QUEUE 1
+#define CONFIG_BT_HCIBTUART_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_STATISTIC_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_CLASSIFY_MODULE 1
+#define CONFIG_INET6_TUNNEL_MODULE 1
+#define CONFIG_IP_VS_SH_MODULE 1
+#define CONFIG_X86_64_ACPI_NUMA 1
+#define CONFIG_USB_SERIAL_SIERRAWIRELESS_MODULE 1
+#define CONFIG_VIDEO_SAA711X_MODULE 1
+#define CONFIG_NET_SB1000_MODULE 1
+#define CONFIG_AIC79XX_RESET_DELAY_MS 15000
+#define CONFIG_IEEE80211_CRYPT_TKIP_MODULE 1
+#define CONFIG_NET_ACT_GACT_MODULE 1
+#define CONFIG_NET_EMATCH_TEXT_MODULE 1
+#define CONFIG_USB_GADGET_SELECTED 1
+#define CONFIG_USB_TOUCHSCREEN_EGALAX 1
+#define CONFIG_JOYSTICK_ADI_MODULE 1
+#define CONFIG_SATA_AHCI 1
+#define CONFIG_SCSI_AIC7XXX 1
+#define CONFIG_PARPORT_PC_FIFO 1
+#define CONFIG_ACPI_DOCK 1
+#define CONFIG_PM 1
+#define CONFIG_CRYPTO_BLOWFISH_MODULE 1
+#define CONFIG_INFINIBAND_MTHCA_MODULE 1
+#define CONFIG_SOUND_KAHLUA_MODULE 1
+#define CONFIG_FB_SAVAGE_MODULE 1
+#define CONFIG_ADM8211_MODULE 1
+#define CONFIG_PATA_OLDPIIX 1
+#define CONFIG_MTD_CFI_STAA_MODULE 1
+#define CONFIG_NET_SCH_INGRESS_MODULE 1
+#define CONFIG_IPV6_ROUTE_INFO 1
+#define CONFIG_IP_ROUTE_MULTIPATH 1
+#define CONFIG_LOCKDEP_SUPPORT 1
+#define CONFIG_MSDOS_PARTITION 1
+#define CONFIG_FB_CFB_IMAGEBLIT 1
+#define CONFIG_USB_QUICKCAM_MESSENGER_MODULE 1
+#define CONFIG_IP_NF_MANGLE_MODULE 1
+#define CONFIG_IP_VS_NQ_MODULE 1
+#define CONFIG_ACORN_PARTITION_CUMANA 1
+#define CONFIG_CRYPTO_CAST5_MODULE 1
+#define CONFIG_USB_STORAGE_DATAFAB 1
+#define CONFIG_USB_UHCI_HCD_MODULE 1
+#define CONFIG_FB_RADEON_MODULE 1
+#define CONFIG_PARPORT_PC_SUPERIO 1
+#define CONFIG_IPV6_MIP6 1
+#define CONFIG_CRYPTO_CAST6_MODULE 1
+#define CONFIG_DCDBAS_MODULE 1
+#define CONFIG_INFINIBAND_USER_MAD_MODULE 1
+#define CONFIG_THRUSTMASTER_FF 1
+#define CONFIG_SND_BT87X_MODULE 1
+#define CONFIG_HAPPYMEAL_MODULE 1
+#define CONFIG_IP_VS_MODULE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_RR_MODULE 1
+#define CONFIG_SND_FM801_TEA575X_MODULE 1
+#define CONFIG_SND_MTS64_MODULE 1
+#define CONFIG_SPECIALIX_MODULE 1
+#define CONFIG_IPV6_PRIVACY 1
+#define CONFIG_X86_PM_TIMER 1
+#define CONFIG_HZ 1000
+#define CONFIG_LDM_DEBUG 1
+#define CONFIG_USB_AN2720 1
+#define CONFIG_SND_AD1889_MODULE 1
+#define CONFIG_FONT_SUN8x16 1
+#define CONFIG_TOUCHSCREEN_TOUCHRIGHT_MODULE 1
+#define CONFIG_ACENIC_MODULE 1
+#define CONFIG_PATA_TRIFLEX 1
+#define CONFIG_PATA_EFAR 1
+#define CONFIG_SMC_IRCC_FIR_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_HELPER_MODULE 1
+#define CONFIG_HUGETLBFS 1
+#define CONFIG_INFINIBAND_IPOIB_MODULE 1
+#define CONFIG_ISDN_DIVAS_DIVACAPI_MODULE 1
+#define CONFIG_WAN_ROUTER_DRIVERS_MODULE 1
+#define CONFIG_HDLC_RAW_ETH_MODULE 1
+#define CONFIG_PATA_RADISYS 1
+#define CONFIG_SATA_INTEL_COMBINED 1
+#define CONFIG_MTD_NAND_IDS_MODULE 1
+#define CONFIG_MTD_PHYSMAP_LEN 0x4000000
+#define CONFIG_IP_VS_RR_MODULE 1
+#define CONFIG_INET_DIAG 1
+#define CONFIG_NLS_ISO8859_1_MODULE 1
+#define CONFIG_I2C_SIS630_MODULE 1
+#define CONFIG_NET_ETHERNET 1
+#define CONFIG_NET_SCH_GRED_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_LENGTH_MODULE 1
+#define CONFIG_ACPI_BLACKLIST_YEAR 0
+#define CONFIG_NLS_ISO8859_2_MODULE 1
+#define CONFIG_FONT_6x11 1
+#define CONFIG_ATM_LANAI_MODULE 1
+#define CONFIG_TR 1
+#define CONFIG_NS83820_MODULE 1
+#define CONFIG_SCSI_NETLINK 1
+#define CONFIG_REED_SOLOMON_MODULE 1
+#define CONFIG_IP6_NF_QUEUE_MODULE 1
+#define CONFIG_NLS_ISO8859_3_MODULE 1
+#define CONFIG_INFINIBAND_IPATH_MODULE 1
+#define CONFIG_MMC_SDHCI_MODULE 1
+#define CONFIG_MMC_BLOCK_MODULE 1
+#define CONFIG_USB_MICROTEK_MODULE 1
+#define CONFIG_USB_OHCI_LITTLE_ENDIAN 1
+#define CONFIG_SOUND_SSCAPE_MODULE 1
+#define CONFIG_VIDEO_ZORAN_DC10_MODULE 1
+#define CONFIG_SC1200_WDT_MODULE 1
+#define CONFIG_SATA_PROMISE 1
+#define CONFIG_TIFM_7XX1_MODULE 1
+#define CONFIG_NET_SCH_HFSC_MODULE 1
+#define CONFIG_NET_SCH_FIFO 1
+#define CONFIG_NLS_ISO8859_4_MODULE 1
+#define CONFIG_USB_EPSON2888 1
+#define CONFIG_SND_BT87X_OVERCLOCK 1
+#define CONFIG_MOUSE_SERIAL 1
+#define CONFIG_DE2104X_MODULE 1
+#define CONFIG_DM_MULTIPATH_MODULE 1
+#define CONFIG_MD_MULTIPATH 1
+#define CONFIG_PARIDE_PD_MODULE 1
+#define CONFIG_NLS_ISO8859_5_MODULE 1
+#define CONFIG_SND_CS4281_MODULE 1
+#define CONFIG_VIDEO_ZORAN_DC30_MODULE 1
+#define CONFIG_SBC_EPX_C3_WATCHDOG_MODULE 1
+#define CONFIG_ATM_BR2684_MODULE 1
+#define CONFIG_NLS_ISO8859_6_MODULE 1
+#define CONFIG_USB_LIBUSUAL 1
+#define CONFIG_FONT_7x14 1
+#define CONFIG_USB_ZC0301_MODULE 1
+#define CONFIG_VT 1
+#define CONFIG_B44_MODULE 1
+#define CONFIG_BLK_DEV_UMEM 1
+#define CONFIG_PARIDE_PF_MODULE 1
+#define CONFIG_ISDN_CAPI_MODULE 1
+#define CONFIG_MIGRATION 1
+#define CONFIG_NLS_ISO8859_7_MODULE 1
+#define CONFIG_NLS_CODEPAGE_1250_MODULE 1
+#define CONFIG_TMPFS_POSIX_ACL 1
+#define CONFIG_SND_AU8810_MODULE 1
+#define CONFIG_SENSORS_SMSC47M1_MODULE 1
+#define CONFIG_SX_MODULE 1
+#define CONFIG_ZD1211RW_D80211_MODULE 1
+#define CONFIG_USB_ZD1201_MODULE 1
+#define CONFIG_MD_LINEAR 1
+#define CONFIG_SATA_VITESSE 1
+#define CONFIG_PARIDE_PG_MODULE 1
+#define CONFIG_CONNECTOR 1
+#define CONFIG_IP_NF_MATCH_TTL_MODULE 1
+#define CONFIG_NLS_CODEPAGE_1251_MODULE 1
+#define CONFIG_NLS_ISO8859_8_MODULE 1
+#define CONFIG_GFS2_FS_LOCKING_DLM_MODULE 1
+#define CONFIG_USB_NET_RNDIS_HOST_MODULE 1
+#define CONFIG_SND_AU8820_MODULE 1
+#define CONFIG_ARCNET_RIM_I_MODULE 1
+#define CONFIG_MD_RAID5_RESHAPE 1
+#define CONFIG_SCSI_EATA_MODULE 1
+#define CONFIG_VLAN_8021Q_MODULE 1
+#define CONFIG_GENERIC_PENDING_IRQ 1
+#define CONFIG_RWSEM_GENERIC_SPINLOCK 1
+#define CONFIG_NLS_ISO8859_9_MODULE 1
+#define CONFIG_NCPFS_OS2_NS 1
+#define CONFIG_USB_KBTAB_MODULE 1
+#define CONFIG_SND_AU8830_MODULE 1
+#define CONFIG_FONT_8x16 1
+#define CONFIG_VIDEO_DPC_MODULE 1
+#define CONFIG_EUROTECH_WDT_MODULE 1
+#define CONFIG_NET_SCHED 1
+#define CONFIG_IP_NF_MATCH_TOS_MODULE 1
+#define CONFIG_BRIDGE_MODULE 1
+#define CONFIG_INET6_ESP_MODULE 1
+#define CONFIG_NETFILTER 1
+#define CONFIG_PCMCIA_MODULE 1
+#define CONFIG_PCCARD 1
+#define CONFIG_ACPI_NUMA 1
+#define CONFIG_SPARSEMEM 1
+#define CONFIG_BASE_FULL 1
+#define CONFIG_RTC_DRV_V3020_MODULE 1
+#define CONFIG_SND_RTCTIMER_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCMCIA_MODULE 1
+#define CONFIG_PCI_ATMEL_MODULE 1
+#define CONFIG_VIA_VELOCITY_MODULE 1
+#define CONFIG_PATA_CYPRESS 1
+#define CONFIG_SCSI_SYM53C8XX_MMIO 1
+#define CONFIG_SCSI_SYM53C8XX_2 1
+#define CONFIG_CRC_CCITT_MODULE 1
+#define CONFIG_IP_MULTICAST 1
+#define CONFIG_USB_G_SERIAL_MODULE 1
+#define CONFIG_FIXED_MII_10_FDX 1
+#define CONFIG_MD_RAID456 1
+#define CONFIG_MTD_BLOCK_RO_MODULE 1
+#define CONFIG_MTD_BLOCK_MODULE 1
+#define CONFIG_NET_IPGRE_BROADCAST 1
+#define CONFIG_NCPFS_EXTRAS 1
+#define CONFIG_USB_SL811_HCD_MODULE 1
+#define CONFIG_VIDEO_ZORAN_BUZ_MODULE 1
+#define CONFIG_TCG_ATMEL_MODULE 1
+#define CONFIG_BLK_DEV_LOOP 1
+#define CONFIG_MTD_NAND_DISKONCHIP_MODULE 1
+#define CONFIG_MTD_M25P80_MODULE 1
+#define CONFIG_IRDA_FAST_RR 1
+#define CONFIG_USB_TOUCHSCREEN_PANJIT 1
+#define CONFIG_SND_ES1938_MODULE 1
+#define CONFIG_ADAPTEC_STARFIRE_MODULE 1
+#define CONFIG_ATA_OVER_ETH_MODULE 1
+#define CONFIG_GACT_PROB 1
+#define CONFIG_IP_NF_FILTER_MODULE 1
+#define CONFIG_PM_LEGACY 1
+#define CONFIG_GENERIC_CALIBRATE_DELAY 1
+#define CONFIG_NFS_ACL_SUPPORT 1
+#define CONFIG_SND_AC97_POWER_SAVE 1
+#define CONFIG_FB_SPLASH 1
+#define CONFIG_FB_DDC_MODULE 1
+#define CONFIG_VIDEO_CX88_VP3054_MODULE 1
+#define CONFIG_EPIC100_MODULE 1
+#define CONFIG_EQUALIZER_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_TRANSPORT_MODULE 1
+#define CONFIG_RTC_DRV_X1205_MODULE 1
+#define CONFIG_SC6600_JOY 1
+#define CONFIG_FB_3DFX_ACCEL 1
+#define CONFIG_VIDEO_BUF_MODULE 1
+#define CONFIG_AGP_INTEL_MODULE 1
+#define CONFIG_MOXA_SMARTIO_MODULE 1
+#define CONFIG_IPW2100_MODULE 1
+#define CONFIG_IEEE1394_DV1394_MODULE 1
+#define CONFIG_MTD_CFI_UTIL_MODULE 1
+#define CONFIG_BT_HCIUSB_MODULE 1
+#define CONFIG_DECNET_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_MULTIPORT_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_POLICY_MODULE 1
+#define CONFIG_NETFILTER_XT_TARGET_NFLOG_MODULE 1
+#define CONFIG_FW_LOADER 1
+#define CONFIG_CRYPTO_SHA512_MODULE 1
+#define CONFIG_SND_ES1968_MODULE 1
+#define CONFIG_NET_WIRELESS 1
+#define CONFIG_IPW2200_MODULE 1
+#define CONFIG_TIGON3_MODULE 1
+#define CONFIG_MTD_CK804XROM_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_MAC_MODULE 1
+#define CONFIG_EARLY_PRINTK 1
+#define CONFIG_NLS_ASCII_MODULE 1
+#define CONFIG_USB_MDC800_MODULE 1
+#define CONFIG_DVB_SP8870_MODULE 1
+#define CONFIG_VIDEO_SAA7134_DVB_MODULE 1
+#define CONFIG_VIDEO_DEV_MODULE 1
+#define CONFIG_VIA_RHINE_MODULE 1
+#define CONFIG_PARIDE 1
+#define CONFIG_MTD_TS5500_MODULE 1
+#define CONFIG_NET_RADIO 1
+#define CONFIG_BRIDGE_EBT_ARPREPLY_MODULE 1
+#define CONFIG_XFRM_SUB_POLICY 1
+#define CONFIG_NCPFS_STRONG 1
+#define CONFIG_FB_PM2_MODULE 1
+#define CONFIG_BCM43XX_D80211_DMA_AND_PIO_MODE 1
+#define CONFIG_SCSI_LPFC 1
+#define CONFIG_NET_ACT_SIMP_MODULE 1
+#define CONFIG_IP_DCCP_CCID2_MODULE 1
+#define CONFIG_MODULE_FORCE_UNLOAD 1
+#define CONFIG_RTC_INTF_DEV 1
+#define CONFIG_USB_SERIAL_KEYSPAN_PDA_MODULE 1
+#define CONFIG_SND_ALS300_MODULE 1
+#define CONFIG_LCD_CLASS_DEVICE_MODULE 1
+#define CONFIG_FB_HGA_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_24XXX 1
+#define CONFIG_IP_DCCP_CCID3_MODULE 1
+#define CONFIG_X86_ACPI_CPUFREQ 1
+#define CONFIG_ISO9660_FS 1
+#define CONFIG_SND_VXPOCKET_MODULE 1
+#define CONFIG_FB_TRIDENT_ACCEL 1
+#define CONFIG_SCSI_GDTH 1
+#define CONFIG_TIFM_CORE_MODULE 1
+#define CONFIG_PARIDE_PT_MODULE 1
+#define CONFIG_BRIDGE_EBT_AMONG_MODULE 1
+#define CONFIG_PACKET 1
+#define CONFIG_CPU_FREQ_GOV_CONSERVATIVE 1
+#define CONFIG_ACPI_ASUS 1
+#define CONFIG_X86_PC 1
+#define CONFIG_CRYPTO_SHA256_MODULE 1
+#define CONFIG_USB_ARMLINUX 1
+#define CONFIG_AEDSP16_SBPRO 1
+#define CONFIG_SND_SERIAL_U16550_MODULE 1
+#define CONFIG_USB_VICAM_MODULE 1
+#define CONFIG_TUNER_3036_MODULE 1
+#define CONFIG_DVB_BT8XX_MODULE 1
+#define CONFIG_BCM43XX_D80211_DMA 1
+#define CONFIG_YELLOWFIN_MODULE 1
+#define CONFIG_AIC79XX_DEBUG_ENABLE 1
+#define CONFIG_PARIDE_EPATC8 1
+#define CONFIG_BT_RFCOMM_MODULE 1
+#define CONFIG_DONGLE 1
+#define CONFIG_NET_SCH_TEQL_MODULE 1
+#define CONFIG_BRIDGE_NETFILTER 1
+#define CONFIG_BSD_PROCESS_ACCT_V3 1
+#define CONFIG_DEBUG_BUGVERBOSE 1
+#define CONFIG_NCPFS_IOCTL_LOCKING 1
+#define CONFIG_JFS_SECURITY 1
+#define CONFIG_FS_POSIX_ACL 1
+#define CONFIG_AEDSP16_MPU401 1
+#define CONFIG_I2C_AMD8111_MODULE 1
+#define CONFIG_COMPUTONE_MODULE 1
+#define CONFIG_R8169_VLAN 1
+#define CONFIG_NETFILTER_XT_MATCH_STRING_MODULE 1
+#define CONFIG_NF_CT_PROTO_GRE_MODULE 1
+#define CONFIG_GENERIC_HARDIRQS 1
+#define CONFIG_SCHED_SMT 1
+#define CONFIG_FB_SAVAGE_I2C 1
+#define CONFIG_HPET_MMAP 1
+#define CONFIG_AIC7XXX_RESET_DELAY_MS 15000
+#define CONFIG_SCSI_3W_9XXX 1
+#define CONFIG_IP6_NF_MATCH_IPV6HEADER_MODULE 1
+#define CONFIG_INET6_XFRM_MODE_TUNNEL_MODULE 1
+#define CONFIG_FIB_RULES 1
+#define CONFIG_QNX4FS_FS 1
+#define CONFIG_CRAMFS_MODULE 1
+#define CONFIG_USB_TOUCHSCREEN_ETURBO 1
+#define CONFIG_SOUND_AEDSP16_MODULE 1
+#define CONFIG_SOUND_ICH_MODULE 1
+#define CONFIG_SND_HWDEP_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_29XXX 1
+#define CONFIG_FUSION_FC 1
+#define CONFIG_MTD_PHRAM_MODULE 1
+#define CONFIG_NET_SCH_CLK_JIFFIES 1
+#define CONFIG_ACORN_PARTITION_RISCIX 1
+#define CONFIG_FB_RADEON_I2C 1
+#define CONFIG_FB_ARC_MODULE 1
+#define CONFIG_VIDEO_MXB_MODULE 1
+#define CONFIG_VIDEO_ZORAN_LML33R10_MODULE 1
+#define CONFIG_VIDEO_SAA5246A_MODULE 1
+#define CONFIG_SERIO_CT82C710 1
+#define CONFIG_JOYSTICK_SIDEWINDER_MODULE 1
+#define CONFIG_MOUSE_PS2 1
+#define CONFIG_ARCNET_MODULE 1
+#define CONFIG_SCSI_PROC_FS 1
+#define CONFIG_MCP2120_DONGLE_MODULE 1
+#define CONFIG_NET_SCH_PRIO_MODULE 1
+#define CONFIG_IP_NF_MATCH_IPRANGE_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_TCPMSS_MODULE 1
+#define CONFIG_NET_IPGRE_MODULE 1
+#define CONFIG_RTC_CLASS 1
+#define CONFIG_USB_SERIAL_EDGEPORT_TI_MODULE 1
+#define CONFIG_USB_STORAGE_FREECOM 1
+#define CONFIG_VIDEO_CX88_BLACKBIRD_MODULE 1
+#define CONFIG_VIDEO_HEXIUM_GEMINI_MODULE 1
+#define CONFIG_IBMASR_MODULE 1
+#define CONFIG_FEALNX_MODULE 1
+#define CONFIG_WIRELESS_EXT 1
+#define CONFIG_ECONET_MODULE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_RANDOM_MODULE 1
+#define CONFIG_I2C_MODULE 1
+#define CONFIG_USB_SERIAL_CP2101_MODULE 1
+#define CONFIG_FB_CIRRUS_MODULE 1
+#define CONFIG_ISDN_CAPI_CAPIFS_MODULE 1
+#define CONFIG_HW_RANDOM 1
+#define CONFIG_MTD_PMC551_MODULE 1
+#define CONFIG_X25_MODULE 1
+#define CONFIG_BRIDGE_EBT_T_FILTER_MODULE 1
+#define CONFIG_PCCARD_NONSTATIC_MODULE 1
+#define CONFIG_NEED_MULTIPLE_NODES 1
+#define CONFIG_NCPFS_NFS_NS 1
+#define CONFIG_INOTIFY_USER 1
+#define CONFIG_USB_WACOM_MODULE 1
+#define CONFIG_HID_FF 1
+#define CONFIG_SND_HDSPM_MODULE 1
+#define CONFIG_SENSORS_W83627EHF_MODULE 1
+#define CONFIG_PCIPCWATCHDOG_MODULE 1
+#define CONFIG_INPUT_JOYDEV_MODULE 1
+#define CONFIG_FIXED_PHY_MODULE 1
+#define CONFIG_CRYPTO_CRC32C 1
+#define CONFIG_USB_SERIAL_AIRPRIME_MODULE 1
+#define CONFIG_I2C_ALI1535_MODULE 1
+#define CONFIG_MACHZ_WDT_MODULE 1
+#define CONFIG_PATA_OPTI 1
+#define CONFIG_ISCSI_TCP_MODULE 1
+#define CONFIG_X86_HT 1
+#define CONFIG_USB_SERIAL_EDGEPORT_MODULE 1
+#define CONFIG_I2C_ALI1563_MODULE 1
+#define CONFIG_INPUT_PCSPKR_MODULE 1
+#define CONFIG_HZ_1000 1
+#define CONFIG_TRACE_IRQFLAGS_SUPPORT 1
+#define CONFIG_BSD_DISKLABEL 1
+#define CONFIG_VIDEO_TEA6415C_MODULE 1
+#define CONFIG_WAFER_WDT_MODULE 1
+#define CONFIG_SHAPER_MODULE 1
+#define CONFIG_BCM43XX_D80211_PCI 1
+#define CONFIG_CHR_DEV_OSST 1
+#define CONFIG_MTD_SLRAM_MODULE 1
+#define CONFIG_MICROCODE_OLD_INTERFACE 1
+#define CONFIG_VIDEO_UPD64083_MODULE 1
+#define CONFIG_PHONE_IXJ_MODULE 1
+#define CONFIG_HOSTAP_CS_MODULE 1
+#define CONFIG_HERMES_MODULE 1
+#define CONFIG_COMPAT 1
+#define CONFIG_POSIX_MQUEUE 1
+#define CONFIG_SECURITY_SELINUX_CHECKREQPROT_VALUE 1
+#define CONFIG_USB_HIDINPUT_POWERBOOK 1
+#define CONFIG_SND_GINA20_MODULE 1
+#define CONFIG_SND_TIMER 1
+#define CONFIG_DVB_BUDGET_PATCH_MODULE 1
+#define CONFIG_I2C_PROSAVAGE_MODULE 1
+#define CONFIG_PCMCIA_NMCLAN_MODULE 1
+#define CONFIG_IPW3945_MODULE 1
+#define CONFIG_MD_FAULTY 1
+#define CONFIG_BRIDGE_EBT_LIMIT_MODULE 1
+#define CONFIG_NCPFS_NLS 1
+#define CONFIG_USB_SERIAL_DIGI_ACCELEPORT_MODULE 1
+#define CONFIG_RADIO_GEMTEK_PCI_MODULE 1
+#define CONFIG_VIDEO_CS53L32A_MODULE 1
+#define CONFIG_MTD_BLOCK2MTD_MODULE 1
+#define CONFIG_X86 1
+#define CONFIG_JOLIET 1
+#define CONFIG_W1_CON 1
+#define CONFIG_8139TOO_MODULE 1
+#define CONFIG_MTD_L440GX_MODULE 1
+#define CONFIG_MTD_REDBOOT_PARTS_UNALLOCATED 1
+#define CONFIG_IEEE80211_RADIOTAP 1
+#define CONFIG_D80211_LEDS 1
+#define CONFIG_IRCOMM_MODULE 1
+#define CONFIG_XFS_SECURITY 1
+#define CONFIG_USB_RIO500_MODULE 1
+#define CONFIG_FB_SIS_300 1
+#define CONFIG_N_HDLC_MODULE 1
+#define CONFIG_PHYLIB_MODULE 1
+#define CONFIG_AIC79XX_CMDS_PER_DEVICE 32
+#define CONFIG_SELECT_MEMORY_MODEL 1
+#define CONFIG_SYSFS_DEPRECATED 1
+#define CONFIG_CRYPTO_TGR192_MODULE 1
+#define CONFIG_KVM_INTEL_MODULE 1
+#define CONFIG_SND_PCXHR_MODULE 1
+#define CONFIG_SND_GINA24_MODULE 1
+#define CONFIG_JOYSTICK_GAMECON_MODULE 1
+#define CONFIG_MTD_AMD76XROM_MODULE 1
+#define CONFIG_IP_PNP_BOOTP 1
+#define CONFIG_ACORN_PARTITION_ICS 1
+#define CONFIG_DVB_LNBP21_MODULE 1
+#define CONFIG_I2O 1
+#define CONFIG_IEEE1394_RAWIO_MODULE 1
+#define CONFIG_NF_CONNTRACK_EVENTS 1
+#define CONFIG_CPU_FREQ_GOV_USERSPACE 1
+#define CONFIG_SPARSEMEM_MANUAL 1
+#define CONFIG_X86_GOOD_APIC 1
+#define CONFIG_SND_MPU401_MODULE 1
+#define CONFIG_FONT_SUN12x22 1
+#define CONFIG_FB_ATY_CT 1
+#define CONFIG_HWMON_VID_MODULE 1
+#define CONFIG_WDTPCI_MODULE 1
+#define CONFIG_SERIO_RAW_MODULE 1
+#define CONFIG_DM_MIRROR 1
+#define CONFIG_PCMCIA_QLOGIC_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_ESP_MODULE 1
+#define CONFIG_USB_SERIAL_PL2303_MODULE 1
+#define CONFIG_SOUND_PAS_MODULE 1
+#define CONFIG_SND_MTPAV_MODULE 1
+#define CONFIG_MTD_DATAFLASH_MODULE 1
+#define CONFIG_CFG80211 1
+#define CONFIG_IP_NF_TARGET_CLUSTERIP_MODULE 1
+#define CONFIG_EDD_MODULE 1
+#define CONFIG_SND_INTEL8X0M_MODULE 1
+#define CONFIG_PPP_ASYNC_MODULE 1
+#define CONFIG_NET_EMATCH_STACK 32
+#define CONFIG_USB_SERIAL_KEYSPAN_USA28XA 1
+#define CONFIG_FB_SIS_315 1
+#define CONFIG_DVB_CX24110_MODULE 1
+#define CONFIG_VIDEO_SAA7134_OSS_MODULE 1
+#define CONFIG_USBPCWATCHDOG_MODULE 1
+#define CONFIG_ATM_HE_MODULE 1
+#define CONFIG_NET_WIRELESS_RTNETLINK 1
+#define CONFIG_MTD_NAND_NANDSIM_MODULE 1
+#define CONFIG_ACT200L_DONGLE_MODULE 1
+#define CONFIG_IP_NF_TARGET_REJECT_MODULE 1
+#define CONFIG_NFS_V3 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA19QI 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA28XB 1
+#define CONFIG_DVB_B2C2_FLEXCOP_PCI_MODULE 1
+#define CONFIG_BCM43XX_D80211_PIO 1
+#define CONFIG_HOSTAP_MODULE 1
+#define CONFIG_SUNGEM_MODULE 1
+#define CONFIG_QSEMI_PHY_MODULE 1
+#define CONFIG_NET_FC 1
+#define CONFIG_INET_XFRM_MODE_BEET 1
+#define CONFIG_NFS_V4 1
+#define CONFIG_JBD 1
+#define CONFIG_USB_ARCH_HAS_HCD 1
+#define CONFIG_SND_DUMMY_MODULE 1
+#define CONFIG_JOYSTICK_IFORCE_USB 1
+#define CONFIG_PHONE_IXJ_PCMCIA_MODULE 1
+#define CONFIG_PCMCIA_HERMES_MODULE 1
+#define CONFIG_TMSPCI_MODULE 1
+#define CONFIG_USB_APPLEDISPLAY_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_MPR 1
+#define CONFIG_USB_NET_CDCETHER_MODULE 1
+#define CONFIG_DVB_CX22700_MODULE 1
+#define CONFIG_IFB_MODULE 1
+#define CONFIG_GIRBIL_DONGLE_MODULE 1
+#define CONFIG_DEFAULT_TCP_CONG "bic"
+#define CONFIG_BSD_PROCESS_ACCT 1
+#define CONFIG_AFS_FS_MODULE 1
+#define CONFIG_INFINIBAND_MODULE 1
+#define CONFIG_USB_EZUSB 1
+#define CONFIG_FIRMWARE_EDID 1
+#define CONFIG_DVB_CINERGYT2_MODULE 1
+#define CONFIG_DVB_S5H1420_MODULE 1
+#define CONFIG_DVB_CX24123_MODULE 1
+#define CONFIG_IDE 1
+#define CONFIG_NET_CLS_RSVP_MODULE 1
+#define CONFIG_GENERIC_IOMAP 1
+#define CONFIG_ZONE_DMA32 1
+#define CONFIG_BFS_FS_MODULE 1
+#define CONFIG_FAT_FS 1
+#define CONFIG_EXT4DEV_FS_SECURITY 1
+#define CONFIG_RTC_DRV_TEST_MODULE 1
+#define CONFIG_SND_PDAUDIOCF_MODULE 1
+#define CONFIG_FB_ATY_GX 1
+#define CONFIG_DVB_CX22702_MODULE 1
+#define CONFIG_I2C_SIS96X_MODULE 1
+#define CONFIG_JOYSTICK_TURBOGRAFX_MODULE 1
+#define CONFIG_MTD_NAND_CAFE_MODULE 1
+#define CONFIG_NF_CONNTRACK_IRC_MODULE 1
+#define CONFIG_SUSPEND2_FILE 1
+#define CONFIG_CRYPTO_BLKCIPHER 1
+#define CONFIG_INPUT_UINPUT_MODULE 1
+#define CONFIG_TOUCHSCREEN_MK712_MODULE 1
+#define CONFIG_NET_TULIP 1
+#define CONFIG_FUSION 1
+#define CONFIG_IP_MROUTE 1
+#define CONFIG_DYN_PAGEFLAGS 1
+#define CONFIG_USB_TOUCHSCREEN_ITM 1
+#define CONFIG_HID 1
+#define CONFIG_FB_ATY_MODULE 1
+#define CONFIG_VIDEO_TLV320AIC23B_MODULE 1
+#define CONFIG_SCSI_STEX 1
+#define CONFIG_BT_HCIBT3C_MODULE 1
+#define CONFIG_NETROM_MODULE 1
+#define CONFIG_IP_NF_RAW_MODULE 1
+#define CONFIG_IP6_NF_MANGLE_MODULE 1
+#define CONFIG_NF_CONNTRACK_H323_MODULE 1
+#define CONFIG_X86_MCE_INTEL 1
+#define CONFIG_EFS_FS_MODULE 1
+#define CONFIG_FAT_DEFAULT_CODEPAGE 437
+#define CONFIG_ZISOFS_FS 1
+#define CONFIG_USB_SERIAL_EMPEG_MODULE 1
+#define CONFIG_FB_SIS_MODULE 1
+#define CONFIG_DVB_OR51211_MODULE 1
+#define CONFIG_DVB_BCM3510_MODULE 1
+#define CONFIG_SMSC37B787_WDT_MODULE 1
+#define CONFIG_E100_MODULE 1
+#define CONFIG_SATA_SIL24 1
+#define CONFIG_ATA 1
+#define CONFIG_IP_DCCP_TFRC_LIB_MODULE 1
+#define CONFIG_IP_NF_TARGET_NETMAP_MODULE 1
+#define CONFIG_NF_NAT_MODULE 1
+#define CONFIG_UNAME_RELEASE "2.6.20-sabayon-r1"
+#define CONFIG_UDF_FS 1
+#define CONFIG_SCTP_HMAC_MD5 1
+#define CONFIG_NF_NAT_AMANDA_MODULE 1
+#define CONFIG_NLS_ISO8859_13_MODULE 1
+#define CONFIG_FONT_10x18 1
+#define CONFIG_DVB_OR51132_MODULE 1
+#define CONFIG_AIC7XXX_DEBUG_ENABLE 1
+#define CONFIG_AGP 1
+#define CONFIG_PRINTK 1
+#define CONFIG_NLS_ISO8859_14_MODULE 1
+#define CONFIG_NCP_FS_MODULE 1
+#define CONFIG_RPCSEC_GSS_SPKM3_MODULE 1
+#define CONFIG_HFS_FS 1
+#define CONFIG_USB_LD_MODULE 1
+#define CONFIG_USB_SERIAL_FTDI_SIO_MODULE 1
+#define CONFIG_JOYSTICK_GF2K_MODULE 1
+#define CONFIG_NET_EMATCH_NBYTE_MODULE 1
+#define CONFIG_NLS_ISO8859_15_MODULE 1
+#define CONFIG_SMB_FS 1
+#define CONFIG_XFS_QUOTA 1
+#define CONFIG_INTEL_IOATDMA_MODULE 1
+#define CONFIG_USB_ACECAD_MODULE 1
+#define CONFIG_BT_SCO_MODULE 1
+#define CONFIG_NF_NAT_NEEDED 1
+#define CONFIG_IP_VS_PROTO_TCP 1
+#define CONFIG_DMI 1
+#define CONFIG_SUNRPC 1
+#define CONFIG_SQUASHFS_VMALLOC 1
+#define CONFIG_JFS_FS 1
+#define CONFIG_FS_MBCACHE 1
+#define CONFIG_SOUND_MSS_MODULE 1
+#define CONFIG_SERIAL_8250_NR_UARTS 4
+#define CONFIG_SCSI_AIC7XXX_OLD 1
+#define CONFIG_LLC 1
+#define CONFIG_IP6_NF_TARGET_HL_MODULE 1
+#define CONFIG_IP_VS_PROTO_ESP 1
+#define CONFIG_XFRM_USER_MODULE 1
+#define CONFIG_CPU_FREQ_GOV_POWERSAVE 1
+#define CONFIG_DVB 1
+#define CONFIG_ADVANTECH_WDT_MODULE 1
+#define CONFIG_ISDN_DIVAS_MAINT_MODULE 1
+#define CONFIG_CRC_ITU_T_MODULE 1
+#define CONFIG_DM_MULTIPATH_EMC_MODULE 1
+#define CONFIG_MTD_DOC2000_MODULE 1
+#define CONFIG_TEKRAM_DONGLE_MODULE 1
+#define CONFIG_DEV_APPLETALK_MODULE 1
+#define CONFIG_BRIDGE_EBT_T_NAT_MODULE 1
+#define CONFIG_IP_VS_SED_MODULE 1
+#define CONFIG_IP_VS_PROTO_UDP 1
+#define CONFIG_SUSPEND2_CORE 1
+#define CONFIG_HAVE_MEMORY_PRESENT 1
+#define CONFIG_PCI 1
+#define CONFIG_BLK_DEV_IO_TRACE 1
+#define CONFIG_IPC_NS 1
+#define CONFIG_DLM_MODULE 1
+#define CONFIG_MMC_MODULE 1
+#define CONFIG_USB_FILE_STORAGE_MODULE 1
+#define CONFIG_USB_PHIDGETSERVO_MODULE 1
+#define CONFIG_USB_SERIAL_KEYSPAN_USA19QW 1
+#define CONFIG_USB_USS720_MODULE 1
+#define CONFIG_SOUND_OSS_MODULE 1
+#define CONFIG_SND_ECHO3G_MODULE 1
+#define CONFIG_DVB_SP887X_MODULE 1
+#define CONFIG_DVB_B2C2_FLEXCOP_USB_MODULE 1
+#define CONFIG_DVB_ZL10353_MODULE 1
+#define CONFIG_VIDEO_V4L1 1
+#define CONFIG_ISDN_DRV_AVMB1_B1PCI_MODULE 1
+#define CONFIG_AMD8111_ETH_MODULE 1
+#define CONFIG_BLK_DEV_DAC960 1
+#define CONFIG_MTD_DOCPROBE_55AA 1
+#define CONFIG_MTD_DOC2001_MODULE 1
+#define CONFIG_INITRAMFS_SOURCE ""
+#define CONFIG_IKCONFIG_PROC 1
+#define CONFIG_ZISOFS 1
+#define CONFIG_USB_UEAGLEATM_MODULE 1
+#define CONFIG_USB_BANDWIDTH 1
+#define CONFIG_SOUND_PSS_MODULE 1
+#define CONFIG_VIDEO_V4L2 1
+#define CONFIG_PCMCIA_XIRCOM_MODULE 1
+#define CONFIG_PATA_SC1200 1
+#define CONFIG_BT_HCIDTL1_MODULE 1
+#define CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG 1
+#define CONFIG_BUG 1
+#define CONFIG_SECURITY_SELINUX_BOOTPARAM_VALUE 1
+#define CONFIG_NFS_FS 1
+#define CONFIG_IPMI_WATCHDOG_MODULE 1
+#define CONFIG_PCNET32_MODULE 1
+#define CONFIG_ULI526X_MODULE 1
+#define CONFIG_MII 1
+#define CONFIG_FIXED_MII_100_FDX 1
+#define CONFIG_I2O_CONFIG 1
+#define CONFIG_BRIDGE_EBT_IP_MODULE 1
+#define CONFIG_NF_CONNTRACK_FTP_MODULE 1
+#define CONFIG_SND_ICE1712_MODULE 1
+#define CONFIG_DVB_AV7110_OSD 1
+#define CONFIG_ARCNET_1201_MODULE 1
+#define CONFIG_BT_HCIUART_H4 1
+#define CONFIG_NF_CONNTRACK_ENABLED_MODULE 1
+#define CONFIG_USB_STORAGE_DPCM 1
+#define CONFIG_DVB_BUDGET_CI_MODULE 1
+#define CONFIG_VIDEO_PVRUSB2_SYSFS 1
+#define CONFIG_VIDEO_CX88_MODULE 1
+#define CONFIG_DVB_FE_CUSTOMISE 1
+#define CONFIG_P54_COMMON_MODULE 1
+#define CONFIG_IP_NF_ARP_MANGLE_MODULE 1
+#define CONFIG_NF_CONNTRACK_SIP_MODULE 1
+#define CONFIG_CRYPTO 1
+#define CONFIG_LCD_DEVICE 1
+#define CONFIG_MTD_CFI_INTELEXT_MODULE 1
+#define CONFIG_ATM_MODULE 1
+#define CONFIG_SYSCTL 1
+#define CONFIG_SND_ICE1724_MODULE 1
+#define CONFIG_DRM_MODULE 1
+#define CONFIG_SERIAL_8250_CS_MODULE 1
+#define CONFIG_ARCNET_1051_MODULE 1
+#define CONFIG_SND_ATIIXP_MODEM_MODULE 1
+#define CONFIG_USB_STV680_MODULE 1
+#define CONFIG_I2C_SIS5595_MODULE 1
+#define CONFIG_I2C_ALI15X3_MODULE 1
+#define CONFIG_SPECIALIX_RTSCTS 1
+#define CONFIG_CYCLADES_SYNC_MODULE 1
+#define CONFIG_ARCNET_COM20020_CS_MODULE 1
+#define CONFIG_CDROM_PKTCDVD 1
+#define CONFIG_ECONET_NATIVE 1
+#define CONFIG_SND 1
+#define CONFIG_SENSORS_W83L785TS_MODULE 1
+#define CONFIG_ISI_MODULE 1
+#define CONFIG_ATP_MODULE 1
+#define CONFIG_CICADA_PHY_MODULE 1
+#define CONFIG_MTD_DOCECC_MODULE 1
+#define CONFIG_MTD_MODULE 1
+#define CONFIG_IP_ROUTE_MULTIPATH_DRR_MODULE 1
+#define CONFIG_HPET_EMULATE_RTC 1
+#define CONFIG_UFS_FS 1
+#define CONFIG_DVB_USB_NOVA_T_USB2_MODULE 1
+#define CONFIG_WAN 1
+#define CONFIG_FTL_MODULE 1
+#define CONFIG_IP_VS_WLC_MODULE 1
+#define CONFIG_IP_PNP 1
+#define CONFIG_ACPI_HOTPLUG_CPU 1
+#define CONFIG_DMA_ENGINE 1
+#define CONFIG_DVB_TTUSB_BUDGET_MODULE 1
+#define CONFIG_DVB_TDA8083_MODULE 1
+#define CONFIG_ISDN_CAPI_MIDDLEWARE 1
+#define CONFIG_PATA_CS5520 1
+#define CONFIG_AIC7XXX_CMDS_PER_DEVICE 32
+#define CONFIG_MTD_PNC2000_MODULE 1
+#define CONFIG_YAM_MODULE 1
+#define CONFIG_IP6_NF_FILTER_MODULE 1
+#define CONFIG_IP_NF_TARGET_ECN_MODULE 1
+#define CONFIG_HT_IRQ 1
+#define CONFIG_NET 1
+#define CONFIG_KERNELVERSION "2.6.20-sabayon-r1"
+#define CONFIG_JFFS2_SUMMARY 1
+#define CONFIG_SND_ALS4000_MODULE 1
+#define CONFIG_I2C_OCORES_MODULE 1
+#define CONFIG_SSB_MODULE 1
+#define CONFIG_VORTEX_MODULE 1
+#define CONFIG_PATA_CS5530 1
+#define CONFIG_MODULE_UNLOAD 1
+#define CONFIG_XFS_FS 1
+#define CONFIG_FS_XIP 1
+#define CONFIG_SND_ALI5451_MODULE 1
+#define CONFIG_RADIO_MAESTRO_MODULE 1
+#define CONFIG_RT61PCI_MODULE 1
+#define CONFIG_BCM43XX_MODULE 1
+#define CONFIG_IEEE1394 1
+#define CONFIG_SCSI_BUSLOGIC 1
+#define CONFIG_IRTTY_SIR_MODULE 1
+#define CONFIG_NET_CLS_BASIC_MODULE 1
+#define CONFIG_TEXTSEARCH_BM_MODULE 1
+#define CONFIG_CALGARY_IOMMU 1
+#define CONFIG_RTC 1
+#define CONFIG_MAC_PARTITION 1
+#define CONFIG_VIDEO_PVRUSB2_MODULE 1
+#define CONFIG_RIO_MODULE 1
+#define CONFIG_GAMEPORT_FM801_MODULE 1
+#define CONFIG_CAPI_EICON 1
+#define CONFIG_NETDEVICES 1
+#define CONFIG_USB 1
+#define CONFIG_ECONET_AUNUDP 1
+#define CONFIG_IP_VS_FTP_MODULE 1
+#define CONFIG_INET_TCP_DIAG 1
+#define CONFIG_YENTA_TOSHIBA 1
+#define CONFIG_JFFS2_ZLIB 1
+#define CONFIG_USB_GADGET_DUALSPEED 1
+#define CONFIG_SENSORS_CORETEMP_MODULE 1
+#define CONFIG_JOYSTICK_STINGER_MODULE 1
+#define CONFIG_HDLC_CISCO_MODULE 1
+#define CONFIG_CHELSIO_T1_MODULE 1
+#define CONFIG_HAMACHI_MODULE 1
+#define CONFIG_PARIDE_PCD_MODULE 1
+#define CONFIG_IP_NF_TARGET_TCPMSS_MODULE 1
+#define CONFIG_SND_HDA_INTEL_MODULE 1
+#define CONFIG_DVB_TUA6100_MODULE 1
+#define CONFIG_DVB_BUDGET_AV_MODULE 1
+#define CONFIG_SPI 1
+#define CONFIG_SOFT_WATCHDOG_MODULE 1
+#define CONFIG_PPP_SYNC_TTY_MODULE 1
+#define CONFIG_ARCNET_COM90xxIO_MODULE 1
+#define CONFIG_SCSI_ACARD 1
+#define CONFIG_MTD_NAND_DISKONCHIP_PROBE_ADDRESS 0x0
+#define CONFIG_SOFTWARE_SUSPEND 1
+#define CONFIG_EFI_PARTITION 1
+#define CONFIG_NLS 1
+#define CONFIG_SENSORS_DS1621_MODULE 1
+#define CONFIG_W1_MASTER_MATROX_MODULE 1
+#define CONFIG_ATM_CLIP_NO_ICMP 1
+#define CONFIG_EXT4DEV_FS_XATTR 1
+#define CONFIG_KVM_MODULE 1
+#define CONFIG_FB_VOODOO1_MODULE 1
+#define CONFIG_VIDEO_BUF_DVB_MODULE 1
+#define CONFIG_I2C_VIAPRO_MODULE 1
+#define CONFIG_SERIAL_8250 1
+#define CONFIG_CDROM_PKTCDVD_WCACHE 1
+#define CONFIG_PNP 1
+#define CONFIG_LEDS_TRIGGERS 1
+#define CONFIG_CRYPTO_ALGAPI 1
+#define CONFIG_SUSPEND2_SWAP 1
+#define CONFIG_USB_FTDI_ELAN_MODULE 1
+#define CONFIG_SND_SEQUENCER_MODULE 1
+#define CONFIG_ISDN_DRV_AVMB1_T1PCI_MODULE 1
+#define CONFIG_ARCNET_COM20020_MODULE 1
+#define CONFIG_MTD_CFI_I1 1
+#define CONFIG_TCP_MD5SIG 1
+#define CONFIG_MMU 1
+#define CONFIG_DVB_ISL6421_MODULE 1
+#define CONFIG_VIDEO_STRADIS_MODULE 1
+#define CONFIG_HW_RANDOM_AMD 1
+#define CONFIG_INPUT_FF_MEMLESS 1
+#define CONFIG_ARCNET_CAP_MODULE 1
+#define CONFIG_SCSI_SYM53C8XX_MAX_TAGS 64
+#define CONFIG_BLK_DEV_RAM_SIZE 16384
+#define CONFIG_MTD_CFI_I2 1
+#define CONFIG_PPP_MODULE 1
+#define CONFIG_SMP 1
+#define CONFIG_USB_AUERSWALD_MODULE 1
+#define CONFIG_SENSORS_W83793_MODULE 1
+#define CONFIG_SENSORS_DS1337_MODULE 1
+#define CONFIG_IPX_MODULE 1
+#define CONFIG_IPV6_SUBTREES 1
+#define CONFIG_IPV6_ROUTER_PREF 1
+#define CONFIG_EXT2_FS_SECURITY 1
+#define CONFIG_USB_IBMCAM_MODULE 1
+#define CONFIG_VIDEO_CPIA_PP_MODULE 1
+#define CONFIG_VIDEO_TVAUDIO_MODULE 1
+#define CONFIG_SENSORS_DS1374_MODULE 1
+#define CONFIG_SK98LIN_MODULE 1
+#define CONFIG_PATA_SERVERWORKS 1
+#define CONFIG_PATA_RZ1000 1
+#define CONFIG_IOSCHED_AS 1
+#define CONFIG_CRYPTO_KHAZAD_MODULE 1
+#define CONFIG_EXT3_FS_SECURITY 1
+#define CONFIG_VIDEO_CPIA_MODULE 1
+#define CONFIG_SENSORS_ASB100_MODULE 1
+#define CONFIG_W1_SLAVE_SMEM_MODULE 1
+#define CONFIG_NET_PCMCIA 1
+#define CONFIG_8139TOO_TUNE_TWISTER 1
+#define CONFIG_BT_HCIVHCI_MODULE 1
+#define CONFIG_NET_ACT_PEDIT_MODULE 1
+#define CONFIG_DECNET_ROUTER 1
+#define CONFIG_IP_NF_TARGET_LOG_MODULE 1
+#define CONFIG_ACPI_VIDEO 1
+#define CONFIG_BASE_SMALL 0
+#define CONFIG_SND_CS46XX_MODULE 1
+#define CONFIG_DVB_VES1820_MODULE 1
+#define CONFIG_MOXA_INTELLIO_MODULE 1
+#define CONFIG_P54_PCI_MODULE 1
+#define CONFIG_PRISM54_MODULE 1
+#define CONFIG_AUDIT_ARCH 1
+#define CONFIG_RTC_DRV_DS1307_MODULE 1
+#define CONFIG_USB_GADGET_MODULE 1
+#define CONFIG_SND_ENS1370_MODULE 1
+#define CONFIG_SND_AC97_CODEC_MODULE 1
+#define CONFIG_JOYSTICK_WARRIOR_MODULE 1
+#define CONFIG_MTD_GEN_PROBE_MODULE 1
+#define CONFIG_ACPI_SLEEP 1
+#define CONFIG_LDM_PARTITION 1
+#define CONFIG_XFS_RT 1
+#define CONFIG_USB_SERIAL_CYBERJACK_MODULE 1
+#define CONFIG_SND_ENS1371_MODULE 1
+#define CONFIG_DVB_BUDGET_MODULE 1
+#define CONFIG_IPMI_POWEROFF_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_COMMENT_MODULE 1
+#define CONFIG_BINFMT_ELF 1
+#define CONFIG_PCI_DIRECT 1
+#define CONFIG_SQUASHFS_EMBEDDED 1
+#define CONFIG_JFFS2_FS_WRITEBUFFER 1
+#define CONFIG_SOUND_UART6850_MODULE 1
+#define CONFIG_SBC8360_WDT_MODULE 1
+#define CONFIG_JOYSTICK_JOYDUMP_MODULE 1
+#define CONFIG_JOYSTICK_TMDC_MODULE 1
+#define CONFIG_NORTEL_HERMES_MODULE 1
+#define CONFIG_TUN_MODULE 1
+#define CONFIG_I2O_CONFIG_OLD_IOCTL 1
+#define CONFIG_MTD_DOCPROBE_ADDRESS 0x0000
+#define CONFIG_BT_HCIUSB_SCO 1
+#define CONFIG_RTC_DRV_DS1742_MODULE 1
+#define CONFIG_RTC_DRV_DS1553_MODULE 1
+#define CONFIG_SND_SUPPORT_OLD_API 1
+#define CONFIG_DVB_TTUSB_DEC_MODULE 1
+#define CONFIG_SERIO_I8042 1
+#define CONFIG_NET_EMATCH 1
+#define CONFIG_DECNET_NF_GRABULATOR_MODULE 1
+#define CONFIG_SND_CMIPCI_MODULE 1
+#define CONFIG_SND_PCM_OSS_PLUGINS 1
+#define CONFIG_USB_SN9C102_MODULE 1
+#define CONFIG_DRM_SAVAGE_MODULE 1
+#define CONFIG_LEGACY_PTY_COUNT 256
+#define CONFIG_JOYSTICK_TWIDJOY_MODULE 1
+#define CONFIG_SCSI_ISCSI_ATTRS 1
+#define CONFIG_MTD_REDBOOT_PARTS_READONLY 1
+#define CONFIG_ESI_DONGLE_MODULE 1
+#define CONFIG_IP_NF_TARGET_MASQUERADE_MODULE 1
+#define CONFIG_PCIEAER 1
+#define CONFIG_RTC_DRV_DS1672_MODULE 1
+#define CONFIG_DVB_USB_VP7045_MODULE 1
+#define CONFIG_VIDEO_SAA7134_ALSA_MODULE 1
+#define CONFIG_SENSORS_ATXP1_MODULE 1
+#define CONFIG_I2C_ISA_MODULE 1
+#define CONFIG_RT73USB_MODULE 1
+#define CONFIG_8139TOO_8129 1
+#define CONFIG_X86_MCE 1
+#define CONFIG_LOG_BUF_SHIFT 15
+#define CONFIG_USB_SERIAL_VISOR_MODULE 1
+#define CONFIG_USB_NET_GL620A_MODULE 1
+#define CONFIG_DVB_NXT6000_MODULE 1
+#define CONFIG_SENSORS_VT1211_MODULE 1
+#define CONFIG_DRM_RADEON_MODULE 1
+#define CONFIG_BITREVERSE 1
+#define CONFIG_TEXTSEARCH 1
+#define CONFIG_NF_CONNTRACK_SECMARK 1
+#define CONFIG_IP_VS_WRR_MODULE 1
+#define CONFIG_TCP_CONG_HTCP_MODULE 1
+#define CONFIG_SGI_PARTITION 1
+#define CONFIG_EXT4DEV_FS 1
+#define CONFIG_USB_NET2280_MODULE 1
+#define CONFIG_FB_3DFX_MODULE 1
+#define CONFIG_SENSORS_HDAPS_MODULE 1
+#define CONFIG_W83877F_WDT_MODULE 1
+#define CONFIG_MOXA_SMARTIO_NEW_MODULE 1
+#define CONFIG_MTD_CONCAT_MODULE 1
+#define CONFIG_NET_SCH_NETEM_MODULE 1
+#define CONFIG_IP_ROUTE_VERBOSE 1
+#define CONFIG_HAVE_ARCH_EARLY_PFN_TO_NID 1
+#define CONFIG_IA32_EMULATION 1
+#define CONFIG_UTS_NS 1
+#define CONFIG_ARCH_POPULATES_NODE_MAP 1
+#define CONFIG_USB_POWERMATE_MODULE 1
+#define CONFIG_USB_HIDDEV 1
+#define CONFIG_I2C_VIA_MODULE 1
+#define CONFIG_W83977F_WDT_MODULE 1
+#define CONFIG_JOYSTICK_GRIP_MP_MODULE 1
+#define CONFIG_LEDS_CLASS_MODULE 1
+#define CONFIG_BAYCOM_PAR_MODULE 1
+#define CONFIG_NETFILTER_XT_MATCH_DCCP_MODULE 1
+#define CONFIG_NFS_V3_ACL 1
+#define CONFIG_AUTOFS4_FS 1
+#define CONFIG_USB_BELKIN 1
+#define CONFIG_SND_RME9652_MODULE 1
+#define CONFIG_SND_INDIGO_MODULE 1
+#define CONFIG_DUMMY_CONSOLE 1
+#define CONFIG_VIDEO_UPD64031A_MODULE 1
+#define CONFIG_8139_OLD_RX_RESET 1
+#define CONFIG_NET_ESTIMATOR 1
+#define CONFIG_NF_CT_NETLINK_MODULE 1
+#define CONFIG_NCPFS_PACKET_SIGNING 1
+#define CONFIG_SND_USB_AUDIO_MODULE 1
+#define CONFIG_I2C_I810_MODULE 1
+#define CONFIG_I2C_I801_MODULE 1
+#define CONFIG_PCI_HERMES_MODULE 1
+#define CONFIG_SECURITY_SELINUX 1
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/linux/utsrelease.h linux-2.6.20-sabayon-r1/include/linux/utsrelease.h
--- linux-2.6.20-sabayon-r1.orig/include/linux/utsrelease.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/linux/utsrelease.h	2007-02-12 15:10:48.000000000 +0100
@@ -0,0 +1 @@
+#define UTS_RELEASE "2.6.20-sabayon-r1"
diff -Nurp linux-2.6.20-sabayon-r1.orig/include/linux/version.h linux-2.6.20-sabayon-r1/include/linux/version.h
--- linux-2.6.20-sabayon-r1.orig/include/linux/version.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/include/linux/version.h	2007-02-12 15:10:48.000000000 +0100
@@ -0,0 +1,2 @@
+#define LINUX_VERSION_CODE 132628
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + (c))
Files linux-2.6.20-sabayon-r1.orig/scripts/basic/docproc and linux-2.6.20-sabayon-r1/scripts/basic/docproc differ
Files linux-2.6.20-sabayon-r1.orig/scripts/basic/fixdep and linux-2.6.20-sabayon-r1/scripts/basic/fixdep differ
Files linux-2.6.20-sabayon-r1.orig/scripts/bin2c and linux-2.6.20-sabayon-r1/scripts/bin2c differ
Files linux-2.6.20-sabayon-r1.orig/scripts/conmakehash and linux-2.6.20-sabayon-r1/scripts/conmakehash differ
Files linux-2.6.20-sabayon-r1.orig/scripts/kallsyms and linux-2.6.20-sabayon-r1/scripts/kallsyms differ
Files linux-2.6.20-sabayon-r1.orig/scripts/kconfig/conf and linux-2.6.20-sabayon-r1/scripts/kconfig/conf differ
diff -Nurp linux-2.6.20-sabayon-r1.orig/scripts/kconfig/lex.zconf.c linux-2.6.20-sabayon-r1/scripts/kconfig/lex.zconf.c
--- linux-2.6.20-sabayon-r1.orig/scripts/kconfig/lex.zconf.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/scripts/kconfig/lex.zconf.c	2007-02-12 15:08:09.000000000 +0100
@@ -0,0 +1,2350 @@
+
+#line 3 "scripts/kconfig/lex.zconf.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 33
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types.
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+#if __STDC__
+
+#define YY_USE_CONST
+
+#endif	/* __STDC__ */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE zconfrestart(zconfin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int zconfleng;
+
+extern FILE *zconfin, *zconfout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up zconftext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+/* The following is because we cannot portably get our hands on size_t
+ * (without autoconf's help, which isn't available because we want
+ * flex-generated scanners to compile on their own).
+ */
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef unsigned int yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via zconfrestart()), so that the user can continue scanning by
+	 * just pointing zconfin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when zconftext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int zconfleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow zconfwrap()'s to do buffer switches
+ * instead of setting up a fresh zconfin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void zconfrestart (FILE *input_file  );
+void zconf_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE zconf_create_buffer (FILE *file,int size  );
+void zconf_delete_buffer (YY_BUFFER_STATE b  );
+void zconf_flush_buffer (YY_BUFFER_STATE b  );
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void zconfpop_buffer_state (void );
+
+static void zconfensure_buffer_stack (void );
+static void zconf_load_buffer_state (void );
+static void zconf_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER zconf_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE zconf_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE zconf_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE zconf_scan_bytes (yyconst char *bytes,int len  );
+
+void *zconfalloc (yy_size_t  );
+void *zconfrealloc (void *,yy_size_t  );
+void zconffree (void *  );
+
+#define yy_new_buffer zconf_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        zconfensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            zconf_create_buffer(zconfin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+#define zconfwrap() 1
+#define YY_SKIP_YYWRAP
+
+typedef unsigned char YY_CHAR;
+
+FILE *zconfin = (FILE *) 0, *zconfout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int zconflineno;
+
+int zconflineno = 1;
+
+extern char *zconftext;
+#define yytext_ptr zconftext
+static yyconst flex_int16_t yy_nxt[][17] =
+    {
+    {
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   12,   13,   14,   12,   12,   15,   12,   12,   12,
+       12,   12,   12,   12,   12,   12,   12
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+    },
+
+    {
+       11,   16,   16,   17,   16,   16,   16,   16,   16,   16,
+       16,   16,   16,   18,   16,   16,   16
+
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   19,   20,   21,   19,   19,   19,   19,   19,   19,
+       19,   19,   19,   19,   19,   19,   19
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   22,   22,   23,   22,   24,   22,   22,   24,   22,
+       22,   22,   22,   22,   22,   25,   22
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+
+    },
+
+    {
+       11,   26,   26,   27,   28,   29,   30,   31,   29,   32,
+       33,   34,   35,   35,   36,   37,   38
+    },
+
+    {
+      -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,  -11,
+      -11,  -11,  -11,  -11,  -11,  -11,  -11
+    },
+
+    {
+       11,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,  -12,
+      -12,  -12,  -12,  -12,  -12,  -12,  -12
+    },
+
+    {
+       11,  -13,   39,   40,  -13,  -13,   41,  -13,  -13,  -13,
+      -13,  -13,  -13,  -13,  -13,  -13,  -13
+    },
+
+    {
+       11,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,  -14,
+      -14,  -14,  -14,  -14,  -14,  -14,  -14
+
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,  -16,
+      -16,  -16,  -16,  -16,  -16,  -16,  -16
+    },
+
+    {
+       11,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,  -17,
+      -17,  -17,  -17,  -17,  -17,  -17,  -17
+    },
+
+    {
+       11,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,  -18,
+      -18,  -18,  -18,   44,  -18,  -18,  -18
+    },
+
+    {
+       11,   45,   45,  -19,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+
+    },
+
+    {
+       11,  -20,   46,   47,  -20,  -20,  -20,  -20,  -20,  -20,
+      -20,  -20,  -20,  -20,  -20,  -20,  -20
+    },
+
+    {
+       11,   48,  -21,  -21,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -22,   49,   49,  -22,   49,
+       49,   49,   49,   49,   49,  -22,   49
+    },
+
+    {
+       11,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,  -23,
+      -23,  -23,  -23,  -23,  -23,  -23,  -23
+    },
+
+    {
+       11,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,  -24,
+      -24,  -24,  -24,  -24,  -24,  -24,  -24
+
+    },
+
+    {
+       11,   51,   51,   52,   51,   51,   51,   51,   51,   51,
+       51,   51,   51,   51,   51,   51,   51
+    },
+
+    {
+       11,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,
+      -26,  -26,  -26,  -26,  -26,  -26,  -26
+    },
+
+    {
+       11,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,  -27,
+      -27,  -27,  -27,  -27,  -27,  -27,  -27
+    },
+
+    {
+       11,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,
+      -28,  -28,  -28,  -28,   53,  -28,  -28
+    },
+
+    {
+       11,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,  -29,
+      -29,  -29,  -29,  -29,  -29,  -29,  -29
+
+    },
+
+    {
+       11,   54,   54,  -30,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+    },
+
+    {
+       11,  -31,  -31,  -31,  -31,  -31,  -31,   55,  -31,  -31,
+      -31,  -31,  -31,  -31,  -31,  -31,  -31
+    },
+
+    {
+       11,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,  -32,
+      -32,  -32,  -32,  -32,  -32,  -32,  -32
+    },
+
+    {
+       11,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,  -33,
+      -33,  -33,  -33,  -33,  -33,  -33,  -33
+    },
+
+    {
+       11,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,  -34,
+      -34,   56,   57,   57,  -34,  -34,  -34
+
+    },
+
+    {
+       11,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,  -35,
+      -35,   57,   57,   57,  -35,  -35,  -35
+    },
+
+    {
+       11,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,  -36,
+      -36,  -36,  -36,  -36,  -36,  -36,  -36
+    },
+
+    {
+       11,  -37,  -37,   58,  -37,  -37,  -37,  -37,  -37,  -37,
+      -37,  -37,  -37,  -37,  -37,  -37,  -37
+    },
+
+    {
+       11,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,  -38,
+      -38,  -38,  -38,  -38,  -38,  -38,   59
+    },
+
+    {
+       11,  -39,   39,   40,  -39,  -39,   41,  -39,  -39,  -39,
+      -39,  -39,  -39,  -39,  -39,  -39,  -39
+
+    },
+
+    {
+       11,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,  -40,
+      -40,  -40,  -40,  -40,  -40,  -40,  -40
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,   42,   42,   43,   42,   42,   42,   42,   42,   42,
+       42,   42,   42,   42,   42,   42,   42
+    },
+
+    {
+       11,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,  -43,
+      -43,  -43,  -43,  -43,  -43,  -43,  -43
+    },
+
+    {
+       11,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,  -44,
+      -44,  -44,  -44,   44,  -44,  -44,  -44
+
+    },
+
+    {
+       11,   45,   45,  -45,   45,   45,   45,   45,   45,   45,
+       45,   45,   45,   45,   45,   45,   45
+    },
+
+    {
+       11,  -46,   46,   47,  -46,  -46,  -46,  -46,  -46,  -46,
+      -46,  -46,  -46,  -46,  -46,  -46,  -46
+    },
+
+    {
+       11,   48,  -47,  -47,   48,   48,   48,   48,   48,   48,
+       48,   48,   48,   48,   48,   48,   48
+    },
+
+    {
+       11,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,  -48,
+      -48,  -48,  -48,  -48,  -48,  -48,  -48
+    },
+
+    {
+       11,   49,   49,   50,   49,  -49,   49,   49,  -49,   49,
+       49,   49,   49,   49,   49,  -49,   49
+
+    },
+
+    {
+       11,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,  -50,
+      -50,  -50,  -50,  -50,  -50,  -50,  -50
+    },
+
+    {
+       11,  -51,  -51,   52,  -51,  -51,  -51,  -51,  -51,  -51,
+      -51,  -51,  -51,  -51,  -51,  -51,  -51
+    },
+
+    {
+       11,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,  -52,
+      -52,  -52,  -52,  -52,  -52,  -52,  -52
+    },
+
+    {
+       11,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,  -53,
+      -53,  -53,  -53,  -53,  -53,  -53,  -53
+    },
+
+    {
+       11,   54,   54,  -54,   54,   54,   54,   54,   54,   54,
+       54,   54,   54,   54,   54,   54,   54
+
+    },
+
+    {
+       11,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,  -55,
+      -55,  -55,  -55,  -55,  -55,  -55,  -55
+    },
+
+    {
+       11,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,  -56,
+      -56,   60,   57,   57,  -56,  -56,  -56
+    },
+
+    {
+       11,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,  -57,
+      -57,   57,   57,   57,  -57,  -57,  -57
+    },
+
+    {
+       11,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,  -58,
+      -58,  -58,  -58,  -58,  -58,  -58,  -58
+    },
+
+    {
+       11,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,  -59,
+      -59,  -59,  -59,  -59,  -59,  -59,  -59
+
+    },
+
+    {
+       11,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,  -60,
+      -60,   57,   57,   57,  -60,  -60,  -60
+    },
+
+    } ;
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up zconftext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	zconfleng = (size_t) (yy_cp - yy_bp); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 33
+#define YY_END_OF_BUFFER 34
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_accept[61] =
+    {   0,
+        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+       34,    5,    4,    2,    3,    7,    8,    6,   32,   29,
+       31,   24,   28,   27,   26,   22,   17,   13,   16,   20,
+       22,   11,   12,   19,   19,   14,   22,   22,    4,    2,
+        3,    3,    1,    6,   32,   29,   31,   30,   24,   23,
+       26,   25,   15,   20,    9,   19,   19,   21,   10,   18
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    4,    5,    6,    1,    1,    7,    8,    9,
+       10,    1,    1,    1,   11,   12,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,    1,    1,
+       14,    1,    1,    1,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+        1,   15,    1,    1,   13,    1,   13,   13,   13,   13,
+
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
+       13,   13,    1,   16,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+extern int zconf_flex_debug;
+int zconf_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define yymore() yymore_used_but_not_detected
+#define YY_MORE_ADJ 0
+#define YY_RESTORE_YY_MORE_OFFSET
+char *zconftext;
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <limits.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#define START_STRSIZE	16
+
+static struct {
+	struct file *file;
+	int lineno;
+} current_pos;
+
+static char *text;
+static int text_size, text_asize;
+
+struct buffer {
+        struct buffer *parent;
+        YY_BUFFER_STATE state;
+};
+
+struct buffer *current_buf;
+
+static int last_ts, first_ts;
+
+static void zconf_endhelp(void);
+static void zconf_endfile(void);
+
+void new_string(void)
+{
+	text = malloc(START_STRSIZE);
+	text_asize = START_STRSIZE;
+	text_size = 0;
+	*text = 0;
+}
+
+void append_string(const char *str, int size)
+{
+	int new_size = text_size + size + 1;
+	if (new_size > text_asize) {
+		new_size += START_STRSIZE - 1;
+		new_size &= -START_STRSIZE;
+		text = realloc(text, new_size);
+		text_asize = new_size;
+	}
+	memcpy(text + text_size, str, size);
+	text_size += size;
+	text[text_size] = 0;
+}
+
+void alloc_string(const char *str, int size)
+{
+	text = malloc(size + 1);
+	memcpy(text, str, size);
+	text[size] = 0;
+}
+
+#define INITIAL 0
+#define COMMAND 1
+#define HELP 2
+#define STRING 3
+#define PARAM 4
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int zconfwrap (void );
+#else
+extern int zconfwrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO (void) fwrite( zconftext, zconfleng, 1, zconfout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	errno=0; \
+	while ( (result = read( fileno(zconfin), (char *) buf, max_size )) < 0 ) \
+	{ \
+		if( errno != EINTR) \
+		{ \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+			break; \
+		} \
+		errno=0; \
+		clearerr(zconfin); \
+	}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int zconflex (void);
+
+#define YY_DECL int zconflex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after zconftext and zconfleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+	int str = 0;
+	int ts, i;
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! zconfin )
+			zconfin = stdin;
+
+		if ( ! zconfout )
+			zconfout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			zconfensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				zconf_create_buffer(zconfin,YY_BUF_SIZE );
+		}
+
+		zconf_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of zconftext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+yy_match:
+		while ( (yy_current_state = yy_nxt[yy_current_state][ yy_ec[YY_SC_TO_UI(*yy_cp)]  ]) > 0 )
+			++yy_cp;
+
+		yy_current_state = -yy_current_state;
+
+yy_find_action:
+		yy_act = yy_accept[yy_current_state];
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+/* rule 1 can match eol */
+case 2:
+/* rule 2 can match eol */
+YY_RULE_SETUP
+{
+	current_file->lineno++;
+	return T_EOL;
+}
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+{
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+{
+	unput(zconftext[0]);
+	BEGIN(COMMAND);
+}
+	YY_BREAK
+
+case 6:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		BEGIN(PARAM);
+		current_pos.file = current_file;
+		current_pos.lineno = current_file->lineno;
+		if (id && id->flags & TF_COMMAND) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+
+	YY_BREAK
+case 8:
+/* rule 8 can match eol */
+YY_RULE_SETUP
+{
+		BEGIN(INITIAL);
+		current_file->lineno++;
+		return T_EOL;
+	}
+	YY_BREAK
+
+case 9:
+YY_RULE_SETUP
+return T_AND;
+	YY_BREAK
+case 10:
+YY_RULE_SETUP
+return T_OR;
+	YY_BREAK
+case 11:
+YY_RULE_SETUP
+return T_OPEN_PAREN;
+	YY_BREAK
+case 12:
+YY_RULE_SETUP
+return T_CLOSE_PAREN;
+	YY_BREAK
+case 13:
+YY_RULE_SETUP
+return T_NOT;
+	YY_BREAK
+case 14:
+YY_RULE_SETUP
+return T_EQUAL;
+	YY_BREAK
+case 15:
+YY_RULE_SETUP
+return T_UNEQUAL;
+	YY_BREAK
+case 16:
+YY_RULE_SETUP
+{
+		str = zconftext[0];
+		new_string();
+		BEGIN(STRING);
+	}
+	YY_BREAK
+case 17:
+/* rule 17 can match eol */
+YY_RULE_SETUP
+BEGIN(INITIAL); current_file->lineno++; return T_EOL;
+	YY_BREAK
+case 18:
+YY_RULE_SETUP
+/* ignore */
+	YY_BREAK
+case 19:
+YY_RULE_SETUP
+{
+		struct kconf_id *id = kconf_id_lookup(zconftext, zconfleng);
+		if (id && id->flags & TF_PARAM) {
+			zconflval.id = id;
+			return id->token;
+		}
+		alloc_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD;
+	}
+	YY_BREAK
+case 20:
+YY_RULE_SETUP
+/* comment */
+	YY_BREAK
+case 21:
+/* rule 21 can match eol */
+YY_RULE_SETUP
+current_file->lineno++;
+	YY_BREAK
+case 22:
+YY_RULE_SETUP
+
+	YY_BREAK
+case YY_STATE_EOF(PARAM):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 23:
+/* rule 23 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 24:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+	}
+	YY_BREAK
+case 25:
+/* rule 25 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+		zconflval.string = text;
+		return T_WORD_QUOTE;
+	}
+	YY_BREAK
+case 26:
+YY_RULE_SETUP
+{
+		append_string(zconftext + 1, zconfleng - 1);
+	}
+	YY_BREAK
+case 27:
+YY_RULE_SETUP
+{
+		if (str == zconftext[0]) {
+			BEGIN(PARAM);
+			zconflval.string = text;
+			return T_WORD_QUOTE;
+		} else
+			append_string(zconftext, 1);
+	}
+	YY_BREAK
+case 28:
+/* rule 28 can match eol */
+YY_RULE_SETUP
+{
+		printf("%s:%d:warning: multi-line strings not supported\n", zconf_curname(), zconf_lineno());
+		current_file->lineno++;
+		BEGIN(INITIAL);
+		return T_EOL;
+	}
+	YY_BREAK
+case YY_STATE_EOF(STRING):
+{
+		BEGIN(INITIAL);
+	}
+	YY_BREAK
+
+case 29:
+YY_RULE_SETUP
+{
+		ts = 0;
+		for (i = 0; i < zconfleng; i++) {
+			if (zconftext[i] == '\t')
+				ts = (ts & ~7) + 8;
+			else
+				ts++;
+		}
+		last_ts = ts;
+		if (first_ts) {
+			if (ts < first_ts) {
+				zconf_endhelp();
+				return T_HELPTEXT;
+			}
+			ts -= first_ts;
+			while (ts > 8) {
+				append_string("        ", 8);
+				ts -= 8;
+			}
+			append_string("        ", ts);
+		}
+	}
+	YY_BREAK
+case 30:
+/* rule 30 can match eol */
+*yy_cp = (yy_hold_char); /* undo effects of setting up zconftext */
+(yy_c_buf_p) = yy_cp -= 1;
+YY_DO_BEFORE_ACTION; /* set up zconftext again */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+case 31:
+/* rule 31 can match eol */
+YY_RULE_SETUP
+{
+		current_file->lineno++;
+		append_string("\n", 1);
+	}
+	YY_BREAK
+case 32:
+YY_RULE_SETUP
+{
+		append_string(zconftext, zconfleng);
+		if (!first_ts)
+			first_ts = last_ts;
+	}
+	YY_BREAK
+case YY_STATE_EOF(HELP):
+{
+		zconf_endhelp();
+		return T_HELPTEXT;
+	}
+	YY_BREAK
+
+case YY_STATE_EOF(INITIAL):
+case YY_STATE_EOF(COMMAND):
+{
+	if (current_file) {
+		zconf_endfile();
+		return T_EOL;
+	}
+	fclose(zconfin);
+	yyterminate();
+}
+	YY_BREAK
+case 33:
+YY_RULE_SETUP
+YY_FATAL_ERROR( "flex scanner jammed" );
+	YY_BREAK
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed zconfin at a new source and called
+			 * zconflex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = zconfin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( zconfwrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * zconftext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of zconflex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
+
+			int yy_c_buf_p_offset =
+				(int) ((yy_c_buf_p) - b->yy_ch_buf);
+
+			if ( b->yy_is_our_buffer )
+				{
+				int new_size = b->yy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->yy_buf_size += b->yy_buf_size / 8;
+				else
+					b->yy_buf_size *= 2;
+
+				b->yy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					zconfrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->yy_ch_buf = 0;
+
+			if ( ! b->yy_ch_buf )
+				YY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
+
+			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			zconfrestart(zconfin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		yy_current_state = yy_nxt[yy_current_state][(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1)];
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	yy_current_state = yy_nxt[yy_current_state][1];
+	yy_is_jam = (yy_current_state <= 0);
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up zconftext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					zconfrestart(zconfin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( zconfwrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve zconftext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void zconfrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        zconfensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            zconf_create_buffer(zconfin,YY_BUF_SIZE );
+	}
+
+	zconf_init_buffer(YY_CURRENT_BUFFER,input_file );
+	zconf_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void zconf_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		zconfpop_buffer_state();
+	 *		zconfpush_buffer_state(new_buffer);
+     */
+	zconfensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	zconf_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (zconfwrap()) processing, but the only time this flag
+	 * is looked at is after zconfwrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void zconf_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	zconfin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE zconf_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) zconfalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	zconf_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with zconf_create_buffer()
+ * 
+ */
+    void zconf_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		zconffree((void *) b->yy_ch_buf  );
+
+	zconffree((void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a zconfrestart() or at EOF.
+ */
+    static void zconf_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	zconf_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then zconf_init_buffer was _probably_
+     * called from zconfrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void zconf_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		zconf_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void zconfpush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	zconfensure_buffer_stack();
+
+	/* This block is copied from zconf_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from zconf_switch_to_buffer. */
+	zconf_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void zconfpop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	zconf_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		zconf_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void zconfensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)zconfrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE zconf_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) zconfalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	zconf_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to zconflex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       zconf_scan_bytes() instead.
+ */
+YY_BUFFER_STATE zconf_scan_string (yyconst char * yystr )
+{
+    
+	return zconf_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to zconflex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE zconf_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) zconfalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in zconf_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = zconf_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in zconf_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up zconftext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		zconftext[zconfleng] = (yy_hold_char); \
+		(yy_c_buf_p) = zconftext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		zconfleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int zconfget_lineno  (void)
+{
+        
+    return zconflineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *zconfget_in  (void)
+{
+        return zconfin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *zconfget_out  (void)
+{
+        return zconfout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int zconfget_leng  (void)
+{
+        return zconfleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *zconfget_text  (void)
+{
+        return zconftext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void zconfset_lineno (int  line_number )
+{
+    
+    zconflineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see zconf_switch_to_buffer
+ */
+void zconfset_in (FILE *  in_str )
+{
+        zconfin = in_str ;
+}
+
+void zconfset_out (FILE *  out_str )
+{
+        zconfout = out_str ;
+}
+
+int zconfget_debug  (void)
+{
+        return zconf_flex_debug;
+}
+
+void zconfset_debug (int  bdebug )
+{
+        zconf_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from zconflex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    zconfin = stdin;
+    zconfout = stdout;
+#else
+    zconfin = (FILE *) 0;
+    zconfout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * zconflex_init()
+     */
+    return 0;
+}
+
+/* zconflex_destroy is for both reentrant and non-reentrant scanners. */
+int zconflex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		zconf_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		zconfpop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	zconffree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * zconflex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *zconfalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *zconfrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void zconffree (void * ptr )
+{
+	free( (char *) ptr );	/* see zconfrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+void zconf_starthelp(void)
+{
+	new_string();
+	last_ts = first_ts = 0;
+	BEGIN(HELP);
+}
+
+static void zconf_endhelp(void)
+{
+	zconflval.string = text;
+	BEGIN(INITIAL);
+}
+
+/*
+ * Try to open specified file with following names:
+ * ./name
+ * $(srctree)/name
+ * The latter is used when srctree is separate from objtree
+ * when compiling the kernel.
+ * Return NULL if file is not found.
+ */
+FILE *zconf_fopen(const char *name)
+{
+	char *env, fullname[PATH_MAX+1];
+	FILE *f;
+
+	f = fopen(name, "r");
+	if (!f && name[0] != '/') {
+		env = getenv(SRCTREE);
+		if (env) {
+			sprintf(fullname, "%s/%s", env, name);
+			f = fopen(fullname, "r");
+		}
+	}
+	return f;
+}
+
+void zconf_initscan(const char *name)
+{
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("can't find file %s\n", name);
+		exit(1);
+	}
+
+	current_buf = malloc(sizeof(*current_buf));
+	memset(current_buf, 0, sizeof(*current_buf));
+
+	current_file = file_lookup(name);
+	current_file->lineno = 1;
+	current_file->flags = FILE_BUSY;
+}
+
+void zconf_nextfile(const char *name)
+{
+	struct file *file = file_lookup(name);
+	struct buffer *buf = malloc(sizeof(*buf));
+	memset(buf, 0, sizeof(*buf));
+
+	current_buf->state = YY_CURRENT_BUFFER;
+	zconfin = zconf_fopen(name);
+	if (!zconfin) {
+		printf("%s:%d: can't open file \"%s\"\n", zconf_curname(), zconf_lineno(), name);
+		exit(1);
+	}
+	zconf_switch_to_buffer(zconf_create_buffer(zconfin,YY_BUF_SIZE));
+	buf->parent = current_buf;
+	current_buf = buf;
+
+	if (file->flags & FILE_BUSY) {
+		printf("recursive scan (%s)?\n", name);
+		exit(1);
+	}
+	if (file->flags & FILE_SCANNED) {
+		printf("file %s already scanned?\n", name);
+		exit(1);
+	}
+	file->flags |= FILE_BUSY;
+	file->lineno = 1;
+	file->parent = current_file;
+	current_file = file;
+}
+
+static void zconf_endfile(void)
+{
+	struct buffer *parent;
+
+	current_file->flags |= FILE_SCANNED;
+	current_file->flags &= ~FILE_BUSY;
+	current_file = current_file->parent;
+
+	parent = current_buf->parent;
+	if (parent) {
+		fclose(zconfin);
+		zconf_delete_buffer(YY_CURRENT_BUFFER);
+		zconf_switch_to_buffer(parent->state);
+	}
+	free(current_buf);
+	current_buf = parent;
+}
+
+int zconf_lineno(void)
+{
+	return current_pos.lineno;
+}
+
+char *zconf_curname(void)
+{
+	return current_pos.file ? current_pos.file->name : "<none>";
+}
+
Files linux-2.6.20-sabayon-r1.orig/scripts/kconfig/mconf and linux-2.6.20-sabayon-r1/scripts/kconfig/mconf differ
diff -Nurp linux-2.6.20-sabayon-r1.orig/scripts/kconfig/zconf.hash.c linux-2.6.20-sabayon-r1/scripts/kconfig/zconf.hash.c
--- linux-2.6.20-sabayon-r1.orig/scripts/kconfig/zconf.hash.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/scripts/kconfig/zconf.hash.c	2007-02-12 15:08:09.000000000 +0100
@@ -0,0 +1,242 @@
+/* ANSI-C code produced by gperf version 3.0.1 */
+/* Command-line: gperf  */
+/* Computed positions: -k'1,3' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+struct kconf_id;
+/* maximum key range = 45, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+kconf_id_hash (register const char *str, register unsigned int len)
+{
+  static unsigned char asso_values[] =
+    {
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 25, 30, 15,
+       0, 15,  0, 47,  5, 15, 47, 47, 30, 20,
+       5,  0, 25, 15,  0,  0, 10, 35, 47, 47,
+       5, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47, 47, 47, 47, 47,
+      47, 47, 47, 47, 47, 47
+    };
+  register int hval = len;
+
+  switch (hval)
+    {
+      default:
+        hval += asso_values[(unsigned char)str[2]];
+      /*FALLTHROUGH*/
+      case 2:
+      case 1:
+        hval += asso_values[(unsigned char)str[0]];
+        break;
+    }
+  return hval;
+}
+
+struct kconf_id_strings_t
+  {
+    char kconf_id_strings_str2[sizeof("on")];
+    char kconf_id_strings_str6[sizeof("string")];
+    char kconf_id_strings_str7[sizeof("default")];
+    char kconf_id_strings_str8[sizeof("def_bool")];
+    char kconf_id_strings_str10[sizeof("range")];
+    char kconf_id_strings_str11[sizeof("def_boolean")];
+    char kconf_id_strings_str12[sizeof("def_tristate")];
+    char kconf_id_strings_str13[sizeof("hex")];
+    char kconf_id_strings_str14[sizeof("defconfig_list")];
+    char kconf_id_strings_str16[sizeof("option")];
+    char kconf_id_strings_str17[sizeof("if")];
+    char kconf_id_strings_str18[sizeof("optional")];
+    char kconf_id_strings_str20[sizeof("endif")];
+    char kconf_id_strings_str21[sizeof("choice")];
+    char kconf_id_strings_str22[sizeof("endmenu")];
+    char kconf_id_strings_str23[sizeof("requires")];
+    char kconf_id_strings_str24[sizeof("endchoice")];
+    char kconf_id_strings_str26[sizeof("config")];
+    char kconf_id_strings_str27[sizeof("modules")];
+    char kconf_id_strings_str28[sizeof("int")];
+    char kconf_id_strings_str29[sizeof("menu")];
+    char kconf_id_strings_str31[sizeof("prompt")];
+    char kconf_id_strings_str32[sizeof("depends")];
+    char kconf_id_strings_str33[sizeof("tristate")];
+    char kconf_id_strings_str34[sizeof("bool")];
+    char kconf_id_strings_str35[sizeof("menuconfig")];
+    char kconf_id_strings_str36[sizeof("select")];
+    char kconf_id_strings_str37[sizeof("boolean")];
+    char kconf_id_strings_str39[sizeof("help")];
+    char kconf_id_strings_str41[sizeof("source")];
+    char kconf_id_strings_str42[sizeof("comment")];
+    char kconf_id_strings_str43[sizeof("mainmenu")];
+    char kconf_id_strings_str46[sizeof("enable")];
+  };
+static struct kconf_id_strings_t kconf_id_strings_contents =
+  {
+    "on",
+    "string",
+    "default",
+    "def_bool",
+    "range",
+    "def_boolean",
+    "def_tristate",
+    "hex",
+    "defconfig_list",
+    "option",
+    "if",
+    "optional",
+    "endif",
+    "choice",
+    "endmenu",
+    "requires",
+    "endchoice",
+    "config",
+    "modules",
+    "int",
+    "menu",
+    "prompt",
+    "depends",
+    "tristate",
+    "bool",
+    "menuconfig",
+    "select",
+    "boolean",
+    "help",
+    "source",
+    "comment",
+    "mainmenu",
+    "enable"
+  };
+#define kconf_id_strings ((const char *) &kconf_id_strings_contents)
+#ifdef __GNUC__
+__inline
+#endif
+struct kconf_id *
+kconf_id_lookup (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 33,
+      MIN_WORD_LENGTH = 2,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 2,
+      MAX_HASH_VALUE = 46
+    };
+
+  static struct kconf_id wordlist[] =
+    {
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str2,		T_ON,		TF_PARAM},
+      {-1}, {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str6,		T_TYPE,		TF_COMMAND, S_STRING},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str7,	T_DEFAULT,	TF_COMMAND, S_UNKNOWN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str8,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str10,		T_RANGE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str11,	T_DEFAULT,	TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str12,	T_DEFAULT,	TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str13,		T_TYPE,		TF_COMMAND, S_HEX},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str14,	T_OPT_DEFCONFIG_LIST,TF_OPTION},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str16,		T_OPTION,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str17,		T_IF,		TF_COMMAND|TF_PARAM},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str18,	T_OPTIONAL,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str20,		T_ENDIF,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str21,		T_CHOICE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str22,	T_ENDMENU,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str23,	T_REQUIRES,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str24,	T_ENDCHOICE,	TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str26,		T_CONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str27,	T_OPT_MODULES,	TF_OPTION},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str28,		T_TYPE,		TF_COMMAND, S_INT},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str29,		T_MENU,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str31,		T_PROMPT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str32,	T_DEPENDS,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str33,	T_TYPE,		TF_COMMAND, S_TRISTATE},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str34,		T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str35,	T_MENUCONFIG,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str36,		T_SELECT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str37,	T_TYPE,		TF_COMMAND, S_BOOLEAN},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str39,		T_HELP,		TF_COMMAND},
+      {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str41,		T_SOURCE,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str42,	T_COMMENT,	TF_COMMAND},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str43,	T_MAINMENU,	TF_COMMAND},
+      {-1}, {-1},
+      {(int)(long)&((struct kconf_id_strings_t *)0)->kconf_id_strings_str46,		T_SELECT,	TF_COMMAND}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = kconf_id_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= 0)
+        {
+          register int o = wordlist[key].name;
+          if (o >= 0)
+            {
+              register const char *s = o + kconf_id_strings;
+
+              if (*str == *s && !strncmp (str + 1, s + 1, len - 1) && s[len] == '\0')
+                return &wordlist[key];
+            }
+        }
+    }
+  return 0;
+}
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/scripts/kconfig/zconf.tab.c linux-2.6.20-sabayon-r1/scripts/kconfig/zconf.tab.c
--- linux-2.6.20-sabayon-r1.orig/scripts/kconfig/zconf.tab.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/scripts/kconfig/zconf.tab.c	2007-02-12 15:08:09.000000000 +0100
@@ -0,0 +1,2345 @@
+/* A Bison parser, made by GNU Bison 2.1.  */
+
+/* Skeleton parser for Yacc-like parsing with Bison,
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* Written by Richard Stallman by simplifying the original so called
+   ``semantic'' parser.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+/* Identify Bison output.  */
+#define YYBISON 1
+
+/* Bison version.  */
+#define YYBISON_VERSION "2.1"
+
+/* Skeleton name.  */
+#define YYSKELETON_NAME "yacc.c"
+
+/* Pure parsers.  */
+#define YYPURE 0
+
+/* Using locations.  */
+#define YYLSP_NEEDED 0
+
+/* Substitute the variable and function names.  */
+#define yyparse zconfparse
+#define yylex   zconflex
+#define yyerror zconferror
+#define yylval  zconflval
+#define yychar  zconfchar
+#define yydebug zconfdebug
+#define yynerrs zconfnerrs
+
+
+/* Tokens.  */
+#ifndef YYTOKENTYPE
+# define YYTOKENTYPE
+   /* Put the tokens into the symbol table, so that GDB and other debuggers
+      know about them.  */
+   enum yytokentype {
+     T_MAINMENU = 258,
+     T_MENU = 259,
+     T_ENDMENU = 260,
+     T_SOURCE = 261,
+     T_CHOICE = 262,
+     T_ENDCHOICE = 263,
+     T_COMMENT = 264,
+     T_CONFIG = 265,
+     T_MENUCONFIG = 266,
+     T_HELP = 267,
+     T_HELPTEXT = 268,
+     T_IF = 269,
+     T_ENDIF = 270,
+     T_DEPENDS = 271,
+     T_REQUIRES = 272,
+     T_OPTIONAL = 273,
+     T_PROMPT = 274,
+     T_TYPE = 275,
+     T_DEFAULT = 276,
+     T_SELECT = 277,
+     T_RANGE = 278,
+     T_OPTION = 279,
+     T_ON = 280,
+     T_WORD = 281,
+     T_WORD_QUOTE = 282,
+     T_UNEQUAL = 283,
+     T_CLOSE_PAREN = 284,
+     T_OPEN_PAREN = 285,
+     T_EOL = 286,
+     T_OR = 287,
+     T_AND = 288,
+     T_EQUAL = 289,
+     T_NOT = 290
+   };
+#endif
+/* Tokens.  */
+#define T_MAINMENU 258
+#define T_MENU 259
+#define T_ENDMENU 260
+#define T_SOURCE 261
+#define T_CHOICE 262
+#define T_ENDCHOICE 263
+#define T_COMMENT 264
+#define T_CONFIG 265
+#define T_MENUCONFIG 266
+#define T_HELP 267
+#define T_HELPTEXT 268
+#define T_IF 269
+#define T_ENDIF 270
+#define T_DEPENDS 271
+#define T_REQUIRES 272
+#define T_OPTIONAL 273
+#define T_PROMPT 274
+#define T_TYPE 275
+#define T_DEFAULT 276
+#define T_SELECT 277
+#define T_RANGE 278
+#define T_OPTION 279
+#define T_ON 280
+#define T_WORD 281
+#define T_WORD_QUOTE 282
+#define T_UNEQUAL 283
+#define T_CLOSE_PAREN 284
+#define T_OPEN_PAREN 285
+#define T_EOL 286
+#define T_OR 287
+#define T_AND 288
+#define T_EQUAL 289
+#define T_NOT 290
+
+
+
+
+/* Copy the first part of user declarations.  */
+
+
+/*
+ * Copyright (C) 2002 Roman Zippel <zippel@linux-m68k.org>
+ * Released under the terms of the GNU GPL v2.0.
+ */
+
+#include <ctype.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+
+#define LKC_DIRECT_LINK
+#include "lkc.h"
+
+#include "zconf.hash.c"
+
+#define printd(mask, fmt...) if (cdebug & (mask)) printf(fmt)
+
+#define PRINTD		0x0001
+#define DEBUG_PARSE	0x0002
+
+int cdebug = PRINTD;
+
+extern int zconflex(void);
+static void zconfprint(const char *err, ...);
+static void zconf_error(const char *err, ...);
+static void zconferror(const char *err);
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken);
+
+struct symbol *symbol_hash[257];
+
+static struct menu *current_menu, *current_entry;
+
+#define YYDEBUG 0
+#if YYDEBUG
+#define YYERROR_VERBOSE
+#endif
+
+
+/* Enabling traces.  */
+#ifndef YYDEBUG
+# define YYDEBUG 0
+#endif
+
+/* Enabling verbose error messages.  */
+#ifdef YYERROR_VERBOSE
+# undef YYERROR_VERBOSE
+# define YYERROR_VERBOSE 1
+#else
+# define YYERROR_VERBOSE 0
+#endif
+
+/* Enabling the token table.  */
+#ifndef YYTOKEN_TABLE
+# define YYTOKEN_TABLE 0
+#endif
+
+#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+
+typedef union YYSTYPE {
+	char *string;
+	struct file *file;
+	struct symbol *symbol;
+	struct expr *expr;
+	struct menu *menu;
+	struct kconf_id *id;
+} YYSTYPE;
+/* Line 196 of yacc.c.  */
+
+# define yystype YYSTYPE /* obsolescent; will be withdrawn */
+# define YYSTYPE_IS_DECLARED 1
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
+
+
+
+/* Copy the second part of user declarations.  */
+
+
+/* Line 219 of yacc.c.  */
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
+# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
+
+#ifndef YY_
+# if YYENABLE_NLS
+#  if ENABLE_NLS
+#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
+#   define YY_(msgid) dgettext ("bison-runtime", msgid)
+#  endif
+# endif
+# ifndef YY_
+#  define YY_(msgid) msgid
+# endif
+#endif
+
+#if ! defined (yyoverflow) || YYERROR_VERBOSE
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# ifdef YYSTACK_USE_ALLOCA
+#  if YYSTACK_USE_ALLOCA
+#   ifdef __GNUC__
+#    define YYSTACK_ALLOC __builtin_alloca
+#   else
+#    define YYSTACK_ALLOC alloca
+#    if defined (__STDC__) || defined (__cplusplus)
+#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#     define YYINCLUDED_STDLIB_H
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+    /* The OS might guarantee only one guard page at the bottom of the stack,
+       and a page size can be as small as 4096 bytes.  So we cannot safely
+       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
+       to allow for a few compiler-allocated temporary stack slots.  */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
+#  endif
+# else
+#  define YYSTACK_ALLOC YYMALLOC
+#  define YYSTACK_FREE YYFREE
+#  ifndef YYSTACK_ALLOC_MAXIMUM
+#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
+#  endif
+#  ifdef __cplusplus
+extern "C" {
+#  endif
+#  ifndef YYMALLOC
+#   define YYMALLOC malloc
+#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifndef YYFREE
+#   define YYFREE free
+#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
+	&& (defined (__STDC__) || defined (__cplusplus)))
+void free (void *); /* INFRINGES ON USER NAME SPACE */
+#   endif
+#  endif
+#  ifdef __cplusplus
+}
+#  endif
+# endif
+#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short int yyss;
+  YYSTYPE yyvs;
+  };
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short int) + sizeof (YYSTYPE))			\
+      + YYSTACK_GAP_MAXIMUM)
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if defined (__GNUC__) && 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  YYSIZE_T yyi;				\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+#if defined (__STDC__) || defined (__cplusplus)
+   typedef signed char yysigned_char;
+#else
+   typedef short int yysigned_char;
+#endif
+
+/* YYFINAL -- State number of the termination state. */
+#define YYFINAL  3
+/* YYLAST -- Last index in YYTABLE.  */
+#define YYLAST   275
+
+/* YYNTOKENS -- Number of terminals. */
+#define YYNTOKENS  36
+/* YYNNTS -- Number of nonterminals. */
+#define YYNNTS  45
+/* YYNRULES -- Number of rules. */
+#define YYNRULES  110
+/* YYNRULES -- Number of states. */
+#define YYNSTATES  183
+
+/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
+#define YYUNDEFTOK  2
+#define YYMAXUTOK   290
+
+#define YYTRANSLATE(YYX)						\
+  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+
+/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
+static const unsigned char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
+       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
+      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
+      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
+      35
+};
+
+#if YYDEBUG
+/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
+   YYRHS.  */
+static const unsigned short int yyprhs[] =
+{
+       0,     0,     3,     5,     6,     9,    12,    15,    20,    23,
+      28,    33,    37,    39,    41,    43,    45,    47,    49,    51,
+      53,    55,    57,    59,    61,    63,    67,    70,    74,    77,
+      81,    84,    85,    88,    91,    94,    97,   100,   103,   107,
+     112,   117,   122,   128,   132,   133,   137,   138,   141,   144,
+     147,   149,   153,   154,   157,   160,   163,   166,   169,   174,
+     178,   181,   186,   187,   190,   194,   196,   200,   201,   204,
+     207,   210,   214,   217,   219,   223,   224,   227,   230,   233,
+     237,   241,   244,   247,   250,   251,   254,   257,   260,   265,
+     269,   273,   274,   277,   279,   281,   284,   287,   290,   292,
+     295,   296,   299,   301,   305,   309,   313,   316,   320,   324,
+     326
+};
+
+/* YYRHS -- A `-1'-separated list of the rules' RHS. */
+static const yysigned_char yyrhs[] =
+{
+      37,     0,    -1,    38,    -1,    -1,    38,    40,    -1,    38,
+      54,    -1,    38,    65,    -1,    38,     3,    75,    77,    -1,
+      38,    76,    -1,    38,    26,     1,    31,    -1,    38,    39,
+       1,    31,    -1,    38,     1,    31,    -1,    16,    -1,    19,
+      -1,    20,    -1,    22,    -1,    18,    -1,    23,    -1,    21,
+      -1,    31,    -1,    60,    -1,    69,    -1,    43,    -1,    45,
+      -1,    67,    -1,    26,     1,    31,    -1,     1,    31,    -1,
+      10,    26,    31,    -1,    42,    46,    -1,    11,    26,    31,
+      -1,    44,    46,    -1,    -1,    46,    47,    -1,    46,    48,
+      -1,    46,    73,    -1,    46,    71,    -1,    46,    41,    -1,
+      46,    31,    -1,    20,    74,    31,    -1,    19,    75,    78,
+      31,    -1,    21,    79,    78,    31,    -1,    22,    26,    78,
+      31,    -1,    23,    80,    80,    78,    31,    -1,    24,    49,
+      31,    -1,    -1,    49,    26,    50,    -1,    -1,    34,    75,
+      -1,     7,    31,    -1,    51,    55,    -1,    76,    -1,    52,
+      57,    53,    -1,    -1,    55,    56,    -1,    55,    73,    -1,
+      55,    71,    -1,    55,    31,    -1,    55,    41,    -1,    19,
+      75,    78,    31,    -1,    20,    74,    31,    -1,    18,    31,
+      -1,    21,    26,    78,    31,    -1,    -1,    57,    40,    -1,
+      14,    79,    77,    -1,    76,    -1,    58,    61,    59,    -1,
+      -1,    61,    40,    -1,    61,    65,    -1,    61,    54,    -1,
+       4,    75,    31,    -1,    62,    72,    -1,    76,    -1,    63,
+      66,    64,    -1,    -1,    66,    40,    -1,    66,    65,    -1,
+      66,    54,    -1,     6,    75,    31,    -1,     9,    75,    31,
+      -1,    68,    72,    -1,    12,    31,    -1,    70,    13,    -1,
+      -1,    72,    73,    -1,    72,    31,    -1,    72,    41,    -1,
+      16,    25,    79,    31,    -1,    16,    79,    31,    -1,    17,
+      79,    31,    -1,    -1,    75,    78,    -1,    26,    -1,    27,
+      -1,     5,    31,    -1,     8,    31,    -1,    15,    31,    -1,
+      31,    -1,    77,    31,    -1,    -1,    14,    79,    -1,    80,
+      -1,    80,    34,    80,    -1,    80,    28,    80,    -1,    30,
+      79,    29,    -1,    35,    79,    -1,    79,    32,    79,    -1,
+      79,    33,    79,    -1,    26,    -1,    27,    -1
+};
+
+/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
+static const unsigned short int yyrline[] =
+{
+       0,   105,   105,   107,   109,   110,   111,   112,   113,   114,
+     115,   119,   123,   123,   123,   123,   123,   123,   123,   127,
+     128,   129,   130,   131,   132,   136,   137,   143,   151,   157,
+     165,   175,   177,   178,   179,   180,   181,   182,   185,   193,
+     199,   209,   215,   221,   224,   226,   237,   238,   243,   252,
+     257,   265,   268,   270,   271,   272,   273,   274,   277,   283,
+     294,   300,   310,   312,   317,   325,   333,   336,   338,   339,
+     340,   345,   352,   357,   365,   368,   370,   371,   372,   375,
+     383,   390,   397,   403,   410,   412,   413,   414,   417,   422,
+     427,   435,   437,   442,   443,   446,   447,   448,   452,   453,
+     456,   457,   460,   461,   462,   463,   464,   465,   466,   469,
+     470
+};
+#endif
+
+#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
+/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
+   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+static const char *const yytname[] =
+{
+  "$end", "error", "$undefined", "T_MAINMENU", "T_MENU", "T_ENDMENU",
+  "T_SOURCE", "T_CHOICE", "T_ENDCHOICE", "T_COMMENT", "T_CONFIG",
+  "T_MENUCONFIG", "T_HELP", "T_HELPTEXT", "T_IF", "T_ENDIF", "T_DEPENDS",
+  "T_REQUIRES", "T_OPTIONAL", "T_PROMPT", "T_TYPE", "T_DEFAULT",
+  "T_SELECT", "T_RANGE", "T_OPTION", "T_ON", "T_WORD", "T_WORD_QUOTE",
+  "T_UNEQUAL", "T_CLOSE_PAREN", "T_OPEN_PAREN", "T_EOL", "T_OR", "T_AND",
+  "T_EQUAL", "T_NOT", "$accept", "input", "stmt_list", "option_name",
+  "common_stmt", "option_error", "config_entry_start", "config_stmt",
+  "menuconfig_entry_start", "menuconfig_stmt", "config_option_list",
+  "config_option", "symbol_option", "symbol_option_list",
+  "symbol_option_arg", "choice", "choice_entry", "choice_end",
+  "choice_stmt", "choice_option_list", "choice_option", "choice_block",
+  "if_entry", "if_end", "if_stmt", "if_block", "menu", "menu_entry",
+  "menu_end", "menu_stmt", "menu_block", "source_stmt", "comment",
+  "comment_stmt", "help_start", "help", "depends_list", "depends",
+  "prompt_stmt_opt", "prompt", "end", "nl", "if_expr", "expr", "symbol", 0
+};
+#endif
+
+# ifdef YYPRINT
+/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
+   token YYLEX-NUM.  */
+static const unsigned short int yytoknum[] =
+{
+       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
+     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
+     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
+     285,   286,   287,   288,   289,   290
+};
+# endif
+
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
+static const unsigned char yyr1[] =
+{
+       0,    36,    37,    38,    38,    38,    38,    38,    38,    38,
+      38,    38,    39,    39,    39,    39,    39,    39,    39,    40,
+      40,    40,    40,    40,    40,    41,    41,    42,    43,    44,
+      45,    46,    46,    46,    46,    46,    46,    46,    47,    47,
+      47,    47,    47,    48,    49,    49,    50,    50,    51,    52,
+      53,    54,    55,    55,    55,    55,    55,    55,    56,    56,
+      56,    56,    57,    57,    58,    59,    60,    61,    61,    61,
+      61,    62,    63,    64,    65,    66,    66,    66,    66,    67,
+      68,    69,    70,    71,    72,    72,    72,    72,    73,    73,
+      73,    74,    74,    75,    75,    76,    76,    76,    77,    77,
+      78,    78,    79,    79,    79,    79,    79,    79,    79,    80,
+      80
+};
+
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
+static const unsigned char yyr2[] =
+{
+       0,     2,     1,     0,     2,     2,     2,     4,     2,     4,
+       4,     3,     1,     1,     1,     1,     1,     1,     1,     1,
+       1,     1,     1,     1,     1,     3,     2,     3,     2,     3,
+       2,     0,     2,     2,     2,     2,     2,     2,     3,     4,
+       4,     4,     5,     3,     0,     3,     0,     2,     2,     2,
+       1,     3,     0,     2,     2,     2,     2,     2,     4,     3,
+       2,     4,     0,     2,     3,     1,     3,     0,     2,     2,
+       2,     3,     2,     1,     3,     0,     2,     2,     2,     3,
+       3,     2,     2,     2,     0,     2,     2,     2,     4,     3,
+       3,     0,     2,     1,     1,     2,     2,     2,     1,     2,
+       0,     2,     1,     3,     3,     3,     2,     3,     3,     1,
+       1
+};
+
+/* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
+   STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
+   means the default is an error.  */
+static const unsigned char yydefact[] =
+{
+       3,     0,     0,     1,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,     0,    12,    16,    13,    14,
+      18,    15,    17,     0,    19,     0,     4,    31,    22,    31,
+      23,    52,    62,     5,    67,    20,    84,    75,     6,    24,
+      84,    21,     8,    11,    93,    94,     0,     0,    95,     0,
+      48,    96,     0,     0,     0,   109,   110,     0,     0,     0,
+     102,    97,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,    98,     7,    71,    79,    80,    27,    29,     0,
+     106,     0,     0,    64,     0,     0,     9,    10,     0,     0,
+       0,     0,     0,    91,     0,     0,     0,    44,     0,    37,
+      36,    32,    33,     0,    35,    34,     0,     0,    91,     0,
+      56,    57,    53,    55,    54,    63,    51,    50,    68,    70,
+      66,    69,    65,    86,    87,    85,    76,    78,    74,    77,
+      73,    99,   105,   107,   108,   104,   103,    26,    82,     0,
+       0,     0,   100,     0,   100,   100,   100,     0,     0,     0,
+      83,    60,   100,     0,   100,     0,    89,    90,     0,     0,
+      38,    92,     0,     0,   100,    46,    43,    25,     0,    59,
+       0,    88,   101,    39,    40,    41,     0,     0,    45,    58,
+      61,    42,    47
+};
+
+/* YYDEFGOTO[NTERM-NUM]. */
+static const short int yydefgoto[] =
+{
+      -1,     1,     2,    25,    26,   100,    27,    28,    29,    30,
+      64,   101,   102,   148,   178,    31,    32,   116,    33,    66,
+     112,    67,    34,   120,    35,    68,    36,    37,   128,    38,
+      70,    39,    40,    41,   103,   104,    69,   105,   143,   144,
+      42,    73,   159,    59,    60
+};
+
+/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
+   STATE-NUM.  */
+#define YYPACT_NINF -135
+static const short int yypact[] =
+{
+    -135,     2,   170,  -135,   -14,    56,    56,    -8,    56,    24,
+      67,    56,     7,    14,    62,    97,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,   156,  -135,   166,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,   138,   151,  -135,   152,
+    -135,  -135,   163,   167,   176,  -135,  -135,    62,    62,   185,
+     -19,  -135,   188,   190,    42,   103,   194,    85,    70,   222,
+      70,   132,  -135,   191,  -135,  -135,  -135,  -135,  -135,   127,
+    -135,    62,    62,   191,   104,   104,  -135,  -135,   193,   203,
+       9,    62,    56,    56,    62,   161,   104,  -135,   196,  -135,
+    -135,  -135,  -135,   233,  -135,  -135,   204,    56,    56,   221,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,
+    -135,  -135,  -135,   219,  -135,  -135,  -135,  -135,  -135,    62,
+     209,   212,   240,   224,   240,    -1,   240,   104,    41,   225,
+    -135,  -135,   240,   226,   240,   218,  -135,  -135,    62,   227,
+    -135,  -135,   228,   229,   240,   230,  -135,  -135,   231,  -135,
+     232,  -135,   112,  -135,  -135,  -135,   234,    56,  -135,  -135,
+    -135,  -135,  -135
+};
+
+/* YYPGOTO[NTERM-NUM].  */
+static const short int yypgoto[] =
+{
+    -135,  -135,  -135,  -135,    94,   -45,  -135,  -135,  -135,  -135,
+     237,  -135,  -135,  -135,  -135,  -135,  -135,  -135,   -54,  -135,
+    -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,  -135,     1,
+    -135,  -135,  -135,  -135,  -135,   195,   235,   -44,   159,    -5,
+      98,   210,  -134,   -53,   -77
+};
+
+/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
+   positive, shift that token.  If negative, reduce the rule which
+   number is the opposite.  If zero, do what YYDEFACT says.
+   If YYTABLE_NINF, syntax error.  */
+#define YYTABLE_NINF -82
+static const short int yytable[] =
+{
+      46,    47,     3,    49,    79,    80,    52,   135,   136,    84,
+     161,   162,   163,   158,   119,    85,   127,    43,   168,   147,
+     170,   111,   114,    48,   124,   125,   124,   125,   133,   134,
+     176,    81,    82,    53,   139,    55,    56,   140,   141,    57,
+      54,   145,   -28,    88,    58,   -28,   -28,   -28,   -28,   -28,
+     -28,   -28,   -28,   -28,    89,    50,   -28,   -28,    90,    91,
+     -28,    92,    93,    94,    95,    96,    97,   165,    98,   121,
+     164,   129,   166,    99,     6,     7,     8,     9,    10,    11,
+      12,    13,    44,    45,    14,    15,   155,   142,    55,    56,
+       7,     8,    57,    10,    11,    12,    13,    58,    51,    14,
+      15,    24,   152,   -30,    88,   172,   -30,   -30,   -30,   -30,
+     -30,   -30,   -30,   -30,   -30,    89,    24,   -30,   -30,    90,
+      91,   -30,    92,    93,    94,    95,    96,    97,    61,    98,
+      55,    56,   -81,    88,    99,   -81,   -81,   -81,   -81,   -81,
+     -81,   -81,   -81,   -81,    81,    82,   -81,   -81,    90,    91,
+     -81,   -81,   -81,   -81,   -81,   -81,   132,    62,    98,    81,
+      82,   115,   118,   123,   126,   117,   122,    63,   130,    72,
+      -2,     4,   182,     5,     6,     7,     8,     9,    10,    11,
+      12,    13,    74,    75,    14,    15,    16,   146,    17,    18,
+      19,    20,    21,    22,    76,    88,    23,   149,    77,   -49,
+     -49,    24,   -49,   -49,   -49,   -49,    89,    78,   -49,   -49,
+      90,    91,   106,   107,   108,   109,    72,    81,    82,    86,
+      98,    87,   131,    88,   137,   110,   -72,   -72,   -72,   -72,
+     -72,   -72,   -72,   -72,   138,   151,   -72,   -72,    90,    91,
+     156,    81,    82,   157,    81,    82,   150,   154,    98,   171,
+      81,    82,    82,   123,   158,   160,   167,   169,   173,   174,
+     175,   113,   179,   180,   177,   181,    65,   153,     0,    83,
+       0,     0,     0,     0,     0,    71
+};
+
+static const short int yycheck[] =
+{
+       5,     6,     0,     8,    57,    58,    11,    84,    85,    28,
+     144,   145,   146,    14,    68,    34,    70,    31,   152,    96,
+     154,    66,    66,    31,    69,    69,    71,    71,    81,    82,
+     164,    32,    33,    26,    25,    26,    27,    90,    91,    30,
+      26,    94,     0,     1,    35,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    12,    31,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    24,    26,    26,    68,
+     147,    70,    31,    31,     4,     5,     6,     7,     8,     9,
+      10,    11,    26,    27,    14,    15,   139,    92,    26,    27,
+       5,     6,    30,     8,     9,    10,    11,    35,    31,    14,
+      15,    31,   107,     0,     1,   158,     3,     4,     5,     6,
+       7,     8,     9,    10,    11,    12,    31,    14,    15,    16,
+      17,    18,    19,    20,    21,    22,    23,    24,    31,    26,
+      26,    27,     0,     1,    31,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    32,    33,    14,    15,    16,    17,
+      18,    19,    20,    21,    22,    23,    29,     1,    26,    32,
+      33,    67,    68,    31,    70,    67,    68,     1,    70,    31,
+       0,     1,   177,     3,     4,     5,     6,     7,     8,     9,
+      10,    11,    31,    31,    14,    15,    16,    26,    18,    19,
+      20,    21,    22,    23,    31,     1,    26,     1,    31,     5,
+       6,    31,     8,     9,    10,    11,    12,    31,    14,    15,
+      16,    17,    18,    19,    20,    21,    31,    32,    33,    31,
+      26,    31,    31,     1,    31,    31,     4,     5,     6,     7,
+       8,     9,    10,    11,    31,    31,    14,    15,    16,    17,
+      31,    32,    33,    31,    32,    33,    13,    26,    26,    31,
+      32,    33,    33,    31,    14,    31,    31,    31,    31,    31,
+      31,    66,    31,    31,    34,    31,    29,   108,    -1,    59,
+      -1,    -1,    -1,    -1,    -1,    40
+};
+
+/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
+   symbol of state STATE-NUM.  */
+static const unsigned char yystos[] =
+{
+       0,    37,    38,     0,     1,     3,     4,     5,     6,     7,
+       8,     9,    10,    11,    14,    15,    16,    18,    19,    20,
+      21,    22,    23,    26,    31,    39,    40,    42,    43,    44,
+      45,    51,    52,    54,    58,    60,    62,    63,    65,    67,
+      68,    69,    76,    31,    26,    27,    75,    75,    31,    75,
+      31,    31,    75,    26,    26,    26,    27,    30,    35,    79,
+      80,    31,     1,     1,    46,    46,    55,    57,    61,    72,
+      66,    72,    31,    77,    31,    31,    31,    31,    31,    79,
+      79,    32,    33,    77,    28,    34,    31,    31,     1,    12,
+      16,    17,    19,    20,    21,    22,    23,    24,    26,    31,
+      41,    47,    48,    70,    71,    73,    18,    19,    20,    21,
+      31,    41,    56,    71,    73,    40,    53,    76,    40,    54,
+      59,    65,    76,    31,    41,    73,    40,    54,    64,    65,
+      76,    31,    29,    79,    79,    80,    80,    31,    31,    25,
+      79,    79,    75,    74,    75,    79,    26,    80,    49,     1,
+      13,    31,    75,    74,    26,    79,    31,    31,    14,    78,
+      31,    78,    78,    78,    80,    26,    31,    31,    78,    31,
+      78,    31,    79,    31,    31,    31,    78,    34,    50,    31,
+      31,    31,    75
+};
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		(-2)
+#define YYEOF		0
+
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT		goto yyabortlab
+#define YYERROR		goto yyerrorlab
+
+
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+
+#define YYFAIL		goto yyerrlab
+
+#define YYRECOVERING()  (!!yyerrstatus)
+
+#define YYBACKUP(Token, Value)					\
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
+      yytoken = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    {								\
+      yyerror (YY_("syntax error: cannot back up")); \
+      YYERROR;							\
+    }								\
+while (0)
+
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+
+/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
+   If N is 0, then set CURRENT to the empty location which ends
+   the previous symbol: RHS[0] (always defined).  */
+
+#define YYRHSLOC(Rhs, K) ((Rhs)[K])
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)				\
+    do									\
+      if (N)								\
+	{								\
+	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
+	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
+	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
+	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
+	}								\
+      else								\
+	{								\
+	  (Current).first_line   = (Current).last_line   =		\
+	    YYRHSLOC (Rhs, 0).last_line;				\
+	  (Current).first_column = (Current).last_column =		\
+	    YYRHSLOC (Rhs, 0).last_column;				\
+	}								\
+    while (0)
+#endif
+
+
+/* YY_LOCATION_PRINT -- Print the location on the stream.
+   This macro was not mandated originally: define only if we know
+   we won't break user code: when these are the locations we know.  */
+
+#ifndef YY_LOCATION_PRINT
+# if YYLTYPE_IS_TRIVIAL
+#  define YY_LOCATION_PRINT(File, Loc)			\
+     fprintf (File, "%d.%d-%d.%d",			\
+              (Loc).first_line, (Loc).first_column,	\
+              (Loc).last_line,  (Loc).last_column)
+# else
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#ifdef YYLEX_PARAM
+# define YYLEX yylex (YYLEX_PARAM)
+#else
+# define YYLEX yylex ()
+#endif
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
+do {								\
+  if (yydebug)							\
+    {								\
+      YYFPRINTF (stderr, "%s ", Title);				\
+      yysymprint (stderr,					\
+                  Type, Value);	\
+      YYFPRINTF (stderr, "\n");					\
+    }								\
+} while (0)
+
+/*------------------------------------------------------------------.
+| yy_stack_print -- Print the state stack from its BOTTOM up to its |
+| TOP (included).                                                   |
+`------------------------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_stack_print (short int *bottom, short int *top)
+#else
+static void
+yy_stack_print (bottom, top)
+    short int *bottom;
+    short int *top;
+#endif
+{
+  YYFPRINTF (stderr, "Stack now");
+  for (/* Nothing. */; bottom <= top; ++bottom)
+    YYFPRINTF (stderr, " %d", *bottom);
+  YYFPRINTF (stderr, "\n");
+}
+
+# define YY_STACK_PRINT(Bottom, Top)				\
+do {								\
+  if (yydebug)							\
+    yy_stack_print ((Bottom), (Top));				\
+} while (0)
+
+
+/*------------------------------------------------.
+| Report that the YYRULE is going to be reduced.  |
+`------------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yy_reduce_print (int yyrule)
+#else
+static void
+yy_reduce_print (yyrule)
+    int yyrule;
+#endif
+{
+  int yyi;
+  unsigned long int yylno = yyrline[yyrule];
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
+             yyrule - 1, yylno);
+  /* Print the symbols being reduced, and their result.  */
+  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
+    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
+}
+
+# define YY_REDUCE_PRINT(Rule)		\
+do {					\
+  if (yydebug)				\
+    yy_reduce_print (Rule);		\
+} while (0)
+
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YY_STACK_PRINT(Bottom, Top)
+# define YY_REDUCE_PRINT(Rule)
+#endif /* !YYDEBUG */
+
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
+#ifndef	YYINITDEPTH
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
+
+#ifndef YYMAXDEPTH
+# define YYMAXDEPTH 10000
+#endif
+
+
+
+#if YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
+}
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  char *yyd = yydest;
+  const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
+}
+#  endif
+# endif
+
+# ifndef yytnamerr
+/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
+   quotes and backslashes, so that it's suitable for yyerror.  The
+   heuristic is that double-quoting is unnecessary unless the string
+   contains an apostrophe, a comma, or backslash (other than
+   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
+   null, do not copy; instead, return the length of what the result
+   would have been.  */
+static YYSIZE_T
+yytnamerr (char *yyres, const char *yystr)
+{
+  if (*yystr == '"')
+    {
+      size_t yyn = 0;
+      char const *yyp = yystr;
+
+      for (;;)
+	switch (*++yyp)
+	  {
+	  case '\'':
+	  case ',':
+	    goto do_not_strip_quotes;
+
+	  case '\\':
+	    if (*++yyp != '\\')
+	      goto do_not_strip_quotes;
+	    /* Fall through.  */
+	  default:
+	    if (yyres)
+	      yyres[yyn] = *yyp;
+	    yyn++;
+	    break;
+
+	  case '"':
+	    if (yyres)
+	      yyres[yyn] = '\0';
+	    return yyn;
+	  }
+    do_not_strip_quotes: ;
+    }
+
+  if (! yyres)
+    return yystrlen (yystr);
+
+  return yystpcpy (yyres, yystr) - yyres;
+}
+# endif
+
+#endif /* YYERROR_VERBOSE */
+
+
+
+#if YYDEBUG
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yysymprint (yyoutput, yytype, yyvaluep)
+    FILE *yyoutput;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# endif
+  switch (yytype)
+    {
+      default:
+        break;
+    }
+  YYFPRINTF (yyoutput, ")");
+}
+
+#endif /* ! YYDEBUG */
+/*-----------------------------------------------.
+| Release the memory associated to this symbol.  |
+`-----------------------------------------------*/
+
+#if defined (__STDC__) || defined (__cplusplus)
+static void
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
+#else
+static void
+yydestruct (yymsg, yytype, yyvaluep)
+    const char *yymsg;
+    int yytype;
+    YYSTYPE *yyvaluep;
+#endif
+{
+  /* Pacify ``unused variable'' warnings.  */
+  (void) yyvaluep;
+
+  if (!yymsg)
+    yymsg = "Deleting";
+  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+
+  switch (yytype)
+    {
+      case 52: /* "choice_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+      case 58: /* "if_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+      case 63: /* "menu_entry" */
+
+        {
+	fprintf(stderr, "%s:%d: missing end statement for this entry\n",
+		(yyvaluep->menu)->file->name, (yyvaluep->menu)->lineno);
+	if (current_menu == (yyvaluep->menu))
+		menu_end_menu();
+};
+
+        break;
+
+      default:
+        break;
+    }
+}
+
+
+/* Prevent warnings from -Wmissing-prototypes.  */
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM);
+# else
+int yyparse ();
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void);
+#else
+int yyparse ();
+#endif
+#endif /* ! YYPARSE_PARAM */
+
+
+
+/* The look-ahead symbol.  */
+int yychar;
+
+/* The semantic value of the look-ahead symbol.  */
+YYSTYPE yylval;
+
+/* Number of syntax errors so far.  */
+int yynerrs;
+
+
+
+/*----------.
+| yyparse.  |
+`----------*/
+
+#ifdef YYPARSE_PARAM
+# if defined (__STDC__) || defined (__cplusplus)
+int yyparse (void *YYPARSE_PARAM)
+# else
+int yyparse (YYPARSE_PARAM)
+  void *YYPARSE_PARAM;
+# endif
+#else /* ! YYPARSE_PARAM */
+#if defined (__STDC__) || defined (__cplusplus)
+int
+yyparse (void)
+#else
+int
+yyparse ()
+    ;
+#endif
+#endif
+{
+  
+  int yystate;
+  int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Look-ahead token as an internal (translated) token number.  */
+  int yytoken = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack.  */
+  short int yyssa[YYINITDEPTH];
+  short int *yyss = yyssa;
+  short int *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
+  YYSTYPE *yyvsp;
+
+
+
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule.  */
+  int yylen;
+
+  YYDPRINTF ((stderr, "Starting parse\n"));
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss;
+  yyvsp = yyvs;
+
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
+
+  if (yyss + yystacksize - 1 <= yyssp)
+    {
+      /* Get the current used size of the three stacks, in elements.  */
+      YYSIZE_T yysize = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short int *yyss1 = yyss;
+
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  This used to be a
+	   conditional around just the two extra args, but that might
+	   be undefined if yyoverflow is a macro.  */
+	yyoverflow (YY_("memory exhausted"),
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+
+		    &yystacksize);
+
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
+#else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyexhaustedlab;
+# else
+      /* Extend the stack our own way.  */
+      if (YYMAXDEPTH <= yystacksize)
+	goto yyexhaustedlab;
+      yystacksize *= 2;
+      if (YYMAXDEPTH < yystacksize)
+	yystacksize = YYMAXDEPTH;
+
+      {
+	short int *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyexhaustedlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+
+#  undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
+
+      if (yyss + yystacksize - 1 <= yyssp)
+	YYABORT;
+    }
+
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
+
+  goto yybackup;
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a look-ahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to look-ahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYPACT_NINF)
+    goto yydefault;
+
+  /* Not known => get a look-ahead token if don't already have one.  */
+
+  /* YYCHAR is either YYEMPTY or YYEOF or a valid look-ahead symbol.  */
+  if (yychar == YYEMPTY)
+    {
+      YYDPRINTF ((stderr, "Reading a token: "));
+      yychar = YYLEX;
+    }
+
+  if (yychar <= YYEOF)
+    {
+      yychar = yytoken = YYEOF;
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
+    }
+  else
+    {
+      yytoken = YYTRANSLATE (yychar);
+      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
+    }
+
+  /* If the proper action on seeing token YYTOKEN is to reduce or to
+     detect an error, take that action.  */
+  yyn += yytoken;
+  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
+    goto yydefault;
+  yyn = yytable[yyn];
+  if (yyn <= 0)
+    {
+      if (yyn == 0 || yyn == YYTABLE_NINF)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the look-ahead token.  */
+  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+
+
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
+yydefault:
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
+yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
+  yylen = yyr2[yyn];
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to garbage.
+     This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+
+  YY_REDUCE_PRINT (yyn);
+  switch (yyn)
+    {
+        case 8:
+
+    { zconf_error("unexpected end statement"); ;}
+    break;
+
+  case 9:
+
+    { zconf_error("unknown statement \"%s\"", (yyvsp[-2].string)); ;}
+    break;
+
+  case 10:
+
+    {
+	zconf_error("unexpected option \"%s\"", kconf_id_strings + (yyvsp[-2].id)->name);
+;}
+    break;
+
+  case 11:
+
+    { zconf_error("invalid statement"); ;}
+    break;
+
+  case 25:
+
+    { zconf_error("unknown option \"%s\"", (yyvsp[-2].string)); ;}
+    break;
+
+  case 26:
+
+    { zconf_error("invalid option"); ;}
+    break;
+
+  case 27:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[-1].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:config %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+;}
+    break;
+
+  case 28:
+
+    {
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 29:
+
+    {
+	struct symbol *sym = sym_lookup((yyvsp[-1].string), 0);
+	sym->flags |= SYMBOL_OPTIONAL;
+	menu_add_entry(sym);
+	printd(DEBUG_PARSE, "%s:%d:menuconfig %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+;}
+    break;
+
+  case 30:
+
+    {
+	if (current_entry->prompt)
+		current_entry->prompt->type = P_MENU;
+	else
+		zconfprint("warning: menuconfig statement without prompt");
+	menu_end_entry();
+	printd(DEBUG_PARSE, "%s:%d:endconfig\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 38:
+
+    {
+	menu_set_type((yyvsp[-2].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[-2].id)->stype);
+;}
+    break;
+
+  case 39:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-2].string), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 40:
+
+    {
+	menu_add_expr(P_DEFAULT, (yyvsp[-2].expr), (yyvsp[-1].expr));
+	if ((yyvsp[-3].id)->stype != S_UNKNOWN)
+		menu_set_type((yyvsp[-3].id)->stype);
+	printd(DEBUG_PARSE, "%s:%d:default(%u)\n",
+		zconf_curname(), zconf_lineno(),
+		(yyvsp[-3].id)->stype);
+;}
+    break;
+
+  case 41:
+
+    {
+	menu_add_symbol(P_SELECT, sym_lookup((yyvsp[-2].string), 0), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:select\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 42:
+
+    {
+	menu_add_expr(P_RANGE, expr_alloc_comp(E_RANGE,(yyvsp[-3].symbol), (yyvsp[-2].symbol)), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:range\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 45:
+
+    {
+	struct kconf_id *id = kconf_id_lookup((yyvsp[-1].string), strlen((yyvsp[-1].string)));
+	if (id && id->flags & TF_OPTION)
+		menu_add_option(id->token, (yyvsp[0].string));
+	else
+		zconfprint("warning: ignoring unknown option %s", (yyvsp[-1].string));
+	free((yyvsp[-1].string));
+;}
+    break;
+
+  case 46:
+
+    { (yyval.string) = NULL; ;}
+    break;
+
+  case 47:
+
+    { (yyval.string) = (yyvsp[0].string); ;}
+    break;
+
+  case 48:
+
+    {
+	struct symbol *sym = sym_lookup(NULL, 0);
+	sym->flags |= SYMBOL_CHOICE;
+	menu_add_entry(sym);
+	menu_add_expr(P_CHOICE, NULL, NULL);
+	printd(DEBUG_PARSE, "%s:%d:choice\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 49:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 50:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_CHOICE, T_ENDCHOICE)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endchoice\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 58:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-2].string), (yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:prompt\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 59:
+
+    {
+	if ((yyvsp[-2].id)->stype == S_BOOLEAN || (yyvsp[-2].id)->stype == S_TRISTATE) {
+		menu_set_type((yyvsp[-2].id)->stype);
+		printd(DEBUG_PARSE, "%s:%d:type(%u)\n",
+			zconf_curname(), zconf_lineno(),
+			(yyvsp[-2].id)->stype);
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 60:
+
+    {
+	current_entry->sym->flags |= SYMBOL_OPTIONAL;
+	printd(DEBUG_PARSE, "%s:%d:optional\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 61:
+
+    {
+	if ((yyvsp[-3].id)->stype == S_UNKNOWN) {
+		menu_add_symbol(P_DEFAULT, sym_lookup((yyvsp[-2].string), 0), (yyvsp[-1].expr));
+		printd(DEBUG_PARSE, "%s:%d:default\n",
+			zconf_curname(), zconf_lineno());
+	} else
+		YYERROR;
+;}
+    break;
+
+  case 64:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:if\n", zconf_curname(), zconf_lineno());
+	menu_add_entry(NULL);
+	menu_add_dep((yyvsp[-1].expr));
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 65:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_IF, T_ENDIF)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endif\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 71:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_MENU, (yyvsp[-1].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:menu\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 72:
+
+    {
+	(yyval.menu) = menu_add_menu();
+;}
+    break;
+
+  case 73:
+
+    {
+	if (zconf_endtoken((yyvsp[0].id), T_MENU, T_ENDMENU)) {
+		menu_end_menu();
+		printd(DEBUG_PARSE, "%s:%d:endmenu\n", zconf_curname(), zconf_lineno());
+	}
+;}
+    break;
+
+  case 79:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:source %s\n", zconf_curname(), zconf_lineno(), (yyvsp[-1].string));
+	zconf_nextfile((yyvsp[-1].string));
+;}
+    break;
+
+  case 80:
+
+    {
+	menu_add_entry(NULL);
+	menu_add_prompt(P_COMMENT, (yyvsp[-1].string), NULL);
+	printd(DEBUG_PARSE, "%s:%d:comment\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 81:
+
+    {
+	menu_end_entry();
+;}
+    break;
+
+  case 82:
+
+    {
+	printd(DEBUG_PARSE, "%s:%d:help\n", zconf_curname(), zconf_lineno());
+	zconf_starthelp();
+;}
+    break;
+
+  case 83:
+
+    {
+	current_entry->sym->help = (yyvsp[0].string);
+;}
+    break;
+
+  case 88:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends on\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 89:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:depends\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 90:
+
+    {
+	menu_add_dep((yyvsp[-1].expr));
+	printd(DEBUG_PARSE, "%s:%d:requires\n", zconf_curname(), zconf_lineno());
+;}
+    break;
+
+  case 92:
+
+    {
+	menu_add_prompt(P_PROMPT, (yyvsp[-1].string), (yyvsp[0].expr));
+;}
+    break;
+
+  case 95:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 96:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 97:
+
+    { (yyval.id) = (yyvsp[-1].id); ;}
+    break;
+
+  case 100:
+
+    { (yyval.expr) = NULL; ;}
+    break;
+
+  case 101:
+
+    { (yyval.expr) = (yyvsp[0].expr); ;}
+    break;
+
+  case 102:
+
+    { (yyval.expr) = expr_alloc_symbol((yyvsp[0].symbol)); ;}
+    break;
+
+  case 103:
+
+    { (yyval.expr) = expr_alloc_comp(E_EQUAL, (yyvsp[-2].symbol), (yyvsp[0].symbol)); ;}
+    break;
+
+  case 104:
+
+    { (yyval.expr) = expr_alloc_comp(E_UNEQUAL, (yyvsp[-2].symbol), (yyvsp[0].symbol)); ;}
+    break;
+
+  case 105:
+
+    { (yyval.expr) = (yyvsp[-1].expr); ;}
+    break;
+
+  case 106:
+
+    { (yyval.expr) = expr_alloc_one(E_NOT, (yyvsp[0].expr)); ;}
+    break;
+
+  case 107:
+
+    { (yyval.expr) = expr_alloc_two(E_OR, (yyvsp[-2].expr), (yyvsp[0].expr)); ;}
+    break;
+
+  case 108:
+
+    { (yyval.expr) = expr_alloc_two(E_AND, (yyvsp[-2].expr), (yyvsp[0].expr)); ;}
+    break;
+
+  case 109:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[0].string), 0); free((yyvsp[0].string)); ;}
+    break;
+
+  case 110:
+
+    { (yyval.symbol) = sym_lookup((yyvsp[0].string), 1); free((yyvsp[0].string)); ;}
+    break;
+
+
+      default: break;
+    }
+
+/* Line 1126 of yacc.c.  */
+
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+
+
+  YY_STACK_PRINT (yyss, yyssp);
+
+  *++yyvsp = yyval;
+
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
+  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTOKENS];
+
+  goto yynewstate;
+
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
+    {
+      ++yynerrs;
+#if YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (YYPACT_NINF < yyn && yyn < YYLAST)
+	{
+	  int yytype = YYTRANSLATE (yychar);
+	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+	  YYSIZE_T yysize = yysize0;
+	  YYSIZE_T yysize1;
+	  int yysize_overflow = 0;
+	  char *yymsg = 0;
+#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
+	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+	  int yyx;
+
+#if 0
+	  /* This is so xgettext sees the translatable formats that are
+	     constructed on the fly.  */
+	  YY_("syntax error, unexpected %s");
+	  YY_("syntax error, unexpected %s, expecting %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+#endif
+	  char *yyfmt;
+	  char const *yyf;
+	  static char const yyunexpected[] = "syntax error, unexpected %s";
+	  static char const yyexpecting[] = ", expecting %s";
+	  static char const yyor[] = " or %s";
+	  char yyformat[sizeof yyunexpected
+			+ sizeof yyexpecting - 1
+			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+			   * (sizeof yyor - 1))];
+	  char const *yyprefix = yyexpecting;
+
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  int yyxbegin = yyn < 0 ? -yyn : 0;
+
+	  /* Stay within bounds of both yycheck and yytname.  */
+	  int yychecklim = YYLAST - yyn;
+	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+	  int yycount = 1;
+
+	  yyarg[0] = yytname[yytype];
+	  yyfmt = yystpcpy (yyformat, yyunexpected);
+
+	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	      {
+		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+		  {
+		    yycount = 1;
+		    yysize = yysize0;
+		    yyformat[sizeof yyunexpected - 1] = '\0';
+		    break;
+		  }
+		yyarg[yycount++] = yytname[yyx];
+		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+		yysize_overflow |= yysize1 < yysize;
+		yysize = yysize1;
+		yyfmt = yystpcpy (yyfmt, yyprefix);
+		yyprefix = yyor;
+	      }
+
+	  yyf = YY_(yyformat);
+	  yysize1 = yysize + yystrlen (yyf);
+	  yysize_overflow |= yysize1 < yysize;
+	  yysize = yysize1;
+
+	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
+	    yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg)
+	    {
+	      /* Avoid sprintf, as that infringes on the user's name space.
+		 Don't have undefined behavior even if the translation
+		 produced a string with the wrong number of "%s"s.  */
+	      char *yyp = yymsg;
+	      int yyi = 0;
+	      while ((*yyp = *yyf))
+		{
+		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		    {
+		      yyp += yytnamerr (yyp, yyarg[yyi++]);
+		      yyf += 2;
+		    }
+		  else
+		    {
+		      yyp++;
+		      yyf++;
+		    }
+		}
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
+	    }
+	  else
+	    {
+	      yyerror (YY_("syntax error"));
+	      goto yyexhaustedlab;
+	    }
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror (YY_("syntax error"));
+    }
+
+
+
+  if (yyerrstatus == 3)
+    {
+      /* If just tried and failed to reuse look-ahead token after an
+	 error, discard it.  */
+
+      if (yychar <= YYEOF)
+        {
+	  /* Return failure if at end of input.  */
+	  if (yychar == YYEOF)
+	    YYABORT;
+        }
+      else
+	{
+	  yydestruct ("Error: discarding", yytoken, &yylval);
+	  yychar = YYEMPTY;
+	}
+    }
+
+  /* Else will try to reuse look-ahead token after shifting the error
+     token.  */
+  goto yyerrlab1;
+
+
+/*---------------------------------------------------.
+| yyerrorlab -- error raised explicitly by YYERROR.  |
+`---------------------------------------------------*/
+yyerrorlab:
+
+  /* Pacify compilers like GCC when the user code never invokes
+     YYERROR and the label yyerrorlab therefore never appears in user
+     code.  */
+  if (0)
+     goto yyerrorlab;
+
+yyvsp -= yylen;
+  yyssp -= yylen;
+  yystate = *yyssp;
+  goto yyerrlab1;
+
+
+/*-------------------------------------------------------------.
+| yyerrlab1 -- common code for both syntax error and YYERROR.  |
+`-------------------------------------------------------------*/
+yyerrlab1:
+  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
+
+  for (;;)
+    {
+      yyn = yypact[yystate];
+      if (yyn != YYPACT_NINF)
+	{
+	  yyn += YYTERROR;
+	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+	    {
+	      yyn = yytable[yyn];
+	      if (0 < yyn)
+		break;
+	    }
+	}
+
+      /* Pop the current state because it cannot handle the error token.  */
+      if (yyssp == yyss)
+	YYABORT;
+
+
+      yydestruct ("Error: popping", yystos[yystate], yyvsp);
+      YYPOPSTACK;
+      yystate = *yyssp;
+      YY_STACK_PRINT (yyss, yyssp);
+    }
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  *++yyvsp = yylval;
+
+
+  /* Shift the error token. */
+  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+
+  yystate = yyn;
+  goto yynewstate;
+
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+#ifndef yyoverflow
+/*-------------------------------------------------.
+| yyexhaustedlab -- memory exhaustion comes here.  |
+`-------------------------------------------------*/
+yyexhaustedlab:
+  yyerror (YY_("memory exhausted"));
+  yyresult = 2;
+  /* Fall through.  */
+#endif
+
+yyreturn:
+  if (yychar != YYEOF && yychar != YYEMPTY)
+     yydestruct ("Cleanup: discarding lookahead",
+		 yytoken, &yylval);
+  while (yyssp != yyss)
+    {
+      yydestruct ("Cleanup: popping",
+		  yystos[*yyssp], yyvsp);
+      YYPOPSTACK;
+    }
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
+}
+
+
+
+
+
+void conf_parse(const char *name)
+{
+	struct symbol *sym;
+	int i;
+
+	zconf_initscan(name);
+
+	sym_init();
+	menu_init();
+	modules_sym = sym_lookup(NULL, 0);
+	modules_sym->type = S_BOOLEAN;
+	modules_sym->flags |= SYMBOL_AUTO;
+	rootmenu.prompt = menu_add_prompt(P_MENU, "Linux Kernel Configuration", NULL);
+
+#if YYDEBUG
+	if (getenv("ZCONF_DEBUG"))
+		zconfdebug = 1;
+#endif
+	zconfparse();
+	if (zconfnerrs)
+		exit(1);
+	if (!modules_sym->prop) {
+		struct property *prop;
+
+		prop = prop_alloc(P_DEFAULT, modules_sym);
+		prop->expr = expr_alloc_symbol(sym_lookup("MODULES", 0));
+	}
+	menu_finalize(&rootmenu);
+	for_all_symbols(i, sym) {
+		sym_check_deps(sym);
+        }
+
+	sym_set_change_count(1);
+}
+
+const char *zconf_tokenname(int token)
+{
+	switch (token) {
+	case T_MENU:		return "menu";
+	case T_ENDMENU:		return "endmenu";
+	case T_CHOICE:		return "choice";
+	case T_ENDCHOICE:	return "endchoice";
+	case T_IF:		return "if";
+	case T_ENDIF:		return "endif";
+	case T_DEPENDS:		return "depends";
+	}
+	return "<token>";
+}
+
+static bool zconf_endtoken(struct kconf_id *id, int starttoken, int endtoken)
+{
+	if (id->token != endtoken) {
+		zconf_error("unexpected '%s' within %s block",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	if (current_menu->file != current_file) {
+		zconf_error("'%s' in different file than '%s'",
+			kconf_id_strings + id->name, zconf_tokenname(starttoken));
+		fprintf(stderr, "%s:%d: location of the '%s'\n",
+			current_menu->file->name, current_menu->lineno,
+			zconf_tokenname(starttoken));
+		zconfnerrs++;
+		return false;
+	}
+	return true;
+}
+
+static void zconfprint(const char *err, ...)
+{
+	va_list ap;
+
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconf_error(const char *err, ...)
+{
+	va_list ap;
+
+	zconfnerrs++;
+	fprintf(stderr, "%s:%d: ", zconf_curname(), zconf_lineno());
+	va_start(ap, err);
+	vfprintf(stderr, err, ap);
+	va_end(ap);
+	fprintf(stderr, "\n");
+}
+
+static void zconferror(const char *err)
+{
+#if YYDEBUG
+	fprintf(stderr, "%s:%d: %s\n", zconf_curname(), zconf_lineno() + 1, err);
+#endif
+}
+
+void print_quoted_string(FILE *out, const char *str)
+{
+	const char *p;
+	int len;
+
+	putc('"', out);
+	while ((p = strchr(str, '"'))) {
+		len = p - str;
+		if (len)
+			fprintf(out, "%.*s", len, str);
+		fputs("\\\"", out);
+		str = p + 1;
+	}
+	fputs(str, out);
+	putc('"', out);
+}
+
+void print_symbol(FILE *out, struct menu *menu)
+{
+	struct symbol *sym = menu->sym;
+	struct property *prop;
+
+	if (sym_is_choice(sym))
+		fprintf(out, "choice\n");
+	else
+		fprintf(out, "config %s\n", sym->name);
+	switch (sym->type) {
+	case S_BOOLEAN:
+		fputs("  boolean\n", out);
+		break;
+	case S_TRISTATE:
+		fputs("  tristate\n", out);
+		break;
+	case S_STRING:
+		fputs("  string\n", out);
+		break;
+	case S_INT:
+		fputs("  integer\n", out);
+		break;
+	case S_HEX:
+		fputs("  hex\n", out);
+		break;
+	default:
+		fputs("  ???\n", out);
+		break;
+	}
+	for (prop = sym->prop; prop; prop = prop->next) {
+		if (prop->menu != menu)
+			continue;
+		switch (prop->type) {
+		case P_PROMPT:
+			fputs("  prompt ", out);
+			print_quoted_string(out, prop->text);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_DEFAULT:
+			fputs( "  default ", out);
+			expr_fprint(prop->expr, out);
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs(" if ", out);
+				expr_fprint(prop->visible.expr, out);
+			}
+			fputc('\n', out);
+			break;
+		case P_CHOICE:
+			fputs("  #choice value\n", out);
+			break;
+		default:
+			fprintf(out, "  unknown prop %d!\n", prop->type);
+			break;
+		}
+	}
+	if (sym->help) {
+		int len = strlen(sym->help);
+		while (sym->help[--len] == '\n')
+			sym->help[len] = 0;
+		fprintf(out, "  help\n%s\n", sym->help);
+	}
+	fputc('\n', out);
+}
+
+void zconfdump(FILE *out)
+{
+	struct property *prop;
+	struct symbol *sym;
+	struct menu *menu;
+
+	menu = rootmenu.list;
+	while (menu) {
+		if ((sym = menu->sym))
+			print_symbol(out, menu);
+		else if ((prop = menu->prompt)) {
+			switch (prop->type) {
+			case P_COMMENT:
+				fputs("\ncomment ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			case P_MENU:
+				fputs("\nmenu ", out);
+				print_quoted_string(out, prop->text);
+				fputs("\n", out);
+				break;
+			default:
+				;
+			}
+			if (!expr_is_yes(prop->visible.expr)) {
+				fputs("  depends ", out);
+				expr_fprint(prop->visible.expr, out);
+				fputc('\n', out);
+			}
+			fputs("\n", out);
+		}
+
+		if (menu->list)
+			menu = menu->list;
+		else if (menu->next)
+			menu = menu->next;
+		else while ((menu = menu->parent)) {
+			if (menu->prompt && menu->prompt->type == P_MENU)
+				fputs("\nendmenu\n", out);
+			if (menu->next) {
+				menu = menu->next;
+				break;
+			}
+		}
+	}
+}
+
+#include "lex.zconf.c"
+#include "util.c"
+#include "confdata.c"
+#include "expr.c"
+#include "symbol.c"
+#include "menu.c"
+
+
diff -Nurp linux-2.6.20-sabayon-r1.orig/scripts/mod/elfconfig.h linux-2.6.20-sabayon-r1/scripts/mod/elfconfig.h
--- linux-2.6.20-sabayon-r1.orig/scripts/mod/elfconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r1/scripts/mod/elfconfig.h	2007-02-12 15:10:50.000000000 +0100
@@ -0,0 +1,5 @@
+#define KERNEL_ELFCLASS ELFCLASS64
+#define KERNEL_ELFDATA ELFDATA2LSB
+#define HOST_ELFCLASS ELFCLASS64
+#define HOST_ELFDATA ELFDATA2LSB
+#define MODULE_SYMBOL_PREFIX ""
Files linux-2.6.20-sabayon-r1.orig/scripts/mod/mk_elfconfig and linux-2.6.20-sabayon-r1/scripts/mod/mk_elfconfig differ
Files linux-2.6.20-sabayon-r1.orig/scripts/mod/modpost and linux-2.6.20-sabayon-r1/scripts/mod/modpost differ
Files linux-2.6.20-sabayon-r1.orig/scripts/pnmtologo and linux-2.6.20-sabayon-r1/scripts/pnmtologo differ
