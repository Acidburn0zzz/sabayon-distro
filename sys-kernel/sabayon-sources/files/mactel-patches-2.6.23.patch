Index: linux-2.6.23-rc8/drivers/hwmon/Kconfig
===================================================================
--- linux-2.6.23-rc8.orig/drivers/hwmon/Kconfig
+++ linux-2.6.23-rc8/drivers/hwmon/Kconfig
@@ -665,6 +665,7 @@ config SENSORS_APPLESMC
 	depends on INPUT && X86
 	select NEW_LEDS
 	select LEDS_CLASS
+	select INPUT_POLLDEV
 	default n
 	help
 	  This driver provides support for the Apple System Management
Index: linux-2.6.23-rc8/drivers/hwmon/applesmc.c
===================================================================
--- linux-2.6.23-rc8.orig/drivers/hwmon/applesmc.c
+++ linux-2.6.23-rc8/drivers/hwmon/applesmc.c
@@ -28,7 +28,7 @@
 
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <linux/input.h>
+#include <linux/input-polldev.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/timer.h>
@@ -39,14 +39,20 @@
 #include <linux/leds.h>
 #include <linux/hwmon.h>
 #include <linux/workqueue.h>
+#include <linux/interrupt.h>
 
 /* data port used by Apple SMC */
 #define APPLESMC_DATA_PORT	0x300
 /* command/status port used by Apple SMC */
 #define APPLESMC_CMD_PORT	0x304
+/* status port used by Apple SMC to get which interrupt type just happened */
+#define APPLESMC_INT_PORT	0x31f
 
 #define APPLESMC_NR_PORTS	32 /* 0x300-0x31f */
 
+/* Defined in ACPI DSDT table, should we read it from there? */
+#define APPLESMC_IRQ		6
+
 #define APPLESMC_MAX_DATA_LENGTH 32
 
 #define APPLESMC_STATUS_MASK	0x0f
@@ -57,17 +63,32 @@
 
 #define KEY_COUNT_KEY		"#KEY" /* r-o ui32 */
 
+#define INTERRUPT_OK_KEY	"NTOK" /* w-o ui8 */
+
 #define LIGHT_SENSOR_LEFT_KEY	"ALV0" /* r-o {alv (6 bytes) */
 #define LIGHT_SENSOR_RIGHT_KEY	"ALV1" /* r-o {alv (6 bytes) */
-#define BACKLIGHT_KEY 		"LKSB" /* w-o {lkb (2 bytes) */
+#define BACKLIGHT_KEY		"LKSB" /* w-o {lkb (2 bytes) */
 
-#define CLAMSHELL_KEY 		"MSLD" /* r-o ui8 (unused) */
+#define CLAMSHELL_KEY		"MSLD" /* r-o ui8 (unused) */
 
 #define MOTION_SENSOR_X_KEY	"MO_X" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_Y_KEY	"MO_Y" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_Z_KEY	"MO_Z" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_KEY	"MOCN" /* r/w ui16 */
 
+/*
+ * Interrupt controls.
+ * If the norm of the position (sqrt(MO_X^2+MO_Y^2+MO_Z^2)) is smaller than
+ * MOLT (free fall), or bigger than MOHT (high acceleration) for longer than the
+ * value of MOLD (or MOHD), SMC will trigger an interrupt.
+ */
+#define MOTION_LOW_NORM			"MOLT" /* r/w sp78 (2 bytes) */
+#define MOTION_HIGH_NORM		"MOHT" /* r/w sp78 (2 bytes) */
+#define MOTION_LOW_NORM_INTERVAL	"MOLD" /* r/w ui8 */
+#define MOTION_HIGH_NORM_INTERVAL	"MOHD" /* r/w ui8 */
+
+#define MSDW_KEY		"MSDW" /* r/w flag (1 byte) */
+
 #define FANS_COUNT		"FNum" /* r-o ui8 */
 #define FANS_MANUAL		"FS! " /* r-w ui16 */
 #define FAN_ACTUAL_SPEED	"F0Ac" /* r-o fpe2 (2 bytes) */
@@ -80,7 +101,7 @@
 /*
  * Temperature sensors keys (sp78 - 2 bytes).
  */
-static const char* temperature_sensors_sets[][13] = {
+static const char* temperature_sensors_sets[][36] = {
 /* Set 0: Macbook Pro */
 	{ "TA0P", "TB0T", "TC0D", "TC0P", "TG0H", "TG0P", "TG0T", "Th0H",
 	  "Th1H", "Tm0P", "Ts0P", "Ts1P", NULL },
@@ -88,7 +109,13 @@ static const char* temperature_sensors_s
 	{ "TB0T", "TC0D", "TC0P", "TM0P", "TN0P", "TN1P", "Th0H", "Th0S",
 	  "Th1H", "Ts0P", NULL },
 /* Set 2: Macmini set */
-	{ "TC0D", "TC0P", NULL }
+	{ "TC0D", "TC0P", NULL },
+/* Set 3: Mac Pro (2 x Quad-Core) */
+	{ "TA0P", "TCAG", "TCAH", "TCBG", "TCBH", "TC0C", "TC0D", "TC0P",
+	  "TC1C", "TC1D", "TC2C", "TC2D", "TC3C", "TC3D", "THTG", "TH0P",
+	  "TH1P", "TH2P", "TH3P", "TMAP", "TMAS", "TMBS", "TM0P", "TM0S",
+	  "TM1P", "TM1S", "TM2P", "TM2S", "TM3S", "TM8P", "TM8S", "TM9P",
+	  "TM9S", "TN0H", "TS0C", NULL },
 };
 
 /* List of keys used to read/write fan speeds */
@@ -103,7 +130,10 @@ static const char* fan_speed_keys[] = {
 #define INIT_TIMEOUT_MSECS	5000	/* wait up to 5s for device init ... */
 #define INIT_WAIT_MSECS		50	/* ... in 50ms increments */
 
-#define APPLESMC_POLL_PERIOD	(HZ/20)	/* poll for input every 1/20s */
+#define ACCESS_TIMEOUT_MSECS	500	/* wait up to 500ms when accessing a key */
+#define ACCESS_WAIT_MSECS	5	/* ... in 5ms increments */
+
+#define APPLESMC_POLL_INTERVAL	50	/* msecs */
 #define APPLESMC_INPUT_FUZZ	4	/* input event threshold */
 #define APPLESMC_INPUT_FLAT	4
 
@@ -125,8 +155,7 @@ static const int debug;
 static struct platform_device *pdev;
 static s16 rest_x;
 static s16 rest_y;
-static struct timer_list applesmc_timer;
-static struct input_dev *applesmc_idev;
+static struct input_polled_dev *applesmc_idev;
 static struct class_device *hwmon_class_dev;
 
 /* Indicates whether this computer has an accelerometer. */
@@ -138,7 +167,7 @@ static unsigned int applesmc_light;
 /* Indicates which temperature sensors set to use. */
 static unsigned int applesmc_temperature_set;
 
-static struct mutex applesmc_lock;
+static DEFINE_MUTEX(applesmc_lock);
 
 /*
  * Last index written to key_at_index sysfs file, and value to use for all other
@@ -178,12 +207,13 @@ static int __wait_status(u8 val)
 
 /*
  * applesmc_read_key - reads len bytes from a given key, and put them in buffer.
+ * Tries up to ACCESS_WAIT_MSECS to read the value.
  * Returns zero on success or a negative error on failure. Callers must
  * hold applesmc_lock.
  */
 static int applesmc_read_key(const char* key, u8* buffer, u8 len)
 {
-	int i;
+	int i, total, ret;
 
 	if (len > APPLESMC_MAX_DATA_LENGTH) {
 		printk(KERN_ERR	"applesmc_read_key: cannot read more than "
@@ -191,33 +221,54 @@ static int applesmc_read_key(const char*
 		return -EINVAL;
 	}
 
-	outb(APPLESMC_READ_CMD, APPLESMC_CMD_PORT);
-	if (__wait_status(0x0c))
-		return -EIO;
+	for (total = ACCESS_TIMEOUT_MSECS; total > 0;
+						total -= ACCESS_WAIT_MSECS) {
+		ret = 0;
+		outb(APPLESMC_READ_CMD, APPLESMC_CMD_PORT);
+		if (__wait_status(0x0c)) {
+			ret = -EIO;
+			goto wait_fail;
+		}
 
-	for (i = 0; i < 4; i++) {
-		outb(key[i], APPLESMC_DATA_PORT);
-		if (__wait_status(0x04))
-			return -EIO;
-	}
-	if (debug)
-		printk(KERN_DEBUG "<%s", key);
+		for (i = 0; i < 4; i++) {
+			outb(key[i], APPLESMC_DATA_PORT);
+			if (__wait_status(0x04)) {
+				ret = -EIO;
+				goto wait_fail;
+			}
+		}
+		if (debug)
+			printk(KERN_DEBUG "<%s", key);
 
-	outb(len, APPLESMC_DATA_PORT);
-	if (debug)
-		printk(KERN_DEBUG ">%x", len);
+		outb(len, APPLESMC_DATA_PORT);
+		if (debug)
+			printk(KERN_DEBUG ">%x", len);
 
-	for (i = 0; i < len; i++) {
-		if (__wait_status(0x05))
-			return -EIO;
-		buffer[i] = inb(APPLESMC_DATA_PORT);
+		for (i = 0; i < len; i++) {
+			if (__wait_status(0x05)) {
+				ret = -EIO;
+				goto wait_fail;
+			}
+			buffer[i] = inb(APPLESMC_DATA_PORT);
+			if (debug)
+				printk(KERN_DEBUG "<%x", buffer[i]);
+		}
 		if (debug)
-			printk(KERN_DEBUG "<%x", buffer[i]);
+			printk(KERN_DEBUG "\n");
+
+		break;
+
+wait_fail:
+		msleep(ACCESS_WAIT_MSECS);
+		continue;		
 	}
-	if (debug)
-		printk(KERN_DEBUG "\n");
 
-	return 0;
+	if (total != ACCESS_TIMEOUT_MSECS) {
+		printk(KERN_DEBUG "Read: Waited %d ms for the value\n",
+						ACCESS_TIMEOUT_MSECS-total);
+	}
+
+	return ret;
 }
 
 /*
@@ -352,12 +403,83 @@ static int applesmc_read_motion_sensor(i
 }
 
 /*
+ * applesmc_init_check_key_value - checks if a given key contains the bytes in
+ * buffer, if not, writes these bytes.
+ * In case of failure retry every INIT_WAIT_MSECS msec, and timeout if it
+ * waited more than INIT_TIMEOUT_MSECS in total.
+ * Returns zero on success or a negative error on failure. Callers must
+ * hold applesmc_lock.
+ */
+static int applesmc_init_check_key_value(const char *key, u8 *buffer, u8 len)
+{
+	int total, ret, i, compare;
+	u8 rdbuffer[APPLESMC_MAX_DATA_LENGTH];
+
+	if (len > APPLESMC_MAX_DATA_LENGTH) {
+		printk(KERN_ERR "applesmc_init_check_key_value: cannot "
+					"read/write more than %d bytes",
+					APPLESMC_MAX_DATA_LENGTH);
+		return -EINVAL;
+	}
+
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		ret = applesmc_read_key(key, rdbuffer, len);
+		if (!ret) {
+			compare = 1;
+			for (i = 0; i < len; i++) {
+				if (rdbuffer[i] != buffer[i]) {
+					compare = 0;
+					break;
+				}
+			}
+
+			if (compare) {
+				return 0;
+			}
+		}
+		ret = applesmc_write_key(key, buffer, len);
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	if (ret)
+		return ret;
+	else
+		return -EIO;
+}
+
+irqreturn_t applesmc_irq_handler(int irq, void *dev_id)
+{
+	u8 int_type = inb(APPLESMC_INT_PORT);
+
+	switch (int_type) {
+	case 0x60:
+		printk(KERN_INFO "applesmc: received a free fall interrupt\n");
+		break;
+	case 0x6f:
+		printk(KERN_INFO
+			"applesmc: received a high acceleration interrupt\n");
+		break;
+	case 0x80:
+		printk(KERN_INFO "applesmc: received a shock interrupt\n");
+		break;
+	default:
+		printk(KERN_INFO
+			"applesmc: received an unknown interrupt %x\n",
+			int_type);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
  * applesmc_device_init - initialize the accelerometer.  Returns zero on success
  * and negative error code on failure.  Can sleep.
  */
 static int applesmc_device_init(void)
 {
-	int total, ret = -ENXIO;
+	int total;
+	int ret = -ENXIO;
+	int ret1, ret2;
 	u8 buffer[2];
 
 	if (!applesmc_accelerometer)
@@ -365,32 +487,79 @@ static int applesmc_device_init(void)
 
 	mutex_lock(&applesmc_lock);
 
+	/* Accept interrupts */
+	buffer[0] = 0x01;
 	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
-		if (debug)
-			printk(KERN_DEBUG "applesmc try %d\n", total);
-		if (!applesmc_read_key(MOTION_SENSOR_KEY, buffer, 2) &&
-				(buffer[0] != 0x00 || buffer[1] != 0x00)) {
-			if (total == INIT_TIMEOUT_MSECS) {
-				printk(KERN_DEBUG "applesmc: device has"
-						" already been initialized"
-						" (0x%02x, 0x%02x).\n",
-						buffer[0], buffer[1]);
-			} else {
-				printk(KERN_DEBUG "applesmc: device"
-						" successfully initialized"
-						" (0x%02x, 0x%02x).\n",
-						buffer[0], buffer[1]);
-			}
-			ret = 0;
-			goto out;
-		}
-		buffer[0] = 0xe0;
-		buffer[1] = 0x00;
-		applesmc_write_key(MOTION_SENSOR_KEY, buffer, 2);
+		ret1 = applesmc_write_key(INTERRUPT_OK_KEY, buffer, 1);
+		msleep(INIT_WAIT_MSECS);
+
+		if (!ret1)
+			break;
+	}
+	if (ret1)
+		printk(KERN_WARNING "applesmc: Cannot set NTOK key, "
+					"will not receive interrupts.\n");
+
+	/* Setup interrupt controls. */
+	buffer[0] = 20; /* 20 msecs */
+	ret1 = applesmc_init_check_key_value(MOTION_LOW_NORM_INTERVAL,
+								buffer, 1);
+
+	buffer[0] = 20; /* 20 msecs */
+	ret2 = applesmc_init_check_key_value(MOTION_HIGH_NORM_INTERVAL,
+								buffer, 1);
+
+	if (ret1 || ret2) {
+		printk(KERN_WARNING "applesmc: Cannot set motion sensor "
+					"interrupt interval, might not receive "
+					"some interrupts.");
+	}
+
+	buffer[0] = 0x00;
+	buffer[1] = 0x60;
+	ret1 = applesmc_init_check_key_value(MOTION_LOW_NORM, buffer, 2);
+
+	buffer[0] = 0x01;
+	buffer[1] = 0xc0;
+	ret2 = applesmc_init_check_key_value(MOTION_HIGH_NORM, buffer, 2);
+
+	if (ret1 || ret2) {
+		printk(KERN_WARNING "applesmc: Cannot set motion sensor "
+				"min/max norm parameters, "
+				"might not receive some interrupts.");
+	}
+
+	/* Mysterious key. */
+	buffer[0] = 0x01;
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		ret1 = applesmc_write_key(MSDW_KEY, buffer, 1);
 		msleep(INIT_WAIT_MSECS);
+
+		if (!ret1)
+			break;
 	}
+	if (ret1)
+		printk(KERN_WARNING "applesmc: Cannot set MSDW key\n");
 
-	printk(KERN_WARNING "applesmc: failed to init the device\n");
+	/* Initialize the device. */
+	buffer[0] = 0xe0;
+	buffer[1] = 0xf8;
+	if (applesmc_init_check_key_value(MOTION_SENSOR_KEY, buffer, 2)) {
+		printk(KERN_WARNING "applesmc: failed to init "
+							"the accelerometer\n");
+		goto out;
+	}
+
+	ret1 = request_irq(APPLESMC_IRQ, applesmc_irq_handler, IRQF_DISABLED,
+						"applesmc_irq_handler", NULL);
+
+	if (ret1) {
+		printk(KERN_WARNING "applesmc: cannot setup irq handler\n");
+	}
+
+	printk(KERN_DEBUG "applesmc: accelerometer "
+						"successfully initialized.\n");
+	ret = 0;
 
 out:
 	mutex_unlock(&applesmc_lock);
@@ -435,9 +604,16 @@ static int applesmc_resume(struct platfo
 	return applesmc_device_init();
 }
 
+static int applesmc_remove(struct platform_device *dev)
+{
+	free_irq(APPLESMC_IRQ, NULL);
+	return 0;
+}
+
 static struct platform_driver applesmc_driver = {
 	.probe = applesmc_probe,
 	.resume = applesmc_resume,
+	.remove = applesmc_remove,
 	.driver	= {
 		.name = "applesmc",
 		.owner = THIS_MODULE,
@@ -455,27 +631,12 @@ static void applesmc_calibrate(void)
 	rest_x = -rest_x;
 }
 
-static int applesmc_idev_open(struct input_dev *dev)
-{
-	add_timer(&applesmc_timer);
-
-	return 0;
-}
-
-static void applesmc_idev_close(struct input_dev *dev)
-{
-	del_timer_sync(&applesmc_timer);
-}
-
-static void applesmc_idev_poll(unsigned long unused)
+static void applesmc_idev_poll(struct input_polled_dev *dev)
 {
+	struct input_dev *idev = dev->input;
 	s16 x, y;
 
-	/* Cannot sleep.  Try nonblockingly.  If we fail, try again later. */
-	if (!mutex_trylock(&applesmc_lock)) {
-		mod_timer(&applesmc_timer, jiffies + APPLESMC_POLL_PERIOD);
-		return;
-	}
+	mutex_lock(&applesmc_lock);
 
 	if (applesmc_read_motion_sensor(SENSOR_X, &x))
 		goto out;
@@ -483,13 +644,11 @@ static void applesmc_idev_poll(unsigned 
 		goto out;
 
 	x = -x;
-	input_report_abs(applesmc_idev, ABS_X, x - rest_x);
-	input_report_abs(applesmc_idev, ABS_Y, y - rest_y);
-	input_sync(applesmc_idev);
+	input_report_abs(idev, ABS_X, x - rest_x);
+	input_report_abs(idev, ABS_Y, y - rest_y);
+	input_sync(idev);
 
 out:
-	mod_timer(&applesmc_timer, jiffies + APPLESMC_POLL_PERIOD);
-
 	mutex_unlock(&applesmc_lock);
 }
 
@@ -821,8 +980,7 @@ static ssize_t applesmc_key_at_index_rea
 
 	if (!ret) {
 		return info[0];
-	}
-	else {
+	} else {
 		return ret;
 	}
 }
@@ -917,6 +1075,123 @@ static ssize_t applesmc_key_at_index_sto
 	return count;
 }
 
+static ssize_t applesmc_accelerometer_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	int ret;
+	unsigned int value = 0;
+	u8 buffer[2];
+	char *key;
+	int length;
+	struct sensor_device_attribute_2 *sensor_attr =
+						to_sensor_dev_attr_2(attr);
+
+	switch (sensor_attr->index) {
+	case 0:
+		key = MOTION_LOW_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 1:
+		key = MOTION_HIGH_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 2:
+		key = MOTION_LOW_NORM;
+		length = 2;
+		break;
+	case 3:
+		key = MOTION_HIGH_NORM;
+		length = 2;
+		break;
+	default:
+		printk(KERN_ERR
+			"Invalid index for applesmc_accelerometer_show");
+		return -EINVAL;
+	}
+
+	mutex_lock(&applesmc_lock);
+
+	ret = applesmc_read_key(key, buffer, length);
+	if (length == 2)
+		value = ((unsigned int)buffer[0] << 8) | buffer[1];
+	else if (length == 1)
+		value = buffer[0];
+	else {
+		printk("Invalid length for applesmc_param_show");
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&applesmc_lock);
+	if (ret)
+		return ret;
+	else
+		return snprintf(sysfsbuf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t applesmc_accelerometer_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *sysfsbuf, size_t count)
+{
+	int ret;
+	u32 value;
+	u8 buffer[2];
+	char *key;
+	int length;
+	struct sensor_device_attribute_2 *sensor_attr =
+						to_sensor_dev_attr_2(attr);
+
+	switch (sensor_attr->index) {
+	case 0:
+		key = MOTION_LOW_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 1:
+		key = MOTION_HIGH_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 2:
+		key = MOTION_LOW_NORM;
+		length = 2;
+		break;
+	case 3:
+		key = MOTION_HIGH_NORM;
+		length = 2;
+		break;
+	default:
+		printk("Invalid index for applesmc_accelerometer_show");
+		return -EINVAL;
+	}
+
+	value = simple_strtoul(sysfsbuf, NULL, 10);
+
+	if (length == 2) {
+		if (value > 0xffff)
+			return -EINVAL;
+
+		buffer[0] = (value >> 8) & 0xff;
+		buffer[1] = value & 0xff;
+	} else if (length == 1) {
+		if (value > 0xff)
+			return -EINVAL;
+
+		buffer[0] = value & 0xff;
+	} else {
+		printk("Invalid length for applesmc_param_store");
+		return -EINVAL;
+	}
+
+	mutex_lock(&applesmc_lock);
+
+	ret = applesmc_write_key(key, buffer, length);
+
+	mutex_unlock(&applesmc_lock);
+
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
 static struct led_classdev applesmc_backlight = {
 	.name			= "smc:kbd_backlight",
 	.default_trigger	= "nand-disk",
@@ -928,10 +1203,22 @@ static DEVICE_ATTR(name, 0444, applesmc_
 static DEVICE_ATTR(position, 0444, applesmc_position_show, NULL);
 static DEVICE_ATTR(calibrate, 0644,
 			applesmc_calibrate_show, applesmc_calibrate_store);
+static SENSOR_DEVICE_ATTR(low_norm_trigger_interval, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 0);
+static SENSOR_DEVICE_ATTR(high_norm_trigger_interval, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 1);
+static SENSOR_DEVICE_ATTR(low_norm_trigger, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 2);
+static SENSOR_DEVICE_ATTR(high_norm_trigger, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 3);
 
 static struct attribute *accelerometer_attributes[] = {
 	&dev_attr_position.attr,
 	&dev_attr_calibrate.attr,
+	&sensor_dev_attr_low_norm_trigger.dev_attr.attr,
+	&sensor_dev_attr_high_norm_trigger.dev_attr.attr,
+	&sensor_dev_attr_low_norm_trigger_interval.dev_attr.attr,
+	&sensor_dev_attr_high_norm_trigger_interval.dev_attr.attr,
 	NULL
 };
 
@@ -1009,14 +1296,18 @@ static struct attribute *fan##offset##_a
 
 /*
  * Create the needed functions for each fan using the macro defined above
- * (2 fans are supported)
+ * (4 fans are supported)
  */
 sysfs_fan_speeds_offset(1);
 sysfs_fan_speeds_offset(2);
+sysfs_fan_speeds_offset(3);
+sysfs_fan_speeds_offset(4);
 
 static const struct attribute_group fan_attribute_groups[] = {
 	{ .attrs = fan1_attributes },
-	{ .attrs = fan2_attributes }
+	{ .attrs = fan2_attributes },
+	{ .attrs = fan3_attributes },
+	{ .attrs = fan4_attributes }
 };
 
 /*
@@ -1046,6 +1337,52 @@ static SENSOR_DEVICE_ATTR(temp11_input, 
 					applesmc_show_temperature, NULL, 10);
 static SENSOR_DEVICE_ATTR(temp12_input, S_IRUGO,
 					applesmc_show_temperature, NULL, 11);
+static SENSOR_DEVICE_ATTR(temp13_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 12);
+static SENSOR_DEVICE_ATTR(temp14_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 13);
+static SENSOR_DEVICE_ATTR(temp15_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 14);
+static SENSOR_DEVICE_ATTR(temp16_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 15);
+static SENSOR_DEVICE_ATTR(temp17_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 16);
+static SENSOR_DEVICE_ATTR(temp18_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 17);
+static SENSOR_DEVICE_ATTR(temp19_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 18);
+static SENSOR_DEVICE_ATTR(temp20_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 19);
+static SENSOR_DEVICE_ATTR(temp21_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 20);
+static SENSOR_DEVICE_ATTR(temp22_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 21);
+static SENSOR_DEVICE_ATTR(temp23_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 22);
+static SENSOR_DEVICE_ATTR(temp24_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 23);
+static SENSOR_DEVICE_ATTR(temp25_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 24);
+static SENSOR_DEVICE_ATTR(temp26_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 25);
+static SENSOR_DEVICE_ATTR(temp27_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 26);
+static SENSOR_DEVICE_ATTR(temp28_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 27);
+static SENSOR_DEVICE_ATTR(temp29_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 28);
+static SENSOR_DEVICE_ATTR(temp30_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 29);
+static SENSOR_DEVICE_ATTR(temp31_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 30);
+static SENSOR_DEVICE_ATTR(temp32_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 31);
+static SENSOR_DEVICE_ATTR(temp33_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 32);
+static SENSOR_DEVICE_ATTR(temp34_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 33);
+static SENSOR_DEVICE_ATTR(temp35_input, S_IRUGO,
+					applesmc_show_temperature, NULL, 34);
 
 static struct attribute *temperature_attributes[] = {
 	&sensor_dev_attr_temp1_input.dev_attr.attr,
@@ -1060,6 +1397,29 @@ static struct attribute *temperature_att
 	&sensor_dev_attr_temp10_input.dev_attr.attr,
 	&sensor_dev_attr_temp11_input.dev_attr.attr,
 	&sensor_dev_attr_temp12_input.dev_attr.attr,
+	&sensor_dev_attr_temp13_input.dev_attr.attr,
+	&sensor_dev_attr_temp14_input.dev_attr.attr,
+	&sensor_dev_attr_temp15_input.dev_attr.attr,
+	&sensor_dev_attr_temp16_input.dev_attr.attr,
+	&sensor_dev_attr_temp17_input.dev_attr.attr,
+	&sensor_dev_attr_temp18_input.dev_attr.attr,
+	&sensor_dev_attr_temp19_input.dev_attr.attr,
+	&sensor_dev_attr_temp20_input.dev_attr.attr,
+	&sensor_dev_attr_temp21_input.dev_attr.attr,
+	&sensor_dev_attr_temp22_input.dev_attr.attr,
+	&sensor_dev_attr_temp23_input.dev_attr.attr,
+	&sensor_dev_attr_temp24_input.dev_attr.attr,
+	&sensor_dev_attr_temp25_input.dev_attr.attr,
+	&sensor_dev_attr_temp26_input.dev_attr.attr,
+	&sensor_dev_attr_temp27_input.dev_attr.attr,
+	&sensor_dev_attr_temp28_input.dev_attr.attr,
+	&sensor_dev_attr_temp29_input.dev_attr.attr,
+	&sensor_dev_attr_temp30_input.dev_attr.attr,
+	&sensor_dev_attr_temp31_input.dev_attr.attr,
+	&sensor_dev_attr_temp32_input.dev_attr.attr,
+	&sensor_dev_attr_temp33_input.dev_attr.attr,
+	&sensor_dev_attr_temp34_input.dev_attr.attr,
+	&sensor_dev_attr_temp35_input.dev_attr.attr,
 	NULL
 };
 
@@ -1093,6 +1453,7 @@ static int applesmc_dmi_match(struct dmi
 /* Create accelerometer ressources */
 static int applesmc_create_accelerometer(void)
 {
+	struct input_dev *idev;
 	int ret;
 
 	ret = sysfs_create_group(&pdev->dev.kobj,
@@ -1100,40 +1461,37 @@ static int applesmc_create_accelerometer
 	if (ret)
 		goto out;
 
-	applesmc_idev = input_allocate_device();
+	applesmc_idev = input_allocate_polled_device();
 	if (!applesmc_idev) {
 		ret = -ENOMEM;
 		goto out_sysfs;
 	}
 
+	applesmc_idev->poll = applesmc_idev_poll;
+	applesmc_idev->poll_interval = APPLESMC_POLL_INTERVAL;
+
 	/* initial calibrate for the input device */
 	applesmc_calibrate();
 
-	/* initialize the input class */
-	applesmc_idev->name = "applesmc";
-	applesmc_idev->id.bustype = BUS_HOST;
-	applesmc_idev->dev.parent = &pdev->dev;
-	applesmc_idev->evbit[0] = BIT(EV_ABS);
-	applesmc_idev->open = applesmc_idev_open;
-	applesmc_idev->close = applesmc_idev_close;
-	input_set_abs_params(applesmc_idev, ABS_X,
+	/* initialize the input device */
+	idev = applesmc_idev->input;
+	idev->name = "applesmc";
+	idev->id.bustype = BUS_HOST;
+	idev->dev.parent = &pdev->dev;
+	idev->evbit[0] = BIT(EV_ABS);
+	input_set_abs_params(idev, ABS_X,
 			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
-	input_set_abs_params(applesmc_idev, ABS_Y,
+	input_set_abs_params(idev, ABS_Y,
 			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
 
-	ret = input_register_device(applesmc_idev);
+	ret = input_register_polled_device(applesmc_idev);
 	if (ret)
 		goto out_idev;
 
-	/* start up our timer for the input device */
-	init_timer(&applesmc_timer);
-	applesmc_timer.function = applesmc_idev_poll;
-	applesmc_timer.expires = jiffies + APPLESMC_POLL_PERIOD;
-
 	return 0;
 
 out_idev:
-	input_free_device(applesmc_idev);
+	input_free_polled_device(applesmc_idev);
 
 out_sysfs:
 	sysfs_remove_group(&pdev->dev.kobj, &accelerometer_attributes_group);
@@ -1146,8 +1504,8 @@ out:
 /* Release all ressources used by the accelerometer */
 static void applesmc_release_accelerometer(void)
 {
-	del_timer_sync(&applesmc_timer);
-	input_unregister_device(applesmc_idev);
+	input_unregister_polled_device(applesmc_idev);
+	input_free_polled_device(applesmc_idev);
 	sysfs_remove_group(&pdev->dev.kobj, &accelerometer_attributes_group);
 }
 
@@ -1158,6 +1516,8 @@ static __initdata struct dmi_match_data 
 	{ .accelerometer = 1, .light = 0, .temperature_set = 1 },
 /* MacMini: temperature set 2 */
 	{ .accelerometer = 0, .light = 0, .temperature_set = 2 },
+/* MacPro: temperature set 3 */
+	{ .accelerometer = 0, .light = 0, .temperature_set = 3 },
 };
 
 /* Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
@@ -1175,6 +1535,10 @@ static __initdata struct dmi_system_id a
 	  DMI_MATCH(DMI_BOARD_VENDOR,"Apple"),
 	  DMI_MATCH(DMI_PRODUCT_NAME,"Macmini") },
 		(void*)&applesmc_dmi_data[2]},
+	{ applesmc_dmi_match, "Apple MacPro2", {
+	  DMI_MATCH(DMI_BOARD_VENDOR,"Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME,"MacPro2") },
+		(void*)&applesmc_dmi_data[3]},
 	{ .ident = NULL }
 };
 
@@ -1184,8 +1548,6 @@ static int __init applesmc_init(void)
 	int count;
 	int i;
 
-	mutex_init(&applesmc_lock);
-
 	if (!dmi_check_system(applesmc_whitelist)) {
 		printk(KERN_WARNING "applesmc: supported laptop not found!\n");
 		ret = -ENODEV;
@@ -1227,9 +1589,19 @@ static int __init applesmc_init(void)
 
 		switch (count) {
 		default:
-			printk(KERN_WARNING "applesmc: More than 2 fans found,"
-					" but at most 2 fans are supported"
+			printk(KERN_WARNING "applesmc: More than 4 fans found,"
+					" but at most 4 fans are supported"
 						" by the driver.\n");
+		case 4:
+			ret = sysfs_create_group(&pdev->dev.kobj,
+						 &fan_attribute_groups[3]);
+			if (ret)
+				goto out_key_enumeration;
+		case 3:
+			ret = sysfs_create_group(&pdev->dev.kobj,
+						 &fan_attribute_groups[2]);
+			if (ret)
+				goto out_key_enumeration;
 		case 2:
 			ret = sysfs_create_group(&pdev->dev.kobj,
 						 &fan_attribute_groups[1]);
Index: linux-2.6.23-rc8/drivers/input/mouse/appletouch.c
===================================================================
--- linux-2.6.23-rc8.orig/drivers/input/mouse/appletouch.c
+++ linux-2.6.23-rc8/drivers/input/mouse/appletouch.c
@@ -127,7 +127,7 @@ MODULE_DEVICE_TABLE (usb, atp_table);
  * Threshold for the touchpad sensors. Any change less than ATP_THRESHOLD is
  * ignored.
  */
-#define ATP_THRESHOLD	 5
+#define ATP_THRESHOLD	 3
 
 /* MacBook Pro (Geyser 3 & 4) initialization constants */
 #define ATP_GEYSER3_MODE_READ_REQUEST_ID 1
