--- a/drivers/net/wireless/mac80211/rt2x00/rt2400pci.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2400pci.c	2007-07-09 21:00:13.000000000 +0200
@@ -42,13 +42,14 @@
 #include <asm/io.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00pci.h"
 #include "rt2400pci.h"
 
 /*
  * Register access.
  * All access to the CSR registers will go through the methods
- * rt2x00_register_read and rt2x00_register_write.
+ * rt2x00pci_register_read and rt2x00pci_register_write.
  * BBP and RF register require indirect register access,
  * and use the CSR registers BBPCSR and RFCSR to achieve this.
  * These indirect registers work with busy bits,
@@ -58,50 +59,22 @@
  * the access attempt is considered to have failed,
  * and we will print an error.
  */
-static inline void rt2x00_register_read(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 *value)
-{
-	*value = readl(rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiread(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	memcpy_fromio(value, rt2x00dev->csr_addr + offset, length);
-}
-
-static inline void rt2x00_register_write(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 value)
-{
-	writel(value, rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiwrite(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	memcpy_toio(rt2x00dev->csr_addr + offset, value, length);
-}
-
-static u32 rt2x00_bbp_check(const struct rt2x00_dev *rt2x00dev)
+static u32 rt2400pci_bbp_check(const struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, BBPCSR, &reg);
+		rt2x00pci_register_read(rt2x00dev, BBPCSR, &reg);
 		if (!rt2x00_get_field32(reg, BBPCSR_BUSY))
-			return reg;
+			break;
 		udelay(REGISTER_BUSY_DELAY);
 	}
 
-	return 0xffff;
+	return reg;
 }
 
-static void rt2x00_bbp_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2400pci_bbp_write(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, const u8 value)
 {
 	u32 reg;
@@ -109,7 +82,8 @@ static void rt2x00_bbp_write(const struc
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2400pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Write failed.\n");
 		return;
 	}
@@ -123,10 +97,10 @@ static void rt2x00_bbp_write(const struc
 	rt2x00_set_field32(&reg, BBPCSR_BUSY, 1);
 	rt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 1);
 
-	rt2x00_register_write(rt2x00dev, BBPCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, BBPCSR, reg);
 }
 
-static void rt2x00_bbp_read(const struct rt2x00_dev *rt2x00dev,
+static void rt2400pci_bbp_read(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, u8 *value)
 {
 	u32 reg;
@@ -134,7 +108,8 @@ static void rt2x00_bbp_read(const struct
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2400pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Read failed.\n");
 		return;
 	}
@@ -147,26 +122,29 @@ static void rt2x00_bbp_read(const struct
 	rt2x00_set_field32(&reg, BBPCSR_BUSY, 1);
 	rt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 0);
 
-	rt2x00_register_write(rt2x00dev, BBPCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, BBPCSR, reg);
 
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	reg = rt2x00_bbp_check(rt2x00dev);
-	if (reg == 0xffff)
+	reg = rt2400pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Read failed.\n");
+		*value = 0xff;
+		return;
+	}
 
 	*value = rt2x00_get_field32(reg, BBPCSR_VALUE);
 }
 
-static void rt2x00_rf_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2400pci_rf_write(const struct rt2x00_dev *rt2x00dev,
 	const u32 value)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, RFCSR, &reg);
+		rt2x00pci_register_read(rt2x00dev, RFCSR, &reg);
 		if (!rt2x00_get_field32(reg, RFCSR_BUSY))
 			goto rf_write;
 		udelay(REGISTER_BUSY_DELAY);
@@ -182,7 +160,7 @@ rf_write:
 	rt2x00_set_field32(&reg, RFCSR_IF_SELECT, 0);
 	rt2x00_set_field32(&reg, RFCSR_BUSY, 1);
 
-	rt2x00_register_write(rt2x00dev, RFCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, RFCSR, reg);
 }
 
 static void rt2400pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
@@ -190,7 +168,7 @@ static void rt2400pci_eepromregister_rea
 	struct rt2x00_dev *rt2x00dev = eeprom->data;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR21, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR21, &reg);
 
 	eeprom->reg_data_in = !!rt2x00_get_field32(reg,
 		CSR21_EEPROM_DATA_IN);
@@ -216,7 +194,7 @@ static void rt2400pci_eepromregister_wri
 	rt2x00_set_field32(&reg, CSR21_EEPROM_CHIP_SELECT,
 		!!eeprom->reg_chip_select);
 
-	rt2x00_register_write(rt2x00dev, CSR21, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR21, reg);
 }
 
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
@@ -225,13 +203,13 @@ static void rt2400pci_eepromregister_wri
 static void rt2400pci_read_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_read(rt2x00dev, CSR_OFFSET(word), data);
+	rt2x00pci_register_read(rt2x00dev, CSR_OFFSET(word), data);
 }
 
 static void rt2400pci_write_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
+	rt2x00pci_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
 }
 
 static void rt2400pci_read_eeprom(struct rt2x00_dev *rt2x00dev,
@@ -249,13 +227,13 @@ static void rt2400pci_write_eeprom(struc
 static void rt2400pci_read_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_read(rt2x00dev, word, data);
+	rt2400pci_bbp_read(rt2x00dev, word, data);
 }
 
 static void rt2400pci_write_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_write(rt2x00dev, word, *((u8*)data));
+	rt2400pci_bbp_write(rt2x00dev, word, *((u8*)data));
 }
 
 static const struct rt2x00debug rt2400pci_rt2x00debug = {
@@ -286,7 +264,7 @@ static int rt2400pci_rfkill_poll(struct 
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, GPIOCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, GPIOCSR, &reg);
 	return rt2x00_get_field32(reg, GPIOCSR_BIT0);
 }
 #endif /* CONFIG_RT2400PCI_RFKILL */
@@ -305,45 +283,29 @@ static void rt2400pci_config_bssid(struc
 	 * The BSSID is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, CSR5, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, CSR5, &reg, sizeof(reg));
 }
 
-static void rt2400pci_config_promisc(struct rt2x00_dev *rt2x00dev, int promisc)
+static void rt2400pci_config_promisc(struct rt2x00_dev *rt2x00dev,
+	const int promisc)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
-
-	if (promisc) {
-		rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, 0);
-		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	} else {
-		rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, 1);
-		__clear_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	}
-
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, !promisc);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 }
 
 static void rt2400pci_config_type(struct rt2x00_dev *rt2x00dev, int type)
 {
 	u32 reg;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (!(is_interface_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
-	    !(is_monitor_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
-		return;
-
-	rt2x00_register_write(rt2x00dev, CSR14, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR14, 0);
 
 	/*
 	 * Apply hardware packet filter.
 	 */
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
 
 	if (!is_monitor_present(&rt2x00dev->interface) &&
 	    (type == IEEE80211_IF_TYPE_IBSS || type == IEEE80211_IF_TYPE_STA))
@@ -362,25 +324,20 @@ static void rt2400pci_config_type(struct
 		rt2x00_set_field32(&reg, RXCSR0_DROP_VERSION_ERROR, 1);
 	}
 
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 
 	/*
 	 * Enable beacon config
 	 */
-	rt2x00_register_read(rt2x00dev, BCNCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, BCNCSR1, &reg);
 	rt2x00_set_field32(&reg, BCNCSR1_PRELOAD,
 		PREAMBLE + get_duration(IEEE80211_HEADER, 2));
-	rt2x00_register_write(rt2x00dev, BCNCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, BCNCSR1, reg);
 
 	/*
 	 * Enable synchronisation.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR12, &reg);
-	rt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL, 100 * 16);
-	rt2x00_set_field32(&reg, CSR12_CFP_MAX_DURATION, 100 * 16);
-	rt2x00_register_write(rt2x00dev, CSR12, reg);
-
-	rt2x00_register_read(rt2x00dev, CSR14, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR14, &reg);
 	if (is_interface_present(&rt2x00dev->interface)) {
 		rt2x00_set_field32(&reg, CSR14_TSF_COUNT, 1);
 		rt2x00_set_field32(&reg, CSR14_TBCN, 1);
@@ -395,52 +352,25 @@ static void rt2400pci_config_type(struct
 		 !is_interface_present(&rt2x00dev->interface))
 		rt2x00_set_field32(&reg, CSR14_TSF_SYNC, 0);
 
-	rt2x00_register_write(rt2x00dev, CSR14, reg);
-
-	/*
-	 * Change flags of enabled interfaces.
-	 */
-	if (type != IEEE80211_IF_TYPE_MNTR) {
-		if (is_interface_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	} else {
-		if (is_monitor_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-	}
+	rt2x00pci_register_write(rt2x00dev, CSR14, reg);
 }
 
 static void rt2400pci_config_channel(struct rt2x00_dev *rt2x00dev,
-	int value, int channel, int freq, int txpower)
+	const int value, const int channel, const int txpower)
 {
 	u32 rf1 = rt2x00dev->rf1;
 	u32 rf2 = value;
 	u32 rf3 = rt2x00dev->rf3;
 
 	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (channel == rt2x00dev->rx_status.channel)
-		return;
-
-	/*
 	 * Switch on tuning bits.
 	 */
 	rt2x00_set_field32(&rf1, RF1_TUNER, 1);
 	rt2x00_set_field32(&rf3, RF3_TUNER, 1);
 
-	INFO(rt2x00dev, "Switching channel. "
-		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x.\n",
-		rf1, rf2, rf3);
-
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3);
+	rt2400pci_rf_write(rt2x00dev, rf1);
+	rt2400pci_rf_write(rt2x00dev, rf2);
+	rt2400pci_rf_write(rt2x00dev, rf3);
 
 	/*
 	 * RF2420 chipset don't need any additional actions.
@@ -453,15 +383,15 @@ static void rt2400pci_config_channel(str
 	 * reference clock rate to activate auto_tune.
 	 * After that we set the value back to the correct channel.
 	 */
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, 0x000c2a32);
-	rt2x00_rf_write(rt2x00dev, rf3);
+	rt2400pci_rf_write(rt2x00dev, rf1);
+	rt2400pci_rf_write(rt2x00dev, 0x000c2a32);
+	rt2400pci_rf_write(rt2x00dev, rf3);
 
 	msleep(1);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3);
+	rt2400pci_rf_write(rt2x00dev, rf1);
+	rt2400pci_rf_write(rt2x00dev, rf2);
+	rt2400pci_rf_write(rt2x00dev, rf3);
 
 	msleep(1);
 
@@ -471,14 +401,8 @@ static void rt2400pci_config_channel(str
 	rt2x00_set_field32(&rf1, RF1_TUNER, 0);
 	rt2x00_set_field32(&rf3, RF3_TUNER, 0);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf3);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.freq = freq;
-	rt2x00dev->rx_status.channel = channel;
+	rt2400pci_rf_write(rt2x00dev, rf1);
+	rt2400pci_rf_write(rt2x00dev, rf3);
 
 	/*
 	 * Update rf fields
@@ -490,72 +414,45 @@ static void rt2400pci_config_channel(str
 	/*
 	 * Clear false CRC during channel switch.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &rf1);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &rf1);
 }
 
 static void rt2400pci_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
 {
-	txpower = TXPOWER_TO_DEV(txpower);
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (txpower == rt2x00dev->tx_power)
-		return;
-
-	rt2x00_bbp_write(rt2x00dev, 3, txpower);
-
-	rt2x00dev->tx_power = txpower;
+	rt2400pci_bbp_write(rt2x00dev, 3, TXPOWER_TO_DEV(txpower));
 }
 
 static void rt2400pci_config_antenna(struct rt2x00_dev *rt2x00dev,
 	int antenna_tx, int antenna_rx)
 {
-	u8 reg_rx;
-	u8 reg_tx;
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.antenna == antenna_rx)
-		return;
+	u8 r1;
+	u8 r4;
 
-	rt2x00_bbp_read(rt2x00dev, 4, &reg_rx);
-	rt2x00_bbp_read(rt2x00dev, 1, &reg_tx);
-
-	/*
-	 * Clear current config antenna bits.
-	 */
-	reg_rx &= ~0x06;
-	reg_tx &= ~0x03;
+	rt2400pci_bbp_read(rt2x00dev, 4, &r4);
+	rt2400pci_bbp_read(rt2x00dev, 1, &r1);
 
 	/*
 	 * Configure the TX antenna.
 	 */
-	if (antenna_tx == 0)		/* Diversity. */
-		reg_tx |= 0x01;
-	else if (antenna_tx == 1)	/* TX: Antenna A */
-		reg_tx |= 0x00;
-	else if (antenna_tx == 2)	/* TX: Antenna B */
-		reg_tx |= 0x02;
+	if (antenna_tx == ANTENNA_DIVERSITY)
+		rt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 1);
+	else if (antenna_tx == ANTENNA_A)
+		rt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 0);
+	else if (antenna_tx == ANTENNA_B)
+		rt2x00_set_field8(&r1, BBP_R1_TX_ANTENNA, 2);
 
 	/*
 	 * Configure the RX antenna.
 	 */
-	if (antenna_rx == 0)		/* Diversity. */
-		reg_rx |= 0x02;
-	else if (antenna_rx == 1)	/* RX: Antenna A */
-		reg_rx |= 0x00;
-	else if (antenna_rx == 2)	/* RX: Antenna B */
-		reg_rx |= 0x04;
-
-	rt2x00_bbp_write(rt2x00dev, 4, reg_rx);
-	rt2x00_bbp_write(rt2x00dev, 1, reg_tx);
+	if (antenna_rx == ANTENNA_DIVERSITY)
+		rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+	else if (antenna_rx == ANTENNA_A)
+		rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 0);
+	else if (antenna_rx == ANTENNA_B)
+		rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);
 
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.antenna = antenna_rx;
+	rt2400pci_bbp_write(rt2x00dev, 4, r4);
+	rt2400pci_bbp_write(rt2x00dev, 1, r1);
 }
 
 static void rt2400pci_config_cw(struct rt2x00_dev *rt2x00dev,
@@ -563,38 +460,43 @@ static void rt2400pci_config_cw(struct r
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_CWMIN, params->cw_min);
 	rt2x00_set_field32(&reg, CSR11_CWMAX, params->cw_max);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 }
 
 static void rt2400pci_config_duration(struct rt2x00_dev *rt2x00dev,
-	int short_slot_time)
+	int short_slot_time, int beacon_int)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_SLOT_TIME,
 		short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR18, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR18, &reg);
 	rt2x00_set_field32(&reg, CSR18_SIFS, SIFS);
 	rt2x00_set_field32(&reg, CSR18_PIFS,
 		short_slot_time ? SHORT_PIFS :  PIFS);
-	rt2x00_register_write(rt2x00dev, CSR18, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR18, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR19, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR19, &reg);
 	rt2x00_set_field32(&reg, CSR19_DIFS,
 		short_slot_time ? SHORT_DIFS : DIFS);
 	rt2x00_set_field32(&reg, CSR19_EIFS, EIFS);
-	rt2x00_register_write(rt2x00dev, CSR19, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR19, reg);
 
-	rt2x00_register_read(rt2x00dev, TXCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR1, &reg);
 	rt2x00_set_field32(&reg, TXCSR1_TSF_OFFSET, IEEE80211_HEADER);
 	rt2x00_set_field32(&reg, TXCSR1_AUTORESPONDER, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR1, reg);
+
+	rt2x00pci_register_read(rt2x00dev, CSR12, &reg);
+	rt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL, beacon_int * 16);
+	rt2x00_set_field32(&reg, CSR12_CFP_MAX_DURATION, beacon_int * 16);
+	rt2x00pci_register_write(rt2x00dev, CSR12, reg);
 }
 
 static void rt2400pci_config_rate(struct rt2x00_dev *rt2x00dev, const int rate)
@@ -608,42 +510,42 @@ static void rt2400pci_config_rate(struct
 		? SHORT_PREAMBLE : PREAMBLE;
 
 	reg = DEVICE_GET_RATE_FIELD(rate, RATEMASK) & DEV_BASIC_RATE;
-	rt2x00_register_write(rt2x00dev, ARCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, TXCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR1, &reg);
 	value = ((conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME) ?
 		 SHORT_DIFS :  DIFS) +
 		PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXCSR1_ACK_TIMEOUT, value);
 	value = SIFS + PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXCSR1_ACK_CONSUME_TIME, value);
-	rt2x00_register_write(rt2x00dev, TXCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR1, reg);
 
 	preamble = DEVICE_GET_RATE_FIELD(rate, PREAMBLE) ? 0x08 : 0x00;
 
-	rt2x00_register_read(rt2x00dev, ARCSR2, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR2, &reg);
 	rt2x00_set_field32(&reg, ARCSR2_SIGNAL, 0x00 | preamble);
 	rt2x00_set_field32(&reg, ARCSR2_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 10));
-	rt2x00_register_write(rt2x00dev, ARCSR2, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR2, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR3, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR3, &reg);
 	rt2x00_set_field32(&reg, ARCSR3_SIGNAL, 0x01 | preamble);
 	rt2x00_set_field32(&reg, ARCSR3_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 20));
-	rt2x00_register_write(rt2x00dev, ARCSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR3, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR4, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR4, &reg);
 	rt2x00_set_field32(&reg, ARCSR4_SIGNAL, 0x02 | preamble);
 	rt2x00_set_field32(&reg, ARCSR4_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 55));
-	rt2x00_register_write(rt2x00dev, ARCSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR4, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR5, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR5, &reg);
 	rt2x00_set_field32(&reg, ARCSR5_SIGNAL, 0x03 | preamble);
 	rt2x00_set_field32(&reg, ARCSR5_SERVICE, 0x84);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 110));
-	rt2x00_register_write(rt2x00dev, ARCSR5, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR5, reg);
 }
 
 static void rt2400pci_config_phymode(struct rt2x00_dev *rt2x00dev,
@@ -652,23 +554,12 @@ static void rt2400pci_config_phymode(str
 	struct ieee80211_hw_mode *mode;
 	struct ieee80211_rate *rate;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.phymode == phymode)
-		return;
-
 	rt2x00dev->curr_hwmode = HWMODE_B;
 
 	mode = &rt2x00dev->hwmodes[rt2x00dev->curr_hwmode];
 	rate = &mode->rates[mode->num_rates - 1];
 
 	rt2400pci_config_rate(rt2x00dev, rate->val2);
-
-	/*
-	 * Update physical mode for rx ring.
-	 */
-	rt2x00dev->rx_status.phymode = phymode;
 }
 
 static void rt2400pci_config_mac_addr(struct rt2x00_dev *rt2x00dev, u8 *addr)
@@ -682,7 +573,7 @@ static void rt2400pci_config_mac_addr(st
 	 * The MAC address is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, CSR3, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, CSR3, &reg, sizeof(reg));
 }
 
 /*
@@ -692,7 +583,7 @@ static void rt2400pci_enable_led(struct 
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, LEDCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, LEDCSR, &reg);
 
 	rt2x00_set_field32(&reg, LEDCSR_ON_PERIOD, 70);
 	rt2x00_set_field32(&reg, LEDCSR_OFF_PERIOD, 30);
@@ -708,23 +599,23 @@ static void rt2400pci_enable_led(struct 
 		rt2x00_set_field32(&reg, LEDCSR_ACTIVITY, 1);
 	}
 
-	rt2x00_register_write(rt2x00dev, LEDCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, LEDCSR, reg);
 }
 
 static void rt2400pci_disable_led(struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, LEDCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, LEDCSR, &reg);
 	rt2x00_set_field32(&reg, LEDCSR_LINK, 0);
 	rt2x00_set_field32(&reg, LEDCSR_ACTIVITY, 0);
-	rt2x00_register_write(rt2x00dev, LEDCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, LEDCSR, reg);
 }
 
 /*
  * Link tuning
  */
-static void rt2400pci_link_tuner(struct rt2x00_dev *rt2x00dev, int rssi)
+static void rt2400pci_link_tuner(struct rt2x00_dev *rt2x00dev)
 {
 	u8 reg;
 	char false_cca_delta;
@@ -733,13 +624,13 @@ static void rt2400pci_link_tuner(struct 
 	 * The link tuner should not run longer then 60 seconds,
 	 * and should run once every 2 seconds.
 	 */
-	if (rt2x00dev->link.count > 60 || !(rt2x00dev->link.count % 1))
+	if (rt2x00dev->link.count > 60 || !(rt2x00dev->link.count & 1))
 		return;
 
 	/*
 	 * Read false CCA counter.
 	 */
-	rt2x00_bbp_read(rt2x00dev, 39, &reg);
+	rt2400pci_bbp_read(rt2x00dev, 39, &reg);
 
 	/*
 	 * Determine difference with previous CCA counter.
@@ -755,39 +646,37 @@ static void rt2400pci_link_tuner(struct 
 		/*
 		 * Read and update RX AGC VGC.
 		 */
-		rt2x00_bbp_read(rt2x00dev, 13, &reg);
+		rt2400pci_bbp_read(rt2x00dev, 13, &reg);
 		reg += 2;
 		if (reg < 0x20)
-			rt2x00_bbp_write(rt2x00dev, 13, reg);
+			rt2400pci_bbp_write(rt2x00dev, 13, reg);
+		rt2x00dev->rx_status.noise = reg;
 	}
 }
 
 /*
  * Initialization functions.
  */
-static void rt2400pci_init_rxring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+static void rt2400pci_init_rxring(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
 	struct data_desc *rxd;
 	unsigned int i;
 	u32 word;
 
-	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
-
-	ring->type = ring_type;
+	memset(rt2x00dev->rx->data_addr, 0x00,
+		rt2x00_get_ring_size(rt2x00dev->rx));
 
-	for (i = 0; i < ring->stats.limit; i++) {
-		rxd = ring->entry[i].priv;
+	for (i = 0; i < rt2x00dev->rx->stats.limit; i++) {
+		rxd = rt2x00dev->rx->entry[i].priv;
 
 		rt2x00_desc_read(rxd, 2, &word);
 		rt2x00_set_field32(&word, RXD_W2_BUFFER_LENGTH,
-			ring->data_size);
+			rt2x00dev->rx->data_size);
 		rt2x00_desc_write(rxd, 2, word);
 
 		rt2x00_desc_read(rxd, 1, &word);
 		rt2x00_set_field32(&word, RXD_W1_BUFFER_ADDRESS,
-			ring->entry[i].data_dma);
+			rt2x00dev->rx->entry[i].data_dma);
 		rt2x00_desc_write(rxd, 1, word);
 
 		rt2x00_desc_read(rxd, 0, &word);
@@ -795,21 +684,19 @@ static void rt2400pci_init_rxring(struct
 		rt2x00_desc_write(rxd, 0, word);
 	}
 
-	rt2x00_ring_index_clear(ring);
+	rt2x00_ring_index_clear(rt2x00dev->rx);
 }
 
 static void rt2400pci_init_txring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+	const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_desc *txd;
 	unsigned int i;
 	u32 word;
 
 	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
 
-	ring->type = ring_type;
-
 	for (i = 0; i < ring->stats.limit; i++) {
 		txd = ring->entry[i].priv;
 
@@ -839,57 +726,57 @@ static int rt2400pci_init_rings(struct r
 	/*
 	 * Initialize rings.
 	 */
-	rt2400pci_init_rxring(rt2x00dev, RING_RX);
-	rt2400pci_init_txring(rt2x00dev, RING_TX);
-	rt2400pci_init_txring(rt2x00dev, RING_ATIM);
-	rt2400pci_init_txring(rt2x00dev, RING_PRIO);
-	rt2400pci_init_txring(rt2x00dev, RING_BEACON);
+	rt2400pci_init_rxring(rt2x00dev);
+	rt2400pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA0);
+	rt2400pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA1);
+	rt2400pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_AFTER_BEACON);
+	rt2400pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * Initialize registers.
 	 */
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR2, &reg);
 	rt2x00_set_field32(&reg, TXCSR2_TXD_SIZE,
-		rt2x00dev->ring[RING_TX].desc_size);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].desc_size);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_TXD,
-		rt2x00dev->ring[RING_TX].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].stats.limit);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_ATIM,
-		rt2x00dev->ring[RING_ATIM].stats.limit);
+		rt2x00dev->bcn[1].stats.limit);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_PRIO,
-		rt2x00dev->ring[RING_PRIO].stats.limit);
-	rt2x00_register_write(rt2x00dev, TXCSR2, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].stats.limit);
+	rt2x00pci_register_write(rt2x00dev, TXCSR2, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR3, &reg);
 	rt2x00_set_field32(&reg, TXCSR3_TX_RING_REGISTER,
-		rt2x00dev->ring[RING_TX].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR3, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR3, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR5, &reg);
 	rt2x00_set_field32(&reg, TXCSR5_PRIO_RING_REGISTER,
-		rt2x00dev->ring[RING_PRIO].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR5, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR5, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR4, &reg);
 	rt2x00_set_field32(&reg, TXCSR4_ATIM_RING_REGISTER,
-		rt2x00dev->ring[RING_ATIM].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR4, reg);
+		rt2x00dev->bcn[1].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR4, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR6, &reg);
 	rt2x00_set_field32(&reg, TXCSR6_BEACON_RING_REGISTER,
-		rt2x00dev->ring[RING_BEACON].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR6, reg);
+		rt2x00dev->bcn[0].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR6, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RXCSR1, &reg);
 	rt2x00_set_field32(&reg, RXCSR1_RXD_SIZE,
-		rt2x00dev->ring[RING_RX].desc_size);
+		rt2x00dev->rx->desc_size);
 	rt2x00_set_field32(&reg, RXCSR1_NUM_RXD,
-		rt2x00dev->ring[RING_RX].stats.limit);
-	rt2x00_register_write(rt2x00dev, RXCSR1, reg);
+		rt2x00dev->rx->stats.limit);
+	rt2x00pci_register_write(rt2x00dev, RXCSR1, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RXCSR2, &reg);
 	rt2x00_set_field32(&reg, RXCSR2_RX_RING_REGISTER,
-		rt2x00dev->ring[RING_RX].data_dma);
-	rt2x00_register_write(rt2x00dev, RXCSR2, reg);
+		rt2x00dev->rx->data_dma);
+	rt2x00pci_register_write(rt2x00dev, RXCSR2, reg);
 
 	return 0;
 }
@@ -901,34 +788,34 @@ static int rt2400pci_init_registers(stru
 	if (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))
 		return -EBUSY;
 
-	rt2x00_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);
 
-	rt2x00_register_write(rt2x00dev, PSCSR0, 0x00020002);
-	rt2x00_register_write(rt2x00dev, PSCSR1, 0x00000002);
-	rt2x00_register_write(rt2x00dev, PSCSR2, 0x00020002);
-	rt2x00_register_write(rt2x00dev, PSCSR3, 0x00000002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR0, 0x00020002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR1, 0x00000002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR2, 0x00020002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR3, 0x00000002);
 
-	rt2x00_register_read(rt2x00dev, TIMECSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, TIMECSR, &reg);
 	rt2x00_set_field32(&reg, TIMECSR_US_COUNT, 33);
 	rt2x00_set_field32(&reg, TIMECSR_US_64_COUNT, 63);
 	rt2x00_set_field32(&reg, TIMECSR_BEACON_EXPECT, 0);
-	rt2x00_register_write(rt2x00dev, TIMECSR, reg);
+	rt2x00pci_register_write(rt2x00dev, TIMECSR, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR9, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR9, &reg);
 	rt2x00_set_field32(&reg, CSR9_MAX_FRAME_UNIT,
-		(rt2x00dev->ring[RING_RX].data_size / 128));
-	rt2x00_register_write(rt2x00dev, CSR9, reg);
+		(rt2x00dev->rx->data_size / 128));
+	rt2x00pci_register_write(rt2x00dev, CSR9, reg);
 
-	rt2x00_register_write(rt2x00dev, CNT3, 0x3f080000);
+	rt2x00pci_register_write(rt2x00dev, CNT3, 0x3f080000);
 
-	rt2x00_register_write(rt2x00dev, MACCSR0, 0x00217223);
-	rt2x00_register_write(rt2x00dev, MACCSR1, 0x00235518);
+	rt2x00pci_register_write(rt2x00dev, MACCSR0, 0x00217223);
+	rt2x00pci_register_write(rt2x00dev, MACCSR1, 0x00235518);
 
-	rt2x00_register_read(rt2x00dev, MACCSR2, &reg);
+	rt2x00pci_register_read(rt2x00dev, MACCSR2, &reg);
 	rt2x00_set_field32(&reg, MACCSR2_DELAY, 64);
-	rt2x00_register_write(rt2x00dev, MACCSR2, reg);
+	rt2x00pci_register_write(rt2x00dev, MACCSR2, reg);
 
-	rt2x00_register_read(rt2x00dev, RXCSR3, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR3, &reg);
 	/*
 	 * Tx power.
 	 */
@@ -944,33 +831,33 @@ static int rt2400pci_init_registers(stru
 	 */
 	rt2x00_set_field32(&reg, RXCSR3_BBP_ID2, 36);
 	rt2x00_set_field32(&reg, RXCSR3_BBP_ID2_VALID, 1);
-	rt2x00_register_write(rt2x00dev, RXCSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR3, reg);
 
-	rt2x00_register_read(rt2x00dev, RALINKCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, RALINKCSR, &reg);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA0, 17);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID0, 154);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA1, 0);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID1, 154);
-	rt2x00_register_write(rt2x00dev, RALINKCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, RALINKCSR, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR1, &reg);
 	rt2x00_set_field32(&reg, CSR1_SOFT_RESET, 1);
 	rt2x00_set_field32(&reg, CSR1_BBP_RESET, 0);
 	rt2x00_set_field32(&reg, CSR1_HOST_READY, 0);
-	rt2x00_register_write(rt2x00dev, CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR1, &reg);
 	rt2x00_set_field32(&reg, CSR1_SOFT_RESET, 0);
 	rt2x00_set_field32(&reg, CSR1_HOST_READY, 1);
-	rt2x00_register_write(rt2x00dev, CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR1, reg);
 
 	/*
 	 * We must clear the FCS and FIFO error count.
 	 * These registers are cleared on read,
 	 * so we may pass a useless variable to store the value.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &reg);
-	rt2x00_register_read(rt2x00dev, CNT4, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT4, &reg);
 
 	return 0;
 }
@@ -983,7 +870,7 @@ static int rt2400pci_init_bbp(struct rt2
 	u8 value;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_bbp_read(rt2x00dev, 0, &value);
+		rt2400pci_bbp_read(rt2x00dev, 0, &value);
 		if ((value != 0xff) && (value != 0x00))
 			goto continue_csr_init;
 		NOTICE(rt2x00dev, "Waiting for BBP register.\n");
@@ -994,21 +881,21 @@ static int rt2400pci_init_bbp(struct rt2
 	return -EACCES;
 
 continue_csr_init:
-	rt2x00_bbp_write(rt2x00dev, 1, 0x00);
-	rt2x00_bbp_write(rt2x00dev, 3, 0x27);
-	rt2x00_bbp_write(rt2x00dev, 4, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 10, 0x0f);
-	rt2x00_bbp_write(rt2x00dev, 13, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 15, 0x72);
-	rt2x00_bbp_write(rt2x00dev, 16, 0x74);
-	rt2x00_bbp_write(rt2x00dev, 17, 0x20);
-	rt2x00_bbp_write(rt2x00dev, 18, 0x72);
-	rt2x00_bbp_write(rt2x00dev, 19, 0x0b);
-	rt2x00_bbp_write(rt2x00dev, 20, 0x00);
-	rt2x00_bbp_write(rt2x00dev, 28, 0x11);
-	rt2x00_bbp_write(rt2x00dev, 29, 0x04);
-	rt2x00_bbp_write(rt2x00dev, 30, 0x21);
-	rt2x00_bbp_write(rt2x00dev, 31, 0x00);
+	rt2400pci_bbp_write(rt2x00dev, 1, 0x00);
+	rt2400pci_bbp_write(rt2x00dev, 3, 0x27);
+	rt2400pci_bbp_write(rt2x00dev, 4, 0x08);
+	rt2400pci_bbp_write(rt2x00dev, 10, 0x0f);
+	rt2400pci_bbp_write(rt2x00dev, 13, 0x08);
+	rt2400pci_bbp_write(rt2x00dev, 15, 0x72);
+	rt2400pci_bbp_write(rt2x00dev, 16, 0x74);
+	rt2400pci_bbp_write(rt2x00dev, 17, 0x20);
+	rt2400pci_bbp_write(rt2x00dev, 18, 0x72);
+	rt2400pci_bbp_write(rt2x00dev, 19, 0x0b);
+	rt2400pci_bbp_write(rt2x00dev, 20, 0x00);
+	rt2400pci_bbp_write(rt2x00dev, 28, 0x11);
+	rt2400pci_bbp_write(rt2x00dev, 29, 0x04);
+	rt2400pci_bbp_write(rt2x00dev, 30, 0x21);
+	rt2400pci_bbp_write(rt2x00dev, 31, 0x00);
 
 	DEBUG(rt2x00dev, "Start initialization from EEPROM...\n");
 	for (i = 0; i < EEPROM_BBP_SIZE; i++) {
@@ -1019,7 +906,7 @@ continue_csr_init:
 			value = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);
 			DEBUG(rt2x00dev, "BBP: 0x%02x, value: 0x%02x.\n",
 				reg_id, value);
-			rt2x00_bbp_write(rt2x00dev, reg_id, value);
+			rt2400pci_bbp_write(rt2x00dev, reg_id, value);
 		}
 	}
 	DEBUG(rt2x00dev, "...End initialization from EEPROM.\n");
@@ -1035,17 +922,41 @@ static void rt2400pci_toggle_rx(struct r
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
 	rt2x00_set_field32(&reg, RXCSR0_DISABLE_RX,
 		state == STATE_RADIO_RX_OFF);
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 }
 
-static int rt2400pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+static void rt2400pci_toggle_irq(struct rt2x00_dev *rt2x00dev, int enabled)
 {
 	u32 reg;
 
 	/*
+	 * When interrupts are being enabled, the interrupt registers
+	 * should clear the register to assure a clean state.
+	 */
+	if (enabled) {
+		rt2x00pci_register_read(rt2x00dev, CSR7, &reg);
+		rt2x00pci_register_write(rt2x00dev, CSR7, reg);
+	}
+
+	/*
+	 * Only toggle the interrupts bits we are going to use.
+	 * Non-checked interrupt bits are disabled by default.
+	 */
+	rt2x00pci_register_read(rt2x00dev, CSR8, &reg);
+	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_RXDONE, !enabled);
+	rt2x00pci_register_write(rt2x00dev, CSR8, reg);
+}
+
+static int rt2400pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+{
+	/*
 	 * Initialize all registers.
 	 */
 	if (rt2400pci_init_rings(rt2x00dev) ||
@@ -1056,21 +967,9 @@ static int rt2400pci_enable_radio(struct
 	}
 
 	/*
-	 * Clear interrupts.
-	 */
-	rt2x00_register_read(rt2x00dev, CSR7, &reg);
-	rt2x00_register_write(rt2x00dev, CSR7, reg);
-
-	/*
 	 * Enable interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR8, &reg);
-	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 0);
-	rt2x00_set_field32(&reg, CSR8_RXDONE, 0);
-	rt2x00_register_write(rt2x00dev, CSR8, reg);
+	rt2400pci_toggle_irq(rt2x00dev, 1);
 
 	/*
 	 * Enable LED
@@ -1089,30 +988,24 @@ static void rt2400pci_disable_radio(stru
 	 */
 	rt2400pci_disable_led(rt2x00dev);
 
-	rt2x00_register_write(rt2x00dev, PWRCSR0, 0);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0);
 
 	/*
 	 * Disable synchronisation.
 	 */
-	rt2x00_register_write(rt2x00dev, CSR14, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR14, 0);
 
 	/*
 	 * Cancel RX and TX.
 	 */
-	rt2x00_register_read(rt2x00dev, TXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR0, &reg);
 	rt2x00_set_field32(&reg, TXCSR0_ABORT, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR0, reg);
 
 	/*
 	 * Disable interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR8, &reg);
-	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 1);
-	rt2x00_set_field32(&reg, CSR8_RXDONE, 1);
-	rt2x00_register_write(rt2x00dev, CSR8, reg);
+	rt2400pci_toggle_irq(rt2x00dev, 0);
 }
 
 static int rt2400pci_set_state(struct rt2x00_dev *rt2x00dev,
@@ -1126,12 +1019,12 @@ static int rt2400pci_set_state(struct rt
 
 	put_to_sleep = (state != STATE_AWAKE);
 
-	rt2x00_register_read(rt2x00dev, PWRCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, PWRCSR1, &reg);
 	rt2x00_set_field32(&reg, PWRCSR1_SET_STATE, 1);
 	rt2x00_set_field32(&reg, PWRCSR1_BBP_DESIRE_STATE, state);
 	rt2x00_set_field32(&reg, PWRCSR1_RF_DESIRE_STATE, state);
 	rt2x00_set_field32(&reg, PWRCSR1_PUT_TO_SLEEP, put_to_sleep);
-	rt2x00_register_write(rt2x00dev, PWRCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR1, reg);
 
 	/*
 	 * Device is not guaranteed to be in the requested state yet.
@@ -1139,7 +1032,7 @@ static int rt2400pci_set_state(struct rt
 	 * device has entered the correct state.
 	 */
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PWRCSR1, &reg);
+		rt2x00pci_register_read(rt2x00dev, PWRCSR1, &reg);
 		bbp_state = rt2x00_get_field32(reg, PWRCSR1_BBP_CURR_STATE);
 		rf_state = rt2x00_get_field32(reg, PWRCSR1_RF_CURR_STATE);
 		if (bbp_state == state && rf_state == state)
@@ -1193,16 +1086,30 @@ static void rt2400pci_write_tx_desc(stru
 	unsigned int length, struct ieee80211_tx_control *control)
 {
 	u32 word;
-
-	/*
-	 * Create the signal and service values, the values should
-	 * be stored as if it was a BBP register with the busy bit
-	 * and register number.
-	 */
-	desc->signal |= 0x8500;
-	desc->service |= 0x8600;
-	desc->length_high |= 0x8700;
-	desc->length_low |= 0x8800;
+	u32 signal = 0;
+	u32 service = 0;
+	u32 length_high = 0;
+	u32 length_low = 0;
+
+	/*
+	 * The PLCP values should be treated as if they
+	 * were BBP values.
+	 */
+	rt2x00_set_field32(&signal, BBPCSR_VALUE, desc->signal);
+	rt2x00_set_field32(&signal, BBPCSR_REGNUM, 5);
+	rt2x00_set_field32(&signal, BBPCSR_BUSY, 1);
+
+	rt2x00_set_field32(&service, BBPCSR_VALUE, desc->service);
+	rt2x00_set_field32(&service, BBPCSR_REGNUM, 6);
+	rt2x00_set_field32(&service, BBPCSR_BUSY, 1);
+
+	rt2x00_set_field32(&length_high, BBPCSR_VALUE, desc->length_high);
+	rt2x00_set_field32(&length_high, BBPCSR_REGNUM, 7);
+	rt2x00_set_field32(&length_high, BBPCSR_BUSY, 1);
+
+	rt2x00_set_field32(&length_low, BBPCSR_VALUE, desc->length_low);
+	rt2x00_set_field32(&length_low, BBPCSR_REGNUM, 8);
+	rt2x00_set_field32(&length_low, BBPCSR_BUSY, 1);
 
 	/*
 	 * Start writing the descriptor words.
@@ -1212,13 +1119,13 @@ static void rt2400pci_write_tx_desc(stru
 	rt2x00_desc_write(txd, 2, word);
 
 	rt2x00_desc_read(txd, 3, &word);
-	rt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL, desc->signal);
-	rt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE, desc->service);
+	rt2x00_set_field32(&word, TXD_W3_PLCP_SIGNAL, signal);
+	rt2x00_set_field32(&word, TXD_W3_PLCP_SERVICE, service);
 	rt2x00_desc_write(txd, 3, word);
 
 	rt2x00_desc_read(txd, 4, &word);
-	rt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_LOW, desc->length_low);
-	rt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_HIGH, desc->length_high);
+	rt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_LOW, length_low);
+	rt2x00_set_field32(&word, TXD_W4_PLCP_LENGTH_HIGH, length_high);
 	rt2x00_desc_write(txd, 4, word);
 
 	rt2x00_desc_read(txd, 0, &word);
@@ -1245,81 +1152,62 @@ static void rt2400pci_kick_tx_queue(stru
 	u32 reg;
 
 	if (queue == IEEE80211_TX_QUEUE_BEACON) {
-		rt2x00_register_read(rt2x00dev, CSR14, &reg);
+		rt2x00pci_register_read(rt2x00dev, CSR14, &reg);
 		if (!rt2x00_get_field32(reg, CSR14_BEACON_GEN)) {
 			rt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);
-			rt2x00_register_write(rt2x00dev, CSR14, reg);
+			rt2x00pci_register_write(rt2x00dev, CSR14, reg);
 		}
 		return;
 	}
 
-	rt2x00_register_read(rt2x00dev, TXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR0, &reg);
 	if (queue == IEEE80211_TX_QUEUE_DATA0)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_PRIO, 1);
 	else if (queue == IEEE80211_TX_QUEUE_DATA1)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_TX, 1);
 	else if (queue == IEEE80211_TX_QUEUE_AFTER_BEACON)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_ATIM, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR0, reg);
 }
 
 /*
- * Interrupt functions.
+ * RX control handlers
  */
-static void rt2400pci_rxdone(struct rt2x00_dev *rt2x00dev, int queue)
+static int rt2400pci_fill_rxdone(struct data_entry *entry,
+	int *signal, int *rssi, int *ofdm)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
-	struct data_entry *entry;
-	struct data_desc *rxd;
+	struct data_desc *rxd = entry->priv;
 	u32 word0;
 	u32 word2;
-	int signal;
-	int rssi;
-	u16 size;
-
-	while (1) {
-		entry = rt2x00_get_data_entry(ring);
-		rxd = entry->priv;
-		rt2x00_desc_read(rxd, 0, &word0);
-		rt2x00_desc_read(rxd, 2, &word2);
-
-		if (rt2x00_get_field32(word0, RXD_W0_OWNER_NIC))
-			break;
-
-		/*
-		 * TODO: Don't we need to keep statistics
-		 * updated about events like CRC and physical errors?
-		 */
-		if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
-		    rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))
-			goto skip_entry;
 
-		/*
-		 * Obtain the status about this packet.
-		 */
-		size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
-		signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL);
-		rssi = rt2x00_get_field32(word2, RXD_W2_RSSI);
+	rt2x00_desc_read(rxd, 0, &word0);
+	rt2x00_desc_read(rxd, 2, &word2);
 
-		/*
-		 * Send the packet to upper layer.
-		 */
-		rt2x00lib_rxdone(entry, entry->data_addr, size,
-			signal, rssi, 0);
+	/*
+	 * TODO: Don't we need to keep statistics
+	 * updated about these errors?
+	 */
+	if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
+	    rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))
+		return -EINVAL;
 
-skip_entry:
-		if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
-			rt2x00_set_field32(&word0, RXD_W0_OWNER_NIC, 1);
-			rt2x00_desc_write(rxd, 0, word0);
-		}
+	/*
+	 * Obtain the status about this packet.
+	 */
+	*signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL);
+	*rssi = rt2x00_get_field32(word2, RXD_W2_RSSI) -
+		entry->ring->rt2x00dev->rssi_offset;
+	*ofdm = 0;
 
-		rt2x00_ring_index_inc(ring);
-	}
+	return rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
 }
 
+/*
+ * Interrupt functions.
+ */
 static void rt2400pci_txdone(struct rt2x00_dev *rt2x00dev, const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_entry *entry;
 	struct data_desc *txd;
 	u32 word;
@@ -1372,8 +1260,8 @@ static irqreturn_t rt2400pci_interrupt(i
 	 * Get the interrupt sources & saved to local variable.
 	 * Write register value back to clear pending interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR7, &reg);
-	rt2x00_register_write(rt2x00dev, CSR7, reg);
+	rt2x00pci_register_read(rt2x00dev, CSR7, &reg);
+	rt2x00pci_register_write(rt2x00dev, CSR7, reg);
 
 	if (!reg)
 		return IRQ_NONE;
@@ -1391,31 +1279,31 @@ static irqreturn_t rt2400pci_interrupt(i
 	 * 1 - Beacon timer expired interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TBCN_EXPIRE))
-		rt2x00pci_beacondone(rt2x00dev, RING_BEACON);
+		rt2x00pci_beacondone(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * 2 - Rx ring done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_RXDONE))
-		rt2400pci_rxdone(rt2x00dev, RING_RX);
+		rt2x00pci_rxdone(rt2x00dev);
 
 	/*
 	 * 3 - Atim ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_ATIMRING))
-		rt2400pci_txdone(rt2x00dev, RING_ATIM);
+		rt2400pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_AFTER_BEACON);
 
 	/*
 	 * 4 - Priority ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_PRIORING))
-		rt2400pci_txdone(rt2x00dev, RING_PRIO);
+		rt2400pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_DATA0);
 
 	/*
 	 * 5 - Tx ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_TXRING))
-		rt2400pci_txdone(rt2x00dev, RING_TX);
+		rt2400pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_DATA1);
 
 	return IRQ_HANDLED;
 }
@@ -1428,6 +1316,7 @@ static int rt2400pci_alloc_eeprom(struct
 	struct eeprom_93cx6 eeprom;
 	u32 reg;
 	u16 word;
+	u8 *mac;
 
 	/*
 	 * Allocate the eeprom memory, check the eeprom width
@@ -1437,7 +1326,7 @@ static int rt2400pci_alloc_eeprom(struct
 	if (!rt2x00dev->eeprom)
 		return -ENOMEM;
 
-	rt2x00_register_read(rt2x00dev, CSR21, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR21, &reg);
 
 	eeprom.data = rt2x00dev;
 	eeprom.register_read = rt2400pci_eepromregister_read;
@@ -1455,6 +1344,12 @@ static int rt2400pci_alloc_eeprom(struct
 	/*
 	 * Start validation of the data that has been read.
 	 */
+	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+	if (!is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		EEPROM(rt2x00dev, "MAC: " MAC_FMT "\n", MAC_ARG(mac));
+	}
+
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);
 	if (word == 0xffff) {
 		ERROR(rt2x00dev, "Invalid EEPROM data detected.\n");
@@ -1479,7 +1374,7 @@ static int rt2400pci_init_eeprom(struct 
 	 * Identify RF chipset.
 	 */
 	value = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);
-	rt2x00_register_read(rt2x00dev, CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR0, &reg);
 	rt2x00_set_chip(rt2x00dev, RT2460, value, reg);
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF2420) &&
@@ -1541,16 +1436,16 @@ static void rt2400pci_init_hw_mode(struc
 		IEEE80211_HW_WEP_INCLUDE_IV |
 		IEEE80211_HW_DATA_NULLFUNC_ACK |
 		IEEE80211_HW_NO_TKIP_WMM_HWACCEL |
-		IEEE80211_HW_MONITOR_DURING_OPER;
+		IEEE80211_HW_MONITOR_DURING_OPER |
+		IEEE80211_HW_NO_PROBE_FILTERING;
 	rt2x00dev->hw->extra_tx_headroom = 0;
 	rt2x00dev->hw->max_rssi = MAX_RX_SSI;
 	rt2x00dev->hw->max_noise = MAX_RX_NOISE;
-	rt2x00dev->hw->queues = RING_NUM_TX;
+	rt2x00dev->hw->queues = 2;
 
-	/*
-	 * This device supports ATIM
-	 */
-	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	SET_IEEE80211_DEV(rt2x00dev->hw, &rt2x00dev_pci(rt2x00dev)->dev);
+	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
+		rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0));
 
 	/*
 	 * Set device specific, but channel independent RF values.
@@ -1571,7 +1466,6 @@ static void rt2400pci_init_hw_mode(struc
 	/*
 	 * Initialize hw_mode information.
 	 */
-	spec->mac_addr = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
 	spec->num_modes = 1;
 	spec->num_rates = 4;
 	spec->num_channels = 14;
@@ -1602,6 +1496,16 @@ static int rt2400pci_init_hw(struct rt2x
 	 */
 	rt2400pci_init_hw_mode(rt2x00dev);
 
+	/*
+	 * This device supports ATIM
+	 */
+	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+
+	/*
+	 * Set the rssi offset.
+	 */
+	rt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;
+
 	return 0;
 }
 
@@ -1619,7 +1523,7 @@ static int rt2400pci_get_stats(struct ie
 	 * The dot11ACKFailureCount, dot11RTSFailureCount and
 	 * dot11RTSSuccessCount are updated in interrupt time.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &reg);
 	rt2x00dev->low_level_stats.dot11FCSErrorCount +=
 		rt2x00_get_field32(reg, CNT0_FCS_ERROR);
 
@@ -1634,10 +1538,10 @@ static int rt2400pci_set_retry_limit(str
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_LONG_RETRY, long_retry);
 	rt2x00_set_field32(&reg, CSR11_SHORT_RETRY, short_retry);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 
 	return 0;
 }
@@ -1646,7 +1550,6 @@ static int rt2400pci_conf_tx(struct ieee
 	int queue, const struct ieee80211_tx_queue_params *params)
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
-	struct data_ring *ring = &rt2x00dev->ring[RING_PRIO];
 
 	/*
 	 * We don't support variating cw_min and cw_max variables
@@ -1662,7 +1565,7 @@ static int rt2400pci_conf_tx(struct ieee
 	/*
 	 * Write configuration to register.
 	 */
-	rt2400pci_config_cw(rt2x00dev, &ring->tx_params);
+	rt2400pci_config_cw(rt2x00dev, &rt2x00dev->tx->tx_params);
 
 	return 0;
 }
@@ -1673,9 +1576,9 @@ static u64 rt2400pci_get_tsf(struct ieee
 	u64 tsf;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR17, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR17, &reg);
 	tsf = (u64)rt2x00_get_field32(reg, CSR17_HIGH_TSFTIMER) << 32;
-	rt2x00_register_read(rt2x00dev, CSR16, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR16, &reg);
 	tsf |= rt2x00_get_field32(reg, CSR16_LOW_TSFTIMER);
 
 	return tsf;
@@ -1685,8 +1588,8 @@ static void rt2400pci_reset_tsf(struct i
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
-	rt2x00_register_write(rt2x00dev, CSR16, 0);
-	rt2x00_register_write(rt2x00dev, CSR17, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR16, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR17, 0);
 }
 
 static int rt2400pci_tx_last_beacon(struct ieee80211_hw *hw)
@@ -1694,15 +1597,13 @@ static int rt2400pci_tx_last_beacon(stru
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR15, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR15, &reg);
 	return rt2x00_get_field32(reg, CSR15_BEACON_SENT);
 }
 
 static const struct ieee80211_ops rt2400pci_mac80211_ops = {
 	.tx			= rt2x00lib_tx,
 	.reset			= rt2x00lib_reset,
-	.open			= rt2x00lib_open,
-	.stop			= rt2x00lib_stop,
 	.add_interface		= rt2x00lib_add_interface,
 	.remove_interface	= rt2x00lib_remove_interface,
 	.config			= rt2x00lib_config,
@@ -1731,6 +1632,7 @@ static const struct rt2x00lib_ops rt2400
 	.write_tx_desc		= rt2400pci_write_tx_desc,
 	.write_tx_data		= rt2x00pci_write_tx_data,
 	.kick_tx_queue		= rt2400pci_kick_tx_queue,
+	.fill_rxdone		= rt2400pci_fill_rxdone,
 	.config_type		= rt2400pci_config_type,
 	.config_phymode		= rt2400pci_config_phymode,
 	.config_channel		= rt2400pci_config_channel,
@@ -1768,12 +1670,6 @@ MODULE_SUPPORTED_DEVICE("Ralink RT2460 P
 MODULE_DEVICE_TABLE(pci, rt2400pci_device_table);
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
-
 static struct pci_driver rt2400pci_driver = {
 	.name		= DRV_NAME,
 	.id_table	= rt2400pci_device_table,
@@ -1787,14 +1683,11 @@ static struct pci_driver rt2400pci_drive
 
 static int __init rt2400pci_init(void)
 {
-	printk(KERN_INFO "Loading module: %s - %s by %s.\n",
-		DRV_NAME, DRV_VERSION, DRV_PROJECT);
 	return pci_register_driver(&rt2400pci_driver);
 }
 
 static void __exit rt2400pci_exit(void)
 {
-	printk(KERN_INFO "Unloading module: %s.\n", DRV_NAME);
 	pci_unregister_driver(&rt2400pci_driver);
 }
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt2400pci.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2400pci.h	2007-07-09 21:00:13.000000000 +0200
@@ -34,10 +34,11 @@
 #define RF2421				0x0001
 
 /*
- * Max RSSI value, required for RSSI <-> dBm conversion.
+ * Signal information.
  */
-#define MAX_RX_SSI			100
+#define MAX_RX_SSI			-1
 #define MAX_RX_NOISE			-110
+#define DEFAULT_RSSI_OFFSET		100
 
 /*
  * Register layout information.
@@ -776,6 +777,21 @@
 #define EEPROM_TXPOWER_2		FIELD16(0xff00)
 
 /*
+ * BBP content.
+ * The wordsize of the BBP is 8 bits.
+ */
+
+/*
+ * BBP_R1: TX antenna control
+ */
+#define BBP_R1_TX_ANTENNA		FIELD8(0x03)
+
+/*
+ * BBP_R4: RX antenna control
+ */
+#define BBP_R4_RX_ANTENNA		FIELD8(0x06)
+
+/*
  * DMA descriptor defines.
  */
 #define TXD_DESC_SIZE			( 8 * sizeof(struct data_desc) )
@@ -888,19 +904,6 @@
 #define RXD_W7_RESERVED			FIELD32(0xffffffff)
 
 /*
- * TX ring index number for rt2x00_dev structure.
- */
-enum ring_index {
-	RING_PRIO = 0,
-	RING_TX = 1,
-	RING_ATIM = 2,
-	RING_BEACON = 3,
-	RING_RX = 4,
-	RING_NUM = 5,
-	RING_NUM_TX = 2,
-};
-
-/*
  * Macro's for converting txpower from EEPROM to dscape value
  * and from dscape value to register value.
  * NOTE: Logics in rt2400pci for txpower are reversed
--- a/drivers/net/wireless/mac80211/rt2x00/rt2500pci.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2500pci.c	2007-07-09 21:00:13.000000000 +0200
@@ -42,13 +42,14 @@
 #include <asm/io.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00pci.h"
 #include "rt2500pci.h"
 
 /*
  * Register access.
  * All access to the CSR registers will go through the methods
- * rt2x00_register_read and rt2x00_register_write.
+ * rt2x00pci_register_read and rt2x00pci_register_write.
  * BBP and RF register require indirect register access,
  * and use the CSR registers BBPCSR and RFCSR to achieve this.
  * These indirect registers work with busy bits,
@@ -58,50 +59,22 @@
  * the access attempt is considered to have failed,
  * and we will print an error.
  */
-static inline void rt2x00_register_read(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 *value)
-{
-	*value = readl(rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiread(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	memcpy_fromio(value, rt2x00dev->csr_addr + offset, length);
-}
-
-static inline void rt2x00_register_write(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 value)
-{
-	writel(value, rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiwrite(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	memcpy_toio(rt2x00dev->csr_addr + offset, value, length);
-}
-
-static u32 rt2x00_bbp_check(const struct rt2x00_dev *rt2x00dev)
+static u32 rt2500pci_bbp_check(const struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, BBPCSR, &reg);
+		rt2x00pci_register_read(rt2x00dev, BBPCSR, &reg);
 		if (!rt2x00_get_field32(reg, BBPCSR_BUSY))
-			return reg;
+			break;
 		udelay(REGISTER_BUSY_DELAY);
 	}
 
-	return 0xffff;
+	return reg;
 }
 
-static void rt2x00_bbp_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2500pci_bbp_write(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, const u8 value)
 {
 	u32 reg;
@@ -109,7 +82,8 @@ static void rt2x00_bbp_write(const struc
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2500pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Write failed.\n");
 		return;
 	}
@@ -123,10 +97,10 @@ static void rt2x00_bbp_write(const struc
 	rt2x00_set_field32(&reg, BBPCSR_BUSY, 1);
 	rt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 1);
 
-	rt2x00_register_write(rt2x00dev, BBPCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, BBPCSR, reg);
 }
 
-static void rt2x00_bbp_read(const struct rt2x00_dev *rt2x00dev,
+static void rt2500pci_bbp_read(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, u8 *value)
 {
 	u32 reg;
@@ -134,7 +108,8 @@ static void rt2x00_bbp_read(const struct
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2500pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Read failed.\n");
 		return;
 	}
@@ -147,26 +122,29 @@ static void rt2x00_bbp_read(const struct
 	rt2x00_set_field32(&reg, BBPCSR_BUSY, 1);
 	rt2x00_set_field32(&reg, BBPCSR_WRITE_CONTROL, 0);
 
-	rt2x00_register_write(rt2x00dev, BBPCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, BBPCSR, reg);
 
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	reg = rt2x00_bbp_check(rt2x00dev);
-	if (reg == 0xffff)
+	reg = rt2500pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, BBPCSR_BUSY)) {
 		ERROR(rt2x00dev, "BBPCSR register busy. Read failed.\n");
+		*value = 0xff;
+		return;
+	}
 
 	*value = rt2x00_get_field32(reg, BBPCSR_VALUE);
 }
 
-static void rt2x00_rf_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2500pci_rf_write(const struct rt2x00_dev *rt2x00dev,
 	const u32 value)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, RFCSR, &reg);
+		rt2x00pci_register_read(rt2x00dev, RFCSR, &reg);
 		if (!rt2x00_get_field32(reg, RFCSR_BUSY))
 			goto rf_write;
 		udelay(REGISTER_BUSY_DELAY);
@@ -182,7 +160,7 @@ rf_write:
 	rt2x00_set_field32(&reg, RFCSR_IF_SELECT, 0);
 	rt2x00_set_field32(&reg, RFCSR_BUSY, 1);
 
-	rt2x00_register_write(rt2x00dev, RFCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, RFCSR, reg);
 }
 
 static void rt2500pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
@@ -190,7 +168,7 @@ static void rt2500pci_eepromregister_rea
 	struct rt2x00_dev *rt2x00dev = eeprom->data;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR21, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR21, &reg);
 
 	eeprom->reg_data_in = !!rt2x00_get_field32(reg,
 		CSR21_EEPROM_DATA_IN);
@@ -216,7 +194,7 @@ static void rt2500pci_eepromregister_wri
 	rt2x00_set_field32(&reg, CSR21_EEPROM_CHIP_SELECT,
 		!!eeprom->reg_chip_select);
 
-	rt2x00_register_write(rt2x00dev, CSR21, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR21, reg);
 }
 
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
@@ -225,13 +203,13 @@ static void rt2500pci_eepromregister_wri
 static void rt2500pci_read_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_read(rt2x00dev, CSR_OFFSET(word), data);
+	rt2x00pci_register_read(rt2x00dev, CSR_OFFSET(word), data);
 }
 
 static void rt2500pci_write_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
+	rt2x00pci_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
 }
 
 static void rt2500pci_read_eeprom(struct rt2x00_dev *rt2x00dev,
@@ -249,13 +227,13 @@ static void rt2500pci_write_eeprom(struc
 static void rt2500pci_read_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_read(rt2x00dev, word, data);
+	rt2500pci_bbp_read(rt2x00dev, word, data);
 }
 
 static void rt2500pci_write_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_write(rt2x00dev, word, *((u8*)data));
+	rt2500pci_bbp_write(rt2x00dev, word, *((u8*)data));
 }
 
 static const struct rt2x00debug rt2500pci_rt2x00debug = {
@@ -286,7 +264,7 @@ static int rt2500pci_rfkill_poll(struct 
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, GPIOCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, GPIOCSR, &reg);
 	return rt2x00_get_field32(reg, GPIOCSR_BIT0);
 }
 #endif /* CONFIG_RT2400PCI_RFKILL */
@@ -305,45 +283,30 @@ static void rt2500pci_config_bssid(struc
 	 * The BSSID is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, CSR5, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, CSR5, &reg, sizeof(reg));
 }
 
-static void rt2500pci_config_promisc(struct rt2x00_dev *rt2x00dev, int promisc)
+static void rt2500pci_config_promisc(struct rt2x00_dev *rt2x00dev,
+	const int promisc)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
-
-	if (promisc) {
-		rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, 0);
-		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	} else {
-		rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, 1);
-		__clear_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	}
-
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00_set_field32(&reg, RXCSR0_DROP_NOT_TO_ME, !promisc);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 }
 
-static void rt2500pci_config_type(struct rt2x00_dev *rt2x00dev, int type)
+static void rt2500pci_config_type(struct rt2x00_dev *rt2x00dev,
+	const int type)
 {
 	u32 reg;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (!(is_interface_present(&rt2x00dev->interface) ^
-	     test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
-	    !(is_monitor_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
-		return;
-
-	rt2x00_register_write(rt2x00dev, CSR14, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR14, 0);
 
 	/*
 	 * Apply hardware packet filter.
 	 */
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
 
 	if (!is_monitor_present(&rt2x00dev->interface) &&
 	    (type == IEEE80211_IF_TYPE_IBSS || type == IEEE80211_IF_TYPE_STA))
@@ -365,27 +328,23 @@ static void rt2500pci_config_type(struct
 	rt2x00_set_field32(&reg, RXCSR0_DROP_MCAST, 0);
 	rt2x00_set_field32(&reg, RXCSR0_DROP_BCAST, 0);
 
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 
 	/*
 	 * Enable beacon config
 	 */
-	rt2x00_register_read(rt2x00dev, BCNCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, BCNCSR1, &reg);
 	rt2x00_set_field32(&reg, BCNCSR1_PRELOAD,
 		PREAMBLE + get_duration(IEEE80211_HEADER, 2));
 	rt2x00_set_field32(&reg, BCNCSR1_BEACON_CWMIN,
-		rt2x00dev->ring[RING_BEACON].tx_params.cw_min);
-	rt2x00_register_write(rt2x00dev, BCNCSR1, reg);
+		rt2x00_get_ring(rt2x00dev, IEEE80211_TX_QUEUE_BEACON)
+			->tx_params.cw_min);
+	rt2x00pci_register_write(rt2x00dev, BCNCSR1, reg);
 
 	/*
 	 * Enable synchronisation.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR12, &reg);
-	rt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL, 100 * 16);
-	rt2x00_set_field32(&reg, CSR12_CFPMAX_DURATION, 100 * 16);
-	rt2x00_register_write(rt2x00dev, CSR12, reg);
-
-	rt2x00_register_read(rt2x00dev, CSR14, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR14, &reg);
 	if (is_interface_present(&rt2x00dev->interface)) {
 		rt2x00_set_field32(&reg, CSR14_TSF_COUNT, 1);
 		rt2x00_set_field32(&reg, CSR14_TBCN, 1);
@@ -400,44 +359,17 @@ static void rt2500pci_config_type(struct
 		 !is_interface_present(&rt2x00dev->interface))
 		rt2x00_set_field32(&reg, CSR14_TSF_SYNC, 0);
 
-	rt2x00_register_write(rt2x00dev, CSR14, reg);
-
-	/*
-	 * Change flags of enabled interfaces.
-	 */
-	if (type != IEEE80211_IF_TYPE_MNTR) {
-		if (is_interface_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	} else {
-		if (is_monitor_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-	}
+	rt2x00pci_register_write(rt2x00dev, CSR14, reg);
 }
 
 static void rt2500pci_config_channel(struct rt2x00_dev *rt2x00dev,
-	int value, int channel, int freq, int txpower)
+	const int value, const int channel, const int txpower)
 {
 	u32 rf1 = rt2x00dev->rf1;
 	u32 rf2 = value;
 	u32 rf3 = rt2x00dev->rf3;
 	u32 rf4 = rt2x00dev->rf4;
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (channel == rt2x00dev->rx_status.channel)
-		return;
-
-	if (txpower == 0xff)
-		txpower = rt2x00dev->tx_power;
-	else
-		txpower = TXPOWER_TO_DEV(txpower);
+	u8 r70;
 
 	if (rt2x00_rf(&rt2x00dev->chip, RF2525) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2525E))
@@ -468,7 +400,7 @@ static void rt2500pci_config_channel(str
 	/*
 	 * Set TXpower.
 	 */
-	rt2x00_set_field32(&rf3, RF3_TXPOWER, txpower);
+	rt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));
 
 	/*
 	 * Switch on tuning bits.
@@ -478,10 +410,6 @@ static void rt2500pci_config_channel(str
 		rt2x00_set_field32(&rf1, RF1_TUNER, 1);
 	rt2x00_set_field32(&rf3, RF3_TUNER, 1);
 
-	INFO(rt2x00dev, "Switching channel. "
-		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x, RF4: 0x%08x.\n",
-		rf1, rf2, rf3, rf4);
-
 	/*
 	 * For RT2525 we should first set the channel to half band higher.
 	 */
@@ -493,23 +421,25 @@ static void rt2500pci_config_channel(str
 			0x00080d2e, 0x00080d3a
 		};
 
-		rt2x00_rf_write(rt2x00dev, rf1);
-		rt2x00_rf_write(rt2x00dev, vals[channel - 1]);
-		rt2x00_rf_write(rt2x00dev, rf3);
+		rt2500pci_rf_write(rt2x00dev, rf1);
+		rt2500pci_rf_write(rt2x00dev, vals[channel - 1]);
+		rt2500pci_rf_write(rt2x00dev, rf3);
 		if (rf4)
-			rt2x00_rf_write(rt2x00dev, rf4);
+			rt2500pci_rf_write(rt2x00dev, rf4);
 	}
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3);
+	rt2500pci_rf_write(rt2x00dev, rf1);
+	rt2500pci_rf_write(rt2x00dev, rf2);
+	rt2500pci_rf_write(rt2x00dev, rf3);
 	if (rf4)
-		rt2x00_rf_write(rt2x00dev, rf4);
+		rt2500pci_rf_write(rt2x00dev, rf4);
 
 	/*
 	 * Channel 14 requires the Japan filter bit to be set.
 	 */
-	rt2x00_bbp_write(rt2x00dev, 70, (channel == 14) ? 0x4e : 0x46);
+	r70 = 0x46;
+	rt2x00_set_field8(&r70, BBP_R70_JAPAN_FILTER, channel == 14);
+	rt2500pci_bbp_write(rt2x00dev, 70, r70);
 
 	msleep(1);
 
@@ -522,15 +452,9 @@ static void rt2500pci_config_channel(str
 
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF2523))
-		rt2x00_rf_write(rt2x00dev, rf1);
-
-	rt2x00_rf_write(rt2x00dev, rf3);
+		rt2500pci_rf_write(rt2x00dev, rf1);
 
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.freq = freq;
-	rt2x00dev->rx_status.channel = channel;
+	rt2500pci_rf_write(rt2x00dev, rf3);
 
 	/*
 	 * Update rf fields
@@ -539,67 +463,47 @@ static void rt2500pci_config_channel(str
 	rt2x00dev->rf2 = rf2;
 	rt2x00dev->rf3 = rf3;
 	rt2x00dev->rf4 = rf4;
-
 	rt2x00dev->tx_power = txpower;
 
 	/*
 	 * Clear false CRC during channel switch.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &rf1);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &rf1);
 }
 
-static void rt2500pci_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
+static void rt2500pci_config_txpower(struct rt2x00_dev *rt2x00dev,
+	const int txpower)
 {
-	txpower = TXPOWER_TO_DEV(txpower);
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (txpower == rt2x00dev->tx_power)
-		return;
-
-	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER, txpower);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3);
+	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER,
+		TXPOWER_TO_DEV(txpower));
+	rt2500pci_rf_write(rt2x00dev, rt2x00dev->rf3);
 
-	rt2x00dev->tx_power = txpower;
 }
 
 static void rt2500pci_config_antenna(struct rt2x00_dev *rt2x00dev,
-	int antenna_tx, int antenna_rx)
+	const int antenna_tx, const int antenna_rx)
 {
 	u32 reg;
-	u8 reg_rx;
-	u8 reg_tx;
+	u8 r14;
+	u8 r2;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.antenna == antenna_rx)
-		return;
-
-	rt2x00_register_read(rt2x00dev, BBPCSR1, &reg);
-	rt2x00_bbp_read(rt2x00dev, 14, &reg_rx);
-	rt2x00_bbp_read(rt2x00dev, 2, &reg_tx);
-
-	/*
-	 * Clear current config antenna bits.
-	 */
-	reg_rx &= ~0x03;
-	reg_tx &= ~0x03;
+	rt2x00pci_register_read(rt2x00dev, BBPCSR1, &reg);
+	rt2500pci_bbp_read(rt2x00dev, 14, &r14);
+	rt2500pci_bbp_read(rt2x00dev, 2, &r2);
 
 	/*
 	 * Configure the TX antenna.
 	 */
-	if (antenna_tx == 0) {		/* Diversity. */
-		reg_tx |= 0x02;
+	if (antenna_tx == ANTENNA_DIVERSITY) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);
 		rt2x00_set_field32(&reg, BBPCSR1_CCK, 2);
 		rt2x00_set_field32(&reg, BBPCSR1_OFDM, 2);
-	} else if (antenna_tx == 1) {	/* TX: Antenna A */
-		reg_tx |= 0x00;
+	} else if (antenna_tx == ANTENNA_A) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 0);
 		rt2x00_set_field32(&reg, BBPCSR1_CCK, 0);
 		rt2x00_set_field32(&reg, BBPCSR1_OFDM, 0);
-	} else if (antenna_tx == 2) {	/* TX: Antenna B */
-		reg_tx |= 0x02;
+	} else if (antenna_tx == ANTENNA_B) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);
 		rt2x00_set_field32(&reg, BBPCSR1_CCK, 2);
 		rt2x00_set_field32(&reg, BBPCSR1_OFDM, 2);
 	}
@@ -607,19 +511,19 @@ static void rt2500pci_config_antenna(str
 	/*
 	 * Configure the RX antenna.
 	 */
-	if (antenna_rx == 0)		/* Diversity. */
-		reg_rx |= 0x02;
-	else if (antenna_rx == 1)	/* RX: Antenna A */
-		reg_rx |= 0x00;
-	else if (antenna_rx == 2)	/* RX: Antenna B */
-		reg_rx |= 0x02;
+	if (antenna_rx == ANTENNA_DIVERSITY)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);
+	else if (antenna_rx == ANTENNA_A)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 0);
+	else if (antenna_rx == ANTENNA_B)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);
 
 	/*
 	 * RT2525E and RT5222 need to flip TX I/Q
 	 */
 	if (rt2x00_rf(&rt2x00dev->chip, RF2525E) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF5222)) {
-		reg_tx |= 0x04;
+		rt2x00_set_field8(&r2, BBP_R2_TX_IQ_FLIP, 1);
 		rt2x00_set_field32(&reg, BBPCSR1_CCK_FLIP, 1);
 		rt2x00_set_field32(&reg, BBPCSR1_OFDM_FLIP, 1);
 
@@ -627,48 +531,48 @@ static void rt2500pci_config_antenna(str
 		 * RT2525E does not need RX I/Q Flip.
 		 */
 		if (rt2x00_rf(&rt2x00dev->chip, RF2525E))
-			reg_rx &= ~0x04;
+			rt2x00_set_field8(&r14, BBP_R14_RX_IQ_FLIP, 0);
 	} else {
 		rt2x00_set_field32(&reg, BBPCSR1_CCK_FLIP, 0);
 		rt2x00_set_field32(&reg, BBPCSR1_OFDM_FLIP, 0);
 	}
 
-	rt2x00_register_write(rt2x00dev, BBPCSR1, reg);
-	rt2x00_bbp_write(rt2x00dev, 14, reg_rx);
-	rt2x00_bbp_write(rt2x00dev, 2, reg_tx);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.antenna = antenna_rx;
+	rt2x00pci_register_write(rt2x00dev, BBPCSR1, reg);
+	rt2500pci_bbp_write(rt2x00dev, 14, r14);
+	rt2500pci_bbp_write(rt2x00dev, 2, r2);
 }
 
 static void rt2500pci_config_duration(struct rt2x00_dev *rt2x00dev,
-	int short_slot_time)
+	const int short_slot_time, const int beacon_int)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_SLOT_TIME,
 		short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR18, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR18, &reg);
 	rt2x00_set_field32(&reg, CSR18_SIFS, SIFS);
 	rt2x00_set_field32(&reg, CSR18_PIFS,
 		short_slot_time ? SHORT_PIFS : PIFS);
-	rt2x00_register_write(rt2x00dev, CSR18, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR18, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR19, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR19, &reg);
 	rt2x00_set_field32(&reg, CSR19_DIFS,
 		short_slot_time ? SHORT_DIFS : DIFS);
 	rt2x00_set_field32(&reg, CSR19_EIFS, EIFS);
-	rt2x00_register_write(rt2x00dev, CSR19, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR19, reg);
 
-	rt2x00_register_read(rt2x00dev, TXCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR1, &reg);
 	rt2x00_set_field32(&reg, TXCSR1_TSF_OFFSET, IEEE80211_HEADER);
 	rt2x00_set_field32(&reg, TXCSR1_AUTORESPONDER, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR1, reg);
+
+	rt2x00pci_register_read(rt2x00dev, CSR12, &reg);
+	rt2x00_set_field32(&reg, CSR12_BEACON_INTERVAL, beacon_int * 16);
+	rt2x00_set_field32(&reg, CSR12_CFP_MAX_DURATION, beacon_int * 16);
+	rt2x00pci_register_write(rt2x00dev, CSR12, reg);
 }
 
 static void rt2500pci_config_rate(struct rt2x00_dev *rt2x00dev, const int rate)
@@ -682,42 +586,42 @@ static void rt2500pci_config_rate(struct
 		? SHORT_PREAMBLE : PREAMBLE;
 
 	reg = DEVICE_GET_RATE_FIELD(rate, RATEMASK) & DEV_BASIC_RATE;
-	rt2x00_register_write(rt2x00dev, ARCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, TXCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR1, &reg);
 	value = ((conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME) ?
 		 SHORT_DIFS :  DIFS) +
 		PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXCSR1_ACK_TIMEOUT, value);
 	value = SIFS + PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXCSR1_ACK_CONSUME_TIME, value);
-	rt2x00_register_write(rt2x00dev, TXCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR1, reg);
 
 	preamble = DEVICE_GET_RATE_FIELD(rate, PREAMBLE) ? 0x08 : 0x00;
 
-	rt2x00_register_read(rt2x00dev, ARCSR2, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR2, &reg);
 	rt2x00_set_field32(&reg, ARCSR2_SIGNAL, 0x00 | preamble);
 	rt2x00_set_field32(&reg, ARCSR2_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 10));
-	rt2x00_register_write(rt2x00dev, ARCSR2, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR2, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR3, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR3, &reg);
 	rt2x00_set_field32(&reg, ARCSR3_SIGNAL, 0x01 | preamble);
 	rt2x00_set_field32(&reg, ARCSR3_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 20));
-	rt2x00_register_write(rt2x00dev, ARCSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR3, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR4, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR4, &reg);
 	rt2x00_set_field32(&reg, ARCSR4_SIGNAL, 0x02 | preamble);
 	rt2x00_set_field32(&reg, ARCSR4_SERVICE, 0x04);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 55));
-	rt2x00_register_write(rt2x00dev, ARCSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR4, reg);
 
-	rt2x00_register_read(rt2x00dev, ARCSR5, &reg);
+	rt2x00pci_register_read(rt2x00dev, ARCSR5, &reg);
 	rt2x00_set_field32(&reg, ARCSR5_SIGNAL, 0x03 | preamble);
 	rt2x00_set_field32(&reg, ARCSR5_SERVICE, 0x84);
 	rt2x00_set_field32(&reg, ARCSR2_LENGTH, get_duration(ACK_SIZE, 110));
-	rt2x00_register_write(rt2x00dev, ARCSR5, reg);
+	rt2x00pci_register_write(rt2x00dev, ARCSR5, reg);
 }
 
 static void rt2500pci_config_phymode(struct rt2x00_dev *rt2x00dev,
@@ -726,12 +630,6 @@ static void rt2500pci_config_phymode(str
 	struct ieee80211_hw_mode *mode;
 	struct ieee80211_rate *rate;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.phymode == phymode)
-		return;
-
 	if (phymode == MODE_IEEE80211A)
 		rt2x00dev->curr_hwmode = HWMODE_A;
 	else if (phymode == MODE_IEEE80211B)
@@ -743,11 +641,6 @@ static void rt2500pci_config_phymode(str
 	rate = &mode->rates[mode->num_rates - 1];
 
 	rt2500pci_config_rate(rt2x00dev, rate->val2);
-
-	/*
-	 * Update physical mode for rx ring.
-	 */
-	rt2x00dev->rx_status.phymode = phymode;
 }
 
 static void rt2500pci_config_mac_addr(struct rt2x00_dev *rt2x00dev, u8 *addr)
@@ -761,7 +654,7 @@ static void rt2500pci_config_mac_addr(st
 	 * The MAC address is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, CSR3, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, CSR3, &reg, sizeof(reg));
 }
 
 /*
@@ -771,7 +664,7 @@ static void rt2500pci_enable_led(struct 
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, LEDCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, LEDCSR, &reg);
 
 	rt2x00_set_field32(&reg, LEDCSR_ON_PERIOD, 70);
 	rt2x00_set_field32(&reg, LEDCSR_OFF_PERIOD, 30);
@@ -787,24 +680,25 @@ static void rt2500pci_enable_led(struct 
 		rt2x00_set_field32(&reg, LEDCSR_ACTIVITY, 1);
 	}
 
-	rt2x00_register_write(rt2x00dev, LEDCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, LEDCSR, reg);
 }
 
 static void rt2500pci_disable_led(struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, LEDCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, LEDCSR, &reg);
 	rt2x00_set_field32(&reg, LEDCSR_LINK, 0);
 	rt2x00_set_field32(&reg, LEDCSR_ACTIVITY, 0);
-	rt2x00_register_write(rt2x00dev, LEDCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, LEDCSR, reg);
 }
 
 /*
  * Link tuning
  */
-static void rt2500pci_link_tuner(struct rt2x00_dev *rt2x00dev, int rssi)
+static void rt2500pci_link_tuner(struct rt2x00_dev *rt2x00dev)
 {
+	int rssi = rt2x00_get_link_rssi(&rt2x00dev->link);
 	u32 reg;
 	u8 r17;
 
@@ -817,7 +711,7 @@ static void rt2500pci_link_tuner(struct 
 	    rt2x00dev->link.count > 20)
 		return;
 
-	rt2x00_bbp_read(rt2x00dev, 17, &r17);
+	rt2500pci_bbp_read(rt2x00dev, 17, &r17);
 
 	/*
 	 * Chipset versions C and lower should directly continue
@@ -833,8 +727,8 @@ static void rt2500pci_link_tuner(struct 
 	 */
 	if (rssi < -80 && rt2x00dev->link.count > 20) {
 		if (r17 >= 0x41) {
-			r17 = rt2x00dev->link.curr_noise;
-			rt2x00_bbp_write(rt2x00dev, 17, r17);
+			r17 = rt2x00dev->rx_status.noise;
+			rt2500pci_bbp_write(rt2x00dev, 17, r17);
 		}
 		return;
 	}
@@ -844,7 +738,7 @@ static void rt2500pci_link_tuner(struct 
 	 */
 	if (rssi >= -58) {
 		if (r17 != 0x50)
-			rt2x00_bbp_write(rt2x00dev, 17, 0x50);
+			rt2500pci_bbp_write(rt2x00dev, 17, 0x50);
 		return;
 	}
 
@@ -853,7 +747,7 @@ static void rt2500pci_link_tuner(struct 
 	 */
 	if (rssi >= -74) {
 		if (r17 != 0x41)
-			rt2x00_bbp_write(rt2x00dev, 17, 0x41);
+			rt2500pci_bbp_write(rt2x00dev, 17, 0x41);
 		return;
 	}
 
@@ -862,7 +756,7 @@ static void rt2500pci_link_tuner(struct 
 	 * to the dynamic tuning range.
 	 */
 	if (r17 >= 0x41) {
-		rt2x00_bbp_write(rt2x00dev, 17, rt2x00dev->link.curr_noise);
+		rt2500pci_bbp_write(rt2x00dev, 17, rt2x00dev->rx_status.noise);
 		return;
 	}
 
@@ -872,39 +766,36 @@ dynamic_cca_tune:
 	 * R17 is inside the dynamic tuning range,
 	 * start tuning the link based on the false cca counter.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT3, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT3, &reg);
 	rt2x00dev->link.false_cca = rt2x00_get_field32(reg, CNT3_FALSE_CCA);
 
 	if (rt2x00dev->link.false_cca > 512 && r17 < 0x40) {
-		rt2x00_bbp_write(rt2x00dev, 17, ++r17);
-		rt2x00dev->link.curr_noise = r17;
+		rt2500pci_bbp_write(rt2x00dev, 17, ++r17);
+		rt2x00dev->rx_status.noise = r17;
 	} else if (rt2x00dev->link.false_cca < 100 && r17 > 0x32) {
-		rt2x00_bbp_write(rt2x00dev, 17, --r17);
-		rt2x00dev->link.curr_noise = r17;
+		rt2500pci_bbp_write(rt2x00dev, 17, --r17);
+		rt2x00dev->rx_status.noise = r17;
 	}
 }
 
 /*
  * Initialization functions.
  */
-static void rt2500pci_init_rxring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+static void rt2500pci_init_rxring(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
 	struct data_desc *rxd;
 	unsigned int i;
 	u32 word;
 
-	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
-
-	ring->type = ring_type;
+	memset(rt2x00dev->rx->data_addr, 0x00,
+		rt2x00_get_ring_size(rt2x00dev->rx));
 
-	for (i = 0; i < ring->stats.limit; i++) {
-		rxd = ring->entry[i].priv;
+	for (i = 0; i < rt2x00dev->rx->stats.limit; i++) {
+		rxd = rt2x00dev->rx->entry[i].priv;
 
 		rt2x00_desc_read(rxd, 1, &word);
 		rt2x00_set_field32(&word, RXD_W1_BUFFER_ADDRESS,
-			ring->entry[i].data_dma);
+			rt2x00dev->rx->entry[i].data_dma);
 		rt2x00_desc_write(rxd, 1, word);
 
 		rt2x00_desc_read(rxd, 0, &word);
@@ -912,21 +803,19 @@ static void rt2500pci_init_rxring(struct
 		rt2x00_desc_write(rxd, 0, word);
 	}
 
-	rt2x00_ring_index_clear(ring);
+	rt2x00_ring_index_clear(rt2x00dev->rx);
 }
 
 static void rt2500pci_init_txring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+	const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_desc *txd;
 	unsigned int i;
 	u32 word;
 
 	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
 
-	ring->type = ring_type;
-
 	for (i = 0; i < ring->stats.limit; i++) {
 		txd = ring->entry[i].priv;
 
@@ -951,57 +840,57 @@ static int rt2500pci_init_rings(struct r
 	/*
 	 * Initialize rings.
 	 */
-	rt2500pci_init_rxring(rt2x00dev, RING_RX);
-	rt2500pci_init_txring(rt2x00dev, RING_TX);
-	rt2500pci_init_txring(rt2x00dev, RING_ATIM);
-	rt2500pci_init_txring(rt2x00dev, RING_PRIO);
-	rt2500pci_init_txring(rt2x00dev, RING_BEACON);
+	rt2500pci_init_rxring(rt2x00dev);
+	rt2500pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA0);
+	rt2500pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA1);
+	rt2500pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_AFTER_BEACON);
+	rt2500pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * Initialize registers.
 	 */
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR2, &reg);
 	rt2x00_set_field32(&reg, TXCSR2_TXD_SIZE,
-		rt2x00dev->ring[RING_TX].desc_size);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].desc_size);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_TXD,
-		rt2x00dev->ring[RING_TX].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].stats.limit);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_ATIM,
-		rt2x00dev->ring[RING_ATIM].stats.limit);
+		rt2x00dev->bcn[1].stats.limit);
 	rt2x00_set_field32(&reg, TXCSR2_NUM_PRIO,
-		rt2x00dev->ring[RING_PRIO].stats.limit);
-	rt2x00_register_write(rt2x00dev, TXCSR2, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].stats.limit);
+	rt2x00pci_register_write(rt2x00dev, TXCSR2, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR3, &reg);
 	rt2x00_set_field32(&reg, TXCSR3_TX_RING_REGISTER,
-		rt2x00dev->ring[RING_TX].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR3, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR3, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR5, &reg);
 	rt2x00_set_field32(&reg, TXCSR5_PRIO_RING_REGISTER,
-		rt2x00dev->ring[RING_PRIO].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR5, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR5, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR4, &reg);
 	rt2x00_set_field32(&reg, TXCSR4_ATIM_RING_REGISTER,
-		rt2x00dev->ring[RING_ATIM].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR4, reg);
+		rt2x00dev->bcn[1].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR4, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TXCSR6, &reg);
 	rt2x00_set_field32(&reg, TXCSR6_BEACON_RING_REGISTER,
-		rt2x00dev->ring[RING_BEACON].data_dma);
-	rt2x00_register_write(rt2x00dev, TXCSR6, reg);
+		rt2x00dev->bcn[0].data_dma);
+	rt2x00pci_register_write(rt2x00dev, TXCSR6, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RXCSR1, &reg);
 	rt2x00_set_field32(&reg, RXCSR1_RXD_SIZE,
-		rt2x00dev->ring[RING_RX].desc_size);
+		rt2x00dev->rx->desc_size);
 	rt2x00_set_field32(&reg, RXCSR1_NUM_RXD,
-		rt2x00dev->ring[RING_RX].stats.limit);
-	rt2x00_register_write(rt2x00dev, RXCSR1, reg);
+		rt2x00dev->rx->stats.limit);
+	rt2x00pci_register_write(rt2x00dev, RXCSR1, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RXCSR2, &reg);
 	rt2x00_set_field32(&reg, RXCSR2_RX_RING_REGISTER,
-		rt2x00dev->ring[RING_RX].data_dma);
-	rt2x00_register_write(rt2x00dev, RXCSR2, reg);
+		rt2x00dev->rx->data_dma);
+	rt2x00pci_register_write(rt2x00dev, RXCSR2, reg);
 
 	return 0;
 }
@@ -1013,45 +902,54 @@ static int rt2500pci_init_registers(stru
 	if (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))
 		return -EBUSY;
 
-	rt2x00_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);
-	rt2x00_register_write(rt2x00dev, PCICSR, 0x000003b8);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0x3f3b3100);
 
-	rt2x00_register_write(rt2x00dev, PSCSR0, 0x00020002);
-	rt2x00_register_write(rt2x00dev, PSCSR1, 0x00000002);
-	rt2x00_register_write(rt2x00dev, PSCSR2, 0x00020002);
-	rt2x00_register_write(rt2x00dev, PSCSR3, 0x00000002);
+	rt2x00pci_register_read(rt2x00dev, PCICSR, &reg);
+	rt2x00_set_field32(&reg, PCICSR_BIG_ENDIAN, 0);
+	rt2x00_set_field32(&reg, PCICSR_RX_TRESHOLD, 0);
+	rt2x00_set_field32(&reg, PCICSR_TX_TRESHOLD, 3);
+	rt2x00_set_field32(&reg, PCICSR_BURST_LENTH, 1);
+	rt2x00_set_field32(&reg, PCICSR_ENABLE_CLK, 1);
+	rt2x00_set_field32(&reg, PCICSR_READ_MULTIPLE, 1);
+	rt2x00_set_field32(&reg, PCICSR_WRITE_INVALID, 1);
+	rt2x00pci_register_write(rt2x00dev, PCICSR, reg);
+
+	rt2x00pci_register_write(rt2x00dev, PSCSR0, 0x00020002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR1, 0x00000002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR2, 0x00020002);
+	rt2x00pci_register_write(rt2x00dev, PSCSR3, 0x00000002);
 
-	rt2x00_register_read(rt2x00dev, TIMECSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, TIMECSR, &reg);
 	rt2x00_set_field32(&reg, TIMECSR_US_COUNT, 33);
 	rt2x00_set_field32(&reg, TIMECSR_US_64_COUNT, 63);
 	rt2x00_set_field32(&reg, TIMECSR_BEACON_EXPECT, 0);
-	rt2x00_register_write(rt2x00dev, TIMECSR, reg);
+	rt2x00pci_register_write(rt2x00dev, TIMECSR, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR9, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR9, &reg);
 	rt2x00_set_field32(&reg, CSR9_MAX_FRAME_UNIT,
-		(rt2x00dev->ring[RING_RX].data_size / 128));
-	rt2x00_register_write(rt2x00dev, CSR9, reg);
+		rt2x00dev->rx->data_size / 128);
+	rt2x00pci_register_write(rt2x00dev, CSR9, reg);
 
-	rt2x00_register_write(rt2x00dev, CNT3, 0);
+	rt2x00pci_register_write(rt2x00dev, CNT3, 0);
 
-	rt2x00_register_write(rt2x00dev, GPIOCSR, 0x0000ff00);
-	rt2x00_register_write(rt2x00dev, TESTCSR, 0x000000f0);
+	rt2x00pci_register_write(rt2x00dev, GPIOCSR, 0x0000ff00);
+	rt2x00pci_register_write(rt2x00dev, TESTCSR, 0x000000f0);
 
-	rt2x00_register_write(rt2x00dev, MACCSR0, 0x00213223);
-	rt2x00_register_write(rt2x00dev, MACCSR1, 0x00235518);
+	rt2x00pci_register_write(rt2x00dev, MACCSR0, 0x00213223);
+	rt2x00pci_register_write(rt2x00dev, MACCSR1, 0x00235518);
 
-	rt2x00_register_read(rt2x00dev, MACCSR2, &reg);
+	rt2x00pci_register_read(rt2x00dev, MACCSR2, &reg);
 	rt2x00_set_field32(&reg, MACCSR2_DELAY, 64);
-	rt2x00_register_write(rt2x00dev, MACCSR2, reg);
+	rt2x00pci_register_write(rt2x00dev, MACCSR2, reg);
 
 	/*
 	 * Always use CWmin and CWmax set in descriptor.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_CW_SELECT, 0);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 
-	rt2x00_register_read(rt2x00dev, RXCSR3, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR3, &reg);
 	/*
 	 * Signal.
 	 */
@@ -1072,43 +970,43 @@ static int rt2500pci_init_registers(stru
 	 */
 	rt2x00_set_field32(&reg, RXCSR3_BBP_ID3, 51);
 	rt2x00_set_field32(&reg, RXCSR3_BBP_ID3_VALID, 1);
-	rt2x00_register_write(rt2x00dev, RXCSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR3, reg);
 
-	rt2x00_register_read(rt2x00dev, RALINKCSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, RALINKCSR, &reg);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA0, 17);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID0, 26);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_VALID0, 1);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_DATA1, 0);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_ID1, 26);
 	rt2x00_set_field32(&reg, RALINKCSR_AR_BBP_VALID1, 1);
-	rt2x00_register_write(rt2x00dev, RALINKCSR, reg);
+	rt2x00pci_register_write(rt2x00dev, RALINKCSR, reg);
 
-	rt2x00_register_write(rt2x00dev, BBPCSR1, 0x82188200);
+	rt2x00pci_register_write(rt2x00dev, BBPCSR1, 0x82188200);
 
-	rt2x00_register_write(rt2x00dev, TXACKCSR0, 0x00000020);
+	rt2x00pci_register_write(rt2x00dev, TXACKCSR0, 0x00000020);
 
-	rt2x00_register_write(rt2x00dev, ARTCSR0, 0x7038140a);
-	rt2x00_register_write(rt2x00dev, ARTCSR1, 0x1d21252d);
-	rt2x00_register_write(rt2x00dev, ARTCSR2, 0x1919191d);
+	rt2x00pci_register_write(rt2x00dev, ARTCSR0, 0x7038140a);
+	rt2x00pci_register_write(rt2x00dev, ARTCSR1, 0x1d21252d);
+	rt2x00pci_register_write(rt2x00dev, ARTCSR2, 0x1919191d);
 
-	rt2x00_register_read(rt2x00dev, CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR1, &reg);
 	rt2x00_set_field32(&reg, CSR1_SOFT_RESET, 1);
 	rt2x00_set_field32(&reg, CSR1_BBP_RESET, 0);
 	rt2x00_set_field32(&reg, CSR1_HOST_READY, 0);
-	rt2x00_register_write(rt2x00dev, CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR1, &reg);
 	rt2x00_set_field32(&reg, CSR1_SOFT_RESET, 0);
 	rt2x00_set_field32(&reg, CSR1_HOST_READY, 1);
-	rt2x00_register_write(rt2x00dev, CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR1, reg);
 
 	/*
 	 * We must clear the FCS and FIFO error count.
 	 * These registers are cleared on read,
 	 * so we may pass a useless variable to store the value.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &reg);
-	rt2x00_register_read(rt2x00dev, CNT4, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT4, &reg);
 
 	return 0;
 }
@@ -1121,7 +1019,7 @@ static int rt2500pci_init_bbp(struct rt2
 	u8 value;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_bbp_read(rt2x00dev, 0, &value);
+		rt2500pci_bbp_read(rt2x00dev, 0, &value);
 		if ((value != 0xff) && (value != 0x00))
 			goto continue_csr_init;
 		NOTICE(rt2x00dev, "Waiting for BBP register.\n");
@@ -1132,37 +1030,37 @@ static int rt2500pci_init_bbp(struct rt2
 	return -EACCES;
 
 continue_csr_init:
-	rt2x00_bbp_write(rt2x00dev, 3, 0x02);
-	rt2x00_bbp_write(rt2x00dev, 4, 0x19);
-	rt2x00_bbp_write(rt2x00dev, 14, 0x1c);
-	rt2x00_bbp_write(rt2x00dev, 15, 0x30);
-	rt2x00_bbp_write(rt2x00dev, 16, 0xac);
-	rt2x00_bbp_write(rt2x00dev, 17, 0x48);
-	rt2x00_bbp_write(rt2x00dev, 18, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 19, 0xff);
-	rt2x00_bbp_write(rt2x00dev, 20, 0x1e);
-	rt2x00_bbp_write(rt2x00dev, 21, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 22, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 23, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 24, 0x70);
-	rt2x00_bbp_write(rt2x00dev, 25, 0x40);
-	rt2x00_bbp_write(rt2x00dev, 26, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 27, 0x23);
-	rt2x00_bbp_write(rt2x00dev, 30, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 31, 0x2b);
-	rt2x00_bbp_write(rt2x00dev, 32, 0xb9);
-	rt2x00_bbp_write(rt2x00dev, 34, 0x12);
-	rt2x00_bbp_write(rt2x00dev, 35, 0x50);
-	rt2x00_bbp_write(rt2x00dev, 39, 0xc4);
-	rt2x00_bbp_write(rt2x00dev, 40, 0x02);
-	rt2x00_bbp_write(rt2x00dev, 41, 0x60);
-	rt2x00_bbp_write(rt2x00dev, 53, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 54, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 56, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 57, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 58, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 61, 0x6d);
-	rt2x00_bbp_write(rt2x00dev, 62, 0x10);
+	rt2500pci_bbp_write(rt2x00dev, 3, 0x02);
+	rt2500pci_bbp_write(rt2x00dev, 4, 0x19);
+	rt2500pci_bbp_write(rt2x00dev, 14, 0x1c);
+	rt2500pci_bbp_write(rt2x00dev, 15, 0x30);
+	rt2500pci_bbp_write(rt2x00dev, 16, 0xac);
+	rt2500pci_bbp_write(rt2x00dev, 17, 0x48);
+	rt2500pci_bbp_write(rt2x00dev, 18, 0x18);
+	rt2500pci_bbp_write(rt2x00dev, 19, 0xff);
+	rt2500pci_bbp_write(rt2x00dev, 20, 0x1e);
+	rt2500pci_bbp_write(rt2x00dev, 21, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 22, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 23, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 24, 0x70);
+	rt2500pci_bbp_write(rt2x00dev, 25, 0x40);
+	rt2500pci_bbp_write(rt2x00dev, 26, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 27, 0x23);
+	rt2500pci_bbp_write(rt2x00dev, 30, 0x10);
+	rt2500pci_bbp_write(rt2x00dev, 31, 0x2b);
+	rt2500pci_bbp_write(rt2x00dev, 32, 0xb9);
+	rt2500pci_bbp_write(rt2x00dev, 34, 0x12);
+	rt2500pci_bbp_write(rt2x00dev, 35, 0x50);
+	rt2500pci_bbp_write(rt2x00dev, 39, 0xc4);
+	rt2500pci_bbp_write(rt2x00dev, 40, 0x02);
+	rt2500pci_bbp_write(rt2x00dev, 41, 0x60);
+	rt2500pci_bbp_write(rt2x00dev, 53, 0x10);
+	rt2500pci_bbp_write(rt2x00dev, 54, 0x18);
+	rt2500pci_bbp_write(rt2x00dev, 56, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 57, 0x10);
+	rt2500pci_bbp_write(rt2x00dev, 58, 0x08);
+	rt2500pci_bbp_write(rt2x00dev, 61, 0x6d);
+	rt2500pci_bbp_write(rt2x00dev, 62, 0x10);
 
 	DEBUG(rt2x00dev, "Start initialization from EEPROM...\n");
 	for (i = 0; i < EEPROM_BBP_SIZE; i++) {
@@ -1173,7 +1071,7 @@ continue_csr_init:
 			value = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);
 			DEBUG(rt2x00dev, "BBP: 0x%02x, value: 0x%02x.\n",
 				reg_id, value);
-			rt2x00_bbp_write(rt2x00dev, reg_id, value);
+			rt2500pci_bbp_write(rt2x00dev, reg_id, value);
 		}
 	}
 	DEBUG(rt2x00dev, "...End initialization from EEPROM.\n");
@@ -1189,17 +1087,41 @@ static void rt2500pci_toggle_rx(struct r
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, RXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, RXCSR0, &reg);
 	rt2x00_set_field32(&reg, RXCSR0_DISABLE_RX,
 		state == STATE_RADIO_RX_OFF);
-	rt2x00_register_write(rt2x00dev, RXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, RXCSR0, reg);
 }
 
-static int rt2500pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+static void rt2500pci_toggle_irq(struct rt2x00_dev *rt2x00dev, int enabled)
 {
 	u32 reg;
 
 	/*
+	 * When interrupts are being enabled, the interrupt registers
+	 * should clear the register to assure a clean state.
+	 */
+	if (enabled) {
+		rt2x00pci_register_read(rt2x00dev, CSR7, &reg);
+		rt2x00pci_register_write(rt2x00dev, CSR7, reg);
+	}
+
+	/*
+	 * Only toggle the interrupts bits we are going to use.
+	 * Non-checked interrupt bits are disabled by default.
+	 */
+	rt2x00pci_register_read(rt2x00dev, CSR8, &reg);
+	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, !enabled);
+	rt2x00_set_field32(&reg, CSR8_RXDONE, !enabled);
+	rt2x00pci_register_write(rt2x00dev, CSR8, reg);
+}
+
+static int rt2500pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+{
+	/*
 	 * Initialize all registers.
 	 */
 	if (rt2500pci_init_rings(rt2x00dev) ||
@@ -1210,21 +1132,9 @@ static int rt2500pci_enable_radio(struct
 	}
 
 	/*
-	 * Clear interrupts.
-	 */
-	rt2x00_register_read(rt2x00dev, CSR7, &reg);
-	rt2x00_register_write(rt2x00dev, CSR7, reg);
-
-	/*
 	 * Enable interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR8, &reg);
-	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 0);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 0);
-	rt2x00_set_field32(&reg, CSR8_RXDONE, 0);
-	rt2x00_register_write(rt2x00dev, CSR8, reg);
+	rt2500pci_toggle_irq(rt2x00dev, 1);
 
 	/*
 	 * Enable LED
@@ -1243,30 +1153,24 @@ static void rt2500pci_disable_radio(stru
 	 */
 	rt2500pci_disable_led(rt2x00dev);
 
-	rt2x00_register_write(rt2x00dev, PWRCSR0, 0);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR0, 0);
 
 	/*
 	 * Disable synchronisation.
 	 */
-	rt2x00_register_write(rt2x00dev, CSR14, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR14, 0);
 
 	/*
 	 * Cancel RX and TX.
 	 */
-	rt2x00_register_read(rt2x00dev, TXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR0, &reg);
 	rt2x00_set_field32(&reg, TXCSR0_ABORT, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR0, reg);
 
 	/*
 	 * Disable interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR8, &reg);
-	rt2x00_set_field32(&reg, CSR8_TBCN_EXPIRE, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_TXRING, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_ATIMRING, 1);
-	rt2x00_set_field32(&reg, CSR8_TXDONE_PRIORING, 1);
-	rt2x00_set_field32(&reg, CSR8_RXDONE, 1);
-	rt2x00_register_write(rt2x00dev, CSR8, reg);
+	rt2500pci_toggle_irq(rt2x00dev, 0);
 }
 
 static int rt2500pci_set_state(struct rt2x00_dev *rt2x00dev,
@@ -1280,12 +1184,12 @@ static int rt2500pci_set_state(struct rt
 
 	put_to_sleep = (state != STATE_AWAKE);
 
-	rt2x00_register_read(rt2x00dev, PWRCSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, PWRCSR1, &reg);
 	rt2x00_set_field32(&reg, PWRCSR1_SET_STATE, 1);
 	rt2x00_set_field32(&reg, PWRCSR1_BBP_DESIRE_STATE, state);
 	rt2x00_set_field32(&reg, PWRCSR1_RF_DESIRE_STATE, state);
 	rt2x00_set_field32(&reg, PWRCSR1_PUT_TO_SLEEP, put_to_sleep);
-	rt2x00_register_write(rt2x00dev, PWRCSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, PWRCSR1, reg);
 
 	/*
 	 * Device is not guaranteed to be in the requested state yet.
@@ -1293,7 +1197,7 @@ static int rt2500pci_set_state(struct rt
 	 * device has entered the correct state.
 	 */
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PWRCSR1, &reg);
+		rt2x00pci_register_read(rt2x00dev, PWRCSR1, &reg);
 		bbp_state = rt2x00_get_field32(reg, PWRCSR1_BBP_CURR_STATE);
 		rf_state = rt2x00_get_field32(reg, PWRCSR1_RF_CURR_STATE);
 		if (bbp_state == state && rf_state == state)
@@ -1397,83 +1301,59 @@ static void rt2500pci_kick_tx_queue(stru
 	u32 reg;
 
 	if (queue == IEEE80211_TX_QUEUE_BEACON) {
-		rt2x00_register_read(rt2x00dev, CSR14, &reg);
+		rt2x00pci_register_read(rt2x00dev, CSR14, &reg);
 		if (!rt2x00_get_field32(reg, CSR14_BEACON_GEN)) {
 			rt2x00_set_field32(&reg, CSR14_BEACON_GEN, 1);
-			rt2x00_register_write(rt2x00dev, CSR14, reg);
+			rt2x00pci_register_write(rt2x00dev, CSR14, reg);
 		}
 		return;
 	}
 
-	rt2x00_register_read(rt2x00dev, TXCSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXCSR0, &reg);
 	if (queue == IEEE80211_TX_QUEUE_DATA0)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_PRIO, 1);
 	else if (queue == IEEE80211_TX_QUEUE_DATA1)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_TX, 1);
 	else if (queue == IEEE80211_TX_QUEUE_AFTER_BEACON)
 		rt2x00_set_field32(&reg, TXCSR0_KICK_ATIM, 1);
-	rt2x00_register_write(rt2x00dev, TXCSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXCSR0, reg);
 }
 
 /*
- * Interrupt functions.
+ * RX control handlers
  */
-static void rt2500pci_rxdone(struct rt2x00_dev *rt2x00dev, int queue)
+static int rt2500pci_fill_rxdone(struct data_entry *entry,
+	int *signal, int *rssi, int *ofdm)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
-	struct data_entry *entry;
-	struct data_desc *rxd;
+	struct data_desc *rxd = entry->priv;
 	u32 word0;
 	u32 word2;
-	int signal;
-	int rssi;
-	int ofdm;
-	u16 size;
-
-	while (1) {
-		entry = rt2x00_get_data_entry(ring);
-		rxd = entry->priv;
-		rt2x00_desc_read(rxd, 0, &word0);
-		rt2x00_desc_read(rxd, 2, &word2);
-
-		if (rt2x00_get_field32(word0, RXD_W0_OWNER_NIC))
-			break;
 
-		/*
-		 * TODO: Don't we need to keep statistics
-		 * updated about events like CRC and physical errors?
-		 */
-		if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
-		    rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))
-			goto skip_entry;
+	rt2x00_desc_read(rxd, 0, &word0);
+	rt2x00_desc_read(rxd, 2, &word2);
 
-		/*
-		 * Obtain the status about this packet.
-		 */
-		size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
-		signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL);
-		rssi = rt2x00_get_field32(word2, RXD_W2_RSSI);
-		ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
-
-		/*
-		 * Send the packet to upper layer.
-		 */
-		rt2x00lib_rxdone(entry, entry->data_addr, size,
-			signal, rssi, ofdm);
+	/*
+	 * TODO: Don't we need to keep statistics
+	 * updated about these errors?
+	 */
+	if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
+	    rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))
+		return -EINVAL;
 
-skip_entry:
-		if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
-			rt2x00_set_field32(&word0, RXD_W0_OWNER_NIC, 1);
-			rt2x00_desc_write(rxd, 0, word0);
-		}
+	*signal = rt2x00_get_field32(word2, RXD_W2_SIGNAL);
+	*rssi = rt2x00_get_field32(word2, RXD_W2_RSSI) -
+		entry->ring->rt2x00dev->rssi_offset;
+	*ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
 
-		rt2x00_ring_index_inc(ring);
-	}
+	return rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
 }
 
+/*
+ * Interrupt functions.
+ */
 static void rt2500pci_txdone(struct rt2x00_dev *rt2x00dev, const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_entry *entry;
 	struct data_desc *txd;
 	u32 word;
@@ -1526,8 +1406,8 @@ static irqreturn_t rt2500pci_interrupt(i
 	 * Get the interrupt sources & saved to local variable.
 	 * Write register value back to clear pending interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, CSR7, &reg);
-	rt2x00_register_write(rt2x00dev, CSR7, reg);
+	rt2x00pci_register_read(rt2x00dev, CSR7, &reg);
+	rt2x00pci_register_write(rt2x00dev, CSR7, reg);
 
 	if (!reg)
 		return IRQ_NONE;
@@ -1545,31 +1425,31 @@ static irqreturn_t rt2500pci_interrupt(i
 	 * 1 - Beacon timer expired interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TBCN_EXPIRE))
-		rt2x00pci_beacondone(rt2x00dev, RING_BEACON);
+		rt2x00pci_beacondone(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * 2 - Rx ring done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_RXDONE))
-		rt2500pci_rxdone(rt2x00dev, RING_RX);
+		rt2x00pci_rxdone(rt2x00dev);
 
 	/*
 	 * 3 - Atim ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_ATIMRING))
-		rt2500pci_txdone(rt2x00dev, RING_ATIM);
+		rt2500pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_AFTER_BEACON);
 
 	/*
 	 * 4 - Priority ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_PRIORING))
-		rt2500pci_txdone(rt2x00dev, RING_PRIO);
+		rt2500pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_DATA0);
 
 	/*
 	 * 5 - Tx ring transmit done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, CSR7_TXDONE_TXRING))
-		rt2500pci_txdone(rt2x00dev, RING_TX);
+		rt2500pci_txdone(rt2x00dev, IEEE80211_TX_QUEUE_DATA1);
 
 	return IRQ_HANDLED;
 }
@@ -1582,6 +1462,7 @@ static int rt2500pci_alloc_eeprom(struct
 	struct eeprom_93cx6 eeprom;
 	u32 reg;
 	u16 word;
+	u8 *mac;
 
 	/*
 	 * Allocate the eeprom memory, check the eeprom width
@@ -1591,7 +1472,7 @@ static int rt2500pci_alloc_eeprom(struct
 	if (!rt2x00dev->eeprom)
 		return -ENOMEM;
 
-	rt2x00_register_read(rt2x00dev, CSR21, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR21, &reg);
 
 	eeprom.data = rt2x00dev;
 	eeprom.register_read = rt2500pci_eepromregister_read;
@@ -1609,6 +1490,12 @@ static int rt2500pci_alloc_eeprom(struct
 	/*
 	 * Start validation of the data that has been read.
 	 */
+	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+	if (!is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		EEPROM(rt2x00dev, "MAC: " MAC_FMT "\n", MAC_ARG(mac));
+	}
+
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);
@@ -1634,7 +1521,7 @@ static int rt2500pci_alloc_eeprom(struct
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_CALIBRATE_OFFSET_RSSI,
-			MAX_RX_SSI);
+			DEFAULT_RSSI_OFFSET);
 		rt2x00_eeprom_write(rt2x00dev, EEPROM_CALIBRATE_OFFSET, word);
 		EEPROM(rt2x00dev, "Calibrate offset: 0x%04x\n", word);
 	}
@@ -1657,7 +1544,7 @@ static int rt2500pci_init_eeprom(struct 
 	 * Identify RF chipset.
 	 */
 	value = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);
-	rt2x00_register_read(rt2x00dev, CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR0, &reg);
 	rt2x00_set_chip(rt2x00dev, RT2560, value, reg);
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF2522) &&
@@ -1702,7 +1589,7 @@ static int rt2500pci_init_eeprom(struct 
 	 * Read the RSSI <-> dBm offset information.
 	 */
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &eeprom);
-	rt2x00dev->hw->max_rssi =
+	rt2x00dev->rssi_offset =
 		rt2x00_get_field16(eeprom, EEPROM_CALIBRATE_OFFSET_RSSI);
 
 	return 0;
@@ -1776,16 +1663,16 @@ static void rt2500pci_init_hw_mode(struc
 		IEEE80211_HW_WEP_INCLUDE_IV |
 		IEEE80211_HW_DATA_NULLFUNC_ACK |
 		IEEE80211_HW_NO_TKIP_WMM_HWACCEL |
-		IEEE80211_HW_MONITOR_DURING_OPER;
+		IEEE80211_HW_MONITOR_DURING_OPER |
+		IEEE80211_HW_NO_PROBE_FILTERING;
 	rt2x00dev->hw->extra_tx_headroom = 0;
 	rt2x00dev->hw->max_rssi = MAX_RX_SSI;
 	rt2x00dev->hw->max_noise = MAX_RX_NOISE;
-	rt2x00dev->hw->queues = RING_NUM_TX;
+	rt2x00dev->hw->queues = 2;
 
-	/*
-	 * This device supports ATIM
-	 */
-	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	SET_IEEE80211_DEV(rt2x00dev->hw, &rt2x00dev_pci(rt2x00dev)->dev);
+	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
+		rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0));
 
 	/*
 	 * Set device specific, but channel independent RF values.
@@ -1808,7 +1695,6 @@ static void rt2500pci_init_hw_mode(struc
 	/*
 	 * Initialize hw_mode information.
 	 */
-	spec->mac_addr = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
 	spec->num_modes = 2;
 	spec->num_rates = 12;
 	spec->num_channels = 14;
@@ -1854,6 +1740,11 @@ static int rt2500pci_init_hw(struct rt2x
 	 */
 	rt2500pci_init_hw_mode(rt2x00dev);
 
+	/*
+	 * This device supports ATIM
+	 */
+	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+
 	return 0;
 }
 
@@ -1871,7 +1762,7 @@ static int rt2500pci_get_stats(struct ie
 	 * The dot11ACKFailureCount, dot11RTSFailureCount and
 	 * dot11RTSSuccessCount are updated in interrupt time.
 	 */
-	rt2x00_register_read(rt2x00dev, CNT0, &reg);
+	rt2x00pci_register_read(rt2x00dev, CNT0, &reg);
 	rt2x00dev->low_level_stats.dot11FCSErrorCount +=
 		rt2x00_get_field32(reg, CNT0_FCS_ERROR);
 
@@ -1886,10 +1777,10 @@ static int rt2500pci_set_retry_limit(str
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR11, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR11, &reg);
 	rt2x00_set_field32(&reg, CSR11_LONG_RETRY, long_retry);
 	rt2x00_set_field32(&reg, CSR11_SHORT_RETRY, short_retry);
-	rt2x00_register_write(rt2x00dev, CSR11, reg);
+	rt2x00pci_register_write(rt2x00dev, CSR11, reg);
 
 	return 0;
 }
@@ -1900,9 +1791,9 @@ static u64 rt2500pci_get_tsf(struct ieee
 	u64 tsf;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR17, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR17, &reg);
 	tsf = (u64)rt2x00_get_field32(reg, CSR17_HIGH_TSFTIMER) << 32;
-	rt2x00_register_read(rt2x00dev, CSR16, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR16, &reg);
 	tsf |= rt2x00_get_field32(reg, CSR16_LOW_TSFTIMER);
 
 	return tsf;
@@ -1912,8 +1803,8 @@ static void rt2500pci_reset_tsf(struct i
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
-	rt2x00_register_write(rt2x00dev, CSR16, 0);
-	rt2x00_register_write(rt2x00dev, CSR17, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR16, 0);
+	rt2x00pci_register_write(rt2x00dev, CSR17, 0);
 }
 
 static int rt2500pci_tx_last_beacon(struct ieee80211_hw *hw)
@@ -1921,15 +1812,13 @@ static int rt2500pci_tx_last_beacon(stru
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, CSR15, &reg);
+	rt2x00pci_register_read(rt2x00dev, CSR15, &reg);
 	return rt2x00_get_field32(reg, CSR15_BEACON_SENT);
 }
 
 static const struct ieee80211_ops rt2500pci_mac80211_ops = {
 	.tx			= rt2x00lib_tx,
 	.reset			= rt2x00lib_reset,
-	.open			= rt2x00lib_open,
-	.stop			= rt2x00lib_stop,
 	.add_interface		= rt2x00lib_add_interface,
 	.remove_interface	= rt2x00lib_remove_interface,
 	.config			= rt2x00lib_config,
@@ -1958,6 +1847,7 @@ static const struct rt2x00lib_ops rt2500
 	.write_tx_desc		= rt2500pci_write_tx_desc,
 	.write_tx_data		= rt2x00pci_write_tx_data,
 	.kick_tx_queue		= rt2500pci_kick_tx_queue,
+	.fill_rxdone		= rt2500pci_fill_rxdone,
 	.config_type		= rt2500pci_config_type,
 	.config_phymode		= rt2500pci_config_phymode,
 	.config_channel		= rt2500pci_config_channel,
@@ -1995,12 +1885,6 @@ MODULE_SUPPORTED_DEVICE("Ralink RT2560 P
 MODULE_DEVICE_TABLE(pci, rt2500pci_device_table);
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
-
 static struct pci_driver rt2500pci_driver = {
 	.name		= DRV_NAME,
 	.id_table	= rt2500pci_device_table,
@@ -2014,14 +1898,11 @@ static struct pci_driver rt2500pci_drive
 
 static int __init rt2500pci_init(void)
 {
-	printk(KERN_INFO "Loading module: %s - %s by %s.\n",
-		DRV_NAME, DRV_VERSION, DRV_PROJECT);
 	return pci_register_driver(&rt2500pci_driver);
 }
 
 static void __exit rt2500pci_exit(void)
 {
-	printk(KERN_INFO "Unloading module: %s.\n", DRV_NAME);
 	pci_unregister_driver(&rt2500pci_driver);
 }
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt2500pci.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2500pci.h	2007-07-09 21:00:13.000000000 +0200
@@ -45,10 +45,11 @@
 #define RT2560_VERSION_D		4
 
 /*
- * Max RSSI value, required for RSSI <-> dBm conversion.
+ * Signal information.
  */
-#define MAX_RX_SSI			121
+#define MAX_RX_SSI			-1
 #define MAX_RX_NOISE			-110
+#define DEFAULT_RSSI_OFFSET		121
 
 /*
  * Register layout information.
@@ -249,11 +250,11 @@
  * CSR12: Synchronization configuration register 0.
  * All units in 1/16 TU.
  * BEACON_INTERVAL: Beacon interval, default is 100 TU.
- * CFPMAX_DURATION: Cfp maximum duration, default is 100 TU.
+ * CFP_MAX_DURATION: Cfp maximum duration, default is 100 TU.
  */
 #define CSR12				0x0030
 #define CSR12_BEACON_INTERVAL		FIELD32(0x0000ffff)
-#define CSR12_CFPMAX_DURATION		FIELD32(0xffff0000)
+#define CSR12_CFP_MAX_DURATION		FIELD32(0xffff0000)
 
 /*
  * CSR13: Synchronization configuration register 1.
@@ -1029,6 +1030,28 @@
 #define EEPROM_CALIBRATE_OFFSET_RSSI	FIELD16(0x00ff)
 
 /*
+ * BBP content.
+ * The wordsize of the BBP is 8 bits.
+ */
+
+/*
+ * BBP_R2: TX antenna control
+ */
+#define BBP_R2_TX_ANTENNA		FIELD8(0x03)
+#define BBP_R2_TX_IQ_FLIP		FIELD8(0x04)
+
+/*
+ * BBP_R14: RX antenna control
+ */
+#define BBP_R14_RX_ANTENNA		FIELD8(0x03)
+#define BBP_R14_RX_IQ_FLIP		FIELD8(0x04)
+
+/*
+ * BBP_R70
+ */
+#define BBP_R70_JAPAN_FILTER		FIELD8(0x08)
+
+/*
  * DMA descriptor defines.
  */
 #define TXD_DESC_SIZE			( 11 * sizeof(struct data_desc) )
@@ -1162,19 +1185,6 @@
 #define RXD_W10_DROP			FIELD32(0x00000001)
 
 /*
- * TX ring index number for rt2x00_dev structure.
- */
-enum ring_index {
-	RING_PRIO = 0,
-	RING_TX = 1,
-	RING_ATIM = 2,
-	RING_BEACON = 3,
-	RING_RX = 4,
-	RING_NUM = 5,
-	RING_NUM_TX = 2,
-};
-
-/*
  * Macro's for converting txpower from EEPROM to dscape value
  * and from dscape value to register value.
  */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2500usb.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2500usb.c	2007-07-09 21:00:14.000000000 +0200
@@ -38,13 +38,14 @@
 #include <linux/etherdevice.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00usb.h"
 #include "rt2500usb.h"
 
 /*
  * Register access.
  * All access to the CSR registers will go through the methods
- * rt2x00_register_read and rt2x00_register_write.
+ * rt2500usb_register_read and rt2500usb_register_write.
  * BBP and RF register require indirect register access,
  * and use the CSR registers BBPCSR and RFCSR to achieve this.
  * These indirect registers work with busy bits,
@@ -54,90 +55,63 @@
  * the access attempt is considered to have failed,
  * and we will print an error.
  */
-static int rt2x00_vendor_request(const struct rt2x00_dev *rt2x00dev,
-	const u8 request, const u8 type, const u16 offset,
-	u32 value, void *buffer, const u16 buffer_length, const u16 timeout)
-{
-	struct usb_device *usb_dev = interface_to_usbdev(
-		rt2x00dev_usb(rt2x00dev));
-	int status;
-	unsigned int i;
-
-	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		status = usb_control_msg(
-			usb_dev,
-			(type == USB_VENDOR_REQUEST_IN) ?
-				usb_rcvctrlpipe(usb_dev, 0) :
-				usb_sndctrlpipe(usb_dev, 0),
-			request, type, value, offset, buffer, buffer_length,
-			timeout);
-		if (status >= 0)
-			return 0;
-	}
-
-	ERROR(rt2x00dev, "vendor request error. Request 0x%02x failed "
-		"for offset 0x%04x with error %d.\n", request, offset, status);
-
-	return status;
-}
-
-static inline void rt2x00_register_read(
+static inline void rt2500usb_register_read(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, u16 *value)
 {
 	__le16 reg;
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_READ, USB_VENDOR_REQUEST_IN,
 		offset, 0x00, &reg, sizeof(u16), REGISTER_TIMEOUT);
 	*value = le16_to_cpu(reg);
 }
 
-static inline void rt2x00_register_multiread(
+static inline void rt2500usb_register_multiread(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, void *value, const u16 length)
 {
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_READ, USB_VENDOR_REQUEST_IN,
 		offset, 0x00, value, length,
 		REGISTER_TIMEOUT * (length / sizeof(u16)));
 }
 
-static inline void rt2x00_register_write(
+static inline void rt2500usb_register_write(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, u16 value)
 {
 	__le16 reg = cpu_to_le16(value);
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_WRITE, USB_VENDOR_REQUEST_OUT,
 		offset, 0x00, &reg, sizeof(u16), REGISTER_TIMEOUT);
 }
 
-static inline void rt2x00_register_multiwrite(
+static inline void rt2500usb_register_multiwrite(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, void *value, const u16 length)
 {
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_WRITE, USB_VENDOR_REQUEST_OUT,
 		offset, 0x00, value, length,
 		REGISTER_TIMEOUT * (length / sizeof(u16)));
 }
 
-static u16 rt2x00_bbp_check(const struct rt2x00_dev *rt2x00dev)
+static u16 rt2500usb_bbp_check(const struct rt2x00_dev *rt2x00dev)
 {
 	u16 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR8, &reg);
-		if (!rt2x00_get_field16(reg, PHY_CSR8_BBP_BUSY))
-			return reg;
+		rt2500usb_register_read(rt2x00dev, PHY_CSR8, &reg);
+		if (!rt2x00_get_field16(reg, PHY_CSR8_BUSY))
+			break;
 		udelay(REGISTER_BUSY_DELAY);
 	}
 
-	return 0xffff;
+	return reg;
 }
 
-static void rt2x00_bbp_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2500usb_bbp_write(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, const u8 value)
 {
 	u16 reg;
@@ -145,7 +119,8 @@ static void rt2x00_bbp_write(const struc
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2500usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field16(reg, PHY_CSR8_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR8 register busy. Write failed.\n");
 		return;
 	}
@@ -154,14 +129,14 @@ static void rt2x00_bbp_write(const struc
 	 * Write the data into the BBP.
 	 */
 	reg = 0;
-	rt2x00_set_field16(&reg, PHY_CSR7_BBP_DATA, value);
-	rt2x00_set_field16(&reg, PHY_CSR7_BBP_REG_ID, reg_id);
-	rt2x00_set_field16(&reg, PHY_CSR7_BBP_READ_CONTROL, 0);
+	rt2x00_set_field16(&reg, PHY_CSR7_DATA, value);
+	rt2x00_set_field16(&reg, PHY_CSR7_REG_ID, reg_id);
+	rt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 0);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR7, reg);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR7, reg);
 }
 
-static void rt2x00_bbp_read(const struct rt2x00_dev *rt2x00dev,
+static void rt2500usb_bbp_read(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, u8 *value)
 {
 	u16 reg;
@@ -169,7 +144,8 @@ static void rt2x00_bbp_read(const struct
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2500usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field16(reg, PHY_CSR8_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR8 register busy. Read failed.\n");
 		return;
 	}
@@ -178,32 +154,33 @@ static void rt2x00_bbp_read(const struct
 	 * Write the request into the BBP.
 	 */
 	reg =0;
-	rt2x00_set_field16(&reg, PHY_CSR7_BBP_REG_ID, reg_id);
-	rt2x00_set_field16(&reg, PHY_CSR7_BBP_READ_CONTROL, 1);
+	rt2x00_set_field16(&reg, PHY_CSR7_REG_ID, reg_id);
+	rt2x00_set_field16(&reg, PHY_CSR7_READ_CONTROL, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR7, reg);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR7, reg);
 
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt2500usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field16(reg, PHY_CSR8_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR8 register busy. Read failed.\n");
 		*value = 0xff;
 		return;
 	}
 
-	rt2x00_register_read(rt2x00dev, PHY_CSR7, &reg);
-	*value = rt2x00_get_field16(reg, PHY_CSR7_BBP_DATA);
+	rt2500usb_register_read(rt2x00dev, PHY_CSR7, &reg);
+	*value = rt2x00_get_field16(reg, PHY_CSR7_DATA);
 }
 
-static void rt2x00_rf_write(const struct rt2x00_dev *rt2x00dev,
+static void rt2500usb_rf_write(const struct rt2x00_dev *rt2x00dev,
 	const u32 value)
 {
 	u16 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR10, &reg);
+		rt2500usb_register_read(rt2x00dev, PHY_CSR10, &reg);
 		if (!rt2x00_get_field16(reg, PHY_CSR10_RF_BUSY))
 			goto rf_write;
 		udelay(REGISTER_BUSY_DELAY);
@@ -214,17 +191,16 @@ static void rt2x00_rf_write(const struct
 
 rf_write:
 	reg = 0;
-	rt2x00_set_field16(&reg, PHY_CSR9_RF_VALUE, value & 0x0000ffff);
-	rt2x00_register_write(rt2x00dev, PHY_CSR9, reg);
+	rt2x00_set_field16(&reg, PHY_CSR9_RF_VALUE, value);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR9, reg);
 
 	reg = 0;
-	rt2x00_set_field16(&reg, PHY_CSR10_RF_VALUE,
-		(value >> 16) & 0x0000ffff);
+	rt2x00_set_field16(&reg, PHY_CSR10_RF_VALUE, value >> 16);
 	rt2x00_set_field16(&reg, PHY_CSR10_RF_NUMBER_OF_BITS, 20);
 	rt2x00_set_field16(&reg, PHY_CSR10_RF_IF_SELECT, 0);
 	rt2x00_set_field16(&reg, PHY_CSR10_RF_BUSY, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR10, reg);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR10, reg);
 }
 
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
@@ -233,13 +209,13 @@ rf_write:
 static void rt2500usb_read_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_read(rt2x00dev, CSR_OFFSET(word), data);
+	rt2500usb_register_read(rt2x00dev, CSR_OFFSET(word), data);
 }
 
 static void rt2500usb_write_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_write(rt2x00dev, CSR_OFFSET(word), *((u16*)data));
+	rt2500usb_register_write(rt2x00dev, CSR_OFFSET(word), *((u16*)data));
 }
 
 static void rt2500usb_read_eeprom(struct rt2x00_dev *rt2x00dev,
@@ -257,13 +233,13 @@ static void rt2500usb_write_eeprom(struc
 static void rt2500usb_read_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_read(rt2x00dev, word, data);
+	rt2500usb_bbp_read(rt2x00dev, word, data);
 }
 
 static void rt2500usb_write_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_write(rt2x00dev, word, *((u8*)data));
+	rt2500usb_bbp_write(rt2x00dev, word, *((u8*)data));
 }
 
 static const struct rt2x00debug rt2500usb_rt2x00debug = {
@@ -303,45 +279,30 @@ static void rt2500usb_config_bssid(struc
 	 * The BSSID is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR5, &reg, sizeof(reg));
+	rt2500usb_register_multiwrite(rt2x00dev, MAC_CSR5, &reg, sizeof(reg));
 }
 
-static void rt2500usb_config_promisc(struct rt2x00_dev *rt2x00dev, int promisc)
+static void rt2500usb_config_promisc(struct rt2x00_dev *rt2x00dev,
+	const int promisc)
 {
 	u16 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR2, &reg);
-
-	if (promisc) {
-		rt2x00_set_field16(&reg, TXRX_CSR2_DROP_NOT_TO_ME, 0);
-		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	} else {
-		rt2x00_set_field16(&reg, TXRX_CSR2_DROP_NOT_TO_ME, 1);
-		__clear_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	}
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);
+	rt2x00_set_field16(&reg, TXRX_CSR2_DROP_NOT_TO_ME, !promisc);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);
 }
 
-static void rt2500usb_config_type(struct rt2x00_dev *rt2x00dev, int type)
+static void rt2500usb_config_type(struct rt2x00_dev *rt2x00dev,
+	const int type)
 {
 	u16 reg;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (!(is_interface_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
-	    !(is_monitor_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
-		return;
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR19, 0);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);
 
 	/*
 	 * Apply hardware packet filter.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR2, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);
 
 	if (!is_monitor_present(&rt2x00dev->interface) &&
 	    (type == IEEE80211_IF_TYPE_IBSS || type == IEEE80211_IF_TYPE_STA))
@@ -360,29 +321,28 @@ static void rt2500usb_config_type(struct
 		rt2x00_set_field16(&reg, TXRX_CSR2_DROP_VERSION_ERROR, 1);
 	}
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);
 
 	/*
 	 * Enable beacon config
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR20, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR20, &reg);
 	rt2x00_set_field16(&reg, TXRX_CSR20_OFFSET,
 		(PREAMBLE + get_duration(IEEE80211_HEADER, 2)) >> 6);
 	if (type == IEEE80211_IF_TYPE_STA)
 		rt2x00_set_field16(&reg, TXRX_CSR20_BCN_EXPECT_WINDOW, 0);
 	else
 		rt2x00_set_field16(&reg, TXRX_CSR20_BCN_EXPECT_WINDOW, 2);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR20, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR20, reg);
 
 	/*
 	 * Enable synchronisation.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR18, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR18, &reg);
 	rt2x00_set_field16(&reg, TXRX_CSR18_OFFSET, 0);
-	rt2x00_set_field16(&reg, TXRX_CSR18_INTERVAL, 100 << 2);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR18, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR19, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);
 	if (is_interface_present(&rt2x00dev->interface)) {
 		rt2x00_set_field16(&reg, TXRX_CSR19_TSF_COUNT, 1);
 		rt2x00_set_field16(&reg, TXRX_CSR19_TBCN, 1);
@@ -397,45 +357,17 @@ static void rt2500usb_config_type(struct
 		 !is_interface_present(&rt2x00dev->interface))
 		rt2x00_set_field16(&reg, TXRX_CSR19_TSF_SYNC, 0);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR19, reg);
-
-	/*
-	 * Change flags of enabled interfaces.
-	 */
-	if (type != IEEE80211_IF_TYPE_MNTR) {
-		if (is_interface_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	} else {
-		if (is_monitor_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-	}
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);
 }
 
 static void rt2500usb_config_channel(struct rt2x00_dev *rt2x00dev,
-	int value, int channel, int freq, int txpower)
+	const int value, const int channel, const int txpower)
 {
 	u32 rf1 = rt2x00dev->rf1;
 	u32 rf2 = value;
 	u32 rf3 = rt2x00dev->rf3;
 	u32 rf4 = rt2x00dev->rf4;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (channel == rt2x00dev->rx_status.channel)
-		return;
-
-	if (txpower == 0xff)
-		txpower = rt2x00dev->tx_power;
-	else
-		txpower = TXPOWER_TO_DEV(txpower);
-
 	if (rt2x00_rf(&rt2x00dev->chip, RF2525))
 		rf2 |= 0x00080000;
 
@@ -476,11 +408,7 @@ static void rt2500usb_config_channel(str
 	/*
 	 * Set TXpower.
 	 */
-	rt2x00_set_field32(&rf3, RF3_TXPOWER, txpower);
-
-	INFO(rt2x00dev, "Switching channel. "
-		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x, RF4: 0x%08x.\n",
-		rf1, rf2, rf3, rf4);
+	rt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));
 
 	/*
 	 * For RT2525E we should first set the channel to half band higher.
@@ -493,22 +421,16 @@ static void rt2500usb_config_channel(str
 			0x00000902, 0x00000906
 		};
 
-		rt2x00_rf_write(rt2x00dev, vals[channel - 1]);
+		rt2500usb_rf_write(rt2x00dev, vals[channel - 1]);
 		if (rf4)
-			rt2x00_rf_write(rt2x00dev, rf4);
+			rt2500usb_rf_write(rt2x00dev, rf4);
 	}
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3);
+	rt2500usb_rf_write(rt2x00dev, rf1);
+	rt2500usb_rf_write(rt2x00dev, rf2);
+	rt2500usb_rf_write(rt2x00dev, rf3);
 	if (rf4)
-		rt2x00_rf_write(rt2x00dev, rf4);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.freq = freq;
-	rt2x00dev->rx_status.channel = channel;
+		rt2500usb_rf_write(rt2x00dev, rf4);
 
 	/*
 	 * Update rf fields
@@ -517,114 +439,93 @@ static void rt2500usb_config_channel(str
 	rt2x00dev->rf2 = rf2;
 	rt2x00dev->rf3 = rf3;
 	rt2x00dev->rf4 = rf4;
-
 	rt2x00dev->tx_power = txpower;
 }
 
-static void rt2500usb_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
+static void rt2500usb_config_txpower(struct rt2x00_dev *rt2x00dev,
+	const int txpower)
 {
-	txpower = TXPOWER_TO_DEV(txpower);
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (txpower == rt2x00dev->tx_power)
-		return;
-
-	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER, txpower);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3);
-
-	rt2x00dev->tx_power = txpower;
+	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER,
+		TXPOWER_TO_DEV(txpower));
+	rt2500usb_rf_write(rt2x00dev, rt2x00dev->rf3);
 }
 
 static void rt2500usb_config_antenna(struct rt2x00_dev *rt2x00dev,
-	int antenna_tx, int antenna_rx)
+	const int antenna_tx, const int antenna_rx)
 {
-	u8 reg_rx;
-	u8 reg_tx;
-	u16 csr5_reg;
-	u16 csr6_reg;
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.antenna == antenna_rx)
-		return;
-
-	rt2x00_bbp_read(rt2x00dev, 2, &reg_tx);
-	rt2x00_bbp_read(rt2x00dev, 14, &reg_rx);
-	rt2x00_register_read(rt2x00dev, PHY_CSR5, &csr5_reg);
-	rt2x00_register_read(rt2x00dev, PHY_CSR6, &csr6_reg);
-
-	/*
-	 * Clear current config antenna bits.
-	 */
-	reg_tx &= ~0x03;
-	reg_rx &= ~0x03;
+	u8 r2;
+	u8 r14;
+	u16 csr5;
+	u16 csr6;
+
+	rt2500usb_bbp_read(rt2x00dev, 2, &r2);
+	rt2500usb_bbp_read(rt2x00dev, 14, &r14);
+	rt2500usb_register_read(rt2x00dev, PHY_CSR5, &csr5);
+	rt2500usb_register_read(rt2x00dev, PHY_CSR6, &csr6);
 
 	/*
 	 * Configure the TX antenna.
 	 */
-	if (antenna_tx == 0) {		/* Diversity. */
-		reg_tx |= 0x01;
-		rt2x00_set_field16(&csr5_reg, PHY_CSR5_CCK, 1);
-		rt2x00_set_field16(&csr6_reg, PHY_CSR6_OFDM, 1);
-	} else if (antenna_tx == 1) {	/* TX: Antenna A */
-		reg_tx |= 0x00;
-		rt2x00_set_field16(&csr5_reg, PHY_CSR5_CCK, 0);
-		rt2x00_set_field16(&csr6_reg, PHY_CSR6_OFDM, 0);
-	} else if (antenna_tx == 2) {	/* TX: Antenna B */
-		reg_tx |= 0x02;
-		rt2x00_set_field16(&csr5_reg, PHY_CSR5_CCK, 2);
-		rt2x00_set_field16(&csr6_reg, PHY_CSR6_OFDM, 2);
+	if (antenna_tx == ANTENNA_DIVERSITY) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 1);
+		rt2x00_set_field16(&csr5, PHY_CSR5_CCK, 1);
+		rt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 1);
+	} else if (antenna_tx == ANTENNA_A) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 0);
+		rt2x00_set_field16(&csr5, PHY_CSR5_CCK, 0);
+		rt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 0);
+	} else if (antenna_tx == ANTENNA_B) {
+		rt2x00_set_field8(&r2, BBP_R2_TX_ANTENNA, 2);
+		rt2x00_set_field16(&csr5, PHY_CSR5_CCK, 2);
+		rt2x00_set_field16(&csr6, PHY_CSR6_OFDM, 2);
 	}
 
 	/*
 	 * Configure the RX antenna.
 	 */
-	if (antenna_rx == 0)		/* Diversity. */
-		reg_rx |= 0x01;
-	else if (antenna_rx == 1)	/* RX: Antenna A */
-		reg_rx |= 0x00;
-	else if (antenna_rx == 2)	/* RX: Antenna B */
-		reg_rx |= 0x02;
+	if (antenna_rx == ANTENNA_DIVERSITY)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 1);
+	else if (antenna_rx == ANTENNA_A)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 0);
+	else if (antenna_rx == ANTENNA_B)
+		rt2x00_set_field8(&r14, BBP_R14_RX_ANTENNA, 2);
 
 	/*
 	 * RT2525E and RT5222 need to flip TX I/Q
 	 */
 	if (rt2x00_rf(&rt2x00dev->chip, RF2525E) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF5222)) {
-		reg_tx |= 0x04;
-		rt2x00_set_field16(&csr5_reg, PHY_CSR5_CCK_FLIP, 1);
-		rt2x00_set_field16(&csr6_reg, PHY_CSR6_OFDM_FLIP, 1);
+		rt2x00_set_field8(&r2, BBP_R2_TX_IQ_FLIP, 1);
+		rt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 1);
+		rt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 1);
 
 		/*
 		 * RT2525E does not need RX I/Q Flip.
 		 */
 		if (rt2x00_rf(&rt2x00dev->chip, RF2525E))
-			reg_rx &= ~0x04;
+			rt2x00_set_field8(&r14, BBP_R14_RX_IQ_FLIP, 0);
 	} else {
-		rt2x00_set_field16(&csr5_reg, PHY_CSR5_CCK_FLIP, 0);
-		rt2x00_set_field16(&csr6_reg, PHY_CSR6_OFDM_FLIP, 0);
+		rt2x00_set_field16(&csr5, PHY_CSR5_CCK_FLIP, 0);
+		rt2x00_set_field16(&csr6, PHY_CSR6_OFDM_FLIP, 0);
 	}
 
-	rt2x00_bbp_write(rt2x00dev, 2, reg_tx);
-	rt2x00_bbp_write(rt2x00dev, 14, reg_rx);
-	rt2x00_register_write(rt2x00dev, PHY_CSR5, csr5_reg);
-	rt2x00_register_write(rt2x00dev, PHY_CSR6, csr6_reg);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.antenna = antenna_rx;
+	rt2500usb_bbp_write(rt2x00dev, 2, r2);
+	rt2500usb_bbp_write(rt2x00dev, 14, r14);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR5, csr5);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR6, csr6);
 }
 
 static void rt2500usb_config_duration(struct rt2x00_dev *rt2x00dev,
-	int short_slot_time)
+	const int short_slot_time, const int beacon_int)
 {
-	short_slot_time = short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME;
+	u16 reg;
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR10, short_slot_time);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR10,
+		short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME);
+
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR18, &reg);
+	rt2x00_set_field16(&reg, TXRX_CSR18_INTERVAL, beacon_int * 4);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR18, reg);
 }
 
 static void rt2500usb_config_rate(struct rt2x00_dev *rt2x00dev, const int rate)
@@ -639,21 +540,21 @@ static void rt2500usb_config_rate(struct
 
 	reg = DEVICE_GET_RATE_FIELD(rate, RATEMASK) & DEV_BASIC_RATE;
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR11, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR11, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR1, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR1, &reg);
 	value = ((conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME) ?
 		 SHORT_DIFS :  DIFS) +
 		PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field16(&reg, TXRX_CSR1_ACK_TIMEOUT, value);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR1, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR10, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR10, &reg);
 	if (preamble == SHORT_PREAMBLE)
 		rt2x00_set_field16(&reg, TXRX_CSR10_AUTORESPOND_PREAMBLE, 1);
 	else
 		rt2x00_set_field16(&reg, TXRX_CSR10_AUTORESPOND_PREAMBLE, 0);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR10, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR10, reg);
 }
 
 static void rt2500usb_config_phymode(struct rt2x00_dev *rt2x00dev,
@@ -662,12 +563,6 @@ static void rt2500usb_config_phymode(str
 	struct ieee80211_hw_mode *mode;
 	struct ieee80211_rate *rate;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.phymode == phymode)
-		return;
-
 	if (phymode == MODE_IEEE80211A)
 		rt2x00dev->curr_hwmode = HWMODE_A;
 	else if (phymode == MODE_IEEE80211B)
@@ -681,17 +576,12 @@ static void rt2500usb_config_phymode(str
 	rt2500usb_config_rate(rt2x00dev, rate->val2);
 
 	if (phymode == MODE_IEEE80211B) {
-		rt2x00_register_write(rt2x00dev, MAC_CSR11, 0x000b);
-		rt2x00_register_write(rt2x00dev, MAC_CSR12, 0x0040);
+		rt2500usb_register_write(rt2x00dev, MAC_CSR11, 0x000b);
+		rt2500usb_register_write(rt2x00dev, MAC_CSR12, 0x0040);
 	} else {
-		rt2x00_register_write(rt2x00dev, MAC_CSR11, 0x0005);
-		rt2x00_register_write(rt2x00dev, MAC_CSR12, 0x016c);
+		rt2500usb_register_write(rt2x00dev, MAC_CSR11, 0x0005);
+		rt2500usb_register_write(rt2x00dev, MAC_CSR12, 0x016c);
 	}
-
-	/*
-	 * Update physical mode for rx ring.
-	 */
-	rt2x00dev->rx_status.phymode = phymode;
 }
 
 static void rt2500usb_config_mac_addr(struct rt2x00_dev *rt2x00dev, u8 *addr)
@@ -705,7 +595,7 @@ static void rt2500usb_config_mac_addr(st
 	 * The MAC address is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
+	rt2500usb_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
 }
 
 /*
@@ -715,12 +605,12 @@ static void rt2500usb_enable_led(struct 
 {
 	u16 reg;
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR21, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR21, &reg);
 	rt2x00_set_field16(&reg, MAC_CSR21_ON_PERIOD, 70);
 	rt2x00_set_field16(&reg, MAC_CSR21_OFF_PERIOD, 30);
-	rt2x00_register_write(rt2x00dev, MAC_CSR21, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR21, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR20, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR20, &reg);
 
 	if (rt2x00dev->led_mode == LED_MODE_TXRX_ACTIVITY) {
 		rt2x00_set_field16(&reg, MAC_CSR20_LINK, 1);
@@ -733,24 +623,25 @@ static void rt2500usb_enable_led(struct 
 		rt2x00_set_field16(&reg, MAC_CSR20_ACTIVITY, 1);
 	}
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR20, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR20, reg);
 }
 
 static void rt2500usb_disable_led(struct rt2x00_dev *rt2x00dev)
 {
 	u16 reg;
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR20, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR20, &reg);
 	rt2x00_set_field16(&reg, MAC_CSR20_LINK, 0);
 	rt2x00_set_field16(&reg, MAC_CSR20_ACTIVITY, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR20, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR20, reg);
 }
 
 /*
  * Link tuning
  */
-static void rt2500usb_link_tuner(struct rt2x00_dev *rt2x00dev, int rssi)
+static void rt2500usb_link_tuner(struct rt2x00_dev *rt2x00dev)
 {
+	int rssi = rt2x00_get_link_rssi(&rt2x00dev->link);
 	u16 bbp_thresh;
 	u16 cca_alarm;
 	u16 vgc_bound;
@@ -784,15 +675,15 @@ static void rt2500usb_link_tuner(struct 
 		r61 = rt2x00_get_field16(r61, EEPROM_BBPTUNE_R61_LOW);
 	}
 
-	rt2x00_bbp_write(rt2x00dev, 24, r24);
-	rt2x00_bbp_write(rt2x00dev, 25, r25);
-	rt2x00_bbp_write(rt2x00dev, 61, r61);
+	rt2500usb_bbp_write(rt2x00dev, 24, r24);
+	rt2500usb_bbp_write(rt2x00dev, 25, r25);
+	rt2500usb_bbp_write(rt2x00dev, 61, r61);
 
 	/*
 	 * Read current r17 value, as well as the sensitivity values
 	 * for the r17 register.
 	 */
-	rt2x00_bbp_read(rt2x00dev, 17, &r17);
+	rt2500usb_bbp_read(rt2x00dev, 17, &r17);
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R17, &r17_sens);
 
 	/*
@@ -802,7 +693,7 @@ static void rt2500usb_link_tuner(struct 
 	 */
 	if (rssi >= -40) {
 		if (r17 != 0x60)
-			rt2x00_bbp_write(rt2x00dev, 17, 0x60);
+			rt2500usb_bbp_write(rt2x00dev, 17, 0x60);
 		return;
 	}
 
@@ -812,7 +703,7 @@ static void rt2500usb_link_tuner(struct 
 	if (rssi >= -58) {
 		sens = rt2x00_get_field16(r17_sens, EEPROM_BBPTUNE_R17_LOW);
 		if (r17 != sens)
-			rt2x00_bbp_write(rt2x00dev, 17, sens);
+			rt2500usb_bbp_write(rt2x00dev, 17, sens);
 		return;
 	}
 
@@ -822,7 +713,7 @@ static void rt2500usb_link_tuner(struct 
 	if (rssi >= -74) {
 		sens = rt2x00_get_field16(r17_sens, EEPROM_BBPTUNE_R17_HIGH);
 		if (r17 != sens)
-			rt2x00_bbp_write(rt2x00dev, 17, sens);
+			rt2500usb_bbp_write(rt2x00dev, 17, sens);
 		return;
 	}
 
@@ -830,7 +721,7 @@ static void rt2500usb_link_tuner(struct 
 	 * Leave short or middle distance condition, restore r17
 	 * to the dynamic tuning range.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR3, &cca_alarm);
+	rt2500usb_register_read(rt2x00dev, STA_CSR3, &cca_alarm);
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC, &vgc_bound);
 	vgc_bound = rt2x00_get_field16(vgc_bound, EEPROM_BBPTUNE_VGCUPPER);
 
@@ -844,133 +735,85 @@ static void rt2500usb_link_tuner(struct 
 		up_bound = low_bound;
 
 	if (r17 > up_bound) {
-		rt2x00_bbp_write(rt2x00dev, 17, up_bound);
-		rt2x00dev->link.curr_noise = up_bound;
+		rt2500usb_bbp_write(rt2x00dev, 17, up_bound);
+		rt2x00dev->rx_status.noise = up_bound;
 	} else if (cca_alarm > 512 && r17 < up_bound) {
-		rt2x00_bbp_write(rt2x00dev, 17, ++r17);
-		rt2x00dev->link.curr_noise = r17;
+		rt2500usb_bbp_write(rt2x00dev, 17, ++r17);
+		rt2x00dev->rx_status.noise = r17;
 	} else if (cca_alarm < 100 && r17 > low_bound) {
-		rt2x00_bbp_write(rt2x00dev, 17, --r17);
-		rt2x00dev->link.curr_noise = r17;
+		rt2500usb_bbp_write(rt2x00dev, 17, --r17);
+		rt2x00dev->rx_status.noise = r17;
 	}
 }
 
 /*
  * Initialization functions.
  */
-static void rt2500usb_init_rxring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
-{
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
-	struct usb_device *usb_dev =
-		interface_to_usbdev(rt2x00dev_usb(rt2x00dev));
-	unsigned int i;
-
-	ring->type = ring_type;
-
-	for (i = 0; i < ring->stats.limit; i++) {
-		usb_fill_bulk_urb(
-			ring->entry[i].priv,
-			usb_dev,
-			usb_rcvbulkpipe(usb_dev, 1),
-			ring->entry[i].skb->data,
-			ring->entry[i].skb->len,
-			rt2500usb_interrupt_rxdone,
-			&ring->entry[i]);
-	}
-
-	rt2x00_ring_index_clear(ring);
-}
-
-static void rt2500usb_init_txring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
-{
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
-	unsigned int i;
-
-	ring->type = ring_type;
-
-	for (i = 0; i < ring->stats.limit; i++)
-		ring->entry[i].flags = 0;
-
-	rt2x00_ring_index_clear(ring);
-}
-
-static int rt2500usb_init_rings(struct rt2x00_dev *rt2x00dev)
-{
-	rt2500usb_init_rxring(rt2x00dev, RING_RX);
-	rt2500usb_init_txring(rt2x00dev, RING_TX);
-	rt2500usb_init_txring(rt2x00dev, RING_ATIM);
-	rt2500usb_init_txring(rt2x00dev, RING_PRIO);
-	rt2500usb_init_txring(rt2x00dev, RING_BEACON);
-
-	return 0;
-}
-
 static int rt2500usb_init_registers(struct rt2x00_dev *rt2x00dev)
 {
 	u16 reg;
 
-	rt2x00_vendor_request(rt2x00dev, USB_DEVICE_MODE,
+	rt2x00usb_vendor_request(rt2x00dev, USB_DEVICE_MODE,
 		USB_VENDOR_REQUEST_OUT, 0x0001, USB_MODE_TEST, NULL, 0,
 		REGISTER_TIMEOUT);
-	rt2x00_vendor_request(rt2x00dev, USB_SINGLE_WRITE,
+	rt2x00usb_vendor_request(rt2x00dev, USB_SINGLE_WRITE,
 		USB_VENDOR_REQUEST_OUT, 0x0308, 0xf0, NULL, 0,
 		REGISTER_TIMEOUT);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, 0x0001);
-	rt2x00_register_write(rt2x00dev, MAC_CSR13, 0x1111);
-	rt2x00_register_write(rt2x00dev, MAC_CSR14, 0x1e11);
-
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, 0x0003);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, 0x0000);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR5, 0x8c8d);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR6, 0x8b8a);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR7, 0x8687);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR8, 0x0085);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR21, 0xe78f);
-	rt2x00_register_write(rt2x00dev, MAC_CSR9, 0xff1d);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);
+	rt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX, 1);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);
+
+	rt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x1111);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x1e11);
+
+	rt2500usb_register_write(rt2x00dev, MAC_CSR1, 0x0003);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR1, 0x0000);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR5, 0x8c8d);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR6, 0x8b8a);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR7, 0x8687);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR8, 0x0085);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR21, 0xe78f);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR9, 0xff1d);
 
 	if (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))
 		return -EBUSY;
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, 0x0004);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR1, 0x0004);
 
-	reg = 0;
-	rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
-	if (reg >= 0x0003) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR2, &reg);
+	if (rt2x00_rev(&rt2x00dev->chip) >= RT2570_VERSION_C) {
+		rt2500usb_register_read(rt2x00dev, PHY_CSR2, &reg);
 		reg &= ~0x0002;
 	} else {
 		reg = 0x3002;
 	}
-	rt2x00_register_write(rt2x00dev, PHY_CSR2, reg);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR2, reg);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR11, 0x0002);
-	rt2x00_register_write(rt2x00dev, MAC_CSR22, 0x0053);
-	rt2x00_register_write(rt2x00dev, MAC_CSR15, 0x01ee);
-	rt2x00_register_write(rt2x00dev, MAC_CSR16, 0x0000);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR11, 0x0002);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR22, 0x0053);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR15, 0x01ee);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR16, 0x0000);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	rt2x00_set_field16(&reg, TXRX_CSR0_IV_OFFSET, IEEE80211_HEADER);
 	rt2x00_set_field16(&reg, TXRX_CSR0_KEY_ID, 0xff);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR8, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR8, &reg);
 	rt2x00_set_field16(&reg, MAC_CSR8_MAX_FRAME_UNIT,
-		rt2x00dev->ring[RING_RX].data_size);
-	rt2x00_register_write(rt2x00dev, MAC_CSR8, reg);
+		rt2x00dev->rx->data_size);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR8, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR18, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR18, &reg);
 	rt2x00_set_field16(&reg, MAC_CSR18_DELAY_AFTER_BEACON, 0x5a);
-	rt2x00_register_write(rt2x00dev, MAC_CSR18, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR18, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR1, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR1, &reg);
 	rt2x00_set_field16(&reg, TXRX_CSR1_AUTO_SEQUENCE, 1);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR1, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, PHY_CSR4, &reg);
-	rt2x00_register_write(rt2x00dev, PHY_CSR4, reg | 0x0001);
+	rt2500usb_register_read(rt2x00dev, PHY_CSR4, &reg);
+	rt2500usb_register_write(rt2x00dev, PHY_CSR4, reg | 0x0001);
 
 	return 0;
 }
@@ -983,7 +826,7 @@ static int rt2500usb_init_bbp(struct rt2
 	u8 reg_id;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_bbp_read(rt2x00dev, 0, &value);
+		rt2500usb_bbp_read(rt2x00dev, 0, &value);
 		if ((value != 0xff) && (value != 0x00))
 			goto continue_csr_init;
 		NOTICE(rt2x00dev, "Waiting for BBP register.\n");
@@ -994,38 +837,38 @@ static int rt2500usb_init_bbp(struct rt2
 	return -EACCES;
 
 continue_csr_init:
-	rt2x00_bbp_write(rt2x00dev, 3, 0x02);
-	rt2x00_bbp_write(rt2x00dev, 4, 0x19);
-	rt2x00_bbp_write(rt2x00dev, 14, 0x1c);
-	rt2x00_bbp_write(rt2x00dev, 15, 0x30);
-	rt2x00_bbp_write(rt2x00dev, 16, 0xac);
-	rt2x00_bbp_write(rt2x00dev, 17, 0x48);
-	rt2x00_bbp_write(rt2x00dev, 18, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 19, 0xff);
-	rt2x00_bbp_write(rt2x00dev, 20, 0x1e);
-	rt2x00_bbp_write(rt2x00dev, 21, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 22, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 23, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 24, 0x80);
-	rt2x00_bbp_write(rt2x00dev, 25, 0x50);
-	rt2x00_bbp_write(rt2x00dev, 26, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 27, 0x23);
-	rt2x00_bbp_write(rt2x00dev, 30, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 31, 0x2b);
-	rt2x00_bbp_write(rt2x00dev, 32, 0xb9);
-	rt2x00_bbp_write(rt2x00dev, 34, 0x12);
-	rt2x00_bbp_write(rt2x00dev, 35, 0x50);
-	rt2x00_bbp_write(rt2x00dev, 39, 0xc4);
-	rt2x00_bbp_write(rt2x00dev, 40, 0x02);
-	rt2x00_bbp_write(rt2x00dev, 41, 0x60);
-	rt2x00_bbp_write(rt2x00dev, 53, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 54, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 56, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 57, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 58, 0x08);
-	rt2x00_bbp_write(rt2x00dev, 61, 0x60);
-	rt2x00_bbp_write(rt2x00dev, 62, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 75, 0xff);
+	rt2500usb_bbp_write(rt2x00dev, 3, 0x02);
+	rt2500usb_bbp_write(rt2x00dev, 4, 0x19);
+	rt2500usb_bbp_write(rt2x00dev, 14, 0x1c);
+	rt2500usb_bbp_write(rt2x00dev, 15, 0x30);
+	rt2500usb_bbp_write(rt2x00dev, 16, 0xac);
+	rt2500usb_bbp_write(rt2x00dev, 17, 0x48);
+	rt2500usb_bbp_write(rt2x00dev, 18, 0x18);
+	rt2500usb_bbp_write(rt2x00dev, 19, 0xff);
+	rt2500usb_bbp_write(rt2x00dev, 20, 0x1e);
+	rt2500usb_bbp_write(rt2x00dev, 21, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 22, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 23, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 24, 0x80);
+	rt2500usb_bbp_write(rt2x00dev, 25, 0x50);
+	rt2500usb_bbp_write(rt2x00dev, 26, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 27, 0x23);
+	rt2500usb_bbp_write(rt2x00dev, 30, 0x10);
+	rt2500usb_bbp_write(rt2x00dev, 31, 0x2b);
+	rt2500usb_bbp_write(rt2x00dev, 32, 0xb9);
+	rt2500usb_bbp_write(rt2x00dev, 34, 0x12);
+	rt2500usb_bbp_write(rt2x00dev, 35, 0x50);
+	rt2500usb_bbp_write(rt2x00dev, 39, 0xc4);
+	rt2500usb_bbp_write(rt2x00dev, 40, 0x02);
+	rt2500usb_bbp_write(rt2x00dev, 41, 0x60);
+	rt2500usb_bbp_write(rt2x00dev, 53, 0x10);
+	rt2500usb_bbp_write(rt2x00dev, 54, 0x18);
+	rt2500usb_bbp_write(rt2x00dev, 56, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 57, 0x10);
+	rt2500usb_bbp_write(rt2x00dev, 58, 0x08);
+	rt2500usb_bbp_write(rt2x00dev, 61, 0x60);
+	rt2500usb_bbp_write(rt2x00dev, 62, 0x10);
+	rt2500usb_bbp_write(rt2x00dev, 75, 0xff);
 
 	DEBUG(rt2x00dev, "Start initialization from EEPROM...\n");
 	for (i = 0; i < EEPROM_BBP_SIZE; i++) {
@@ -1036,26 +879,26 @@ continue_csr_init:
 			value = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);
 			DEBUG(rt2x00dev, "BBP: 0x%02x, value: 0x%02x.\n",
 				reg_id, value);
-			rt2x00_bbp_write(rt2x00dev, reg_id, value);
+			rt2500usb_bbp_write(rt2x00dev, reg_id, value);
 		}
 	}
 	DEBUG(rt2x00dev, "...End initialization from EEPROM.\n");
 
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R24, &eeprom);
 	value = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R24_LOW);
-	rt2x00_bbp_write(rt2x00dev, 24, value);
+	rt2500usb_bbp_write(rt2x00dev, 24, value);
 
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R25, &eeprom);
 	value = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R25_LOW);
-	rt2x00_bbp_write(rt2x00dev, 25, value);
+	rt2500usb_bbp_write(rt2x00dev, 25, value);
 
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_R61, &eeprom);
 	value = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_R61_LOW);
-	rt2x00_bbp_write(rt2x00dev, 61, value);
+	rt2500usb_bbp_write(rt2x00dev, 61, value);
 
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_BBPTUNE_VGC, &eeprom);
 	value = rt2x00_get_field16(eeprom, EEPROM_BBPTUNE_VGCUPPER);
-	rt2x00_bbp_write(rt2x00dev, 17, value);
+	rt2500usb_bbp_write(rt2x00dev, 17, value);
 
 	return 0;
 }
@@ -1068,32 +911,24 @@ static void rt2500usb_toggle_rx(struct r
 {
 	u16 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR2, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR2, &reg);
 	rt2x00_set_field16(&reg, TXRX_CSR2_DISABLE_RX,
 		state == STATE_RADIO_RX_OFF);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, reg);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR2, reg);
 }
 
 static int rt2500usb_enable_radio(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring;
-	unsigned int i;
-
 	/*
 	 * Initialize all registers.
 	 */
-	if (rt2500usb_init_rings(rt2x00dev) ||
-	    rt2500usb_init_registers(rt2x00dev) ||
+	if (rt2500usb_init_registers(rt2x00dev) ||
 	    rt2500usb_init_bbp(rt2x00dev)) {
 		ERROR(rt2x00dev, "Register initialization failed.\n");
 		return -EIO;
 	}
 
-	ring = &rt2x00dev->ring[RING_RX];
-	for (i = 0; i < ring->stats.limit; i++) {
-		__set_bit(ENTRY_OWNER_NIC, &ring->entry[i].flags);
-		usb_submit_urb(ring->entry[i].priv, GFP_ATOMIC);
-	}
+	rt2x00usb_enable_radio(rt2x00dev);
 
 	/*
 	 * Enable LED
@@ -1105,47 +940,20 @@ static int rt2500usb_enable_radio(struct
 
 static void rt2500usb_disable_radio(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring;
-	unsigned int i;
-
 	/*
 	 * Disable LED
 	 */
 	rt2500usb_disable_led(rt2x00dev);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR13, 0x2121);
-	rt2x00_register_write(rt2x00dev, MAC_CSR14, 0x2121);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR13, 0x2121);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR14, 0x2121);
 
 	/*
 	 * Disable synchronisation.
 	 */
-	rt2x00_register_write(rt2x00dev, TXRX_CSR19, 0);
+	rt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);
 
-	/*
-	 * Cancel RX and TX.
-	 */
-	rt2x00_vendor_request(rt2x00dev, USB_RX_CONTROL,
-		USB_VENDOR_REQUEST_OUT, 0x00, 0x00, NULL, 0, REGISTER_TIMEOUT);
-
-	ring = &rt2x00dev->ring[RING_RX];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_TX];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_ATIM];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_PRIO];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_BEACON];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
+	rt2x00usb_disable_radio(rt2x00dev);
 }
 
 static int rt2500usb_set_state(struct rt2x00_dev *rt2x00dev,
@@ -1164,9 +972,9 @@ static int rt2500usb_set_state(struct rt
 	rt2x00_set_field16(&reg, MAC_CSR17_BBP_DESIRE_STATE, state);
 	rt2x00_set_field16(&reg, MAC_CSR17_RF_DESIRE_STATE, state);
 	rt2x00_set_field16(&reg, MAC_CSR17_PUT_TO_SLEEP, put_to_sleep);
-	rt2x00_register_write(rt2x00dev, MAC_CSR17, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);
 	rt2x00_set_field16(&reg, MAC_CSR17_SET_STATE, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR17, reg);
+	rt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);
 
 	/*
 	 * Device is not guaranteed to be in the requested state yet.
@@ -1174,12 +982,12 @@ static int rt2500usb_set_state(struct rt
 	 * device has entered the correct state.
 	 */
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, MAC_CSR17, &reg2);
+		rt2500usb_register_read(rt2x00dev, MAC_CSR17, &reg2);
 		bbp_state = rt2x00_get_field16(reg2, MAC_CSR17_BBP_CURR_STATE);
 		rf_state = rt2x00_get_field16(reg2, MAC_CSR17_RF_CURR_STATE);
 		if (bbp_state == state && rf_state == state)
 			return 0;
-		rt2x00_register_write(rt2x00dev, MAC_CSR17, reg);
+		rt2500usb_register_write(rt2x00dev, MAC_CSR17, reg);
 		msleep(30);
 	}
 
@@ -1258,7 +1066,7 @@ static void rt2500usb_write_tx_desc(stru
 	rt2x00_set_field32(&word, TXD_W0_OFDM,
 		test_bit(ENTRY_TXD_OFDM_RATE, &entry->flags));
 	rt2x00_set_field32(&word, TXD_W0_NEW_SEQ,
-		test_bit(ENTRY_TXD_NEW_SEQ, &entry->flags));
+		control->flags & IEEE80211_TXCTL_FIRST_FRAGMENT);
 	rt2x00_set_field32(&word, TXD_W0_IFS, desc->ifs);
 	rt2x00_set_field32(&word, TXD_W0_DATABYTE_COUNT, length);
 	rt2x00_set_field32(&word, TXD_W0_CIPHER, CIPHER_NONE);
@@ -1275,7 +1083,7 @@ static void rt2500usb_kick_tx_queue(stru
 	if (queue != IEEE80211_TX_QUEUE_BEACON)
 		return;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR19, &reg);
+	rt2500usb_register_read(rt2x00dev, TXRX_CSR19, &reg);
 	if (!rt2x00_get_field16(reg, TXRX_CSR19_BEACON_GEN)) {
 		rt2x00_set_field16(&reg, TXRX_CSR19_BEACON_GEN, 1);
 		/*
@@ -1283,83 +1091,49 @@ static void rt2500usb_kick_tx_queue(stru
 		 * To prevent this we need to register the TXRX_CSR19
 		 * register several times.
 		 */
-		rt2x00_register_write(rt2x00dev, TXRX_CSR19, reg);
-		rt2x00_register_write(rt2x00dev, TXRX_CSR19, 0);
-		rt2x00_register_write(rt2x00dev, TXRX_CSR19, reg);
-		rt2x00_register_write(rt2x00dev, TXRX_CSR19, 0);
-		rt2x00_register_write(rt2x00dev, TXRX_CSR19, reg);
+		rt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);
+		rt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);
+		rt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);
+		rt2500usb_register_write(rt2x00dev, TXRX_CSR19, 0);
+		rt2500usb_register_write(rt2x00dev, TXRX_CSR19, reg);
 	}
 }
 
 /*
- * Interrupt functions.
+ * RX control handlers
  */
-static void rt2500usb_interrupt_rxdone(struct urb *urb)
+static int rt2500usb_fill_rxdone(struct data_entry *entry,
+	int *signal, int *rssi, int *ofdm)
 {
-	struct data_entry *entry = (struct data_entry*)urb->context;
-	struct data_ring *ring = entry->ring;
-	struct rt2x00_dev *rt2x00dev = ring->rt2x00dev;
-	struct data_desc *rxd = (struct data_desc*)
-		(entry->skb->data + urb->actual_length - ring->desc_size);
+	struct urb *urb = entry->priv;
+	struct data_desc *rxd = (struct data_desc*)(entry->skb->data +
+		(urb->actual_length - entry->ring->desc_size));
 	u32 word0;
 	u32 word1;
-	int signal;
-	int rssi;
-	int ofdm;
-	u16 size;
-
-	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags) ||
-	    !test_and_clear_bit(ENTRY_OWNER_NIC, &entry->flags))
-		return;
-
-	/*
-	 * Check if the received data is simply too small
-	 * to be actually valid, or if the urb is signaling
-	 * a problem.
-	 */
-	if (urb->actual_length < entry->ring->desc_size || urb->status)
-		goto skip_entry;
 
 	rt2x00_desc_read(rxd, 0, &word0);
 	rt2x00_desc_read(rxd, 1, &word1);
 
 	/*
 	 * TODO: Don't we need to keep statistics
-	 * updated about events like CRC and physical errors?
+	 * updated about these errors?
 	 */
 	if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
 	    rt2x00_get_field32(word0, RXD_W0_PHYSICAL_ERROR))
-		goto skip_entry;
+		return -EINVAL;
 
 	/*
 	 * Obtain the status about this packet.
 	 */
-	size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT) - FCS_LEN;
-	signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
-	rssi = rt2x00_get_field32(word1, RXD_W1_RSSI);
-	ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
+	*signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
+	*rssi = rt2x00_get_field32(word1, RXD_W1_RSSI) -
+		entry->ring->rt2x00dev->rssi_offset;
+	*ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
 
 	/*
-	 * Trim the skb_buffer to only contain the valid
-	 * frame data (so ignore the device's descriptor).
+	 * rt2570 includes the FCS, so fix data length accordingly.
 	 */
-	skb_trim(entry->skb, size);
-
-	/*
-	 * Send the packet to upper layer, and update urb.
-	 */
-	rt2x00lib_rxdone(entry, NULL, ring->data_size + ring->desc_size,
-		signal, rssi, ofdm);
-	urb->transfer_buffer = entry->skb->data;
-	urb->transfer_buffer_length = entry->skb->len;
-
-skip_entry:
-	if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
-		__set_bit(ENTRY_OWNER_NIC, &entry->flags);
-		usb_submit_urb(urb, GFP_ATOMIC);
-	}
-
-	rt2x00_ring_index_inc(ring);
+	return rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT) - FCS_LEN;
 }
 
 /*
@@ -1368,6 +1142,7 @@ skip_entry:
 static int rt2500usb_alloc_eeprom(struct rt2x00_dev *rt2x00dev)
 {
 	u16 word;
+	u8 *mac;
 
 	/*
 	 * Allocate the eeprom memory, check the eeprom width
@@ -1377,7 +1152,7 @@ static int rt2500usb_alloc_eeprom(struct
 	if (!rt2x00dev->eeprom)
 		return -ENOMEM;
 
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_EEPROM_READ, USB_VENDOR_REQUEST_IN,
 		EEPROM_BASE, 0x00, rt2x00dev->eeprom, EEPROM_SIZE,
 		REGISTER_TIMEOUT * (EEPROM_SIZE / sizeof(u16)));
@@ -1385,6 +1160,12 @@ static int rt2500usb_alloc_eeprom(struct
 	/*
 	 * Start validation of the data that has been read.
 	 */
+	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+	if (!is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		EEPROM(rt2x00dev, "MAC: " MAC_FMT "\n", MAC_ARG(mac));
+	}
+
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);
@@ -1410,7 +1191,7 @@ static int rt2500usb_alloc_eeprom(struct
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_CALIBRATE_OFFSET_RSSI,
-			MAX_RX_SSI);
+			DEFAULT_RSSI_OFFSET);
 		rt2x00_eeprom_write(rt2x00dev, EEPROM_CALIBRATE_OFFSET, word);
 		EEPROM(rt2x00dev, "Calibrate offset: 0x%04x\n", word);
 	}
@@ -1479,7 +1260,7 @@ static int rt2500usb_init_eeprom(struct 
 	 * Identify RF chipset.
 	 */
 	value = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);
-	rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
+	rt2500usb_register_read(rt2x00dev, MAC_CSR0, &reg);
 	rt2x00_set_chip(rt2x00dev, RT2570, value, reg);
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF2522) &&
@@ -1517,7 +1298,7 @@ static int rt2500usb_init_eeprom(struct 
 	 * Read the RSSI <-> dBm offset information.
 	 */
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_CALIBRATE_OFFSET, &eeprom);
-	rt2x00dev->hw->max_rssi =
+	rt2x00dev->rssi_offset =
 		rt2x00_get_field16(eeprom, EEPROM_CALIBRATE_OFFSET_RSSI);
 
 	return 0;
@@ -1594,16 +1375,16 @@ static void rt2500usb_init_hw_mode(struc
 		IEEE80211_HW_WEP_INCLUDE_IV |
 		IEEE80211_HW_DATA_NULLFUNC_ACK |
 		IEEE80211_HW_NO_TKIP_WMM_HWACCEL |
-		IEEE80211_HW_MONITOR_DURING_OPER;
+		IEEE80211_HW_MONITOR_DURING_OPER |
+		IEEE80211_HW_NO_PROBE_FILTERING;
 	rt2x00dev->hw->extra_tx_headroom = TXD_DESC_SIZE;
 	rt2x00dev->hw->max_rssi = MAX_RX_SSI;
 	rt2x00dev->hw->max_noise = MAX_RX_NOISE;
-	rt2x00dev->hw->queues = RING_NUM_TX;
+	rt2x00dev->hw->queues = 2;
 
-	/*
-	 * This device supports ATIM
-	 */
-	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	SET_IEEE80211_DEV(rt2x00dev->hw, &rt2x00dev_usb(rt2x00dev)->dev);
+	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
+		rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0));
 
 	/*
 	 * Set device specific, but channel independent RF values.
@@ -1626,7 +1407,6 @@ static void rt2500usb_init_hw_mode(struc
 	/*
 	 * Initialize hw_mode information.
 	 */
-	spec->mac_addr = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
 	spec->num_modes = 2;
 	spec->num_rates = 12;
 	spec->num_channels = 14;
@@ -1673,6 +1453,11 @@ static int rt2500usb_init_hw(struct rt2x
 	 */
 	rt2500usb_init_hw_mode(rt2x00dev);
 
+	/*
+	 * This device supports ATIM
+	 */
+	__set_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+
 	return 0;
 }
 
@@ -1690,7 +1475,7 @@ static int rt2500usb_get_stats(struct ie
 	 * The dot11ACKFailureCount, dot11RTSFailureCount and
 	 * dot11RTSSuccessCount are updated in interrupt time.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR0, &reg);
+	rt2500usb_register_read(rt2x00dev, STA_CSR0, &reg);
 	rt2x00dev->low_level_stats.dot11FCSErrorCount +=
 		rt2x00_get_field16(reg, STA_CSR0_FCS_ERROR);
 
@@ -1702,8 +1487,6 @@ static int rt2500usb_get_stats(struct ie
 static const struct ieee80211_ops rt2500usb_mac80211_ops = {
 	.tx			= rt2x00lib_tx,
 	.reset			= rt2x00lib_reset,
-	.open			= rt2x00lib_open,
-	.stop			= rt2x00lib_stop,
 	.add_interface		= rt2x00lib_add_interface,
 	.remove_interface	= rt2x00lib_remove_interface,
 	.config			= rt2x00lib_config,
@@ -1724,6 +1507,7 @@ static const struct rt2x00lib_ops rt2500
 	.write_tx_desc		= rt2500usb_write_tx_desc,
 	.write_tx_data		= rt2x00usb_write_tx_data,
 	.kick_tx_queue		= rt2500usb_kick_tx_queue,
+	.fill_rxdone		= rt2500usb_fill_rxdone,
 	.config_type		= rt2500usb_config_type,
 	.config_phymode		= rt2500usb_config_phymode,
 	.config_channel		= rt2500usb_config_channel,
@@ -1803,12 +1587,6 @@ MODULE_SUPPORTED_DEVICE("Ralink RT2570 U
 MODULE_DEVICE_TABLE(usb, rt2500usb_device_table);
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
-
 static struct usb_driver rt2500usb_driver = {
 	.name		= DRV_NAME,
 	.id_table	= rt2500usb_device_table,
@@ -1822,14 +1600,11 @@ static struct usb_driver rt2500usb_drive
 
 static int __init rt2500usb_init(void)
 {
-	printk(KERN_INFO "Loading module: %s - %s by %s.\n",
-		DRV_NAME, DRV_VERSION, DRV_PROJECT);
 	return usb_register(&rt2500usb_driver);
 }
 
 static void __exit rt2500usb_exit(void)
 {
-	printk(KERN_INFO "Unloading module: %s.\n", DRV_NAME);
 	usb_deregister(&rt2500usb_driver);
 }
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt2500usb.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2500usb.h	2007-07-09 21:00:14.000000000 +0200
@@ -38,10 +38,18 @@
 #define RF5222				0x0010
 
 /*
- * Max RSSI value, required for RSSI <-> dBm conversion.
+ * RT2570 version
  */
-#define MAX_RX_SSI			120
+#define RT2570_VERSION_B		2
+#define RT2570_VERSION_C		3
+#define RT2570_VERSION_D		4
+
+/*
+ * Signal information.
+ */
+#define MAX_RX_SSI			-1
 #define MAX_RX_NOISE			-110
+#define DEFAULT_RSSI_OFFSET		120
 
 /*
  * Register layout information.
@@ -424,16 +432,16 @@
  * BBP_READ_CONTROL: 0: write, 1: read.
  */
 #define PHY_CSR7			0x04ce
-#define PHY_CSR7_BBP_DATA		FIELD16(0x00ff)
-#define PHY_CSR7_BBP_REG_ID		FIELD16(0x7f00)
-#define PHY_CSR7_BBP_READ_CONTROL	FIELD16(0x8000)
+#define PHY_CSR7_DATA			FIELD16(0x00ff)
+#define PHY_CSR7_REG_ID			FIELD16(0x7f00)
+#define PHY_CSR7_READ_CONTROL		FIELD16(0x8000)
 
 /*
  * PHY_CSR8: BBP access register 1.
  * BBP_BUSY: ASIC is busy execute BBP programming.
  */
 #define PHY_CSR8			0x04d0
-#define PHY_CSR8_BBP_BUSY		FIELD16(0x0001)
+#define PHY_CSR8_BUSY			FIELD16(0x0001)
 
 /*
  * PHY_CSR9: RF access register.
@@ -607,6 +615,23 @@
 #define EEPROM_CALIBRATE_OFFSET_RSSI	FIELD16(0x00ff)
 
 /*
+ * BBP content.
+ * The wordsize of the BBP is 8 bits.
+ */
+
+/*
+ * BBP_R2: TX antenna control
+ */
+#define BBP_R2_TX_ANTENNA		FIELD8(0x03)
+#define BBP_R2_TX_IQ_FLIP		FIELD8(0x04)
+
+/*
+ * BBP_R14: RX antenna control
+ */
+#define BBP_R14_RX_ANTENNA		FIELD8(0x03)
+#define BBP_R14_RX_IQ_FLIP		FIELD8(0x04)
+
+/*
  * DMA descriptor defines.
  */
 #define TXD_DESC_SIZE			( 5 * sizeof(struct data_desc) )
@@ -692,19 +717,6 @@
 #define RXD_W3_EIV			FIELD32(0xffffffff)
 
 /*
- * TX ring index number for rt2x00_dev structure.
- */
-enum ring_index {
-	RING_PRIO = 0,
-	RING_TX = 1,
-	RING_ATIM = 2,
-	RING_BEACON = 3,
-	RING_RX = 4,
-	RING_NUM = 5,
-	RING_NUM_TX = 2,
-};
-
-/*
  * Macro's for converting txpower from EEPROM to dscape value
  * and from dscape value to register value.
  */
@@ -725,9 +737,4 @@ enum ring_index {
 	(__txpower));					\
 })
 
-/*
- * Interrupt functions.
- */
-static void rt2500usb_interrupt_rxdone(struct urb *urb);
-
 #endif /* RT2500USB_H */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00_compat.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00_compat.h	2007-07-09 21:00:14.000000000 +0200
@@ -0,0 +1,66 @@
+/*
+ * RT2X00 Compatability fixes for specific kernels.
+ */
+#ifndef RT2X00_COMPAT_H
+#define RT2X00_COMPAT_H
+
+/*
+ * First include the 2 config headers.
+ * The rt2x00_config.h should overrule
+ * the kernel configuration.
+ */
+#include <linux/autoconf.h>
+#include "rt2x00_config.h"
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+
+/*
+ * Check minimal requirements.
+ */
+#if (!defined(CONFIG_MAC80211) && !defined(CONFIG_MAC80211_MODULE))
+#error mac80211 support not enabled in kernel!
+#endif
+
+#if !defined(CONFIG_WLAN_80211)
+#error 802.11 wlan card support not enabled in kernel!
+#endif
+
+#if (defined(CONFIG_RT2400PCI) || defined(CONFIG_RT2500PCI) || defined(CONFIG_RT61PCI))
+#if (!defined(CONFIG_PCI) && !defined(CONFIG_PCI_MODULE))
+#error PCI has been disabled in your kernel!
+#endif
+#if (!defined(CONFIG_EEPROM_93CX6) && !defined(CONFIG_EEPROM_93CX6_MODULE))
+#error EEPROM_93CX6 has been disabled in your kernel!
+#endif
+#endif
+
+#if (defined(CONFIG_RT2500USB) || defined(CONFIG_RT73USB))
+#if (!defined(CONFIG_USB) && !defined(CONFIG_USB_MODULE))
+#error USB has been disabled in your kernel!
+#endif
+#endif
+
+#if (defined(CONFIG_RT61PCI) || defined(CONFIG_RT73USB))
+#if (!defined(CONFIG_FW_LOADER) && !defined(CONFIG_FW_LOADER_MODULE))
+#error Firmware loading has been disabled in your kernel!
+#endif
+#if (!defined(CONFIG_CRC_ITU_T) && !defined(CONFIG_CRC_ITU_T_MODULE))
+#error CRC_ITU_T loading has been disabled in your kernel!
+#endif
+#endif
+
+#if (defined(CONFIG_RT2X00_DEBUGFS))
+#if (!defined(CONFIG_MAC80211_DEBUGFS) && !defined(CONFIG_MAC80211_DEBUGFS_MODULE))
+#error mac80211 debugfs support has been disabled in your kernel!
+#endif
+#endif
+
+#if (defined(CONFIG_RT2400PCI_BUTTON) || defined(CONFIG_RT2500PCI_BUTTON) || defined(CONFIG_RT61PCI_BUTTON))
+#if (!defined(CONFIG_RFKILL) && !defined (CONFIG_RFKILL_MODULE))
+#error RFKILL has been disabled in your kernel!
+#endif
+#endif
+
+#endif /* RT2X00_COMPAT_H */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00debug.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00debug.c	2007-07-09 21:00:14.000000000 +0200
@@ -30,6 +30,7 @@
 #include <asm/uaccess.h>
 
 #include "rt2x00.h"
+#include "rt2x00debug.h"
 
 #define PRINT_REG8_STR		( "0x%.2x\n" )
 #define PRINT_REG16_STR		( "0x%.4x\n" )
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00debug.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00debug.h	2007-07-09 21:00:14.000000000 +0200
@@ -28,8 +28,6 @@
 #ifndef RT2X00DEBUG_H
 #define RT2X00DEBUG_H
 
-#include <net/wireless.h>
-
 typedef void (debug_access_t)(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data);
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00dev.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00dev.c	2007-07-09 21:00:14.000000000 +0200
@@ -38,6 +38,8 @@
 #include <linux/etherdevice.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
+#include "rt2x00dev.h"
 
 /*
  * Radio control handlers.
@@ -66,28 +68,32 @@ int rt2x00lib_enable_radio(struct rt2x00
 
 	ieee80211_start_queues(rt2x00dev->hw);
 
+	if (is_interface_present(&rt2x00dev->interface))
+		rt2x00_start_link_tune(rt2x00dev);
+
 	return 0;
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_enable_radio);
 
 void rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev)
 {
 	if (!__test_and_clear_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags))
 		return;
 
+	rt2x00_stop_link_tune(rt2x00dev);
+
 	ieee80211_stop_queues(rt2x00dev->hw);
 
-	rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_RX_OFF);
+	rt2x00lib_toggle_rx(rt2x00dev, 0);
+
 	rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_RADIO_OFF);
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_disable_radio);
 
 void rt2x00lib_toggle_rx(struct rt2x00_dev *rt2x00dev, int enable)
 {
 	/*
 	 * When we are disabling the rx, we should also stop the link tuner.
 	 */
-	if (!enable && work_pending(&rt2x00dev->link.work.work))
+	if (!enable)
 		rt2x00_stop_link_tune(rt2x00dev);
 
 	rt2x00dev->ops->lib->set_device_state(rt2x00dev,
@@ -96,27 +102,20 @@ void rt2x00lib_toggle_rx(struct rt2x00_d
 	/*
 	 * When we are enabling the rx, we should also start the link tuner.
 	 */
-	if (enable)
+	if (enable && is_interface_present(&rt2x00dev->interface))
 		rt2x00_start_link_tune(rt2x00dev);
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_toggle_rx);
 
 static void rt2x00lib_link_tuner(struct work_struct *work)
 {
 	struct rt2x00_dev *rt2x00dev =
 		container_of(work, struct rt2x00_dev, link.work.work);
-	int rssi;
 
 	/*
-	 * Check if we should update promisc mode.
-	 * This is only needed when we are not working with
-	 * monitor mode, since promisc mode is forced on in that case.
-	 */
-	if (!is_monitor_present(&rt2x00dev->interface) &&
-	    (test_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags) !=
-	     rt2x00dev->interface.promisc))
-		rt2x00dev->ops->lib->config_promisc(rt2x00dev,
-			rt2x00dev->interface.promisc);
+	 * Update promisc mode (this function will first check
+	 * if updating is really required).
+	 */
+	rt2x00lib_config_promisc(rt2x00dev, rt2x00dev->interface.promisc);
 
 	/*
 	 * Cancel all link tuning if the eeprom has indicated
@@ -125,66 +124,145 @@ static void rt2x00lib_link_tuner(struct 
 	if (test_bit(CONFIG_DISABLE_LINK_TUNING, &rt2x00dev->flags))
 		return;
 
-	/*
-	 * Retrieve link quality.
-	 * Also convert rssi to dBm using the max_rssi value.
-	 */
-	rssi = rt2x00_get_link_rssi(&rt2x00dev->link);
-	rssi -= rt2x00dev->hw->max_rssi;
-
-	rt2x00dev->ops->lib->link_tuner(rt2x00dev, rssi);
+	rt2x00dev->ops->lib->link_tuner(rt2x00dev);
 
 	/*
 	 * Increase tuner counter, and reschedule the next link tuner run.
 	 */
 	rt2x00dev->link.count++;
-	queue_delayed_work(rt2x00dev->workqueue, &rt2x00dev->link.work,
+	queue_delayed_work(rt2x00dev->hw->workqueue, &rt2x00dev->link.work,
 		LINK_TUNE_INTERVAL);
 }
 
 /*
+ * Config handlers
+ */
+void rt2x00lib_config_type(struct rt2x00_dev *rt2x00dev, const int type)
+{
+	if (!(is_interface_present(&rt2x00dev->interface) ^
+	      test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
+	    !(is_monitor_present(&rt2x00dev->interface) ^
+	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
+		return;
+
+	rt2x00dev->ops->lib->config_type(rt2x00dev, type);
+
+	if (type != IEEE80211_IF_TYPE_MNTR) {
+		if (is_interface_present(&rt2x00dev->interface))
+			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
+		else
+			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
+	} else {
+		if (is_monitor_present(&rt2x00dev->interface))
+			__set_bit(INTERFACE_ENABLED_MONITOR,
+				&rt2x00dev->flags);
+		else
+			__clear_bit(INTERFACE_ENABLED_MONITOR,
+				&rt2x00dev->flags);
+	}
+}
+
+void rt2x00lib_config_phymode(struct rt2x00_dev *rt2x00dev, const int phymode)
+{
+	if (rt2x00dev->rx_status.phymode == phymode)
+		return;
+
+	rt2x00dev->ops->lib->config_phymode(rt2x00dev, phymode);
+
+	rt2x00dev->rx_status.phymode = phymode;
+}
+
+void rt2x00lib_config_channel(struct rt2x00_dev *rt2x00dev, const int value,
+	const int channel, const int freq, const int txpower)
+{
+	if (channel == rt2x00dev->rx_status.channel)
+		return;
+
+	rt2x00dev->ops->lib->config_channel(rt2x00dev, value, channel, txpower);
+
+	INFO(rt2x00dev, "Switching channel. "
+		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x, RF3: 0x%08x.\n",
+		rt2x00dev->rf1, rt2x00dev->rf2,
+		rt2x00dev->rf3, rt2x00dev->rf4);
+
+	rt2x00dev->rx_status.freq = freq;
+	rt2x00dev->rx_status.channel = channel;
+}
+
+void rt2x00lib_config_promisc(struct rt2x00_dev *rt2x00dev, const int promisc)
+{
+	/*
+	 * Monitor mode implies promisc mode enabled.
+	 * In all other instances, check if we need to toggle promisc mode.
+	 */
+	if (is_monitor_present(&rt2x00dev->interface) &&
+	    !test_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags)) {
+		rt2x00dev->ops->lib->config_promisc(rt2x00dev, 1);
+		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
+	}
+
+	if (test_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags) != promisc) {
+		rt2x00dev->ops->lib->config_promisc(rt2x00dev, promisc);
+		__change_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
+	}
+}
+
+void rt2x00lib_config_txpower(struct rt2x00_dev *rt2x00dev, const int txpower)
+{
+	if (txpower == rt2x00dev->tx_power)
+		return;
+
+	rt2x00dev->ops->lib->config_txpower(rt2x00dev, txpower);
+
+	rt2x00dev->tx_power = txpower;
+}
+
+void rt2x00lib_config_antenna(struct rt2x00_dev *rt2x00dev,
+	const int antenna_tx, const int antenna_rx)
+{
+	if (rt2x00dev->rx_status.antenna == antenna_rx)
+		return;
+
+	rt2x00dev->ops->lib->config_antenna(rt2x00dev, antenna_tx, antenna_rx);
+
+	rt2x00dev->rx_status.antenna = antenna_rx;
+}
+
+/*
  * Driver initialization handlers.
  */
-#define create_channel_a(__entry, __channel, __tx_power, __value)	\
-({									\
-	(__entry)->chan = (__channel);					\
-	(__entry)->freq = ( 5000 + (5 * (__channel)));			\
-	(__entry)->val = __value;					\
-	(__entry)->flag =						\
-		IEEE80211_CHAN_W_IBSS |					\
-		IEEE80211_CHAN_W_ACTIVE_SCAN |				\
-		IEEE80211_CHAN_W_SCAN;					\
-	(__entry)->power_level = __tx_power;				\
-	(__entry)->antenna_max = 0xff;					\
-})
-
-#define create_channel_bg(__entry, __channel, __tx_power, __value)	\
-({									\
-	(__entry)->chan = (__channel);					\
-	(__entry)->freq = 2407 + (5 * (__channel));			\
-	(__entry)->val = __value;					\
-	(__entry)->flag =						\
-		IEEE80211_CHAN_W_IBSS |					\
-		IEEE80211_CHAN_W_ACTIVE_SCAN |				\
-		IEEE80211_CHAN_W_SCAN;					\
-	(__entry)->power_level = __tx_power;				\
-	(__entry)->antenna_max = 0xff;					\
-})
-
-#define create_rate(__entry, __rate, __mask, __plcp, __flags)		\
-({									\
-	(__entry)->rate = (__rate);					\
-	(__entry)->val =						\
-		DEVICE_SET_RATE_FIELD((__rate), RATE) |			\
-		DEVICE_SET_RATE_FIELD((__mask), RATEMASK) |		\
-		DEVICE_SET_RATE_FIELD((__plcp), PLCP);			\
-	(__entry)->flags = (__flags);					\
-	(__entry)->val2 = (__entry)->val;				\
-	if ((__entry)->flags & IEEE80211_RATE_PREAMBLE2)		\
-		(__entry)->val2 |= DEVICE_SET_RATE_FIELD(1, PREAMBLE);	\
-	(__entry)->min_rssi_ack = 0;					\
-	(__entry)->min_rssi_ack_delta = 0;				\
-})
+static void rt2x00lib_channel(struct ieee80211_channel *entry,
+	const int channel, const int tx_power, const int value)
+{
+	entry->chan = channel;
+	if (channel <= 14)
+		entry->freq = 2407 + (5 * channel);
+	else
+		entry->freq = 5000 + (5 * channel);
+	entry->val = value;
+	entry->flag =
+		IEEE80211_CHAN_W_IBSS |
+		IEEE80211_CHAN_W_ACTIVE_SCAN |
+		IEEE80211_CHAN_W_SCAN;
+	entry->power_level = tx_power;
+	entry->antenna_max = 0xff;
+}
+
+static void rt2x00lib_rate(struct ieee80211_rate *entry,
+	const int rate,const int mask, const int plcp, const int flags)
+{
+	entry->rate = rate;
+	entry->val =
+		DEVICE_SET_RATE_FIELD(rate, RATE) |
+		DEVICE_SET_RATE_FIELD(mask, RATEMASK) |
+		DEVICE_SET_RATE_FIELD(plcp, PLCP);
+	entry->flags = flags;
+	entry->val2 = entry->val;
+	if (entry->flags & IEEE80211_RATE_PREAMBLE2)
+		entry->val2 |= DEVICE_SET_RATE_FIELD(1, PREAMBLE);
+	entry->min_rssi_ack = 0;
+	entry->min_rssi_ack_delta = 0;
+}
 
 static int rt2x00lib_init_hw_modes(struct rt2x00_dev *rt2x00dev,
 	struct hw_mode_spec *spec)
@@ -211,27 +289,27 @@ static int rt2x00lib_init_hw_modes(struc
 	/*
 	 * Initialize Rate list.
 	 */
-	create_rate(&rates[0], 10, 0x001, 0x00, IEEE80211_RATE_CCK);
-	create_rate(&rates[1], 20, 0x003, 0x01, IEEE80211_RATE_CCK_2);
-	create_rate(&rates[2], 55, 0x007, 0x02, IEEE80211_RATE_CCK_2);
-	create_rate(&rates[3], 110, 0x00f, 0x03, IEEE80211_RATE_CCK_2);
+	rt2x00lib_rate(&rates[0], 10, 0x001, 0x00, IEEE80211_RATE_CCK);
+	rt2x00lib_rate(&rates[1], 20, 0x003, 0x01, IEEE80211_RATE_CCK_2);
+	rt2x00lib_rate(&rates[2], 55, 0x007, 0x02, IEEE80211_RATE_CCK_2);
+	rt2x00lib_rate(&rates[3], 110, 0x00f, 0x03, IEEE80211_RATE_CCK_2);
 
 	if (spec->num_rates > 4) {
-		create_rate(&rates[4], 60, 0x01f, 0x0b, IEEE80211_RATE_OFDM);
-		create_rate(&rates[5], 90, 0x03f, 0x0f, IEEE80211_RATE_OFDM);
-		create_rate(&rates[6], 120, 0x07f, 0x0a, IEEE80211_RATE_OFDM);
-		create_rate(&rates[7], 180, 0x0ff, 0x0e, IEEE80211_RATE_OFDM);
-		create_rate(&rates[8], 240, 0x1ff, 0x09, IEEE80211_RATE_OFDM);
-		create_rate(&rates[9], 360, 0x3ff, 0x0d, IEEE80211_RATE_OFDM);
-		create_rate(&rates[10], 480, 0x7ff, 0x08, IEEE80211_RATE_OFDM);
-		create_rate(&rates[11], 540, 0xfff, 0x0c, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[4], 60, 0x01f, 0x0b, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[5], 90, 0x03f, 0x0f, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[6], 120, 0x07f, 0x0a, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[7], 180, 0x0ff, 0x0e, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[8], 240, 0x1ff, 0x09, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[9], 360, 0x3ff, 0x0d, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[10], 480, 0x7ff, 0x08, IEEE80211_RATE_OFDM);
+		rt2x00lib_rate(&rates[11], 540, 0xfff, 0x0c, IEEE80211_RATE_OFDM);
 	}
 
 	/*
 	 * Initialize Channel list.
 	 */
 	for (i = 0; i < 14; i++)
-		create_channel_bg(&channels[i], i + 1,
+		rt2x00lib_channel(&channels[i], i + 1,
 			spec->tx_power_bg[i], spec->chan_val_bg[i]);
 
 	if (spec->num_channels > 14) {
@@ -249,8 +327,9 @@ static int rt2x00lib_init_hw_modes(struc
 			else
 				tx_power = spec->tx_power_default;
 
-			create_channel_a(&channels[i], channels[i].chan,
-				tx_power, spec->chan_val_a[i]);
+			rt2x00lib_channel(&channels[i],
+				channels[i].chan, tx_power,
+				spec->chan_val_a[i]);
 		}
 	}
 
@@ -342,22 +421,6 @@ static int rt2x00lib_init_hw(struct rt2x
 	int status;
 
 	/*
-	 * Initialize device.
-	 */
-	SET_IEEE80211_DEV(rt2x00dev->hw, rt2x00dev->device);
-
-	/*
-	 * Initialize MAC address.
-	 */
-	if (!is_valid_ether_addr(spec->mac_addr)) {
-		ERROR(rt2x00dev, "Invalid MAC addr: " MAC_FMT ".\n",
-			MAC_ARG(spec->mac_addr));
-		return -EINVAL;
-	}
-	rt2x00dev->ops->lib->config_mac_addr(rt2x00dev, spec->mac_addr);
-	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw, spec->mac_addr);
-
-	/*
 	 * Initialize HW modes.
 	 */
 	status = rt2x00lib_init_hw_modes(rt2x00dev, spec);
@@ -379,52 +442,207 @@ static int rt2x00lib_init_hw(struct rt2x
 }
 
 /*
+ * Initialization/uninitialization handlers.
+ */
+static int rt2x00lib_alloc_ring_entries(struct data_ring *ring,
+	const u16 max_entries, const u16 data_size, const u16 desc_size)
+{
+	struct data_entry *entry;
+	unsigned int i;
+
+	ring->stats.limit = max_entries;
+	ring->data_size = data_size;
+	ring->desc_size = desc_size;
+
+	/*
+	 * Allocate all ring entries.
+	 */
+	entry = kzalloc(ring->stats.limit * sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		return -ENOMEM;
+
+	for (i = 0; i < ring->stats.limit; i++) {
+		entry[i].flags = 0;
+		entry[i].ring = ring;
+		entry[i].skb = NULL;
+	}
+
+	ring->entry = entry;
+
+	return 0;
+}
+
+static int rt2x00lib_allocate_ring_entries(struct rt2x00_dev *rt2x00dev)
+{
+	struct data_ring *ring;
+
+	/*
+	 * Allocate the RX ring.
+	 */
+	if (rt2x00lib_alloc_ring_entries(rt2x00dev->rx,
+		RX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->rxd_size))
+		return -ENOMEM;
+
+	/*
+	 * First allocate the TX rings.
+	 */
+	txring_for_each(rt2x00dev, ring) {
+		if (rt2x00lib_alloc_ring_entries(ring,
+			TX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->txd_size))
+			return -ENOMEM;
+	}
+
+	/*
+	 * Allocate the BEACON ring.
+	 */
+	if (rt2x00lib_alloc_ring_entries(&rt2x00dev->bcn[0],
+		BEACON_ENTRIES, MGMT_FRAME_SIZE, rt2x00dev->ops->txd_size))
+		return -ENOMEM;
+
+	/*
+	 * Allocate the Atim ring.
+	 */
+	if (test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags)) {
+		if (rt2x00lib_alloc_ring_entries(&rt2x00dev->bcn[1],
+			ATIM_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->txd_size))
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void rt2x00lib_free_ring_entries(struct rt2x00_dev *rt2x00dev)
+{
+	struct data_ring *ring;
+
+	ring_for_each(rt2x00dev, ring) {
+		kfree(ring->entry);
+		ring->entry = NULL;
+	}
+}
+
+int rt2x00lib_initialize(struct rt2x00_dev *rt2x00dev)
+{
+	int status;
+
+	if (test_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
+		return 0;
+
+	/*
+	 * Allocate all data rings.
+	 */
+	status = rt2x00lib_allocate_ring_entries(rt2x00dev);
+	if (status) {
+		ERROR(rt2x00dev, "DMA allocation failed.\n");
+		return status;
+	}
+
+	/*
+	 * Initialize the device.
+	 */
+	status = rt2x00dev->ops->lib->initialize(rt2x00dev);
+	if (status)
+		goto exit;
+
+	__set_bit(DEVICE_INITIALIZED, &rt2x00dev->flags);
+
+	/*
+	 * Register the rfkill handler.
+	 */
+	status = rt2x00lib_register_rfkill(rt2x00dev);
+	if (status)
+		goto exit_unitialize;
+
+	return 0;
+
+exit_unitialize:
+	rt2x00lib_uninitialize(rt2x00dev);
+
+exit:
+	rt2x00lib_free_ring_entries(rt2x00dev);
+
+	return status;
+}
+
+void rt2x00lib_uninitialize(struct rt2x00_dev *rt2x00dev)
+{
+	if (!__test_and_clear_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
+		return;
+
+	/*
+	 * Unregister rfkill.
+	 */
+	rt2x00lib_unregister_rfkill(rt2x00dev);
+
+	/*
+	 * Allow the HW to uninitialize.
+	 */
+	rt2x00dev->ops->lib->uninitialize(rt2x00dev);
+
+	/*
+	 * Free allocated datarings.
+	 */
+	rt2x00lib_free_ring_entries(rt2x00dev);
+}
+
+/*
  * driver allocation handlers.
  */
 static int rt2x00lib_alloc_rings(struct rt2x00_dev *rt2x00dev)
 {
+	struct data_ring *ring;
 	unsigned int ring_num;
-	unsigned int i;
 
 	/*
-	 * We support 1 RX queue, 1 Beacon ring
-	 * and we could support 1 ATIM ring
-	 * if the driver has raised that flag.
+	 * We need the following rings:
+	 * RX: 1
+	 * TX: hw->queues
+	 * Beacon: 1
+	 * Atim: 1 (if supported)
 	 */
 	ring_num = 2 + rt2x00dev->hw->queues +
 		test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
 
-	rt2x00dev->ring = kzalloc(
-		sizeof(struct data_ring) * ring_num, GFP_KERNEL);
-	if (!rt2x00dev->ring) {
+	ring = kzalloc(sizeof(*ring) * ring_num, GFP_KERNEL);
+	if (!ring) {
 		ERROR(rt2x00dev, "Ring allocation failed.\n");
 		return -ENOMEM;
 	}
 
-	for (i = 0; i < ring_num; i++) {
-		rt2x00dev->ring[i].rt2x00dev = rt2x00dev;
-
-		/*
-		 * Initialize ring parameters.
-		 * cw_min: 2^5 = 32.
-		 * cw_max: 2^10 = 1024.
-		 */
-		rt2x00dev->ring[i].tx_params.aifs = 2;
-		rt2x00dev->ring[i].tx_params.cw_min = 5;
-		rt2x00dev->ring[i].tx_params.cw_max = 10;
+	/*
+	 * Initialize pointers
+	 */
+	rt2x00dev->rx = &ring[0];
+	rt2x00dev->tx = &ring[1];
+	rt2x00dev->bcn = &ring[1 + rt2x00dev->hw->queues];
+
+	/*
+	 * Initialize ring parameters.
+	 * cw_min: 2^5 = 32.
+	 * cw_max: 2^10 = 1024.
+	 */
+	ring_for_each(rt2x00dev, ring) {
+		ring->rt2x00dev = rt2x00dev;
+		ring->tx_params.aifs = 2;
+		ring->tx_params.cw_min = 5;
+		ring->tx_params.cw_max = 10;
 	}
 
 	return 0;
 }
 
-int rt2x00lib_alloc_dev(struct rt2x00_dev *rt2x00dev)
+int rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev)
 {
+	int retval = -ENOMEM;
+
 	/*
-	 * Create workqueue.
+	 * Let the driver probe the device to detect the capabilities.
 	 */
-	rt2x00dev->workqueue = create_singlethread_workqueue(DRV_NAME);
-	if (!rt2x00dev->workqueue)
+	retval = rt2x00dev->ops->lib->init_hw(rt2x00dev);
+	if (retval) {
+		ERROR(rt2x00dev, "Failed to allocate device.\n");
 		goto exit;
+	}
 
 	/*
 	 * Initialize configuration work.
@@ -439,18 +657,27 @@ int rt2x00lib_alloc_dev(struct rt2x00_de
 	/*
 	 * Allocate ring array.
 	 */
-	if (rt2x00lib_alloc_rings(rt2x00dev))
+	retval = rt2x00lib_alloc_rings(rt2x00dev);
+	if (retval)
 		goto exit;
 
 	/*
 	 * Initialize ieee80211 structure.
 	 */
-	if (rt2x00lib_init_hw(rt2x00dev)) {
+	retval = rt2x00lib_init_hw(rt2x00dev);
+	if (retval) {
 		ERROR(rt2x00dev, "Failed to initialize hw.\n");
 		goto exit;
 	}
 
 	/*
+	 * Allocatie rfkill.
+	 */
+	retval = rt2x00lib_allocate_rfkill(rt2x00dev);
+	if (retval)
+		goto exit;
+
+	/*
 	 * Open the debugfs entry.
 	 */
 	rt2x00debug_register(rt2x00dev);
@@ -464,52 +691,103 @@ int rt2x00lib_alloc_dev(struct rt2x00_de
 		 * initializing of the card until the firmware
 		 * has been loaded.
 		 */
-		if (rt2x00lib_load_firmware(rt2x00dev))
+		retval = rt2x00lib_load_firmware(rt2x00dev);
+		if (retval)
 			goto exit;
 	}
 
 	return 0;
 
 exit:
-	rt2x00lib_free_dev(rt2x00dev);
+	rt2x00lib_remove_dev(rt2x00dev);
 
-	return -ENODEV;
+	return retval;
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_alloc_dev);
+EXPORT_SYMBOL_GPL(rt2x00lib_probe_dev);
 
-void rt2x00lib_free_dev(struct rt2x00_dev *rt2x00dev)
+void rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev)
 {
 	/*
+	 * Disable radio.
+	 */
+	rt2x00lib_disable_radio(rt2x00dev);
+
+	/*
+	 * Uninitialize device.
+	 */
+	rt2x00lib_uninitialize(rt2x00dev);
+
+	/*
 	 * Close debugfs entry.
 	 */
 	rt2x00debug_deregister(rt2x00dev);
 
 	/*
-	 * Free workqueue.
+	 * Free rfkill
 	 */
-	if (likely(rt2x00dev->workqueue)) {
-		destroy_workqueue(rt2x00dev->workqueue);
-		rt2x00dev->workqueue = NULL;
-	}
+	rt2x00lib_free_rfkill(rt2x00dev);
+
+	/*
+	 * Free ieee80211_hw memory.
+	 */
+	rt2x00lib_deinit_hw(rt2x00dev);
 
 	/*
 	 * Free ring structures.
 	 */
-	kfree(rt2x00dev->ring);
-	rt2x00dev->ring = NULL;
+	kfree(rt2x00dev->rx);
+	rt2x00dev->rx = NULL;
+	rt2x00dev->tx = NULL;
+	rt2x00dev->bcn = NULL;
 
 	/*
 	 * Free EEPROM memory.
 	 */
 	kfree(rt2x00dev->eeprom);
 	rt2x00dev->eeprom = NULL;
+}
+EXPORT_SYMBOL_GPL(rt2x00lib_remove_dev);
+
+/*
+ * Device state handlers
+ */
+int rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev,
+	pm_message_t state)
+{
+	int retval;
+
+	NOTICE(rt2x00dev, "Going to sleep.\n");
+
+	rt2x00lib_disable_radio(rt2x00dev);
 
 	/*
-	 * Free ieee80211_hw memory.
+	 * Set device mode to sleep for power management.
 	 */
-	rt2x00lib_deinit_hw(rt2x00dev);
+	retval = rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_SLEEP);
+	if (retval)
+		return retval;
+
+	rt2x00lib_remove_dev(rt2x00dev);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rt2x00lib_suspend);
+
+int rt2x00lib_resume(struct rt2x00_dev *rt2x00dev)
+{
+	int retval;
+
+	NOTICE(rt2x00dev, "Waking up.\n");
+
+	retval = rt2x00lib_probe_dev(rt2x00dev);
+	if (retval) {
+		ERROR(rt2x00dev, "Failed to allocate device.\n");
+		return retval;
+	}
+
+	return 0;
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_free_dev);
+EXPORT_SYMBOL_GPL(rt2x00lib_resume);
 
 /*
  * Interrupt context handlers.
@@ -590,14 +868,14 @@ void rt2x00lib_rxdone(struct data_entry 
 			 */
 			if (signal & 0x08)
 				val = rate->val2;
-			val = rate->val;
+			else
+				val = rate->val;
 			break;
 		}
 	}
 
 	rx_status->rate = val;
 	rx_status->ssi = rssi;
-	rx_status->noise = rt2x00dev->link.curr_noise;
 	rt2x00_update_link_rssi(&rt2x00dev->link, rssi);
 
 	/*
@@ -678,12 +956,6 @@ void rt2x00lib_write_tx_desc(struct rt2x
 		__set_bit(ENTRY_TXD_MORE_FRAG, &entry->flags);
 
 	/*
-	 * Check if this is a new sequence
-	 */
-	if ((seq_ctrl & IEEE80211_SCTL_FRAG) == 0)
-		__set_bit(ENTRY_TXD_NEW_SEQ, &entry->flags);
-
-	/*
 	 * Beacons and probe responses require the tsf timestamp
 	 * to be inserted into the frame.
 	 */
@@ -756,9 +1028,3 @@ MODULE_AUTHOR(DRV_PROJECT);
 MODULE_VERSION(DRV_VERSION);
 MODULE_DESCRIPTION("rt2x00 library");
 MODULE_LICENSE("GPL");
-
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00dev.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00dev.h	2007-07-09 21:00:14.000000000 +0200
@@ -0,0 +1,60 @@
+/*
+	Copyright (C) 2004 - 2007 rt2x00 SourceForge Project
+	<http://rt2x00.serialmonkey.com>
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation; either version 2 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the
+	Free Software Foundation, Inc.,
+	59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+/*
+	Module: rt2x00lib
+	Abstract: Data structures for the rt2x00lib module.
+	Supported chipsets: RT2460, RT2560, RT2570,
+	rt2561, rt2561s, rt2661, rt2571W & rt2671.
+ */
+
+#ifndef RT2X00DEV_H
+#define RT2X00DEV_H
+
+#include "rt2x00debug.h"
+#include "rt2x00firmware.h"
+#include "rt2x00rfkill.h"
+
+/*
+ * Radio control.
+ */
+int rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev);
+void rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev);
+void rt2x00lib_toggle_rx(struct rt2x00_dev *rt2x00dev, int enable);
+
+/*
+ * Initialization/uninitialization handlers.
+ */
+int rt2x00lib_initialize(struct rt2x00_dev *rt2x00dev);
+void rt2x00lib_uninitialize(struct rt2x00_dev *rt2x00dev);
+
+/*
+ * Config handlers.
+ */
+void rt2x00lib_config_type(struct rt2x00_dev *rt2x00dev, const int type);
+void rt2x00lib_config_phymode(struct rt2x00_dev *rt2x00dev, const int phymode);
+void rt2x00lib_config_channel(struct rt2x00_dev *rt2x00dev, const int value,
+	const int channel, const int freq, const int txpower);
+void rt2x00lib_config_promisc(struct rt2x00_dev *rt2x00dev, const int promisc);
+void rt2x00lib_config_txpower(struct rt2x00_dev *rt2x00dev, const int txpower);
+void rt2x00lib_config_antenna(struct rt2x00_dev *rt2x00dev,
+	const int antenna_tx, const int antenna_rx);
+
+#endif /* RT2X00DEV_H */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00firmware.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00firmware.c	2007-07-09 21:00:14.000000000 +0200
@@ -34,11 +34,8 @@
 #include <linux/firmware.h>
 
 #include "rt2x00.h"
-
-struct fw_entry {
-	u32	chip;
-	char	*name;
-};
+#include "rt2x00lib.h"
+#include "rt2x00firmware.h"
 
 static void rt2x00lib_load_firmware_continued(const struct firmware *fw,
 	void *context)
@@ -95,12 +92,17 @@ int rt2x00lib_load_firmware(struct rt2x0
 	 * Read correct firmware from harddisk.
 	 */
 	fw_name = rt2x00dev->ops->lib->get_fw_name(rt2x00dev);
-	BUG_ON(fw_name == NULL);
+	if (!fw_name) {
+		ERROR(rt2x00dev,
+			"Invalid firmware filename.\n"
+			"Please file bug report to %s.\n", DRV_PROJECT);
+		return -EINVAL;
+	}
 
 	INFO(rt2x00dev, "Loading firmware file '%s'.\n", fw_name);
 
 	status = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
-		fw_name, rt2x00dev->device, rt2x00dev,
+		fw_name, wiphy_dev(rt2x00dev->hw->wiphy), rt2x00dev,
 		&rt2x00lib_load_firmware_continued);
 
 	if (status)
@@ -127,4 +129,3 @@ int rt2x00lib_load_firmware_wait(struct 
 	ERROR(rt2x00dev, "Firmware loading timed out.\n");
 	return -ETIMEDOUT;
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_load_firmware_wait);
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00.h	2007-07-09 21:00:14.000000000 +0200
@@ -29,29 +29,22 @@
 #define RT2X00_H
 
 #include <linux/bitops.h>
+#include <linux/prefetch.h>
 #include <linux/skbuff.h>
 #include <linux/workqueue.h>
 
 #include <net/mac80211.h>
 
-#include "rt2x00lib.h"
-#include "rt2x00debug.h"
-#include "rt2x00rfkill.h"
-#include "rt2x00firmware.h"
-
 /*
  * Module information.
+ * DRV_NAME should be set within the individual module source files.
  */
-#ifndef DRV_NAME
-#define DRV_NAME	"rt2x00"
-#endif /* DRV_NAME */
-#define DRV_VERSION	"2.0.1"
+#define DRV_VERSION	"2.0.2"
 #define DRV_PROJECT	"http://rt2x00.serialmonkey.com"
 
 /*
  * Debug definitions.
- * Debug output has to be enabled during compile time,
- * and should be switched on using the module parameter.
+ * Debug output has to be enabled during compile time.
  */
 #define DEBUG_PRINTK_MSG(__dev, __kernlvl, __lvl, __msg, __args...)	\
 	printk(__kernlvl "%s -> %s: %s - " __msg,			\
@@ -63,19 +56,10 @@
 		DRV_NAME, __FUNCTION__, __lvl, 	##__args)
 
 #ifdef CONFIG_RT2X00_DEBUG
-/*
- * Module parameter.
- */
-extern int rt2x00_debug_level;
-
-#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...)		\
-	do {								\
-		if (rt2x00_debug_level)					\
-			DEBUG_PRINTK_MSG(__dev,				\
-				__kernlvl, __lvl, __msg, ##__args);	\
-	} while (0)
+#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...) \
+	DEBUG_PRINTK_MSG(__dev, __kernlvl, __lvl, __msg, ##__args);
 #else /* CONFIG_RT2X00_DEBUG */
-#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...)		\
+#define DEBUG_PRINTK(__dev, __kernlvl, __lvl, __msg, __args...) \
 	do { } while (0)
 #endif /* CONFIG_RT2X00_DEBUG */
 
@@ -154,7 +138,7 @@ extern int rt2x00_debug_level;
 /*
  * Interval defines
  */
-#define LINK_TUNE_INTERVAL	( 1 * HZ )
+#define LINK_TUNE_INTERVAL	( round_jiffies(HZ) )
 #define RFKILL_POLL_INTERVAL	( HZ / 4 )
 
 /*
@@ -169,6 +153,15 @@ enum TX_STATUS {
 };
 
 /*
+ * Antenna values
+ */
+enum antenna {
+	ANTENNA_DIVERSITY = 0,
+	ANTENNA_A = 1,
+	ANTENNA_B = 2,
+};
+
+/*
  * Led mode values.
  */
 enum led_mode {
@@ -313,7 +306,7 @@ static inline u16 rt2x00_get_field16(con
 }
 
 static inline void rt2x00_set_field8(u8 *reg,
-	const struct rt2x00_field16 field, const u8 value)
+	const struct rt2x00_field8 field, const u8 value)
 {
 	*reg &= ~(field.bit_mask);
 	*reg |= (value << field.bit_offset) & field.bit_mask;
@@ -395,7 +388,6 @@ struct data_entry {
 #define ENTRY_TXD_MORE_FRAG	5
 #define ENTRY_TXD_REQ_TIMESTAMP	6
 #define ENTRY_TXD_REQ_ACK	7
-#define ENTRY_TXD_NEW_SEQ	8
 
 	/*
 	 * Ring we belong to.
@@ -465,13 +457,8 @@ struct data_ring {
 	/*
 	 * Index variables.
 	 */
-	u8 index;
-	u8 index_done;
-
-	/*
-	 * Ring type.
-	 */
-	u16 type;
+	u16 index;
+	u16 index_done;
 
 	/*
 	 * Size of packet and descriptor in bytes.
@@ -578,16 +565,25 @@ struct link {
 	u32 count;
 
 	/*
-	 * RSSI statistics.
-	 */
-	u32 count_rssi;
-	u32 total_rssi;
-
-	/*
 	 * Misc statistics.
+	 * For the average RSSI value we use the "Walking average" approach.
+	 * When adding RSSI to the average value the following calculation
+	 * is needed:
+	 *
+	 * 	avg_rssi = ((avg_rssi * 7) + rssi) / 8;
+	 *
+	 * The advantage of this approach is that we only need 1 variable
+	 * to store the average in (No need for a count and a total).
+	 * But more importantly, normal average values will over time
+	 * move less and less towards newly added values.
+	 * This means that with link tuning, the device can have a very
+	 * good RSSI for a few minutes but when the device is moved away
+	 * from the AP the average will not decrease fast enough to
+	 * compensate. The walking average compensates this and will
+	 * move towards the new values correctly.
 	 */
-	u32 curr_noise;
-	u32 false_cca;
+	int avg_rssi;
+	int false_cca;
 
 	/*
 	 * Work structure for scheduling periodic link tuning.
@@ -645,6 +641,33 @@ static inline int is_monitor_present(str
 }
 
 /*
+ * Details about the supported modes, rates and channels
+ * of a particular chipset. This is used by rt2x00lib
+ * to build the ieee80211_hw_mode array for mac80211.
+ */
+struct hw_mode_spec {
+	/*
+	 * Number of modes, rates and channels.
+	 */
+	int num_modes;
+	int num_rates;
+	int num_channels;
+
+	/*
+	 * txpower values.
+	 */
+	const u8 *tx_power_a;
+	const u8 *tx_power_bg;
+	u8 tx_power_default;
+
+	/*
+	 * Device/chipset specific value.
+	 */
+	const u32 *chan_val_a;
+	const u32 *chan_val_bg;
+};
+
+/*
  * rt2x00lib callback functions.
  */
 struct rt2x00lib_ops {
@@ -673,7 +696,7 @@ struct rt2x00lib_ops {
 	int (*set_device_state)(struct rt2x00_dev *rt2x00dev,
 		enum dev_state state);
 	int (*rfkill_poll)(struct rt2x00_dev *rt2x00dev);
-	void (*link_tuner)(struct rt2x00_dev *rt2x00dev, int rssi);
+	void (*link_tuner)(struct rt2x00_dev *rt2x00dev);
 
 	/*
 	 * TX control handlers
@@ -689,20 +712,26 @@ struct rt2x00lib_ops {
 	void (*kick_tx_queue)(struct rt2x00_dev *rt2x00dev, int queue);
 
 	/*
+	 * RX control handlers
+	 */
+	int (*fill_rxdone)(struct data_entry *entry,
+		int *signal, int *rssi, int *ofdm);
+
+	/*
 	 * Configuration handlers.
 	 */
-	void (*config_type)(struct rt2x00_dev *rt2x00dev, int type);
+	void (*config_type)(struct rt2x00_dev *rt2x00dev, const int type);
 	void (*config_phymode)(struct rt2x00_dev *rt2x00dev, const int phy);
 	void (*config_channel)(struct rt2x00_dev *rt2x00dev, const int value,
-		const int channel, const int freq, const int txpower);
+		const int channel, const int txpower);
 	void (*config_mac_addr)(struct rt2x00_dev *rt2x00dev, u8 *mac);
 	void (*config_bssid)(struct rt2x00_dev *rt2x00dev, u8 *bssid);
-	void (*config_promisc)(struct rt2x00_dev *rt2x00dev, int promisc);
-	void (*config_txpower)(struct rt2x00_dev *rt2x00dev, int txpower);
+	void (*config_promisc)(struct rt2x00_dev *rt2x00dev, const int promisc);
+	void (*config_txpower)(struct rt2x00_dev *rt2x00dev, const int txpower);
 	void (*config_antenna)(struct rt2x00_dev *rt2x00dev,
-		int antenna_tx, int antenna_rx);
+		const int antenna_tx, const int antenna_rx);
 	void (*config_duration)(struct rt2x00_dev *rt2x00dev,
-		int short_slot_time);
+		const int short_slot_time, const int beacon_int);
 };
 
 /*
@@ -710,11 +739,13 @@ struct rt2x00lib_ops {
  */
 struct rt2x00_ops {
 	const char *name;
-	unsigned int rxd_size;
-	unsigned int txd_size;
+	const unsigned int rxd_size;
+	const unsigned int txd_size;
 	const struct rt2x00lib_ops *lib;
 	const struct ieee80211_ops *hw;
+#ifdef CONFIG_RT2X00_LIB_DEBUGFS
 	const struct rt2x00debug *debugfs;
+#endif /* CONFIG_RT2X00_LIB_DEBUGFS */
 };
 
 /*
@@ -729,7 +760,6 @@ struct rt2x00_dev {
 	 * macro's should be used for correct typecasting.
 	 */
 	void *dev;
-	struct device *device;
 #define rt2x00dev_pci(__dev)	( (struct pci_dev*)(__dev)->dev )
 #define rt2x00dev_usb(__dev)	( (struct usb_interface*)(__dev)->dev )
 
@@ -802,12 +832,9 @@ struct rt2x00_dev {
 	 * If enabled, the debugfs interface structures
 	 * required for deregistration of debugfs.
 	 */
+#ifdef CONFIG_RT2X00_LIB_DEBUGFS
 	const struct rt2x00debug_intf *debugfs_intf;
-
-	/*
-	 * Queue for deferred work.
-	 */
-	struct workqueue_struct *workqueue;
+#endif /* CONFIG_RT2X00_LIB_DEBUGFS */
 
 	/*
 	 * Interface configuration.
@@ -850,9 +877,9 @@ struct rt2x00_dev {
 	u8 led_mode;
 
 	/*
-	 * EEPROM bus width (PCI devices only).
+	 * Rssi <-> Dbm offset
 	 */
-	u8 eeprom_width;
+	u8 rssi_offset;
 
 	/*
 	 * Frequency offset (for rt61pci & rt73usb).
@@ -871,50 +898,66 @@ struct rt2x00_dev {
 	struct ieee80211_rx_status rx_status;
 
 	/*
-	 * Data rings for both RX and TX.
-	 * The first entries must be the normal TX
-	 * rings, followed by a possible ATIM ring
-	 * (when atim is used atim_available must be set)
-	 * after that the beacon and RX ring follow.
-	 */
-	struct data_ring *ring;
+	 * Data ring arrays for RX, TX and Beacon.
+	 * The Beacon array also contains the Atim ring
+	 * if that is supported by the device.
+	 */
+	struct data_ring *rx;
+	struct data_ring *tx;
+	struct data_ring *bcn;
 };
 
 static inline struct data_ring* rt2x00_get_ring(
-	struct rt2x00_dev *rt2x00dev, const int ring)
+	struct rt2x00_dev *rt2x00dev, const unsigned int queue)
 {
-	int atim;
-
-	atim = test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	int atim = test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
 
 	/*
 	 * Check if the rings have been allocated.
 	 */
-	if (!rt2x00dev->ring)
+	if (!rt2x00dev->tx || !rt2x00dev->bcn)
 		return NULL;
 
 	/*
-	 * Check for beacon ring, the beacon ring
-	 * is located behing the normal TX and, when available
-	 * the atim ring.
-	 */
-	if (ring == IEEE80211_TX_QUEUE_BEACON)
-		return &rt2x00dev->ring[rt2x00dev->hw->queues + atim];
-
-	if (ring == IEEE80211_TX_QUEUE_AFTER_BEACON && atim)
-		return &rt2x00dev->ring[rt2x00dev->hw->queues];
-
-	/*
-	 * Make sure the requested ring does not exceed
-	 * the maximum number of rings.
-	 */
-	if (ring < rt2x00dev->hw->queues)
-		return &rt2x00dev->ring[ring];
+	 * Check if we are requesting a reqular TX ring,
+	 * or if we are requesting a Beacon or Atim ring.
+	 * For Atim rings, we should check if it is supported.
+	 */
+	if (queue < rt2x00dev->hw->queues)
+		return &rt2x00dev->tx[queue];
+	else if (queue == IEEE80211_TX_QUEUE_BEACON)
+		return &rt2x00dev->bcn[0];
+	else if (queue == IEEE80211_TX_QUEUE_AFTER_BEACON && atim)
+		return &rt2x00dev->bcn[1];
 
 	return NULL;
 }
 
 /*
+ * For-each loop for the ring array.
+ * Since the all rings are allocated as a single array,
+ * we can start at the rx pointer and move forward to the tx rings.
+ * The 1 + Atim check will assure that the address directly after
+ * the ring array is obtained and the for-each loop exits correctly.
+ */
+#define ring_end(__dev) \
+	&(__dev)->bcn[1 + test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags)]
+
+#define ring_loop(__entry, __start, __end)			\
+	for ((__entry) = (__start);				\
+	     prefetch(&(__entry)[1]), (__entry) != (__end);	\
+	     (__entry) = &(__entry)[1])
+
+#define ring_for_each(__dev, __entry) \
+	ring_loop(__entry, (__dev)->rx, ring_end(__dev))
+
+#define txring_for_each(__dev, __entry) \
+	ring_loop(__entry, (__dev)->tx, (__dev)->bcn)
+
+#define txringall_for_each(__dev, __entry) \
+	ring_loop(__entry, (__dev)->tx, ring_end(__dev))
+
+/*
  * EEPROM access.
  * The EEPROM is being accessed by word index.
  */
@@ -942,11 +985,10 @@ static inline void rt2x00_eeprom_write(c
 static inline void rt2x00_start_link_tune(struct rt2x00_dev *rt2x00dev)
 {
 	rt2x00dev->link.count = 0;
-	rt2x00dev->link.count_rssi = 0;
-	rt2x00dev->link.total_rssi = 0;
-	rt2x00dev->link.curr_noise = 0;
+	rt2x00dev->link.avg_rssi = 0;
+	rt2x00dev->link.false_cca = 0;
 
-	queue_delayed_work(rt2x00dev->workqueue,
+	queue_delayed_work(rt2x00dev->hw->workqueue,
 		&rt2x00dev->link.work, LINK_TUNE_INTERVAL);
 }
 
@@ -954,26 +996,20 @@ static inline void rt2x00_stop_link_tune
 {
 	if (work_pending(&rt2x00dev->link.work.work))
 		cancel_rearming_delayed_workqueue(
-			rt2x00dev->workqueue, &rt2x00dev->link.work);
+			rt2x00dev->hw->workqueue, &rt2x00dev->link.work);
 }
 
-static inline void rt2x00_update_link_rssi(struct link *link, u32 rssi)
+static inline void rt2x00_update_link_rssi(struct link *link, int rssi)
 {
-	link->count_rssi++;
-	link->total_rssi += rssi;
+	if (!link->avg_rssi)
+		link->avg_rssi = rssi;
+	else
+		link->avg_rssi = ((link->avg_rssi * 7) + rssi) / 8;
 }
 
-static inline u32 rt2x00_get_link_rssi(struct link *link)
+static inline int rt2x00_get_link_rssi(struct link *link)
 {
-	u32 average = 0;
-
-	if (link->count_rssi && link->total_rssi)
-		average = link->total_rssi / link->count_rssi;
-
-	link->count_rssi = 0;
-	link->total_rssi = 0;
-
-	return average;
+	return link->avg_rssi;
 }
 
 /*
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00lib.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00lib.h	2007-07-09 21:00:14.000000000 +0200
@@ -28,55 +28,17 @@
 #ifndef RT2X00LIB_H
 #define RT2X00LIB_H
 
-struct rt2x00_dev;
-struct data_desc;
-struct data_entry_desc;
-struct data_entry;
-
-/*
- * Details about the supported modes, rates and channels
- * of a particular chipset. This is used by rt2x00lib
- * to build the ieee80211_hw_mode array for mac80211.
- */
-struct hw_mode_spec {
-	/*
-	 * Default mac address.
-	 */
-	char *mac_addr;
-
-	/*
-	 * Number of modes, rates and channels.
-	 */
-	int num_modes;
-	int num_rates;
-	int num_channels;
-
-	/*
-	 * txpower values.
-	 */
-	const u8 *tx_power_a;
-	const u8 *tx_power_bg;
-	u8 tx_power_default;
-
-	/*
-	 * Device/chipset specific value.
-	 */
-	const u32 *chan_val_a;
-	const u32 *chan_val_bg;
-};
-
 /*
- * Radio control handlers.
+ * Driver allocation handlers.
  */
-int rt2x00lib_enable_radio(struct rt2x00_dev *rt2x00dev);
-void rt2x00lib_disable_radio(struct rt2x00_dev *rt2x00dev);
-void rt2x00lib_toggle_rx(struct rt2x00_dev *rt2x00dev, int enable);
+int rt2x00lib_probe_dev(struct rt2x00_dev *rt2x00dev);
+void rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev);
 
 /*
- * Driver allocation handlers.
+ * Driver status handlers.
  */
-int rt2x00lib_alloc_dev(struct rt2x00_dev *rt2x00dev);
-void rt2x00lib_free_dev(struct rt2x00_dev *rt2x00dev);
+int rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev, pm_message_t state);
+int rt2x00lib_resume(struct rt2x00_dev *rt2x00dev);
 
 /*
  * Interrupt context handlers.
@@ -100,8 +62,6 @@ void rt2x00lib_write_tx_desc(struct rt2x
 int rt2x00lib_tx(struct ieee80211_hw *hw, struct sk_buff *skb,
 	struct ieee80211_tx_control *control);
 int rt2x00lib_reset(struct ieee80211_hw *hw);
-int rt2x00lib_open(struct ieee80211_hw *hw);
-int rt2x00lib_stop(struct ieee80211_hw *hw);
 int rt2x00lib_add_interface(struct ieee80211_hw *hw,
 	struct ieee80211_if_init_conf *conf);
 void rt2x00lib_remove_interface(struct ieee80211_hw *hw,
@@ -116,4 +76,6 @@ int rt2x00lib_get_tx_stats(struct ieee80
 int rt2x00lib_conf_tx(struct ieee80211_hw *hw, int queue,
 	const struct ieee80211_tx_queue_params *params);
 
+#include "rt2x00debug.h"
+
 #endif /* RT2X00LIB_H */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00mac.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00mac.c	2007-07-09 21:00:14.000000000 +0200
@@ -33,6 +33,8 @@
 #include <linux/netdevice.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
+#include "rt2x00dev.h"
 
 static int rt2x00_tx_rts_cts(struct rt2x00_dev *rt2x00dev,
 	struct data_ring *ring, struct sk_buff *frag_skb,
@@ -128,52 +130,18 @@ int rt2x00lib_reset(struct ieee80211_hw 
 }
 EXPORT_SYMBOL_GPL(rt2x00lib_reset);
 
-int rt2x00lib_open(struct ieee80211_hw *hw)
-{
-	struct rt2x00_dev *rt2x00dev = hw->priv;
-	int status;
-
-	/*
-	 * Initialize the device.
-	 */
-	status = rt2x00dev->ops->lib->initialize(rt2x00dev);
-	if (status)
-		return status;
-
-	/*
-	 * Enable radio.
-	 */
-	status = rt2x00lib_enable_radio(rt2x00dev);
-	if (status) {
-		rt2x00dev->ops->lib->uninitialize(rt2x00dev);
-		return status;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rt2x00lib_open);
-
-int rt2x00lib_stop(struct ieee80211_hw *hw)
-{
-	struct rt2x00_dev *rt2x00dev = hw->priv;
-
-	rt2x00lib_disable_radio(rt2x00dev);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(rt2x00lib_stop);
-
 int rt2x00lib_add_interface(struct ieee80211_hw *hw,
 	struct ieee80211_if_init_conf *conf)
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	struct interface *intf = &rt2x00dev->interface;
+	int status;
 
 	/*
 	 * We only support 1 non-monitor interface.
 	 */
 	if (conf->type != IEEE80211_IF_TYPE_MNTR &&
-	    is_interface_present(&rt2x00dev->interface))
+	    is_interface_present(intf))
 		return -ENOBUFS;
 
 	/*
@@ -191,17 +159,39 @@ int rt2x00lib_add_interface(struct ieee8
 	}
 
 	/*
-	 * If this is the first interface which is being added,
-	 * we should write the MAC address to the device.
-	 */
-	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags))
-		rt2x00dev->ops->lib->config_mac_addr(rt2x00dev, conf->mac_addr);
-
-	/*
-	 * Enable periodic link tuning if this is a non-monitor interface.
+	 * Initialize interface, and enable the radio when this
+	 * is the first interface that is brought up.
 	 */
-	if (conf->type != IEEE80211_IF_TYPE_MNTR)
-		rt2x00_start_link_tune(rt2x00dev);
+	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags)) {
+		/*
+		 * We must wait on the firmware before
+		 * we can safely continue.
+		 */
+		status = rt2x00lib_load_firmware_wait(rt2x00dev);
+		if (status)
+			return status;
+
+		/*
+		 * Before initialization, the mac address should
+		 * be configured.
+		 */
+		rt2x00dev->ops->lib->config_mac_addr(rt2x00dev,
+			conf->mac_addr);
+ 
+		/*
+		 * Initialize the device.
+		 */
+		status = rt2x00lib_initialize(rt2x00dev);
+		if (status)
+			return status;
+
+		/*
+		 * Enable radio.
+		 */
+		status = rt2x00lib_enable_radio(rt2x00dev);
+		if (status)
+			return status;
+	}
 
 	return 0;
 }
@@ -217,12 +207,12 @@ void rt2x00lib_remove_interface(struct i
 	 * We only support 1 non-monitor interface.
 	 */
 	if (conf->type != IEEE80211_IF_TYPE_MNTR &&
-	    !is_interface_present(&rt2x00dev->interface))
+	    !is_interface_present(intf))
 		return;
 
 	/*
-	 * We support muliple monitor mode interfaces.
-	 * All we need to do is decrease the monitor_count.
+	 * When removing an monitor interface, decrease monitor_count.
+	 * For non-monitor interfaces, all interface data needs to be reset.
 	 */
 	if (conf->type == IEEE80211_IF_TYPE_MNTR) {
 		intf->monitor_count--;
@@ -234,33 +224,18 @@ void rt2x00lib_remove_interface(struct i
 	}
 
 	/*
-	 * When this is a non-monitor mode, stop the periodic link tuning.
-	 */
-	if (conf->type != IEEE80211_IF_TYPE_MNTR)
-		rt2x00_stop_link_tune(rt2x00dev);
-
-	/*
-	 * Check if we still have 1 non-monitor or a monitor
-	 * interface enabled. In that case we should update the
-	 * registers.
-	 */
-	if (is_monitor_present(&rt2x00dev->interface) ^
-	    is_interface_present(&rt2x00dev->interface)) {
-		if (is_interface_present(&rt2x00dev->interface))
-			rt2x00dev->ops->lib->config_type(rt2x00dev,
-				rt2x00dev->interface.type);
-		else
-			rt2x00dev->ops->lib->config_type(rt2x00dev,
-				IEEE80211_IF_TYPE_MNTR);
-	}
-
-	/*
-	 * Check which interfaces have been disabled.
-	 */
-	if (!is_interface_present(&rt2x00dev->interface))
-		__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	else if (!is_monitor_present(&rt2x00dev->interface))
-		__clear_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags);
+	 * If this was the last interface,
+	 * this is the time to disable the radio.
+	 * If this is not the last interface, then we should
+	 * check if we should switch completely to monitor
+	 * mode or completely switch to the non-monitor mode.
+	 */
+	if (!is_monitor_present(intf) && !is_interface_present(intf))
+		rt2x00lib_disable_radio(rt2x00dev);
+	else if (is_monitor_present(intf) ^ is_interface_present(intf))
+		rt2x00lib_config_type(rt2x00dev,
+			is_interface_present(intf) ?
+				intf->type : IEEE80211_IF_TYPE_MNTR);
 }
 EXPORT_SYMBOL_GPL(rt2x00lib_remove_interface);
 
@@ -279,15 +254,15 @@ int rt2x00lib_config(struct ieee80211_hw
 			rt2x00lib_toggle_rx(rt2x00dev, 0);
 	}
 
-	rt2x00dev->ops->lib->config_phymode(rt2x00dev, conf->phymode);
-	rt2x00dev->ops->lib->config_channel(rt2x00dev,
-		conf->channel_val, conf->channel, conf->freq,
-		conf->power_level);
-	rt2x00dev->ops->lib->config_txpower(rt2x00dev, conf->power_level);
-	rt2x00dev->ops->lib->config_antenna(rt2x00dev,
+	rt2x00lib_config_phymode(rt2x00dev, conf->phymode);
+	rt2x00lib_config_channel(rt2x00dev, conf->channel_val,
+		conf->channel, conf->freq, conf->power_level);
+	rt2x00lib_config_txpower(rt2x00dev, conf->power_level);
+	rt2x00lib_config_antenna(rt2x00dev,
 		conf->antenna_sel_tx, conf->antenna_sel_rx);
 	rt2x00dev->ops->lib->config_duration(rt2x00dev,
-		(conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME));
+		(conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME),
+		conf->beacon_int);
 
 	/*
 	 * Reenable RX only if the radio should be on.
@@ -330,9 +305,8 @@ int rt2x00lib_config_interface(struct ie
 	 * Enable configuration.
 	 * For Monitor mode, promisc mode will be forced on.
 	 */
-	rt2x00dev->ops->lib->config_type(rt2x00dev, conf->type);
-	if (conf->type == IEEE80211_IF_TYPE_MNTR)
-		rt2x00dev->ops->lib->config_promisc(rt2x00dev, 1);
+	rt2x00lib_config_type(rt2x00dev, conf->type);
+	rt2x00lib_config_promisc(rt2x00dev, rt2x00dev->interface.promisc);
 	rt2x00dev->ops->lib->config_bssid(rt2x00dev, intf->bssid);
 
 	/*
@@ -365,10 +339,10 @@ void rt2x00lib_set_multicast_list(struct
 	 * Check if the new state is different then the old state.
 	 */
 	if (test_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags) ==
-	    (flags & IFF_PROMISC))
+	    !!(flags & IFF_PROMISC))
 		return;
 
-	rt2x00dev->interface.promisc = (flags & IFF_PROMISC);
+	rt2x00dev->interface.promisc = !!(flags & IFF_PROMISC);
 
 	/*
 	 * Schedule the link tuner if this does not run
@@ -376,7 +350,7 @@ void rt2x00lib_set_multicast_list(struct
 	 * switched off when it is not required.
 	 */
 	if (!work_pending(&rt2x00dev->link.work.work))
-		queue_work(rt2x00dev->workqueue, &rt2x00dev->link.work.work);
+		queue_work(rt2x00dev->hw->workqueue, &rt2x00dev->link.work.work);
 }
 EXPORT_SYMBOL_GPL(rt2x00lib_set_multicast_list);
 
@@ -387,8 +361,8 @@ int rt2x00lib_get_tx_stats(struct ieee80
 	unsigned int i;
 
 	for (i = 0; i < hw->queues; i++)
-		memcpy(&stats->data[i], &rt2x00dev->ring[i].stats,
-			sizeof(rt2x00dev->ring[i].stats));
+		memcpy(&stats->data[i], &rt2x00dev->tx[i].stats,
+			sizeof(rt2x00dev->tx[i].stats));
 
 	return 0;
 }
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00pci.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00pci.c	2007-07-09 21:00:14.000000000 +0200
@@ -36,6 +36,7 @@
 #include <linux/pci.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00pci.h"
 
 /*
@@ -74,7 +75,7 @@ EXPORT_SYMBOL_GPL(rt2x00pci_beacon_updat
 
 void rt2x00pci_beacondone(struct rt2x00_dev *rt2x00dev, const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_entry *entry = rt2x00_get_data_entry(ring);
 	struct sk_buff *skb;
 
@@ -109,7 +110,8 @@ int rt2x00pci_write_tx_data(struct rt2x0
 
 	rt2x00_desc_read(txd, 0, &word);
 
-	if (rt2x00_get_field32(word, TXD_ENTRY_AVAILABLE)) {
+	if (rt2x00_get_field32(word, TXD_ENTRY_OWNER_NIC) ||
+	    rt2x00_get_field32(word, TXD_ENTRY_VALID)) {
 		ERROR(rt2x00dev,
 			"Arrived at non-free entry in the non-full queue %d.\n"
 			"Please file bug report to %s.\n",
@@ -118,11 +120,11 @@ int rt2x00pci_write_tx_data(struct rt2x0
 		return -EINVAL;
 	}
 
+	entry->skb = skb;
+	memcpy(&entry->tx_status.control, control, sizeof(*control));
 	memcpy(entry->data_addr, skb->data, skb->len);
 	rt2x00lib_write_tx_desc(rt2x00dev, entry, txd, ieee80211hdr,
 		skb->len, control);
-	memcpy(&entry->tx_status.control, control, sizeof(*control));
-	entry->skb = skb;
 
 	rt2x00_ring_index_inc(ring);
 
@@ -134,6 +136,50 @@ int rt2x00pci_write_tx_data(struct rt2x0
 EXPORT_SYMBOL_GPL(rt2x00pci_write_tx_data);
 
 /*
+ * RX data handlers.
+ */
+void rt2x00pci_rxdone(struct rt2x00_dev *rt2x00dev)
+{
+	struct data_ring *ring = rt2x00dev->rx;
+	struct data_entry *entry;
+	struct data_desc *rxd;
+	u32 desc;
+	int signal;
+	int rssi;
+	int ofdm;
+	int size;
+
+	while (1) {
+		entry = rt2x00_get_data_entry(ring);
+		rxd = entry->priv;
+		rt2x00_desc_read(rxd, 0, &desc);
+
+		if (rt2x00_get_field32(desc, RXD_ENTRY_OWNER_NIC))
+			break;
+
+		size = rt2x00dev->ops->lib->fill_rxdone(
+			entry, &signal, &rssi, &ofdm);
+		if (size < 0)
+			goto skip_entry;
+
+		/*
+		 * Send the packet to upper layer.
+		 */
+		rt2x00lib_rxdone(entry, entry->data_addr, size,
+			signal, rssi, ofdm);
+
+skip_entry:
+		if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
+			rt2x00_set_field32(&desc, RXD_ENTRY_OWNER_NIC, 1);
+			rt2x00_desc_write(rxd, 0, desc);
+		}
+
+		rt2x00_ring_index_inc(ring);
+	}
+}
+EXPORT_SYMBOL_GPL(rt2x00pci_rxdone);
+
+/*
  * Device initialization handlers.
  */
 #define priv_offset(__ring, __i)				\
@@ -155,43 +201,24 @@ EXPORT_SYMBOL_GPL(rt2x00pci_write_tx_dat
 		+ ((__i) * (__ring)->data_size);		\
 })
 
-static int rt2x00pci_alloc_dma_ring(struct rt2x00_dev *rt2x00dev,
-	const int queue, const u16 max_entries,
-	const u16 data_size, const u16 desc_size)
+static int rt2x00pci_alloc_ring(struct rt2x00_dev *rt2x00dev,
+	struct data_ring *ring)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
 	unsigned int i;
 
-	ring->stats.limit = max_entries;
-	ring->data_size = data_size;
-	ring->desc_size = desc_size;
-
-	/*
-	 * Allocate all ring entries.
-	 */
-	ring->entry = kzalloc(ring->stats.limit * sizeof(struct data_entry),
-		GFP_KERNEL);
-	if (!ring->entry)
-		return -ENOMEM;
-
 	/*
 	 * Allocate DMA memory for descriptor and buffer.
 	 */
 	ring->data_addr = pci_alloc_consistent(rt2x00dev_pci(rt2x00dev),
 		rt2x00_get_ring_size(ring), &ring->data_dma);
-	if (!ring->data_addr) {
-		kfree(ring->entry);
+	if (!ring->data_addr)
 		return -ENOMEM;
-	}
 
 	/*
 	 * Initialize all ring entries to contain valid
 	 * addresses.
 	 */
 	for (i = 0; i < ring->stats.limit; i++) {
-		ring->entry[i].flags = 0;
-		ring->entry[i].ring = ring;
-		ring->entry[i].skb = NULL;
 		ring->entry[i].priv = priv_offset(ring, i);
 		ring->entry[i].data_addr = data_addr_offset(ring, i);
 		ring->entry[i].data_dma = data_dma_offset(ring, i);
@@ -200,104 +227,22 @@ static int rt2x00pci_alloc_dma_ring(stru
 	return 0;
 }
 
-static void rt2x00pci_free_ring(struct rt2x00_dev *rt2x00dev, const int queue)
-{
-	struct data_ring *ring = &rt2x00dev->ring[queue];
-	if (ring->data_addr)
-		pci_free_consistent(rt2x00dev_pci(rt2x00dev),
-			rt2x00_get_ring_size(ring),
-			ring->data_addr, ring->data_dma);
-	ring->data_addr = NULL;
-
-	kfree(ring->entry);
-	ring->entry = NULL;
-}
-
-static int rt2x00pci_allocate_dma_rings(struct rt2x00_dev *rt2x00dev)
-{
-	unsigned int i;
-	int rings;
-
-	/*
-	 * The TX rings reported to mac80211,
-	 * plus the additional ATIM ring (if supported).
-	 */
-	rings = rt2x00dev->hw->queues +
-		test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
-
-	/*
-	 * First allocate the TX rings (minus BEACON).
-	 */
-	for (i = 0; i < rings; i++) {
-		if (rt2x00pci_alloc_dma_ring(rt2x00dev, i,
-			TX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->txd_size))
-			return -ENOMEM;
-	}
-
-	/*
-	 * Allocate the BEACON ring.
-	 */
-	if (rt2x00pci_alloc_dma_ring(rt2x00dev, rings,
-		BEACON_ENTRIES, MGMT_FRAME_SIZE, rt2x00dev->ops->txd_size))
-		return -ENOMEM;
-
-	/*
-	 * Allocate the RX ring.
-	 */
-	if (rt2x00pci_alloc_dma_ring(rt2x00dev, rings + 1,
-		RX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->rxd_size))
-		return -ENOMEM;
-
-	return 0;
-}
-
-static void rt2x00pci_free_rings(struct rt2x00_dev *rt2x00dev)
-{
-	unsigned int i;
-	int rings;
-
-	/*
-	 * The BEACON and RX ring, plus TX rings reported to mac80211,
-	 * and the additional ATIM ring (if supported).
-	 */
-	rings = 2 + rt2x00dev->hw->queues +
-		test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
-
-	for (i = 0; i < rings; i++)
-		rt2x00pci_free_ring(rt2x00dev, i);
-}
-
 int rt2x00pci_initialize(struct rt2x00_dev *rt2x00dev)
 {
 	struct pci_dev *pci_dev = rt2x00dev_pci(rt2x00dev);
+	struct data_ring *ring;
 	int status;
 
-	if (test_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
-		return 0;
-
-	/*
-	 * We must wait on the firmware before
-	 * we can safely continue.
-	 */
-	if (rt2x00lib_load_firmware_wait(rt2x00dev))
-		return -ENODEV;
-
 	/*
-	 * Allocate all data rings.
+	 * Allocate DMA
 	 */
-	status = rt2x00pci_allocate_dma_rings(rt2x00dev);
-	if (status) {
-		ERROR(rt2x00dev, "DMA allocation failed.\n");
-		goto exit_fail;
+	ring_for_each(rt2x00dev, ring) {
+		status = rt2x00pci_alloc_ring(rt2x00dev, ring);
+		if (status)
+			goto exit;
 	}
 
 	/*
-	 * Register the rfkill handler.
-	 */
-	if (rt2x00lib_register_rfkill(rt2x00dev))
-		goto exit_fail;
-
-	/*
 	 * Register interrupt handler.
 	 */
 	status = request_irq(pci_dev->irq, rt2x00dev->ops->lib->irq_handler,
@@ -305,18 +250,13 @@ int rt2x00pci_initialize(struct rt2x00_d
 	if (status) {
 		ERROR(rt2x00dev, "IRQ %d allocation failed (error %d).\n",
 			pci_dev->irq, status);
-		goto exit_fail_rfkill;
+		return status;
 	}
 
-	__set_bit(DEVICE_INITIALIZED, &rt2x00dev->flags);
-
 	return 0;
 
-exit_fail_rfkill:
-	rt2x00lib_unregister_rfkill(rt2x00dev);
-
-exit_fail:
-	rt2x00pci_free_rings(rt2x00dev);
+exit:
+	rt2x00pci_uninitialize(rt2x00dev);
 
 	return status;
 }
@@ -324,59 +264,31 @@ EXPORT_SYMBOL_GPL(rt2x00pci_initialize);
 
 void rt2x00pci_uninitialize(struct rt2x00_dev *rt2x00dev)
 {
-	if (!__test_and_clear_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
-		return;
+	struct data_ring *ring;
 
 	/*
-	 * Flush out all pending work.
-	 */
-	flush_workqueue(rt2x00dev->workqueue);
-
-	/*
-	 * Unregister rfkill.
-	 */
-	rt2x00lib_unregister_rfkill(rt2x00dev);
-
-	/*
-	 * Free DMA rings.
+	 * Free irq line.
 	 */
-	rt2x00pci_free_rings(rt2x00dev);
+	free_irq(rt2x00dev_pci(rt2x00dev)->irq, rt2x00dev);
 
 	/*
-	 * Free irq line.
+	 * Free DMA
 	 */
-	free_irq(rt2x00dev_pci(rt2x00dev)->irq, rt2x00dev);
+	ring_for_each(rt2x00dev, ring) {
+		if (ring->data_addr)
+			pci_free_consistent(rt2x00dev_pci(rt2x00dev),
+				rt2x00_get_ring_size(ring),
+				ring->data_addr, ring->data_dma);
+		ring->data_addr = NULL;
+	}
 }
 EXPORT_SYMBOL_GPL(rt2x00pci_uninitialize);
 
 /*
  * PCI driver handlers.
  */
-static void rt2x00pci_remove_dev(struct rt2x00_dev *rt2x00dev)
-{
-	/*
-	 * Free rfkill
-	 */
-	rt2x00lib_free_rfkill(rt2x00dev);
-
-	/*
-	 * Release CSR memory.
-	 */
-	if (rt2x00dev->csr_addr) {
-		iounmap(rt2x00dev->csr_addr);
-		rt2x00dev->csr_addr = NULL;
-	}
-
-	rt2x00lib_free_dev(rt2x00dev);
-}
-
-static int rt2x00pci_probe_dev(struct rt2x00_dev *rt2x00dev)
+static int rt2x00pci_alloc_csr(struct rt2x00_dev *rt2x00dev)
 {
-	int retval;
-
-	/*
-	 * Allocate the CSR memory.
-	 */
 	rt2x00dev->csr_addr = ioremap(
 		pci_resource_start(rt2x00dev_pci(rt2x00dev), 0),
 		pci_resource_len(rt2x00dev_pci(rt2x00dev), 0));
@@ -385,33 +297,15 @@ static int rt2x00pci_probe_dev(struct rt
 		return -ENOMEM;
 	}
 
-	/*
-	 * Let the driver probe the device to
-	 * detect the capabilities.
-	 */
-	retval = rt2x00dev->ops->lib->init_hw(rt2x00dev);
-	if (retval) {
-		ERROR(rt2x00dev, "Failed to allocate device.\n");
-		goto exit;
-	}
-
-	/*
-	 * Allocatie rfkill.
-	 */
-	retval = rt2x00lib_allocate_rfkill(rt2x00dev);
-	if (retval)
-		goto exit;
-
-	retval = rt2x00lib_alloc_dev(rt2x00dev);
-	if (retval)
-		goto exit;
-
 	return 0;
+}
 
-exit:
-	rt2x00pci_remove_dev(rt2x00dev);
-
-	return retval;
+static void rt2x00pci_free_csr(struct rt2x00_dev *rt2x00dev)
+{
+	if (rt2x00dev->csr_addr) {
+		iounmap(rt2x00dev->csr_addr);
+		rt2x00dev->csr_addr = NULL;
+	}
 }
 
 int rt2x00pci_probe(struct pci_dev *pci_dev, const struct pci_device_id *id)
@@ -456,16 +350,22 @@ int rt2x00pci_probe(struct pci_dev *pci_
 
 	rt2x00dev = hw->priv;
 	rt2x00dev->dev = pci_dev;
-	rt2x00dev->device = &pci_dev->dev;
 	rt2x00dev->ops = ops;
 	rt2x00dev->hw = hw;
 
-	retval = rt2x00pci_probe_dev(rt2x00dev);
+	retval = rt2x00pci_alloc_csr(rt2x00dev);
 	if (retval)
 		goto exit_free_device;
 
+	retval = rt2x00lib_probe_dev(rt2x00dev);
+	if (retval)
+		goto exit_free_csr;
+
 	return 0;
 
+exit_free_csr:
+	rt2x00pci_free_csr(rt2x00dev);
+
 exit_free_device:
 	ieee80211_free_hw(hw);
 
@@ -488,15 +388,9 @@ void rt2x00pci_remove(struct pci_dev *pc
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
 	/*
-	 * Uninitialize and free the rt61pci driver data.
-	 */
-	rt2x00lib_disable_radio(rt2x00dev);
-	rt2x00pci_uninitialize(rt2x00dev);
-	rt2x00pci_remove_dev(rt2x00dev);
-
-	/*
-	 * Free the 80211 stack data.
+	 * Free all allocated data.
 	 */
+	rt2x00lib_remove_dev(rt2x00dev);
 	ieee80211_free_hw(hw);
 
 	/*
@@ -515,29 +409,12 @@ int rt2x00pci_suspend(struct pci_dev *pc
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	int retval;
 
-	NOTICE(rt2x00dev, "Going to sleep.\n");
-
-	/*
-	 * Disable the radio.
-	 */
-	rt2x00lib_disable_radio(rt2x00dev);
-
-	/*
-	 * Set device mode to sleep for power management.
-	 */
-	retval = rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_SLEEP);
+	retval = rt2x00lib_suspend(rt2x00dev, state);
 	if (retval)
 		return retval;
 
-	/*
-	 * Uninitialize device and hardware.
-	 */
-	rt2x00pci_uninitialize(rt2x00dev);
-	rt2x00pci_remove_dev(rt2x00dev);
+	rt2x00pci_free_csr(rt2x00dev);
 
-	/*
-	 * Disable PCI.
-	 */
 	pci_save_state(pci_dev);
 	pci_disable_device(pci_dev);
 	return pci_set_power_state(pci_dev, pci_choose_state(pci_dev, state));
@@ -550,11 +427,6 @@ int rt2x00pci_resume(struct pci_dev *pci
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	int retval;
 
-	NOTICE(rt2x00dev, "Waking up.\n");
-
-	/*
-	 * Enable PCI.
-	 */
 	if (pci_set_power_state(pci_dev, PCI_D0) ||
 	    pci_enable_device(pci_dev) ||
 	    pci_restore_state(pci_dev)) {
@@ -562,23 +434,11 @@ int rt2x00pci_resume(struct pci_dev *pci
 		return -EIO;
 	}
 
-	/*
-	 * Initialize hardware.
-	 */
-	retval = rt2x00pci_probe_dev(rt2x00dev);
-	if (retval) {
-		ERROR(rt2x00dev, "Failed to allocate device.\n");
-		return retval;
-	}
-
-	/*
-	 * Set device mode to awake for power management.
-	 */
-	retval = rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE);
+	retval = rt2x00pci_alloc_csr(rt2x00dev);
 	if (retval)
 		return retval;
 
-	return 0;
+	return rt2x00lib_resume(rt2x00dev);
 }
 EXPORT_SYMBOL_GPL(rt2x00pci_resume);
 #endif /* CONFIG_PM */
@@ -590,9 +450,3 @@ MODULE_AUTHOR(DRV_PROJECT);
 MODULE_VERSION(DRV_VERSION);
 MODULE_DESCRIPTION("rt2x00 library");
 MODULE_LICENSE("GPL");
-
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00pci.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00pci.h	2007-07-09 21:00:14.000000000 +0200
@@ -43,12 +43,42 @@
 #define REGISTER_BUSY_DELAY	100
 
 /*
- * TX descriptor available flag.
- * This flag is the combination of the TXD_W0_OWNER_NIC
- * and TXD_W0_VALID flag which have the same value on all
- * PCI drivers.
+ * Descriptor availability flags.
+ * All PCI device descriptors have these 2 flags
+ * with the exact same definition.
  */
-#define TXD_ENTRY_AVAILABLE	FIELD32(0x00000003)
+#define TXD_ENTRY_OWNER_NIC	FIELD32(0x00000001)
+#define TXD_ENTRY_VALID		FIELD32(0x00000002)
+#define RXD_ENTRY_OWNER_NIC	FIELD32(0x00000001)
+
+/*
+ * Register access.
+ */
+static inline void rt2x00pci_register_read(const struct rt2x00_dev *rt2x00dev,
+	const unsigned long offset, u32 *value)
+{
+	*value = readl(rt2x00dev->csr_addr + offset);
+}
+
+static inline void rt2x00pci_register_multiread(
+	const struct rt2x00_dev *rt2x00dev,
+	const unsigned long offset, void *value, const u16 length)
+{
+	memcpy_fromio(value, rt2x00dev->csr_addr + offset, length);
+}
+
+static inline void rt2x00pci_register_write(const struct rt2x00_dev *rt2x00dev,
+	const unsigned long offset, u32 value)
+{
+	writel(value, rt2x00dev->csr_addr + offset);
+}
+
+static inline void rt2x00pci_register_multiwrite(
+	const struct rt2x00_dev *rt2x00dev,
+	const unsigned long offset, void *value, const u16 length)
+{
+	memcpy_toio(rt2x00dev->csr_addr + offset, value, length);
+}
 
 /*
  * Beacon handlers.
@@ -65,6 +95,11 @@ int rt2x00pci_write_tx_data(struct rt2x0
 	struct ieee80211_tx_control *control);
 
 /*
+ * RX data handlers.
+ */
+void rt2x00pci_rxdone(struct rt2x00_dev *rt2x00dev);
+
+/*
  * Device initialization handlers.
  */
 int rt2x00pci_initialize(struct rt2x00_dev *rt2x00dev);
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00rfkill.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00rfkill.c	2007-07-09 21:00:14.000000000 +0200
@@ -70,7 +70,7 @@ static void rt2x00lib_rfkill_poll(struct
 	rfkill_switch_all(rt2x00dev->rfkill->type,
 		rt2x00dev->ops->lib->rfkill_poll(rt2x00dev));
 
-	queue_delayed_work(rt2x00dev->workqueue, &rt2x00dev->rfkill_work,
+	queue_delayed_work(rt2x00dev->hw->workqueue, &rt2x00dev->rfkill_work,
 		RFKILL_POLL_INTERVAL);
 }
 
@@ -87,17 +87,15 @@ int rt2x00lib_register_rfkill(struct rt2
 	return !schedule_delayed_work(&rt2x00dev->rfkill_work,
 		RFKILL_POLL_INTERVAL);
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_register_rfkill);
 
 void rt2x00lib_unregister_rfkill(struct rt2x00_dev *rt2x00dev)
 {
 	if (delayed_work_pending(&rt2x00dev->rfkill_work))
 		cancel_rearming_delayed_workqueue(
-			rt2x00dev->workqueue, &rt2x00dev->rfkill_work);
+			rt2x00dev->hw->workqueue, &rt2x00dev->rfkill_work);
 
 	rfkill_unregister(rt2x00dev->rfkill);
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_unregister_rfkill);
 
 int rt2x00lib_allocate_rfkill(struct rt2x00_dev *rt2x00dev)
 {
@@ -121,7 +119,6 @@ int rt2x00lib_allocate_rfkill(struct rt2
 
 	return 0;
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_allocate_rfkill);
 
 void rt2x00lib_free_rfkill(struct rt2x00_dev *rt2x00dev)
 {
@@ -130,4 +127,3 @@ void rt2x00lib_free_rfkill(struct rt2x00
 
 	rfkill_free(rt2x00dev->rfkill);
 }
-EXPORT_SYMBOL_GPL(rt2x00lib_free_rfkill);
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00usb.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00usb.c	2007-07-09 21:00:14.000000000 +0200
@@ -36,9 +36,41 @@
 #include <linux/usb.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00usb.h"
 
 /*
+ * Interfacing with the HW.
+ */
+int rt2x00usb_vendor_request(const struct rt2x00_dev *rt2x00dev,
+	const u8 request, const u8 type, const u16 offset,
+	u32 value, void *buffer, const u16 buffer_length, const u16 timeout)
+{
+	struct usb_device *usb_dev = interface_to_usbdev(
+		rt2x00dev_usb(rt2x00dev));
+	int status;
+	unsigned int i;
+
+	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
+		status = usb_control_msg(
+			usb_dev,
+			(type == USB_VENDOR_REQUEST_IN) ?
+				usb_rcvctrlpipe(usb_dev, 0) :
+				usb_sndctrlpipe(usb_dev, 0),
+			request, type, value, offset, buffer, buffer_length,
+			timeout);
+		if (status >= 0)
+			return 0;
+	}
+
+	ERROR(rt2x00dev, "Vendor Request 0x%02x failed for offset 0x%04x"
+		" with error %d.\n", request, offset, status);
+
+	return status;
+}
+EXPORT_SYMBOL_GPL(rt2x00usb_vendor_request);
+
+/*
  * Beacon handlers.
  */
 int rt2x00usb_beacon_update(struct ieee80211_hw *hw, struct sk_buff *skb,
@@ -169,7 +201,7 @@ static void rt2x00usb_interrupt_txdone(s
 	int tx_status;
 
 	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags) ||
-	    !__test_and_clear_bit(ENTRY_OWNER_NIC, &rt2x00dev->flags))
+	    !__test_and_clear_bit(ENTRY_OWNER_NIC, &entry->flags))
 		return;
 
 	rt2x00_desc_read(txd, 0, &word);
@@ -263,209 +295,202 @@ int rt2x00usb_write_tx_data(struct rt2x0
 EXPORT_SYMBOL_GPL(rt2x00usb_write_tx_data);
 
 /*
- * Device initialization handlers.
+ * RX data handlers.
  */
-static int rt2x00usb_alloc_dma_ring(struct rt2x00_dev *rt2x00dev,
-	const int queue, const u16 max_entries, const u16 data_size,
-	const u16 desc_size, const int rx_ring)
+static void rt2x00usb_interrupt_rxdone(struct urb *urb)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
-	unsigned int entry_size;
-	unsigned int i;
+	struct data_entry *entry = (struct data_entry*)urb->context;
+	struct data_ring *ring = entry->ring;
+	struct rt2x00_dev *rt2x00dev = ring->rt2x00dev;
+	int signal;
+	int rssi;
+	int ofdm;
+	int size;
 
-	ring->stats.limit = max_entries;
-	ring->data_size = data_size;
-	ring->desc_size = desc_size;
+	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags) ||
+	    !test_and_clear_bit(ENTRY_OWNER_NIC, &entry->flags))
+		return;
 
 	/*
-	 * Allocate all ring entries.
+	 * Check if the received data is simply too small
+	 * to be actually valid, or if the urb is signaling
+	 * a problem.
 	 */
-	ring->entry = kzalloc(ring->stats.limit * sizeof(struct data_entry),
-		GFP_KERNEL);
-	if (!ring->entry)
-		return -ENOMEM;
+	if (urb->actual_length < entry->ring->desc_size || urb->status)
+		goto skip_entry;
+
+	size = rt2x00dev->ops->lib->fill_rxdone(entry, &signal, &rssi, &ofdm);
+	if (size < 0)
+		goto skip_entry;
 
 	/*
-	 * Initialize all ring entries to contain valid
-	 * addresses.
+	 * Trim the skb_buffer to only contain the valid
+	 * frame data (so ignore the device's descriptor).
 	 */
-	entry_size = ring->data_size + ring->desc_size;
-	for (i = 0; i < ring->stats.limit; i++) {
-		ring->entry[i].flags = 0;
-		ring->entry[i].ring = ring;
-		ring->entry[i].priv = usb_alloc_urb(0, GFP_KERNEL);
-		if (!ring->entry[i].priv)
-			return -ENOMEM;
+	skb_trim(entry->skb, size);
 
-		if (rx_ring) {
-			ring->entry[i].skb =
-				dev_alloc_skb(NET_IP_ALIGN + entry_size);
-			if (!ring->entry[i].skb)
-				return -ENOMEM;
+	/*
+	 * Send the packet to upper layer, and update urb.
+	 */
+	rt2x00lib_rxdone(entry, NULL, ring->data_size + ring->desc_size,
+		signal, rssi, ofdm);
+	urb->transfer_buffer = entry->skb->data;
+	urb->transfer_buffer_length = entry->skb->len;
 
-			skb_reserve(ring->entry[i].skb, NET_IP_ALIGN);
-			skb_put(ring->entry[i].skb, entry_size);
-		}
+skip_entry:
+	if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
+		__set_bit(ENTRY_OWNER_NIC, &entry->flags);
+		usb_submit_urb(urb, GFP_ATOMIC);
 	}
 
-	return 0;
+	rt2x00_ring_index_inc(ring);
 }
 
-static void rt2x00usb_free_ring(struct rt2x00_dev *rt2x00dev, const int queue)
+/*
+ * Radio handlers
+ */
+void rt2x00usb_enable_radio(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
+	struct usb_device *usb_dev =
+		interface_to_usbdev(rt2x00dev_usb(rt2x00dev));
+	struct data_ring *ring;
+	struct data_entry *entry;
 	unsigned int i;
 
-	if (!ring->entry)
-		return;
+	/*
+	 * Initialize the TX rings
+	 */
+	txringall_for_each(rt2x00dev, ring) {
+		for (i = 0; i < ring->stats.limit; i++)
+			ring->entry[i].flags = 0;
 
-	for (i = 0; i < ring->stats.limit; i++) {
-		usb_kill_urb(ring->entry[i].priv);
-		usb_free_urb(ring->entry[i].priv);
-		if (ring->entry[i].skb)
-			kfree_skb(ring->entry[i].skb);
+		rt2x00_ring_index_clear(ring);
 	}
 
-	kfree(ring->entry);
-	ring->entry = NULL;
+	/*
+	 * Initialize and start the RX ring.
+	 */
+	rt2x00_ring_index_clear(rt2x00dev->rx);
+
+	for (i = 0; i < rt2x00dev->rx->stats.limit; i++) {
+		entry = &rt2x00dev->rx->entry[i];
+
+		usb_fill_bulk_urb(
+			entry->priv,
+			usb_dev,
+			usb_rcvbulkpipe(usb_dev, 1),
+			entry->skb->data,
+			entry->skb->len,
+			rt2x00usb_interrupt_rxdone,
+			entry);
+
+		__set_bit(ENTRY_OWNER_NIC, &entry->flags);
+		usb_submit_urb(entry->priv, GFP_ATOMIC);
+	}
 }
+EXPORT_SYMBOL_GPL(rt2x00usb_enable_radio);
 
-static int rt2x00usb_allocate_dma_rings(struct rt2x00_dev *rt2x00dev)
+void rt2x00usb_disable_radio(struct rt2x00_dev *rt2x00dev)
 {
+	struct data_ring *ring;
 	unsigned int i;
-	int rings;
 
-	/*
-	 * The TX rings reported to mac80211,
-	 * plus the additional ATIM ring (if supported).
-	 */
-	rings = rt2x00dev->hw->queues +
-		test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	rt2x00usb_vendor_request(rt2x00dev, USB_RX_CONTROL,
+		USB_VENDOR_REQUEST_OUT, 0x00, 0x00, NULL, 0, REGISTER_TIMEOUT);
 
 	/*
-	 * First allocate the TX rings (minus BEACON).
+	 * Cancel all rings.
 	 */
-	for (i = 0; i < rings; i++) {
-		if (rt2x00usb_alloc_dma_ring(rt2x00dev, i,
-			TX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->txd_size, 0))
-			return -ENOMEM;
+	ring_for_each(rt2x00dev, ring) {
+		for (i = 0; i < ring->stats.limit; i++)
+			usb_kill_urb(ring->entry[i].priv);
 	}
-
-	/*
-	 * Allocate the BEACON ring.
-	 */
-	if (rt2x00usb_alloc_dma_ring(rt2x00dev, rings,
-		BEACON_ENTRIES, MGMT_FRAME_SIZE, rt2x00dev->ops->txd_size, 0))
-		return -ENOMEM;
-
-	/*
-	 * Allocate the RX ring.
-	 */
-	if (rt2x00usb_alloc_dma_ring(rt2x00dev, rings + 1,
-		RX_ENTRIES, DATA_FRAME_SIZE, rt2x00dev->ops->rxd_size, 1))
-		return -ENOMEM;
-
-	return 0;
 }
+EXPORT_SYMBOL_GPL(rt2x00usb_disable_radio);
 
-static void rt2x00usb_free_rings(struct rt2x00_dev *rt2x00dev)
+/*
+ * Device initialization handlers.
+ */
+static int rt2x00usb_alloc_ring(struct rt2x00_dev *rt2x00dev,
+	struct data_ring *ring)
 {
 	unsigned int i;
-	int rings;
 
 	/*
-	 * The BEACON and RX ring, plus TX rings reported to mac80211,
-	 * and the additional ATIM ring (if supported).
+	 * Allocate the URB's
 	 */
-	rings = 2 + rt2x00dev->hw->queues +
-		test_bit(DEVICE_SUPPORT_ATIM, &rt2x00dev->flags);
+	for (i = 0; i < ring->stats.limit; i++) {
+		ring->entry[i].priv = usb_alloc_urb(0, GFP_KERNEL);
+		if (!ring->entry[i].priv)
+			return -ENOMEM;
+	}
 
-	for (i = 0; i < rings; i++)
-		rt2x00usb_free_ring(rt2x00dev, i);
+	return 0;
 }
 
 int rt2x00usb_initialize(struct rt2x00_dev *rt2x00dev)
 {
-	if (test_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
-		return 0;
+	struct data_ring *ring;
+	struct sk_buff *skb;
+	unsigned int entry_size;
+	unsigned int i;
+	int status;
 
 	/*
-	 * We must wait on the firmware before
-	 * we can safely continue.
+	 * Allocate DMA
 	 */
-	if (rt2x00lib_load_firmware_wait(rt2x00dev))
-		return -ENODEV;
+	ring_for_each(rt2x00dev, ring) {
+		status = rt2x00usb_alloc_ring(rt2x00dev, ring);
+		if (status)
+			goto exit;
+	}
 
 	/*
-	 * Allocate all data rings.
+	 * For the RX ring, skb's should be allocated.
 	 */
-	if (rt2x00usb_allocate_dma_rings(rt2x00dev)) {
-		ERROR(rt2x00dev, "DMA allocation failed.\n");
-		goto exit_fail;
-	}
+	entry_size = ring->data_size + ring->desc_size;
+	for (i = 0; i < rt2x00dev->rx->stats.limit; i++) {
+		skb = dev_alloc_skb(NET_IP_ALIGN + entry_size);
+		if (!skb)
+			goto exit;
 
-	__set_bit(DEVICE_INITIALIZED, &rt2x00dev->flags);
+		skb_reserve(skb, NET_IP_ALIGN);
+		skb_put(skb, entry_size);
+
+		rt2x00dev->rx->entry[i].skb = skb;
+	}
 
 	return 0;
 
-exit_fail:
-	rt2x00usb_free_rings(rt2x00dev);
+exit:
+	rt2x00usb_uninitialize(rt2x00dev);
 
-	return -EIO;
+	return status;
 }
 EXPORT_SYMBOL_GPL(rt2x00usb_initialize);
 
 void rt2x00usb_uninitialize(struct rt2x00_dev *rt2x00dev)
 {
-	if (!__test_and_clear_bit(DEVICE_INITIALIZED, &rt2x00dev->flags))
-		return;
-
-	/*
-	 * Flush out all pending work.
-	 */
-	flush_workqueue(rt2x00dev->workqueue);
+	struct data_ring *ring;
+	unsigned int i;
 
-	/*
-	 * Free DMA rings.
-	 */
-	rt2x00usb_free_rings(rt2x00dev);
+	ring_for_each(rt2x00dev, ring) {
+		if (!ring->entry)
+			continue;
+
+		for (i = 0; i < ring->stats.limit; i++) {
+			usb_kill_urb(ring->entry[i].priv);
+			usb_free_urb(ring->entry[i].priv);
+			if (ring->entry[i].skb)
+				kfree_skb(ring->entry[i].skb);
+		}
+	}
 }
 EXPORT_SYMBOL_GPL(rt2x00usb_uninitialize);
 
 /*
  * USB driver handlers.
  */
-static void rt2x00usb_remove_dev(struct rt2x00_dev *rt2x00dev)
-{
-	rt2x00lib_free_dev(rt2x00dev);
-}
-
-static int rt2x00usb_probe_dev(struct rt2x00_dev *rt2x00dev)
-{
-	int retval;
-
-	/*
-	 * Let the driver probe the device to
-	 * detect the capabilities.
-	 */
-	retval = rt2x00dev->ops->lib->init_hw(rt2x00dev);
-	if (retval) {
-		ERROR(rt2x00dev, "Failed to allocate device.\n");
-		goto exit;
-	}
-
-	retval = rt2x00lib_alloc_dev(rt2x00dev);
-	if (retval)
-		goto exit;
-
-	return 0;
-
-exit:
-	rt2x00usb_remove_dev(rt2x00dev);
-
-	return retval;
-}
-
 int rt2x00usb_probe(struct usb_interface *usb_intf,
 	const struct usb_device_id *id)
 {
@@ -488,11 +513,10 @@ int rt2x00usb_probe(struct usb_interface
 
 	rt2x00dev = hw->priv;
 	rt2x00dev->dev = usb_intf;
-	rt2x00dev->device = &usb_intf->dev;
 	rt2x00dev->ops = ops;
 	rt2x00dev->hw = hw;
 
-	retval = rt2x00usb_probe_dev(rt2x00dev);
+	retval = rt2x00lib_probe_dev(rt2x00dev);
 	if (retval)
 		goto exit_free_device;
 
@@ -516,15 +540,9 @@ void rt2x00usb_disconnect(struct usb_int
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
 	/*
-	 * Uninitialize and free the rt73usb driver data.
-	 */
-	rt2x00lib_disable_radio(rt2x00dev);
-	rt2x00usb_uninitialize(rt2x00dev);
-	rt2x00usb_remove_dev(rt2x00dev);
-
-	/*
-	 * Free the 80211 stack data.
+	 * Free all allocated data.
 	 */
+	rt2x00lib_remove_dev(rt2x00dev);
 	ieee80211_free_hw(hw);
 
 	/*
@@ -542,27 +560,11 @@ int rt2x00usb_suspend(struct usb_interfa
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	int retval;
 
-	NOTICE(rt2x00dev, "Going to sleep.\n");
-
-	/*
-	 * Disable the radio.
-	 */
-	rt2x00lib_disable_radio(rt2x00dev);
-
-	/*
-	 * Set device mode to sleep for power management.
-	 */
-	retval = rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_SLEEP);
+	retval = rt2x00lib_suspend(rt2x00dev, state);
 	if (retval)
 		return retval;
 
 	/*
-	 * Uninitialize device and hardware.
-	 */
-	rt2x00usb_uninitialize(rt2x00dev);
-	rt2x00usb_remove_dev(rt2x00dev);
-
-	/*
 	 * Decrease usbdev refcount.
 	 */
 	usb_put_dev(interface_to_usbdev(usb_intf));
@@ -575,32 +577,10 @@ int rt2x00usb_resume(struct usb_interfac
 {
 	struct ieee80211_hw *hw = usb_get_intfdata(usb_intf);
 	struct rt2x00_dev *rt2x00dev = hw->priv;
-	int retval;
-
-	NOTICE(rt2x00dev, "Waking up.\n");
 
-	/*
-	 * Increase usbdev refcount.
-	 */
 	usb_get_dev(interface_to_usbdev(usb_intf));
 
-	/*
-	 * Initialize hardware.
-	 */
-	retval = rt2x00usb_probe_dev(rt2x00dev);
-	if (retval) {
-		ERROR(rt2x00dev, "Failed to allocate device.\n");
-		return retval;
-	}
-
-	/*
-	 * Set device mode to awake for power management.
-	 */
-	retval = rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE);
-	if (retval)
-		return retval;
-
-	return 0;
+	return rt2x00lib_resume(rt2x00dev);
 }
 EXPORT_SYMBOL_GPL(rt2x00usb_resume);
 #endif /* CONFIG_PM */
@@ -612,9 +592,3 @@ MODULE_AUTHOR(DRV_PROJECT);
 MODULE_VERSION(DRV_VERSION);
 MODULE_DESCRIPTION("rt2x00 library");
 MODULE_LICENSE("GPL");
-
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
--- a/drivers/net/wireless/mac80211/rt2x00/rt2x00usb.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt2x00usb.h	2007-07-09 21:00:14.000000000 +0200
@@ -86,13 +86,25 @@
 #define BEACON_ENTRIES 2
 
 /*
+ * Interfacing with the HW.
+ */
+int rt2x00usb_vendor_request(const struct rt2x00_dev *rt2x00dev,
+	const u8 request, const u8 type, const u16 offset,
+	u32 value, void *buffer, const u16 buffer_length, const u16 timeout);
+
+/*
+ * Radio handlers
+ */
+void rt2x00usb_enable_radio(struct rt2x00_dev *rt2x00dev);
+void rt2x00usb_disable_radio(struct rt2x00_dev *rt2x00dev);
+
+/*
  * Beacon handlers.
  */
 int rt2x00usb_beacon_update(struct ieee80211_hw *hw, struct sk_buff *skb,
 	struct ieee80211_tx_control *control);
 void rt2x00usb_beacondone(struct urb *urb);
 
-
 /*
  * TX data handlers.
  */
--- a/drivers/net/wireless/mac80211/rt2x00/rt61pci.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt61pci.c	2007-07-09 21:00:14.000000000 +0200
@@ -42,13 +42,12 @@
 #include <asm/io.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00pci.h"
 #include "rt61pci.h"
 
 /*
  * Register access.
- * All access to the CSR registers will go through the methods
- * rt2x00_register_read and rt2x00_register_write.
  * BBP and RF register require indirect register access,
  * and use the CSR registers PHY_CSR3 and PHY_CSR4 to achieve this.
  * These indirect registers work with busy bits,
@@ -58,54 +57,22 @@
  * the access attempt is considered to have failed,
  * and we will print an error.
  */
-static inline void rt2x00_register_read(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 *value)
-{
-	readl(rt2x00dev->csr_addr + MAC_CSR0);
-	*value = readl(rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiread(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	readl(rt2x00dev->csr_addr + MAC_CSR0);
-	memcpy_fromio(value, rt2x00dev->csr_addr + offset, length);
-}
-
-static inline void rt2x00_register_write(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, u32 value)
-{
-	readl(rt2x00dev->csr_addr + MAC_CSR0);
-	writel(value, rt2x00dev->csr_addr + offset);
-}
-
-static inline void rt2x00_register_multiwrite(
-	const struct rt2x00_dev *rt2x00dev,
-	const unsigned long offset, void *value, const u16 length)
-{
-	readl(rt2x00dev->csr_addr + MAC_CSR0);
-	memcpy_toio(rt2x00dev->csr_addr + offset, value, length);
-}
-
-static u32 rt2x00_bbp_check(const struct rt2x00_dev *rt2x00dev)
+static u32 rt61pci_bbp_check(const struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR3, &reg);
+		rt2x00pci_register_read(rt2x00dev, PHY_CSR3, &reg);
 		if (!rt2x00_get_field32(reg, PHY_CSR3_BUSY))
-			return reg;
+			break;
 		udelay(REGISTER_BUSY_DELAY);
 	}
 
-	return 0xffff;
+	return reg;
 }
 
-static void rt2x00_bbp_write(const struct rt2x00_dev *rt2x00dev,
+static void rt61pci_bbp_write(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, const u8 value)
 {
 	u32 reg;
@@ -113,7 +80,8 @@ static void rt2x00_bbp_write(const struc
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt61pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Write failed.\n");
 		return;
 	}
@@ -127,10 +95,10 @@ static void rt2x00_bbp_write(const struc
 	rt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);
 	rt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 0);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR3, reg);
 }
 
-static void rt2x00_bbp_read(const struct rt2x00_dev *rt2x00dev,
+static void rt61pci_bbp_read(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, u8 *value)
 {
 	u32 reg;
@@ -138,7 +106,8 @@ static void rt2x00_bbp_read(const struct
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt61pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Read failed.\n");
 		return;
 	}
@@ -151,26 +120,29 @@ static void rt2x00_bbp_read(const struct
 	rt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);
 	rt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR3, reg);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR3, reg);
 
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	reg = rt2x00_bbp_check(rt2x00dev);
-	if (reg == 0xffff)
+	reg = rt61pci_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Read failed.\n");
+		*value = 0xff;
+		return;
+	}
 
 	*value = rt2x00_get_field32(reg, PHY_CSR3_VALUE);
 }
 
-static void rt2x00_rf_write(const struct rt2x00_dev *rt2x00dev,
+static void rt61pci_rf_write(const struct rt2x00_dev *rt2x00dev,
 	const u32 value)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR4, &reg);
+		rt2x00pci_register_read(rt2x00dev, PHY_CSR4, &reg);
 		if (!rt2x00_get_field32(reg, PHY_CSR4_BUSY))
 			goto rf_write;
 		udelay(REGISTER_BUSY_DELAY);
@@ -186,15 +158,15 @@ rf_write:
 	rt2x00_set_field32(&reg, PHY_CSR4_IF_SELECT, 0);
 	rt2x00_set_field32(&reg, PHY_CSR4_BUSY, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR4, reg);
 }
 
-static void rt2x00_mcu_request(const struct rt2x00_dev *rt2x00dev,
+static void rt61pci_mcu_request(const struct rt2x00_dev *rt2x00dev,
 	const u8 command, const u8 token, const u8 arg0, const u8 arg1)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, H2M_MAILBOX_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, H2M_MAILBOX_CSR, &reg);
 
 	if (rt2x00_get_field32(reg, H2M_MAILBOX_CSR_OWNER)) {
 		ERROR(rt2x00dev, "mcu request error. "
@@ -207,12 +179,12 @@ static void rt2x00_mcu_request(const str
 	rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_CMD_TOKEN, token);
 	rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG0, arg0);
 	rt2x00_set_field32(&reg, H2M_MAILBOX_CSR_ARG1, arg1);
-	rt2x00_register_write(rt2x00dev, H2M_MAILBOX_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, H2M_MAILBOX_CSR, reg);
 
-	rt2x00_register_read(rt2x00dev, HOST_CMD_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, HOST_CMD_CSR, &reg);
 	rt2x00_set_field32(&reg, HOST_CMD_CSR_HOST_COMMAND, command);
 	rt2x00_set_field32(&reg, HOST_CMD_CSR_INTERRUPT_MCU, 1);
-	rt2x00_register_write(rt2x00dev, HOST_CMD_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, HOST_CMD_CSR, reg);
 }
 
 static void rt61pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
@@ -220,7 +192,7 @@ static void rt61pci_eepromregister_read(
 	struct rt2x00_dev *rt2x00dev = eeprom->data;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, E2PROM_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, E2PROM_CSR, &reg);
 
 	eeprom->reg_data_in = !!rt2x00_get_field32(reg,
 		E2PROM_CSR_DATA_IN);
@@ -246,7 +218,7 @@ static void rt61pci_eepromregister_write
 	rt2x00_set_field32(&reg, E2PROM_CSR_CHIP_SELECT,
 		!!eeprom->reg_chip_select);
 
-	rt2x00_register_write(rt2x00dev, E2PROM_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, E2PROM_CSR, reg);
 }
 
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
@@ -255,13 +227,13 @@ static void rt61pci_eepromregister_write
 static void rt61pci_read_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_read(rt2x00dev, CSR_OFFSET(word), data);
+	rt2x00pci_register_read(rt2x00dev, CSR_OFFSET(word), data);
 }
 
 static void rt61pci_write_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
+	rt2x00pci_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
 }
 
 static void rt61pci_read_eeprom(struct rt2x00_dev *rt2x00dev,
@@ -279,13 +251,13 @@ static void rt61pci_write_eeprom(struct 
 static void rt61pci_read_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_read(rt2x00dev, word, data);
+	rt61pci_bbp_read(rt2x00dev, word, data);
 }
 
 static void rt61pci_write_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_write(rt2x00dev, word, *((u8*)data));
+	rt61pci_bbp_write(rt2x00dev, word, *((u8*)data));
 }
 
 static const struct rt2x00debug rt61pci_rt2x00debug = {
@@ -316,7 +288,7 @@ static int rt61pci_rfkill_poll(struct rt
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR13, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR13, &reg);
 	return rt2x00_get_field32(reg, MAC_CSR13_BIT5);;
 }
 #endif /* CONFIG_RT2400PCI_RFKILL */
@@ -337,45 +309,30 @@ static void rt61pci_config_bssid(struct 
 	 * The BSSID is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR4, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, MAC_CSR4, &reg, sizeof(reg));
 }
 
-static void rt61pci_config_promisc(struct rt2x00_dev *rt2x00dev, int promisc)
+static void rt61pci_config_promisc(struct rt2x00_dev *rt2x00dev,
+	const int promisc)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
-
-	if (promisc) {
-		rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, 0);
-		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	} else {
-		rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, 1);
-		__clear_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	}
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, !promisc);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 }
 
-static void rt61pci_config_type(struct rt2x00_dev *rt2x00dev, int type)
+static void rt61pci_config_type(struct rt2x00_dev *rt2x00dev,
+	const int type)
 {
 	u32 reg;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (!(is_interface_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
-	    !(is_monitor_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
-		return;
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, 0);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR9, 0);
 
 	/*
 	 * Apply hardware packet filter.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
 
 	if (!is_monitor_present(&rt2x00dev->interface) &&
 	    (type == IEEE80211_IF_TYPE_IBSS || type == IEEE80211_IF_TYPE_STA))
@@ -397,14 +354,13 @@ static void rt61pci_config_type(struct r
 	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_MULTICAST, 0);
 	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_BORADCAST, 0);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 
 	/*
 	 * Enable synchronisation.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR9, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR9, &reg);
 	if (is_interface_present(&rt2x00dev->interface)) {
-		rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, 100 * 16);
 		rt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 1);
 		rt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 1);
 	}
@@ -418,28 +374,11 @@ static void rt61pci_config_type(struct r
 		 !is_interface_present(&rt2x00dev->interface))
 		rt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, 0);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, reg);
-
-	/*
-	 * Change flags of enabled interfaces.
-	 */
-	if (type != IEEE80211_IF_TYPE_MNTR) {
-		if (is_interface_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	} else {
-		if (is_monitor_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-	}
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR9, reg);
 }
 
 static void rt61pci_config_channel(struct rt2x00_dev *rt2x00dev,
-	int value, int channel, int freq, int txpower)
+	const int value, const int channel, const int txpower)
 {
 	u8 reg = 0;
 	u32 rf1 = 0;
@@ -447,17 +386,6 @@ static void rt61pci_config_channel(struc
 	u32 rf3 = 0;
 	u32 rf4 = 0;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (channel == rt2x00dev->rx_status.channel)
-		return;
-
-	if (txpower == 0xff)
-		txpower = rt2x00dev->tx_power;
-	else
-		txpower = TXPOWER_TO_DEV(txpower);
-
 	if (!test_bit(CONFIG_RF_SEQUENCE, &rt2x00dev->flags) || channel <= 14)
 		rf1 = 0x00002ccc;
 	else if (channel == 36 ||
@@ -627,251 +555,227 @@ static void rt61pci_config_channel(struc
 	/*
 	 * Set TXpower.
 	 */
-	rt2x00_set_field32(&rf3, RF3_TXPOWER, txpower);
-
-	INFO(rt2x00dev, "Switching channel. "
-		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x, RF4: 0x%08x.\n",
-		rf1, rf2, rf3, rf4);
+	rt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));
 
 	/*
 	 * Set Frequency offset.
 	 */
 	rt2x00_set_field32(&rf4, RF4_FREQ_OFFSET, rt2x00dev->freq_offset);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
+	rt61pci_rf_write(rt2x00dev, rf1);
+	rt61pci_rf_write(rt2x00dev, rf2);
+	rt61pci_rf_write(rt2x00dev, rf3 & ~0x00000004);
+	rt61pci_rf_write(rt2x00dev, rf4);
 
 	udelay(200);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 | 0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
+	rt61pci_rf_write(rt2x00dev, rf1);
+	rt61pci_rf_write(rt2x00dev, rf2);
+	rt61pci_rf_write(rt2x00dev, rf3 | 0x00000004);
+	rt61pci_rf_write(rt2x00dev, rf4);
 
 	udelay(200);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
+	rt61pci_rf_write(rt2x00dev, rf1);
+	rt61pci_rf_write(rt2x00dev, rf2);
+	rt61pci_rf_write(rt2x00dev, rf3 & ~0x00000004);
+	rt61pci_rf_write(rt2x00dev, rf4);
 
-	rt2x00_bbp_read(rt2x00dev, 3, &reg);
+	rt61pci_bbp_read(rt2x00dev, 3, &reg);
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2527))
 		reg &= ~0x01;
 	else
 		reg |= 0x01;
-	rt2x00_bbp_write(rt2x00dev, 3, reg);
+	rt61pci_bbp_write(rt2x00dev, 3, reg);
 
 	msleep(1);
 
 	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.freq = freq;
-	rt2x00dev->rx_status.channel = channel;
-
-	/*
 	 * Update rf fields
 	 */
 	rt2x00dev->rf1 = rf1;
 	rt2x00dev->rf2 = rf2;
 	rt2x00dev->rf3 = rf3;
 	rt2x00dev->rf4 = rf4;
-
 	rt2x00dev->tx_power = txpower;
 }
 
-static void rt61pci_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
+static void rt61pci_config_txpower(struct rt2x00_dev *rt2x00dev,
+	const int txpower)
 {
-	txpower = TXPOWER_TO_DEV(txpower);
+	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER,
+		TXPOWER_TO_DEV(txpower));
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (txpower == rt2x00dev->tx_power)
-		return;
-
-	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER, txpower);
-
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf4);
 
 	udelay(200);
 
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 | 0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf3 | 0x00000004);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf4);
 
 	udelay(200);
 
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
-
-	rt2x00dev->tx_power = txpower;
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
+	rt61pci_rf_write(rt2x00dev, rt2x00dev->rf4);
 }
 
 static void rt61pci_config_antenna(struct rt2x00_dev *rt2x00dev,
-	int antenna_tx, int antenna_rx)
+	const int antenna_tx, const int antenna_rx)
 {
 	u32 reg;
-	u8 reg_r3;
-	u8 reg_r4;
-	u8 reg_r77;
-	u8 frame_type;
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.antenna == antenna_rx)
-		return;
+	u8 r3;
+	u8 r4;
+	u8 r77;
 
-	rt2x00_register_read(rt2x00dev, PHY_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, PHY_CSR0, &reg);
 
 	if (rt2x00dev->curr_hwmode == HWMODE_A) {
 		if (test_bit(CONFIG_EXTERNAL_LNA_A, &rt2x00dev->flags)) {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x38);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x78);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x48);
-			rt2x00_bbp_write(rt2x00dev, 75, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 86, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 88, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 17, 0x38);
+			rt61pci_bbp_write(rt2x00dev, 96, 0x78);
+			rt61pci_bbp_write(rt2x00dev, 104, 0x48);
+			rt61pci_bbp_write(rt2x00dev, 75, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 86, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 88, 0x80);
 		} else {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x28);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x58);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x38);
-			rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 17, 0x28);
+			rt61pci_bbp_write(rt2x00dev, 96, 0x58);
+			rt61pci_bbp_write(rt2x00dev, 104, 0x38);
+			rt61pci_bbp_write(rt2x00dev, 75, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 86, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 88, 0xfe);
 		}
-		rt2x00_bbp_write(rt2x00dev, 35, 0x60);
-		rt2x00_bbp_write(rt2x00dev, 97, 0x58);
-		rt2x00_bbp_write(rt2x00dev, 98, 0x58);
+		rt61pci_bbp_write(rt2x00dev, 35, 0x60);
+		rt61pci_bbp_write(rt2x00dev, 97, 0x58);
+		rt61pci_bbp_write(rt2x00dev, 98, 0x58);
 
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG, 0);
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A, 1);
 	} else {
 		if (test_bit(CONFIG_EXTERNAL_LNA_BG, &rt2x00dev->flags)) {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x30);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x68);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x3c);
-			rt2x00_bbp_write(rt2x00dev, 75, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 86, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 88, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 17, 0x30);
+			rt61pci_bbp_write(rt2x00dev, 96, 0x68);
+			rt61pci_bbp_write(rt2x00dev, 104, 0x3c);
+			rt61pci_bbp_write(rt2x00dev, 75, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 86, 0x80);
+			rt61pci_bbp_write(rt2x00dev, 88, 0x80);
 		} else {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x20);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x48);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x2c);
-			rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 17, 0x20);
+			rt61pci_bbp_write(rt2x00dev, 96, 0x48);
+			rt61pci_bbp_write(rt2x00dev, 104, 0x2c);
+			rt61pci_bbp_write(rt2x00dev, 75, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 86, 0xfe);
+			rt61pci_bbp_write(rt2x00dev, 88, 0xfe);
 		}
-		rt2x00_bbp_write(rt2x00dev, 35, 0x50);
-		rt2x00_bbp_write(rt2x00dev, 97, 0x48);
-		rt2x00_bbp_write(rt2x00dev, 98, 0x48);
+		rt61pci_bbp_write(rt2x00dev, 35, 0x50);
+		rt61pci_bbp_write(rt2x00dev, 97, 0x48);
+		rt61pci_bbp_write(rt2x00dev, 98, 0x48);
 
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG, 1);
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A, 0);
 	}
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR0, reg);
 
-	rt2x00_bbp_read(rt2x00dev, 3, &reg_r3);
-	rt2x00_bbp_read(rt2x00dev, 4, &reg_r4);
-	rt2x00_bbp_read(rt2x00dev, 77, &reg_r77);
+	rt61pci_bbp_read(rt2x00dev, 3, &r3);
+	rt61pci_bbp_read(rt2x00dev, 4, &r4);
+	rt61pci_bbp_read(rt2x00dev, 77, &r77);
 
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2527))
-		reg_r3 &= ~0x01;
-	reg_r4 &= ~0x23;
-	frame_type = ~(test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags) << 5);
+		rt2x00_set_field8(&r3, BBP_R3_SMART_MODE, 0);
 
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF5325)) {
-		if (antenna_rx == 0) {		/* Diversity. */
-			reg_r4 |= 0x02;
+		if (antenna_rx == ANTENNA_DIVERSITY) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);
 			if (rt2x00dev->curr_hwmode != HWMODE_A)
-				reg_r4 |= 0x20;
-		} else if (antenna_rx == 1) {	/* RX: Antenna A */
-			reg_r4 |= 0x01;
+				rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+		} else if (antenna_rx == ANTENNA_A) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
 			if (rt2x00dev->curr_hwmode == HWMODE_A)
-				reg_r77 &= ~0x03;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
 			else
-				reg_r77 |= 0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
-		} else if (antenna_rx == 2) {	/* RX: Antenna B */
-			reg_r4 |= 0x01;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
+			rt61pci_bbp_write(rt2x00dev, 77, r77);
+		} else if (antenna_rx == ANTENNA_B) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
 			if (rt2x00dev->curr_hwmode == HWMODE_A)
-				reg_r77 |= 0x03;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
 			else
-				reg_r77 &= ~0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
+			rt61pci_bbp_write(rt2x00dev, 77, r77);
 		}
 	} else if (rt2x00_rf(&rt2x00dev->chip, RF2527) ||
 		   (rt2x00_rf(&rt2x00dev->chip, RF2529) &&
 		    test_bit(CONFIG_DOUBLE_ANTENNA, &rt2x00dev->flags))) {
-		if (antenna_rx == 0) {		/* Diversity. */
-			reg_r4 |= 0x22;
-			reg_r4 &= frame_type;
-		} else if (antenna_rx == 1) {	/* RX: Antenna A */
-			reg_r4 |= 0x21;
-			reg_r4 &= frame_type;
-			reg_r77 |= 0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
-		} else if (antenna_rx == 2) {	/* RX: Antenna B */
-			reg_r4 |= 0x21;
-			reg_r4 &= frame_type;
-			reg_r77 &= ~0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
+		if (antenna_rx == ANTENNA_DIVERSITY) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+		} else if (antenna_rx == ANTENNA_A) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+			rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
+			rt61pci_bbp_write(rt2x00dev, 77, r77);
+		} else if (antenna_rx == ANTENNA_B) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+			rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
+			rt61pci_bbp_write(rt2x00dev, 77, r77);
 		}
 	}
 
 	/*
-	 * TODO: RF2529 with another antenna value than 2 are ignored.
+	 * TODO: RF2529 with another antenna value then 2 are ignored.
 	 * The legacy driver is unclear whether in those cases there is
 	 * a possibility to switch antenna.
 	 */
 
-	rt2x00_bbp_write(rt2x00dev, 3, reg_r3);
-	rt2x00_bbp_write(rt2x00dev, 4, reg_r4);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.antenna = antenna_rx;
+	rt61pci_bbp_write(rt2x00dev, 3, r3);
+	rt61pci_bbp_write(rt2x00dev, 4, r4);
 }
 
 static void rt61pci_config_duration(struct rt2x00_dev *rt2x00dev,
-	int short_slot_time)
+	const int short_slot_time, const int beacon_int)
 {
 	u32 reg;
 
-	short_slot_time = short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME;
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR9, &reg);
+	rt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME,
+		short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR9, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR9, &reg);
-	rt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME, short_slot_time);
-	rt2x00_register_write(rt2x00dev, MAC_CSR9, reg);
-
-	rt2x00_register_read(rt2x00dev, MAC_CSR8, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR8, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR8_SIFS, SIFS);
 	rt2x00_set_field32(&reg, MAC_CSR8_SIFS_AFTER_RX_OFDM, 3);
 	rt2x00_set_field32(&reg, MAC_CSR8_EIFS, EIFS);
-	rt2x00_register_write(rt2x00dev, MAC_CSR8, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR8, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR0_TSF_OFFSET, IEEE80211_HEADER);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_ENABLE, 1);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR4, reg);
+
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR9, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, beacon_int * 16);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR9, reg);
 }
 
 static void rt61pci_config_rate(struct rt2x00_dev *rt2x00dev, const int rate)
@@ -891,21 +795,21 @@ static void rt61pci_config_rate(struct r
 	 */
 	reg = DEVICE_GET_RATE_FIELD(rate, RATEMASK) & DEV_BASIC_RATE;
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR5, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR5, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	value = ((conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME) ?
 		 SHORT_DIFS :  DIFS) +
 		PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXRX_CSR0_RX_ACK_TIMEOUT, value);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	if (preamble == SHORT_PREAMBLE)
 		rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE, 1);
 	else
 		rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE, 0);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR4, reg);
 }
 
 static void rt61pci_config_phymode(struct rt2x00_dev *rt2x00dev,
@@ -914,12 +818,6 @@ static void rt61pci_config_phymode(struc
 	struct ieee80211_hw_mode *mode;
 	struct ieee80211_rate *rate;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.phymode == phymode)
-		return;
-
 	if (phymode == MODE_IEEE80211A)
 		rt2x00dev->curr_hwmode = HWMODE_A;
 	else if (phymode == MODE_IEEE80211B)
@@ -931,11 +829,6 @@ static void rt61pci_config_phymode(struc
 	rate = &mode->rates[mode->num_rates - 1];
 
 	rt61pci_config_rate(rt2x00dev, rate->val2);
-
-	/*
-	 * Update physical mode for rx ring.
-	 */
-	rt2x00dev->rx_status.phymode = phymode;
 }
 
 static void rt61pci_config_mac_addr(struct rt2x00_dev *rt2x00dev, u8 *addr)
@@ -951,7 +844,7 @@ static void rt61pci_config_mac_addr(stru
 	 * The MAC address is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
+	rt2x00pci_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
 }
 
 /*
@@ -964,10 +857,10 @@ static void rt61pci_enable_led(struct rt
 	u8 arg0;
 	u8 arg1;
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR14, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR14, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR14_ON_PERIOD, 70);
 	rt2x00_set_field32(&reg, MAC_CSR14_OFF_PERIOD, 30);
-	rt2x00_register_write(rt2x00dev, MAC_CSR14, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR14, reg);
 
 	led_reg = rt2x00dev->led_reg;
 	rt2x00_set_field16(&led_reg, MCU_LEDCS_RADIO_STATUS, 1);
@@ -979,7 +872,7 @@ static void rt61pci_enable_led(struct rt
 	arg0 = led_reg & 0xff;
 	arg1 = (led_reg >> 8) & 0xff;
 
-	rt2x00_mcu_request(rt2x00dev, MCU_LED, 0xff, arg0, arg1);
+	rt61pci_mcu_request(rt2x00dev, MCU_LED, 0xff, arg0, arg1);
 }
 
 static void rt61pci_disable_led(struct rt2x00_dev *rt2x00dev)
@@ -996,16 +889,22 @@ static void rt61pci_disable_led(struct r
 	arg0 = led_reg & 0xff;
 	arg1 = (led_reg >> 8) & 0xff;
 
-	rt2x00_mcu_request(rt2x00dev, MCU_LED, 0xff, arg0, arg1);
+	rt61pci_mcu_request(rt2x00dev, MCU_LED, 0xff, arg0, arg1);
 }
 
-static void rt61pci_activity_led(struct rt2x00_dev *rt2x00dev, char rssi)
+static void rt61pci_activity_led(struct rt2x00_dev *rt2x00dev, int rssi)
 {
 	u8 led;
 
 	if (rt2x00dev->led_mode != LED_MODE_SIGNAL_STRENGTH)
 		return;
 
+	/*
+	 * Led handling requires a positive value for the rssi,
+	 * to do that correctly we need to add the correction.
+	 */
+	rssi += rt2x00dev->rssi_offset;
+
 	if (rssi <= 30)
 		led = 0;
 	else if (rssi <= 39)
@@ -1019,14 +918,15 @@ static void rt61pci_activity_led(struct 
 	else
 		led = 5;
 
-	rt2x00_mcu_request(rt2x00dev, MCU_LED_STRENGTH, 0xff, led, 0);
+	rt61pci_mcu_request(rt2x00dev, MCU_LED_STRENGTH, 0xff, led, 0);
 }
 
 /*
  * Link tuning
  */
-static void rt61pci_link_tuner(struct rt2x00_dev *rt2x00dev, int rssi)
+static void rt61pci_link_tuner(struct rt2x00_dev *rt2x00dev)
 {
+	int rssi = rt2x00_get_link_rssi(&rt2x00dev->link);
 	u32 reg;
 	u8 r17;
 	u8 up_bound;
@@ -1037,7 +937,7 @@ static void rt61pci_link_tuner(struct rt
 	 */
 	rt61pci_activity_led(rt2x00dev, rssi);
 
-	rt2x00_bbp_read(rt2x00dev, 17, &r17);
+	rt61pci_bbp_read(rt2x00dev, 17, &r17);
 
 	/*
 	 * Determine r17 bounds.
@@ -1063,7 +963,7 @@ static void rt61pci_link_tuner(struct rt
 	 */
 	if (rssi >= -35) {
 		if (r17 != 0x60)
-			rt2x00_bbp_write(rt2x00dev, 17, 0x60);
+			rt61pci_bbp_write(rt2x00dev, 17, 0x60);
 		return;
 	}
 
@@ -1072,7 +972,7 @@ static void rt61pci_link_tuner(struct rt
 	 */
 	if (rssi >= -58) {
 		if (r17 != up_bound)
-			rt2x00_bbp_write(rt2x00dev, 17, up_bound);
+			rt61pci_bbp_write(rt2x00dev, 17, up_bound);
 		return;
 	}
 
@@ -1082,7 +982,7 @@ static void rt61pci_link_tuner(struct rt
 	if (rssi >= -66) {
 		low_bound += 0x10;
 		if (r17 != low_bound)
-			rt2x00_bbp_write(rt2x00dev, 17, low_bound);
+			rt61pci_bbp_write(rt2x00dev, 17, low_bound);
 		return;
 	}
 
@@ -1092,7 +992,7 @@ static void rt61pci_link_tuner(struct rt
 	if (rssi >= -74) {
 		low_bound += 0x08;
 		if (r17 != low_bound)
-			rt2x00_bbp_write(rt2x00dev, 17, low_bound);
+			rt61pci_bbp_write(rt2x00dev, 17, low_bound);
 		return;
 	}
 
@@ -1105,7 +1005,7 @@ static void rt61pci_link_tuner(struct rt
 		up_bound = low_bound;
 
 	if (r17 > up_bound) {
-		rt2x00_bbp_write(rt2x00dev, 17, up_bound);
+		rt61pci_bbp_write(rt2x00dev, 17, up_bound);
 		return;
 	}
 
@@ -1113,18 +1013,20 @@ static void rt61pci_link_tuner(struct rt
 	 * r17 does not yet exceed upper limit, continue and base
 	 * the r17 tuning on the false CCA count.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, STA_CSR1, &reg);
 	rt2x00dev->link.false_cca =
 		rt2x00_get_field32(reg, STA_CSR1_FALSE_CCA_ERROR);
 
 	if (rt2x00dev->link.false_cca > 512 && r17 < up_bound) {
 		if (++r17 > up_bound)
 			r17 = up_bound;
-		rt2x00_bbp_write(rt2x00dev, 17, r17);
+		rt61pci_bbp_write(rt2x00dev, 17, r17);
+		rt2x00dev->rx_status.noise = r17;
 	} else if (rt2x00dev->link.false_cca < 100 && r17 > low_bound) {
 		if (--r17 < low_bound)
 			r17 = low_bound;
-		rt2x00_bbp_write(rt2x00dev, 17, r17);
+		rt61pci_bbp_write(rt2x00dev, 17, r17);
+		rt2x00dev->rx_status.noise = r17;
 	}
 }
 
@@ -1166,7 +1068,7 @@ static int rt61pci_load_firmware(struct 
 	 * Wait for stable hardware.
 	 */
 	for (i = 0; i < 100; i++) {
-		rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
+		rt2x00pci_register_read(rt2x00dev, MAC_CSR0, &reg);
 		if (reg)
 			break;
 		msleep(1);
@@ -1182,10 +1084,10 @@ static int rt61pci_load_firmware(struct 
 	 */
 	reg = 0;
 	rt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);
-	rt2x00_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
-	rt2x00_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);
-	rt2x00_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
-	rt2x00_register_write(rt2x00dev, HOST_CMD_CSR, 0);
+	rt2x00pci_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);
+	rt2x00pci_register_write(rt2x00dev, H2M_MAILBOX_CSR, 0);
+	rt2x00pci_register_write(rt2x00dev, HOST_CMD_CSR, 0);
 
 	/*
 	 * Write firmware to device.
@@ -1193,19 +1095,19 @@ static int rt61pci_load_firmware(struct 
 	reg = 0;
 	rt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 1);
 	rt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 1);
-	rt2x00_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
 
-	rt2x00_register_multiwrite(
+	rt2x00pci_register_multiwrite(
 		rt2x00dev, FIRMWARE_IMAGE_BASE, data, len);
 
 	rt2x00_set_field32(&reg, MCU_CNTL_CSR_SELECT_BANK, 0);
-	rt2x00_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
 
 	rt2x00_set_field32(&reg, MCU_CNTL_CSR_RESET, 0);
-	rt2x00_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, MCU_CNTL_CSR, reg);
 
 	for (i = 0; i < 100; i++) {
-		rt2x00_register_read(rt2x00dev, MCU_CNTL_CSR, &reg);
+		rt2x00pci_register_read(rt2x00dev, MCU_CNTL_CSR, &reg);
 		if (rt2x00_get_field32(reg, MCU_CNTL_CSR_READY))
 			break;
 		msleep(1);
@@ -1222,38 +1124,35 @@ static int rt61pci_load_firmware(struct 
 	reg = 0;
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
 	return 0;
 }
 
-static void rt61pci_init_rxring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+static void rt61pci_init_rxring(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
 	struct data_desc *rxd;
 	unsigned int i;
 	u32 word;
 
-	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
-
-	ring->type = ring_type;
+	memset(rt2x00dev->rx->data_addr, 0x00,
+		rt2x00_get_ring_size(rt2x00dev->rx));
 
-	for (i = 0; i < ring->stats.limit; i++) {
-		rxd = ring->entry[i].priv;
+	for (i = 0; i < rt2x00dev->rx->stats.limit; i++) {
+		rxd = rt2x00dev->rx->entry[i].priv;
 
 		rt2x00_desc_read(rxd, 5, &word);
 		rt2x00_set_field32(&word, RXD_W5_BUFFER_PHYSICAL_ADDRESS,
-			ring->entry[i].data_dma);
+			rt2x00dev->rx->entry[i].data_dma);
 		rt2x00_desc_write(rxd, 5, word);
 
 		rt2x00_desc_read(rxd, 0, &word);
@@ -1261,21 +1160,19 @@ static void rt61pci_init_rxring(struct r
 		rt2x00_desc_write(rxd, 0, word);
 	}
 
-	rt2x00_ring_index_clear(ring);
+	rt2x00_ring_index_clear(rt2x00dev->rx);
 }
 
 static void rt61pci_init_txring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
+	const int queue)
 {
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
+	struct data_ring *ring = rt2x00_get_ring(rt2x00dev, queue);
 	struct data_desc *txd;
 	unsigned int i;
 	u32 word;
 
 	memset(ring->data_addr, 0x00, rt2x00_get_ring_size(ring));
 
-	ring->type = ring_type;
-
 	for (i = 0; i < ring->stats.limit; i++) {
 		txd = ring->entry[i].priv;
 
@@ -1284,7 +1181,7 @@ static void rt61pci_init_txring(struct r
 		rt2x00_desc_write(txd, 1, word);
 
 		rt2x00_desc_read(txd, 5, &word);
-		rt2x00_set_field32(&word, TXD_W5_PID_TYPE, ring_type);
+		rt2x00_set_field32(&word, TXD_W5_PID_TYPE, queue);
 		rt2x00_set_field32(&word, TXD_W5_PID_SUBTYPE, i);
 		rt2x00_desc_write(txd, 5, word);
 
@@ -1309,76 +1206,76 @@ static int rt61pci_init_rings(struct rt2
 	/*
 	 * Initialize rings.
 	 */
-	rt61pci_init_rxring(rt2x00dev, RING_RX);
-	rt61pci_init_txring(rt2x00dev, RING_AC_VO);
-	rt61pci_init_txring(rt2x00dev, RING_AC_VI);
-	rt61pci_init_txring(rt2x00dev, RING_AC_BE);
-	rt61pci_init_txring(rt2x00dev, RING_AC_BK);
-	rt61pci_init_txring(rt2x00dev, RING_PRIO);
-	rt61pci_init_txring(rt2x00dev, RING_BEACON);
+	rt61pci_init_rxring(rt2x00dev);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA0);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA1);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA2);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA3);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_DATA4);
+	rt61pci_init_txring(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * Initialize registers.
 	 */
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TX_RING_CSR0, &reg);
 	rt2x00_set_field32(&reg, TX_RING_CSR0_AC0_RING_SIZE,
-		rt2x00dev->ring[RING_AC_VO].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].stats.limit);
 	rt2x00_set_field32(&reg, TX_RING_CSR0_AC1_RING_SIZE,
-		rt2x00dev->ring[RING_AC_VI].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].stats.limit);
 	rt2x00_set_field32(&reg, TX_RING_CSR0_AC2_RING_SIZE,
-		rt2x00dev->ring[RING_AC_BE].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA2].stats.limit);
 	rt2x00_set_field32(&reg, TX_RING_CSR0_AC3_RING_SIZE,
-		rt2x00dev->ring[RING_AC_BK].stats.limit);
-	rt2x00_register_write(rt2x00dev, TX_RING_CSR0, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA3].stats.limit);
+	rt2x00pci_register_write(rt2x00dev, TX_RING_CSR0, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, TX_RING_CSR1, &reg);
 	rt2x00_set_field32(&reg, TX_RING_CSR1_MGMT_RING_SIZE,
-		rt2x00dev->ring[RING_PRIO].stats.limit);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA4].stats.limit);
 	rt2x00_set_field32(&reg, TX_RING_CSR1_TXD_SIZE,
-		rt2x00dev->ring[RING_AC_VO].desc_size / 4);
-	rt2x00_register_write(rt2x00dev, TX_RING_CSR1, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].desc_size / 4);
+	rt2x00pci_register_write(rt2x00dev, TX_RING_CSR1, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, AC0_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, AC0_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_AC_VO].data_dma);
-	rt2x00_register_write(rt2x00dev, AC0_BASE_CSR, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA0].data_dma);
+	rt2x00pci_register_write(rt2x00dev, AC0_BASE_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, AC1_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, AC1_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_AC_VI].data_dma);
-	rt2x00_register_write(rt2x00dev, AC1_BASE_CSR, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA1].data_dma);
+	rt2x00pci_register_write(rt2x00dev, AC1_BASE_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, AC2_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, AC2_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_AC_BE].data_dma);
-	rt2x00_register_write(rt2x00dev, AC2_BASE_CSR, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA2].data_dma);
+	rt2x00pci_register_write(rt2x00dev, AC2_BASE_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, AC3_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, AC3_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_AC_BK].data_dma);
-	rt2x00_register_write(rt2x00dev, AC3_BASE_CSR, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA3].data_dma);
+	rt2x00pci_register_write(rt2x00dev, AC3_BASE_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, MGMT_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, MGMT_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_PRIO].data_dma);
-	rt2x00_register_write(rt2x00dev, MGMT_BASE_CSR, reg);
+		rt2x00dev->tx[IEEE80211_TX_QUEUE_DATA4].data_dma);
+	rt2x00pci_register_write(rt2x00dev, MGMT_BASE_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RX_RING_CSR, &reg);
 	rt2x00_set_field32(&reg, RX_RING_CSR_RING_SIZE,
-		rt2x00dev->ring[RING_RX].stats.limit);
+		rt2x00dev->rx->stats.limit);
 	rt2x00_set_field32(&reg, RX_RING_CSR_RXD_SIZE,
-		rt2x00dev->ring[RING_RX].desc_size / 4);
+		rt2x00dev->rx->desc_size / 4);
 	rt2x00_set_field32(&reg, RX_RING_CSR_RXD_WRITEBACK_SIZE, 4);
-	rt2x00_register_write(rt2x00dev, RX_RING_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, RX_RING_CSR, reg);
 
-	reg = 0;
+	rt2x00pci_register_read(rt2x00dev, RX_BASE_CSR, &reg);
 	rt2x00_set_field32(&reg, RX_BASE_CSR_RING_REGISTER,
-		rt2x00dev->ring[RING_RX].data_dma);
-	rt2x00_register_write(rt2x00dev, RX_BASE_CSR, reg);
+		rt2x00dev->rx->data_dma);
+	rt2x00pci_register_write(rt2x00dev, RX_BASE_CSR, reg);
 
-	rt2x00_register_write(rt2x00dev, TX_DMA_DST_CSR, 0x000000aa);
-	rt2x00_register_write(rt2x00dev, LOAD_TX_RING_CSR, 0x0000001f);
-	rt2x00_register_write(rt2x00dev, RX_CNTL_CSR, 0x00000002);
+	rt2x00pci_register_write(rt2x00dev, TX_DMA_DST_CSR, 0x000000aa);
+	rt2x00pci_register_write(rt2x00dev, LOAD_TX_RING_CSR, 0x0000001f);
+	rt2x00pci_register_write(rt2x00dev, RX_CNTL_CSR, 0x00000002);
 
 	return 0;
 }
@@ -1390,64 +1287,65 @@ static int rt61pci_init_registers(struct
 	if (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))
 		return -EBUSY;
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR10, 0x00000718);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR10, 0x00000718);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, 0x025eb032);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_ACK_CTS, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_TX_WITHOUT_WAITING, 0);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR1, 0x9eb39eb3);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, 0x8a8b8c8d);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR3, 0x00858687);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR1, 0x9eb39eb3);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR2, 0x8a8b8c8d);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR3, 0x00858687);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR7, 0x2e31353b);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR8, 0x2a2a2a2c);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR7, 0x2e31353b);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR8, 0x2a2a2a2c);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR13, 0x0000e000);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR13, 0x0000e000);
 
-	rt2x00_register_write(rt2x00dev, SEC_CSR0, 0x00000000);
-	rt2x00_register_write(rt2x00dev, SEC_CSR1, 0x00000000);
-	rt2x00_register_write(rt2x00dev, SEC_CSR5, 0x00000000);
+	rt2x00pci_register_write(rt2x00dev, SEC_CSR0, 0x00000000);
+	rt2x00pci_register_write(rt2x00dev, SEC_CSR1, 0x00000000);
+	rt2x00pci_register_write(rt2x00dev, SEC_CSR5, 0x00000000);
 
-	rt2x00_register_read(rt2x00dev, AC_TXOP_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, AC_TXOP_CSR0, &reg);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR0_AC0_TX_OP, 0);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR0_AC1_TX_OP, 0);
-	rt2x00_register_write(rt2x00dev, AC_TXOP_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, AC_TXOP_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, AC_TXOP_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, AC_TXOP_CSR1, &reg);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR1_AC2_TX_OP, 192);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR1_AC3_TX_OP, 48);
-	rt2x00_register_write(rt2x00dev, AC_TXOP_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, AC_TXOP_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR9, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR9, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR9_CW_SELECT, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR9, reg);
-
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
-	rt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR9, reg);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR1, 0x000023b0);
-	rt2x00_register_write(rt2x00dev, PHY_CSR5, 0x060a100c);
-	rt2x00_register_write(rt2x00dev, PHY_CSR6, 0x00080606);
-	rt2x00_register_write(rt2x00dev, PHY_CSR7, 0x00000a08);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR1, 0x000023b0);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR5, 0x060a100c);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR6, 0x00080606);
+	rt2x00pci_register_write(rt2x00dev, PHY_CSR7, 0x00000a08);
 
-	rt2x00_register_write(rt2x00dev, PCI_CFG_CSR, 0x28ca4404);
+	rt2x00pci_register_write(rt2x00dev, PCI_CFG_CSR, 0x28ca4404);
 
-	rt2x00_register_write(rt2x00dev, TEST_MODE_CSR, 0x00000200);
+	rt2x00pci_register_write(rt2x00dev, TEST_MODE_CSR, 0x00000200);
 
-	rt2x00_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);
+	rt2x00pci_register_write(rt2x00dev, M2H_CMD_DONE_CSR, 0xffffffff);
 
 	/*
 	 * We must clear the error counters.
 	 * These registers are cleared on read,
 	 * so we may pass a useless variable to store the value.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR0, &reg);
-	rt2x00_register_read(rt2x00dev, STA_CSR1, &reg);
-	rt2x00_register_read(rt2x00dev, STA_CSR2, &reg);
+	rt2x00pci_register_read(rt2x00dev, STA_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, STA_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, STA_CSR2, &reg);
 
 	/*
 	 * Reset MAC and BBP registers.
@@ -1455,16 +1353,16 @@ static int rt61pci_init_registers(struct
 	reg = 0;
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR1, reg);
 
 	return 0;
 }
@@ -1477,7 +1375,7 @@ static int rt61pci_init_bbp(struct rt2x0
 	u8 value;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_bbp_read(rt2x00dev, 0, &value);
+		rt61pci_bbp_read(rt2x00dev, 0, &value);
 		if ((value != 0xff) && (value != 0x00))
 			goto continue_csr_init;
 		NOTICE(rt2x00dev, "Waiting for BBP register.\n");
@@ -1488,31 +1386,31 @@ static int rt61pci_init_bbp(struct rt2x0
 	return -EACCES;
 
 continue_csr_init:
-	rt2x00_bbp_write(rt2x00dev, 3, 0x00);
-	rt2x00_bbp_write(rt2x00dev, 15, 0x30);
-	rt2x00_bbp_write(rt2x00dev, 17, 0x20);
-	rt2x00_bbp_write(rt2x00dev, 21, 0xc8);
-	rt2x00_bbp_write(rt2x00dev, 22, 0x38);
-	rt2x00_bbp_write(rt2x00dev, 23, 0x06);
-	rt2x00_bbp_write(rt2x00dev, 24, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 25, 0x0a);
-	rt2x00_bbp_write(rt2x00dev, 26, 0x0d);
-	rt2x00_bbp_write(rt2x00dev, 34, 0x12);
-	rt2x00_bbp_write(rt2x00dev, 37, 0x07);
-	rt2x00_bbp_write(rt2x00dev, 39, 0xf8);
-	rt2x00_bbp_write(rt2x00dev, 41, 0x60);
-	rt2x00_bbp_write(rt2x00dev, 53, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 54, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 60, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 61, 0x04);
-	rt2x00_bbp_write(rt2x00dev, 62, 0x04);
-	rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 90, 0x0f);
-	rt2x00_bbp_write(rt2x00dev, 99, 0x00);
-	rt2x00_bbp_write(rt2x00dev, 102, 0x16);
-	rt2x00_bbp_write(rt2x00dev, 107, 0x04);
+	rt61pci_bbp_write(rt2x00dev, 3, 0x00);
+	rt61pci_bbp_write(rt2x00dev, 15, 0x30);
+	rt61pci_bbp_write(rt2x00dev, 17, 0x20);
+	rt61pci_bbp_write(rt2x00dev, 21, 0xc8);
+	rt61pci_bbp_write(rt2x00dev, 22, 0x38);
+	rt61pci_bbp_write(rt2x00dev, 23, 0x06);
+	rt61pci_bbp_write(rt2x00dev, 24, 0xfe);
+	rt61pci_bbp_write(rt2x00dev, 25, 0x0a);
+	rt61pci_bbp_write(rt2x00dev, 26, 0x0d);
+	rt61pci_bbp_write(rt2x00dev, 34, 0x12);
+	rt61pci_bbp_write(rt2x00dev, 37, 0x07);
+	rt61pci_bbp_write(rt2x00dev, 39, 0xf8);
+	rt61pci_bbp_write(rt2x00dev, 41, 0x60);
+	rt61pci_bbp_write(rt2x00dev, 53, 0x10);
+	rt61pci_bbp_write(rt2x00dev, 54, 0x18);
+	rt61pci_bbp_write(rt2x00dev, 60, 0x10);
+	rt61pci_bbp_write(rt2x00dev, 61, 0x04);
+	rt61pci_bbp_write(rt2x00dev, 62, 0x04);
+	rt61pci_bbp_write(rt2x00dev, 75, 0xfe);
+	rt61pci_bbp_write(rt2x00dev, 86, 0xfe);
+	rt61pci_bbp_write(rt2x00dev, 88, 0xfe);
+	rt61pci_bbp_write(rt2x00dev, 90, 0x0f);
+	rt61pci_bbp_write(rt2x00dev, 99, 0x00);
+	rt61pci_bbp_write(rt2x00dev, 102, 0x16);
+	rt61pci_bbp_write(rt2x00dev, 107, 0x04);
 
 	DEBUG(rt2x00dev, "Start initialization from EEPROM...\n");
 	for (i = 0; i < EEPROM_BBP_SIZE; i++) {
@@ -1523,7 +1421,7 @@ continue_csr_init:
 			value = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);
 			DEBUG(rt2x00dev, "BBP: 0x%02x, value: 0x%02x.\n",
 				reg_id, value);
-			rt2x00_bbp_write(rt2x00dev, reg_id, value);
+			rt61pci_bbp_write(rt2x00dev, reg_id, value);
 		}
 	}
 	DEBUG(rt2x00dev, "...End initialization from EEPROM.\n");
@@ -1539,17 +1437,55 @@ static void rt61pci_toggle_rx(struct rt2
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX,
 		state == STATE_RADIO_RX_OFF);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR0, reg);
 }
 
-static int rt61pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+static void rt61pci_toggle_irq(struct rt2x00_dev *rt2x00dev, int enabled)
 {
 	u32 reg;
 
 	/*
+	 * When interrupts are being enabled, the interrupt registers
+	 * should clear the register to assure a clean state.
+	 */
+	if (enabled) {
+		rt2x00pci_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
+		rt2x00pci_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
+
+		rt2x00pci_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg);
+		rt2x00pci_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);
+	}
+
+	/*
+	 * Only toggle the interrupts bits we are going to use.
+	 * Non-checked interrupt bits are disabled by default.
+	 */
+	rt2x00pci_register_read(rt2x00dev, INT_MASK_CSR, &reg);
+	rt2x00_set_field32(&reg, INT_MASK_CSR_TXDONE, !enabled);
+	rt2x00_set_field32(&reg, INT_MASK_CSR_RXDONE, !enabled);
+	rt2x00_set_field32(&reg, INT_MASK_CSR_BEACON_DONE, !enabled);
+	rt2x00_set_field32(&reg, INT_MASK_CSR_ENABLE_MITIGATION, !enabled);
+	rt2x00_set_field32(&reg, INT_MASK_CSR_MITIGATION_PERIOD, 0xff);
+	rt2x00pci_register_write(rt2x00dev, INT_MASK_CSR, reg);
+
+	rt2x00pci_register_read(rt2x00dev, MCU_INT_MASK_CSR, &reg);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_0, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_1, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_2, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_3, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_4, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_5, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_6, !enabled);
+	rt2x00_set_field32(&reg, MCU_INT_MASK_CSR_7, !enabled);
+	rt2x00pci_register_write(rt2x00dev, MCU_INT_MASK_CSR, reg);
+}
+
+static int rt61pci_enable_radio(struct rt2x00_dev *rt2x00dev)
+{
+	/*
 	 * Initialize all registers.
 	 */
 	if (rt61pci_init_rings(rt2x00dev) ||
@@ -1560,28 +1496,14 @@ static int rt61pci_enable_radio(struct r
 	}
 
 	/*
-	 * Clear interrupts.
-	 */
-	rt2x00_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
-	rt2x00_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
-
-	rt2x00_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg);
-	rt2x00_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);
-
-	/*
 	 * Enable interrupts.
 	 */
-	reg = 0;
-	rt2x00_set_field32(&reg, INT_MASK_CSR_TX_ABORT_DONE, 1);
-	rt2x00_set_field32(&reg, INT_MASK_CSR_MITIGATION_PERIOD, 0xff);
-	rt2x00_register_write(rt2x00dev, INT_MASK_CSR, reg);
-
-	rt2x00_register_write(rt2x00dev, MCU_INT_MASK_CSR, 0x00000000);
+	rt61pci_toggle_irq(rt2x00dev, 1);
 
 	/*
 	 * Enable RX.
 	 */
-	rt2x00_register_write(rt2x00dev, RX_CNTL_CSR, 0x00000001);
+	rt2x00pci_register_write(rt2x00dev, RX_CNTL_CSR, 0x00000001);
 
 	/*
 	 * Enable LED
@@ -1600,32 +1522,28 @@ static void rt61pci_disable_radio(struct
 	 */
 	rt61pci_disable_led(rt2x00dev);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR10, 0x00001818);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR10, 0x00001818);
 
 	/*
 	 * Disable synchronisation.
 	 */
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, 0);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR9, 0);
 
 	/*
 	 * Cancel RX and TX.
 	 */
-	rt2x00_register_read(rt2x00dev, TX_CNTL_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, TX_CNTL_CSR, &reg);
 	rt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC0, 1);
 	rt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC1, 1);
 	rt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC2, 1);
 	rt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_AC3, 1);
 	rt2x00_set_field32(&reg, TX_CNTL_CSR_ABORT_TX_MGMT, 1);
-	rt2x00_register_write(rt2x00dev, TX_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, TX_CNTL_CSR, reg);
 
 	/*
 	 * Disable interrupts.
 	 */
-	reg = 0xffffffff;
-	rt2x00_set_field32(&reg, INT_MASK_CSR_ENABLE_MITIGATION, 0);
-	rt2x00_register_write(rt2x00dev, INT_MASK_CSR, reg);
-
-	rt2x00_register_write(rt2x00dev, MCU_INT_MASK_CSR, 0xffffffff);
+	rt61pci_toggle_irq(rt2x00dev, 0);
 }
 
 static int rt61pci_set_state(struct rt2x00_dev *rt2x00dev,
@@ -1638,21 +1556,21 @@ static int rt61pci_set_state(struct rt2x
 
 	put_to_sleep = (state != STATE_AWAKE);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR12, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR12, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR12_FORCE_WAKEUP, !put_to_sleep);
 	rt2x00_set_field32(&reg, MAC_CSR12_PUT_TO_SLEEP, put_to_sleep);
-	rt2x00_register_write(rt2x00dev, MAC_CSR12, reg);
+	rt2x00pci_register_write(rt2x00dev, MAC_CSR12, reg);
 
 	if (put_to_sleep) {
-		rt2x00_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000005);
-		rt2x00_register_write(rt2x00dev, IO_CNTL_CSR, 0x0000001c);
-		rt2x00_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000060);
-		rt2x00_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0x00, 0x00);
+		rt2x00pci_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000005);
+		rt2x00pci_register_write(rt2x00dev, IO_CNTL_CSR, 0x0000001c);
+		rt2x00pci_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000060);
+		rt61pci_mcu_request(rt2x00dev, MCU_SLEEP, 0xff, 0x00, 0x00);
 	} else {
-		rt2x00_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000007);
-		rt2x00_register_write(rt2x00dev, IO_CNTL_CSR, 0x00000018);
-		rt2x00_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000020);
-		rt2x00_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0x00, 0x00);
+		rt2x00pci_register_write(rt2x00dev, SOFT_RESET_CSR, 0x00000007);
+		rt2x00pci_register_write(rt2x00dev, IO_CNTL_CSR, 0x00000018);
+		rt2x00pci_register_write(rt2x00dev, PCI_USEC_CSR, 0x00000020);
+		rt61pci_mcu_request(rt2x00dev, MCU_WAKEUP, 0xff, 0x00, 0x00);
 	}
 
 	/*
@@ -1661,7 +1579,7 @@ static int rt61pci_set_state(struct rt2x
 	 * device has entered the correct state.
 	 */
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, MAC_CSR12, &reg);
+		rt2x00pci_register_read(rt2x00dev, MAC_CSR12, &reg);
 		current_state = rt2x00_get_field32(reg,
 			MAC_CSR12_BBP_CURRENT_STATE);
 		if (current_state == !put_to_sleep)
@@ -1771,15 +1689,15 @@ static void rt61pci_kick_tx_queue(struct
 	u32 reg;
 
 	if (queue == IEEE80211_TX_QUEUE_BEACON) {
-		rt2x00_register_read(rt2x00dev, TXRX_CSR9, &reg);
+		rt2x00pci_register_read(rt2x00dev, TXRX_CSR9, &reg);
 		if (!rt2x00_get_field32(reg, TXRX_CSR9_BEACON_GEN)) {
 			rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);
-			rt2x00_register_write(rt2x00dev, TXRX_CSR9, reg);
+			rt2x00pci_register_write(rt2x00dev, TXRX_CSR9, reg);
 		}
 		return;
 	}
 
-	rt2x00_register_read(rt2x00dev, TX_CNTL_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, TX_CNTL_CSR, &reg);
 	if (queue == IEEE80211_TX_QUEUE_DATA0)
 		rt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC0, 1);
 	else if (queue == IEEE80211_TX_QUEUE_DATA1)
@@ -1790,64 +1708,84 @@ static void rt61pci_kick_tx_queue(struct
 		rt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_AC3, 1);
 	else if (queue == IEEE80211_TX_QUEUE_DATA4)
 		rt2x00_set_field32(&reg, TX_CNTL_CSR_KICK_TX_MGMT, 1);
-	rt2x00_register_write(rt2x00dev, TX_CNTL_CSR, reg);
+	rt2x00pci_register_write(rt2x00dev, TX_CNTL_CSR, reg);
 }
 
 /*
- * Interrupt functions.
+ * RX control handlers
  */
-static void rt61pci_rxdone(struct rt2x00_dev *rt2x00dev, int queue)
+static int rt61pci_agc_to_rssi(struct rt2x00_dev *rt2x00dev, int rxd_w1)
 {
-	struct data_ring *ring = &rt2x00dev->ring[queue];
-	struct data_entry *entry;
-	struct data_desc *rxd;
-	u32 word0;
-	u32 word1;
-	int signal;
-	int rssi;
-	int ofdm;
-	u16 size;
+	u16 eeprom;
+	char offset;
+	char lna;
 
-	while (1) {
-		entry = rt2x00_get_data_entry(ring);
-		rxd = entry->priv;
-		rt2x00_desc_read(rxd, 0, &word0);
-		rt2x00_desc_read(rxd, 1, &word1);
+	lna = rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_LNA);
+	switch (lna) {
+		case 3:
+			offset = 90;
+		break;
+		case 2:
+			offset = 74;
+		break;
+		case 1:
+			offset = 64;
+		break;
+		default:
+			return 0;
+	}
 
-		if (rt2x00_get_field32(word0, RXD_W0_OWNER_NIC))
-			break;
+	if (rt2x00dev->rx_status.phymode == MODE_IEEE80211A) {
+		if (test_bit(CONFIG_EXTERNAL_LNA_A, &rt2x00dev->flags))
+			offset += 14;
 
-		/*
-		 * TODO: Don't we need to keep statistics
-		 * updated about events like CRC and physical errors?
-		 */
-		if (rt2x00_get_field32(word0, RXD_W0_CRC))
-			goto skip_entry;
+		if (lna == 3 || lna == 2)
+			offset += 10;
 
-		/*
-		 * Obtain the status about this packet.
-		 */
-		size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
-		signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
-		rssi = rt2x00_get_field32(word1, RXD_W1_RSSI);
-		ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
+		rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &eeprom);
+		offset -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_A_1);
+	} else {
+		if (test_bit(CONFIG_EXTERNAL_LNA_BG, &rt2x00dev->flags))
+			offset += 14;
 
-		/*
-		 * Send the packet to upper layer.
-		 */
-		rt2x00lib_rxdone(entry, entry->data_addr, size,
-			signal, rssi, ofdm);
+		rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &eeprom);
+		offset -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_BG_1);
+	}
 
-skip_entry:
-		if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
-			rt2x00_set_field32(&word0, RXD_W0_OWNER_NIC, 1);
-			rt2x00_desc_write(rxd, 0, word0);
-		}
+	return rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_AGC) * 2 - offset;
+}
 
-		rt2x00_ring_index_inc(ring);
-	}
+static int rt61pci_fill_rxdone(struct data_entry *entry,
+	int *signal, int *rssi, int *ofdm)
+{
+	struct data_desc *rxd = entry->priv;
+	u32 word0;
+	u32 word1;
+
+	rt2x00_desc_read(rxd, 0, &word0);
+	rt2x00_desc_read(rxd, 1, &word1);
+
+	/*
+	 * TODO: Don't we need to keep statistics
+	 * updated about these errors?
+	 */
+	if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
+	    rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR))
+		return -EINVAL;
+
+	/*
+	 * Obtain the status about this packet.
+	 */
+	*signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
+	*rssi = rt61pci_agc_to_rssi(entry->ring->rt2x00dev, word1);
+	*ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
+
+	return rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
 }
 
+/*
+ * Interrupt functions.
+ */
 static void rt61pci_txdone(struct rt2x00_dev *rt2x00dev)
 {
 	struct data_ring *ring;
@@ -1860,7 +1798,7 @@ static void rt61pci_txdone(struct rt2x00
 	int retry;
 
 	while (1) {
-		rt2x00_register_read(rt2x00dev, STA_CSR4, &reg);
+		rt2x00pci_register_read(rt2x00dev, STA_CSR4, &reg);
 		if (!rt2x00_get_field32(reg, STA_CSR4_VALID))
 			break;
 
@@ -1925,11 +1863,11 @@ static irqreturn_t rt61pci_interrupt(int
 	 * Get the interrupt sources & saved to local variable.
 	 * Write register value back to clear pending interrupts.
 	 */
-	rt2x00_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg);
-	rt2x00_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);
+	rt2x00pci_register_read(rt2x00dev, MCU_INT_SOURCE_CSR, &reg);
+	rt2x00pci_register_write(rt2x00dev, MCU_INT_SOURCE_CSR, reg);
 
-	rt2x00_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
-	rt2x00_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
+	rt2x00pci_register_read(rt2x00dev, INT_SOURCE_CSR, &reg);
+	rt2x00pci_register_write(rt2x00dev, INT_SOURCE_CSR, reg);
 
 	if (!reg)
 		return IRQ_NONE;
@@ -1947,13 +1885,13 @@ static irqreturn_t rt61pci_interrupt(int
 	 * 1 - Beacon timer expired interrupt.
 	 */
 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_BEACON_DONE))
-		rt2x00pci_beacondone(rt2x00dev, RING_BEACON);
+		rt2x00pci_beacondone(rt2x00dev, IEEE80211_TX_QUEUE_BEACON);
 
 	/*
 	 * 2 - Rx ring done interrupt.
 	 */
 	if (rt2x00_get_field32(reg, INT_SOURCE_CSR_RXDONE))
-		rt61pci_rxdone(rt2x00dev, RING_RX);
+		rt2x00pci_rxdone(rt2x00dev);
 
 	/*
 	 * 3 - Tx ring done interrupt.
@@ -1972,6 +1910,8 @@ static int rt61pci_alloc_eeprom(struct r
 	struct eeprom_93cx6 eeprom;
 	u32 reg;
 	u16 word;
+	u8 *mac;
+	char value;
 
 	/*
 	 * Allocate the eeprom memory, check the eeprom width
@@ -1981,7 +1921,7 @@ static int rt61pci_alloc_eeprom(struct r
 	if (!rt2x00dev->eeprom)
 		return -ENOMEM;
 
-	rt2x00_register_read(rt2x00dev, E2PROM_CSR, &reg);
+	rt2x00pci_register_read(rt2x00dev, E2PROM_CSR, &reg);
 
 	eeprom.data = rt2x00dev;
 	eeprom.register_read = rt61pci_eepromregister_read;
@@ -1999,6 +1939,12 @@ static int rt61pci_alloc_eeprom(struct r
 	/*
 	 * Start validation of the data that has been read.
 	 */
+	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+	if (!is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		EEPROM(rt2x00dev, "MAC: " MAC_FMT "\n", MAC_ARG(mac));
+	}
+
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);
@@ -2040,6 +1986,38 @@ static int rt61pci_alloc_eeprom(struct r
 		EEPROM(rt2x00dev, "Freq: 0x%04x\n", word);
 	}
 
+	rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &word);
+	if (word == 0xffff) {
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);
+		EEPROM(rt2x00dev, "RSSI OFFSET BG: 0x%04x\n", word);
+	} else {
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_1);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_2);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);
+	}
+
+	rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &word);
+	if (word == 0xffff) {
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);
+		EEPROM(rt2x00dev, "RSSI OFFSET BG: 0x%04x\n", word);
+	} else {
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_1);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_2);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);
+	}
+
 	return 0;
 }
 
@@ -2063,7 +2041,7 @@ static int rt61pci_init_eeprom(struct rt
 	pci_read_config_word(rt2x00dev_pci(rt2x00dev),
 		PCI_CONFIG_HEADER_DEVICE, &device);
 	value = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);
-	rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, MAC_CSR0, &reg);
 	rt2x00_set_chip(rt2x00dev, device, value, reg);
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF5225) &&
@@ -2199,11 +2177,16 @@ static void rt61pci_init_hw_mode(struct 
 		IEEE80211_HW_WEP_INCLUDE_IV |
 		IEEE80211_HW_DATA_NULLFUNC_ACK |
 		IEEE80211_HW_NO_TKIP_WMM_HWACCEL |
-		IEEE80211_HW_MONITOR_DURING_OPER;
+		IEEE80211_HW_MONITOR_DURING_OPER |
+		IEEE80211_HW_NO_PROBE_FILTERING;
 	rt2x00dev->hw->extra_tx_headroom = 0;
 	rt2x00dev->hw->max_rssi = MAX_RX_SSI;
 	rt2x00dev->hw->max_noise = MAX_RX_NOISE;
-	rt2x00dev->hw->queues = RING_NUM_TX;
+	rt2x00dev->hw->queues = 5;
+
+	SET_IEEE80211_DEV(rt2x00dev->hw, &rt2x00dev_pci(rt2x00dev)->dev);
+	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
+		rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0));
 
 	/*
 	 * Convert tx_power array in eeprom.
@@ -2215,7 +2198,6 @@ static void rt61pci_init_hw_mode(struct 
 	/*
 	 * Initialize hw_mode information.
 	 */
-	spec->mac_addr = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
 	spec->num_modes = 2;
 	spec->num_rates = 12;
 	spec->num_channels = 14;
@@ -2263,10 +2245,15 @@ static int rt61pci_init_hw(struct rt2x00
 	rt61pci_init_hw_mode(rt2x00dev);
 
 	/*
-	 * rt61pci requires firmware
+	 * This device requires firmware
 	 */
 	__set_bit(FIRMWARE_REQUIRED, &rt2x00dev->flags);
 
+	/*
+	 * Set the rssi offset.
+	 */
+	rt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;
+
 	return 0;
 }
 
@@ -2284,7 +2271,7 @@ static int rt61pci_get_stats(struct ieee
 	 * The dot11ACKFailureCount, dot11RTSFailureCount and
 	 * dot11RTSSuccessCount are updated in interrupt time.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR0, &reg);
+	rt2x00pci_register_read(rt2x00dev, STA_CSR0, &reg);
 	rt2x00dev->low_level_stats.dot11FCSErrorCount +=
 		rt2x00_get_field32(reg, STA_CSR0_FCS_ERROR);
 
@@ -2299,10 +2286,10 @@ static int rt61pci_set_retry_limit(struc
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR4_LONG_RETRY_LIMIT, long_retry);
 	rt2x00_set_field32(&reg, TXRX_CSR4_SHORT_RETRY_LIMIT, short_retry);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR4, reg);
 
 	return 0;
 }
@@ -2313,9 +2300,9 @@ static u64 rt61pci_get_tsf(struct ieee80
 	u64 tsf;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR13, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR13, &reg);
 	tsf = (u64)rt2x00_get_field32(reg, TXRX_CSR13_HIGH_TSFTIMER) << 32;
-	rt2x00_register_read(rt2x00dev, TXRX_CSR12, &reg);
+	rt2x00pci_register_read(rt2x00dev, TXRX_CSR12, &reg);
 	tsf |= rt2x00_get_field32(reg, TXRX_CSR12_LOW_TSFTIMER);
 
 	return tsf;
@@ -2325,15 +2312,13 @@ static void rt61pci_reset_tsf(struct iee
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR12, 0);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR13, 0);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR12, 0);
+	rt2x00pci_register_write(rt2x00dev, TXRX_CSR13, 0);
 }
 
 static const struct ieee80211_ops rt61pci_mac80211_ops = {
 	.tx			= rt2x00lib_tx,
 	.reset			= rt2x00lib_reset,
-	.open			= rt2x00lib_open,
-	.stop			= rt2x00lib_stop,
 	.add_interface		= rt2x00lib_add_interface,
 	.remove_interface	= rt2x00lib_remove_interface,
 	.config			= rt2x00lib_config,
@@ -2363,6 +2348,7 @@ static const struct rt2x00lib_ops rt61pc
 	.write_tx_desc		= rt61pci_write_tx_desc,
 	.write_tx_data		= rt2x00pci_write_tx_data,
 	.kick_tx_queue		= rt61pci_kick_tx_queue,
+	.fill_rxdone		= rt61pci_fill_rxdone,
 	.config_type		= rt61pci_config_type,
 	.config_phymode		= rt61pci_config_phymode,
 	.config_channel		= rt61pci_config_channel,
@@ -2409,12 +2395,6 @@ MODULE_FIRMWARE(FIRMWARE_RT2561s);
 MODULE_FIRMWARE(FIRMWARE_RT2661);
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
-
 static struct pci_driver rt61pci_driver = {
 	.name		= DRV_NAME,
 	.id_table	= rt61pci_device_table,
@@ -2428,14 +2408,11 @@ static struct pci_driver rt61pci_driver 
 
 static int __init rt61pci_init(void)
 {
-	printk(KERN_INFO "Loading module: %s - %s by %s.\n",
-		DRV_NAME, DRV_VERSION, DRV_PROJECT);
 	return pci_register_driver(&rt61pci_driver);
 }
 
 static void __exit rt61pci_exit(void)
 {
-	printk(KERN_INFO "Unloading module: %s.\n", DRV_NAME);
 	pci_unregister_driver(&rt61pci_driver);
 }
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt61pci.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt61pci.h	2007-07-09 21:00:14.000000000 +0200
@@ -36,10 +36,11 @@
 #define RF2529				0x0004
 
 /*
- * Max RSSI value, required for RSSI <-> dBm conversion.
+ * Signal information.
  */
-#define MAX_RX_SSI			120
+#define MAX_RX_SSI			-1
 #define MAX_RX_NOISE			-110
+#define DEFAULT_RSSI_OFFSET		120
 
 /*
  * Register layout information.
@@ -1103,6 +1104,48 @@ struct hw_pairwise_ta_entry {
 #define EEPROM_TXPOWER_A_2		FIELD16(0xff00)
 
 /*
+ * EEPROM RSSI offset 802.11BG
+ */
+#define EEPROM_RSSI_OFFSET_BG		0x004d
+#define EEPROM_RSSI_OFFSET_BG_1		FIELD16(0x00ff)
+#define EEPROM_RSSI_OFFSET_BG_2		FIELD16(0xff00)
+
+/*
+ * EEPROM RSSI offset 802.11A
+ */
+#define EEPROM_RSSI_OFFSET_A		0x004e
+#define EEPROM_RSSI_OFFSET_A_1		FIELD16(0x00ff)
+#define EEPROM_RSSI_OFFSET_A_2		FIELD16(0xff00)
+
+/*
+ * BBP content.
+ * The wordsize of the BBP is 8 bits.
+ */
+
+/*
+ * BBP_R2
+ */
+#define BBP_R2_BG_MODE			FIELD8(0x20)
+
+/*
+ * BBP_R3
+ */
+#define BBP_R3_SMART_MODE		FIELD8(0x01)
+
+/*
+ * BBP_R4: RX antenna control
+ * FRAME_END: 1 - DPDT, 0 - SPDT (Only valid for 802.11G, RF2527 & RF2529)
+ */
+#define BBP_R4_RX_ANTENNA		FIELD8(0x03)
+#define BBP_R4_RX_FRAME_END		FIELD8(0x10)
+#define BBP_R4_RX_BG_MODE		FIELD8(0x20)
+
+/*
+ * BBP_R77
+ */
+#define BBP_R77_PAIR			FIELD8(0x03)
+
+/*
  * MCU mailbox commands.
  */
 #define MCU_SLEEP			0x30
@@ -1257,10 +1300,10 @@ struct hw_pairwise_ta_entry {
 /*
  * Word1
  * SIGNAL: RX raw data rate reported by BBP.
- * RSSI: RSSI reported by BBP.
  */
 #define RXD_W1_SIGNAL			FIELD32(0x000000ff)
-#define RXD_W1_RSSI			FIELD32(0x0000ff00)
+#define RXD_W1_RSSI_AGC			FIELD32(0x00001f00)
+#define RXD_W1_RSSI_LNA			FIELD32(0x00006000)
 #define RXD_W1_FRAME_OFFSET		FIELD32(0x7f000000)
 
 /*
@@ -1307,21 +1350,6 @@ struct hw_pairwise_ta_entry {
 #define RXD_W15_RESERVED		FIELD32(0xffffffff)
 
 /*
- * TX ring index number for rt2x00_dev structure.
- */
-enum ring_index {
-	RING_AC_VO = 0,
-	RING_AC_VI = 1,
-	RING_AC_BE = 2,
-	RING_AC_BK = 3,
-	RING_PRIO = 4,
-	RING_BEACON = 5,
-	RING_RX = 6,
-	RING_NUM = 7,
-	RING_NUM_TX = 5,
-};
-
-/*
  * Macro's for converting txpower from EEPROM to dscape value
  * and from dscape value to register value.
  */
--- a/drivers/net/wireless/mac80211/rt2x00/rt73usb.c	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt73usb.c	2007-07-09 21:00:14.000000000 +0200
@@ -38,13 +38,14 @@
 #include <linux/etherdevice.h>
 
 #include "rt2x00.h"
+#include "rt2x00lib.h"
 #include "rt2x00usb.h"
 #include "rt73usb.h"
 
 /*
  * Register access.
  * All access to the CSR registers will go through the methods
- * rt2x00_register_read and rt2x00_register_write.
+ * rt73usb_register_read and rt73usb_register_write.
  * BBP and RF register require indirect register access,
  * and use the CSR registers BBPCSR and RFCSR to achieve this.
  * These indirect registers work with busy bits,
@@ -54,90 +55,63 @@
  * the access attempt is considered to have failed,
  * and we will print an error.
  */
-static int rt2x00_vendor_request(const struct rt2x00_dev *rt2x00dev,
-	const u8 request, const u8 type, const u16 offset,
-	u32 value, void *buffer, const u16 buffer_length, const u16 timeout)
-{
-	struct usb_device *usb_dev = interface_to_usbdev(
-		rt2x00dev_usb(rt2x00dev));
-	int status;
-	unsigned int i;
-
-	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		status = usb_control_msg(
-			usb_dev,
-			(type == USB_VENDOR_REQUEST_IN) ?
-				usb_rcvctrlpipe(usb_dev, 0) :
-				usb_sndctrlpipe(usb_dev, 0),
-			request, type, value, offset, buffer, buffer_length,
-			timeout);
-		if (status >= 0)
-			return 0;
-	}
-
-	ERROR(rt2x00dev, "vendor request error. Request 0x%02x failed "
-		"for offset 0x%04x with error %d.\n", request, offset, status);
-
-	return status;
-}
-
-static inline void rt2x00_register_read(
+static inline void rt73usb_register_read(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, u32 *value)
 {
 	__le32 reg;
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_READ, USB_VENDOR_REQUEST_IN,
 		offset, 0x00, &reg, sizeof(u32), REGISTER_TIMEOUT);
 	*value = le32_to_cpu(reg);
 }
 
-static inline void rt2x00_register_multiread(
+static inline void rt73usb_register_multiread(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, void *value, const u32 length)
 {
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_READ, USB_VENDOR_REQUEST_IN,
 		offset, 0x00, value, length,
 		REGISTER_TIMEOUT * (length / sizeof(u32)));
 }
 
-static inline void rt2x00_register_write(
+static inline void rt73usb_register_write(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, u32 value)
 {
 	__le32 reg = cpu_to_le32(value);
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_WRITE, USB_VENDOR_REQUEST_OUT,
 		offset, 0x00, &reg, sizeof(u32), REGISTER_TIMEOUT);
 }
 
-static inline void rt2x00_register_multiwrite(
+static inline void rt73usb_register_multiwrite(
 	const struct rt2x00_dev *rt2x00dev,
 	const u16 offset, void *value, const u32 length)
 {
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_MULTI_WRITE, USB_VENDOR_REQUEST_OUT,
 		offset, 0x00, value, length,
 		REGISTER_TIMEOUT * (length / sizeof(u32)));
 }
 
-static u32 rt2x00_bbp_check(const struct rt2x00_dev *rt2x00dev)
+static u32 rt73usb_bbp_check(const struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR3, &reg);
+		rt73usb_register_read(rt2x00dev, PHY_CSR3, &reg);
 		if (!rt2x00_get_field32(reg, PHY_CSR3_BUSY))
-			return reg;
+			break;
 		udelay(REGISTER_BUSY_DELAY);
 	}
 
-	return 0xffff;
+	return reg;
 }
 
-static void rt2x00_bbp_write(const struct rt2x00_dev *rt2x00dev,
+static void rt73usb_bbp_write(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, const u8 value)
 {
 	u32 reg;
@@ -145,7 +119,8 @@ static void rt2x00_bbp_write(const struc
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt73usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Write failed.\n");
 		return;
 	}
@@ -159,10 +134,10 @@ static void rt2x00_bbp_write(const struc
 	rt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);
 	rt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 0);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR3, reg);
+	rt73usb_register_write(rt2x00dev, PHY_CSR3, reg);
 }
 
-static void rt2x00_bbp_read(const struct rt2x00_dev *rt2x00dev,
+static void rt73usb_bbp_read(const struct rt2x00_dev *rt2x00dev,
 	const u8 reg_id, u8 *value)
 {
 	u32 reg;
@@ -170,7 +145,8 @@ static void rt2x00_bbp_read(const struct
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	if (rt2x00_bbp_check(rt2x00dev) == 0xffff) {
+	reg = rt73usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Read failed.\n");
 		return;
 	}
@@ -183,26 +159,29 @@ static void rt2x00_bbp_read(const struct
 	rt2x00_set_field32(&reg, PHY_CSR3_BUSY, 1);
 	rt2x00_set_field32(&reg, PHY_CSR3_READ_CONTROL, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR3, reg);
+	rt73usb_register_write(rt2x00dev, PHY_CSR3, reg);
 
 	/*
 	 *  Wait until the BBP becomes ready.
 	 */
-	reg = rt2x00_bbp_check(rt2x00dev);
-	if (reg == 0xffff)
+	reg = rt73usb_bbp_check(rt2x00dev);
+	if (rt2x00_get_field32(reg, PHY_CSR3_BUSY)) {
 		ERROR(rt2x00dev, "PHY_CSR3 register busy. Read failed.\n");
+		*value = 0xff;
+		return;
+	}
 
 	*value = rt2x00_get_field32(reg, PHY_CSR3_VALUE);
 }
 
-static void rt2x00_rf_write(const struct rt2x00_dev *rt2x00dev,
+static void rt73usb_rf_write(const struct rt2x00_dev *rt2x00dev,
 	const u32 value)
 {
 	u32 reg;
 	unsigned int i;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, PHY_CSR4, &reg);
+		rt73usb_register_read(rt2x00dev, PHY_CSR4, &reg);
 		if (!rt2x00_get_field32(reg, PHY_CSR4_BUSY))
 			goto rf_write;
 		udelay(REGISTER_BUSY_DELAY);
@@ -218,7 +197,7 @@ rf_write:
 	rt2x00_set_field32(&reg, PHY_CSR4_IF_SELECT, 0);
 	rt2x00_set_field32(&reg, PHY_CSR4_BUSY, 1);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR4, reg);
+	rt73usb_register_write(rt2x00dev, PHY_CSR4, reg);
 }
 
 #ifdef CONFIG_RT2X00_LIB_DEBUGFS
@@ -227,13 +206,13 @@ rf_write:
 static void rt73usb_read_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_read(rt2x00dev, CSR_OFFSET(word), data);
+	rt73usb_register_read(rt2x00dev, CSR_OFFSET(word), data);
 }
 
 static void rt73usb_write_csr(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
+	rt73usb_register_write(rt2x00dev, CSR_OFFSET(word), *((u32*)data));
 }
 
 static void rt73usb_read_eeprom(struct rt2x00_dev *rt2x00dev,
@@ -251,13 +230,13 @@ static void rt73usb_write_eeprom(struct 
 static void rt73usb_read_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_read(rt2x00dev, word, data);
+	rt73usb_bbp_read(rt2x00dev, word, data);
 }
 
 static void rt73usb_write_bbp(struct rt2x00_dev *rt2x00dev,
 	const unsigned long word, void *data)
 {
-	rt2x00_bbp_write(rt2x00dev, word, *((u8*)data));
+	rt73usb_bbp_write(rt2x00dev, word, *((u8*)data));
 }
 
 static const struct rt2x00debug rt73usb_rt2x00debug = {
@@ -299,45 +278,30 @@ static void rt73usb_config_bssid(struct 
 	 * The BSSID is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR4, &reg, sizeof(reg));
+	rt73usb_register_multiwrite(rt2x00dev, MAC_CSR4, &reg, sizeof(reg));
 }
 
-static void rt73usb_config_promisc(struct rt2x00_dev *rt2x00dev, int promisc)
+static void rt73usb_config_promisc(struct rt2x00_dev *rt2x00dev,
+	const int promisc)
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
-
-	if (promisc) {
-		rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, 0);
-		__set_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	} else {
-		rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, 1);
-		__clear_bit(INTERFACE_ENABLED_PROMISC, &rt2x00dev->flags);
-	}
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_NOT_TO_ME, !promisc);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 }
 
-static void rt73usb_config_type(struct rt2x00_dev *rt2x00dev, int type)
+static void rt73usb_config_type(struct rt2x00_dev *rt2x00dev,
+	const int type)
 {
 	u32 reg;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (!(is_interface_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED, &rt2x00dev->flags)) &&
-	    !(is_monitor_present(&rt2x00dev->interface) ^
-	      test_bit(INTERFACE_ENABLED_MONITOR, &rt2x00dev->flags)))
-		return;
-
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, 0);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR9, 0);
 
 	/*
 	 * Apply hardware packet filter.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
 
 	if (!is_monitor_present(&rt2x00dev->interface) &&
 	    (type == IEEE80211_IF_TYPE_IBSS || type == IEEE80211_IF_TYPE_STA))
@@ -359,14 +323,13 @@ static void rt73usb_config_type(struct r
 	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_MULTICAST, 0);
 	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_BORADCAST, 0);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 
 	/*
 	 * Enable synchronisation.
 	 */
-	rt2x00_register_read(rt2x00dev, TXRX_CSR9, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR9, &reg);
 	if (is_interface_present(&rt2x00dev->interface)) {
-		rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, 100 * 16);
 		rt2x00_set_field32(&reg, TXRX_CSR9_TSF_TICKING, 1);
 		rt2x00_set_field32(&reg, TXRX_CSR9_TBTT_ENABLE, 1);
 	}
@@ -380,28 +343,11 @@ static void rt73usb_config_type(struct r
 		 !is_interface_present(&rt2x00dev->interface))
 		rt2x00_set_field32(&reg, TXRX_CSR9_TSF_SYNC, 0);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, reg);
-
-	/*
-	 * Change flags of enabled interfaces.
-	 */
-	if (type != IEEE80211_IF_TYPE_MNTR) {
-		if (is_interface_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED, &rt2x00dev->flags);
-	} else {
-		if (is_monitor_present(&rt2x00dev->interface))
-			__set_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-		else
-			__clear_bit(INTERFACE_ENABLED_MONITOR,
-				&rt2x00dev->flags);
-	}
+	rt73usb_register_write(rt2x00dev, TXRX_CSR9, reg);
 }
 
 static void rt73usb_config_channel(struct rt2x00_dev *rt2x00dev,
-	int value, int channel, int freq, int txpower)
+	const int value, const int channel, const int txpower)
 {
 	u8 reg = 0;
 	u32 rf1 = rt2x00dev->rf1;
@@ -409,17 +355,6 @@ static void rt73usb_config_channel(struc
 	u32 rf3 = rt2x00dev->rf3;
 	u32 rf4 = 0;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (channel == rt2x00dev->rx_status.channel)
-		return;
-
-	if (txpower == 0xff)
-		txpower = rt2x00dev->tx_power;
-	else
-		txpower = TXPOWER_TO_DEV(txpower);
-
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2527))
 		rf2 |= 0x00004000;
@@ -500,237 +435,215 @@ static void rt73usb_config_channel(struc
 	/*
 	 * Set TXpower.
 	 */
-	rt2x00_set_field32(&rf3, RF3_TXPOWER, txpower);
-
-	INFO(rt2x00dev, "Switching channel. "
-		"RF1: 0x%08x, RF2: 0x%08x, RF3: 0x%08x, RF4: 0x%08x.\n",
-		rf1, rf2, rf3, rf4);
+	rt2x00_set_field32(&rf3, RF3_TXPOWER, TXPOWER_TO_DEV(txpower));
 
 	/*
 	 * Set Frequency offset.
 	 */
 	rt2x00_set_field32(&rf4, RF4_FREQ_OFFSET, rt2x00dev->freq_offset);
 
-	rt2x00_bbp_read(rt2x00dev, 3, &reg);
+	rt73usb_bbp_read(rt2x00dev, 3, &reg);
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2527))
 		reg &= ~0x01;
 	else
 		reg |= 0x01;
-	rt2x00_bbp_write(rt2x00dev, 3, reg);
+	rt73usb_bbp_write(rt2x00dev, 3, reg);
 
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
-
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 | 0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
-
-	rt2x00_rf_write(rt2x00dev, rf1);
-	rt2x00_rf_write(rt2x00dev, rf2);
-	rt2x00_rf_write(rt2x00dev, rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rf4);
+	rt73usb_rf_write(rt2x00dev, rf1);
+	rt73usb_rf_write(rt2x00dev, rf2);
+	rt73usb_rf_write(rt2x00dev, rf3 & ~0x00000004);
+	rt73usb_rf_write(rt2x00dev, rf4);
+
+	rt73usb_rf_write(rt2x00dev, rf1);
+	rt73usb_rf_write(rt2x00dev, rf2);
+	rt73usb_rf_write(rt2x00dev, rf3 | 0x00000004);
+	rt73usb_rf_write(rt2x00dev, rf4);
+
+	rt73usb_rf_write(rt2x00dev, rf1);
+	rt73usb_rf_write(rt2x00dev, rf2);
+	rt73usb_rf_write(rt2x00dev, rf3 & ~0x00000004);
+	rt73usb_rf_write(rt2x00dev, rf4);
 
 	msleep(1);
 
 	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.freq = freq;
-	rt2x00dev->rx_status.channel = channel;
-
-	/*
 	 * Update rf fields
 	 */
 	rt2x00dev->rf1 = rf1;
 	rt2x00dev->rf2 = rf2;
 	rt2x00dev->rf3 = rf3;
 	rt2x00dev->rf4 = rf4;
-
 	rt2x00dev->tx_power = txpower;
 }
 
-static void rt73usb_config_txpower(struct rt2x00_dev *rt2x00dev, int txpower)
+static void rt73usb_config_txpower(struct rt2x00_dev *rt2x00dev,
+	const int txpower)
 {
-	txpower = TXPOWER_TO_DEV(txpower);
-
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (txpower == rt2x00dev->tx_power)
-		return;
-
-	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER, txpower);
-
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
-
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 | 0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
-
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf1);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf2);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
-	rt2x00_rf_write(rt2x00dev, rt2x00dev->rf4);
+	rt2x00_set_field32(&rt2x00dev->rf3, RF3_TXPOWER,
+		TXPOWER_TO_DEV(txpower));
 
-	rt2x00dev->tx_power = txpower;
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf4);
+
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf3 | 0x00000004);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf4);
+
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf1);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf2);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf3 & ~0x00000004);
+	rt73usb_rf_write(rt2x00dev, rt2x00dev->rf4);
 }
 
 static void rt73usb_config_antenna(struct rt2x00_dev *rt2x00dev,
-	int antenna_tx, int antenna_rx)
+	const int antenna_tx, const int antenna_rx)
 {
 	u32 reg;
-	u8 reg_r3;
-	u8 reg_r4;
-	u8 reg_r77;
-	u8 frame_type;
+	u8 r3;
+	u8 r4;
+	u8 r77;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.antenna == antenna_rx)
-		return;
-
-	rt2x00_register_read(rt2x00dev, PHY_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, PHY_CSR0, &reg);
 
 	if (rt2x00dev->curr_hwmode == HWMODE_A) {
 		if (test_bit(CONFIG_EXTERNAL_LNA, &rt2x00dev->flags)) {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x38);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x78);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x48);
-			rt2x00_bbp_write(rt2x00dev, 75, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 86, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 88, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 17, 0x38);
+			rt73usb_bbp_write(rt2x00dev, 96, 0x78);
+			rt73usb_bbp_write(rt2x00dev, 104, 0x48);
+			rt73usb_bbp_write(rt2x00dev, 75, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 86, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 88, 0x80);
 		} else {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x28);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x58);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x38);
-			rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 17, 0x28);
+			rt73usb_bbp_write(rt2x00dev, 96, 0x58);
+			rt73usb_bbp_write(rt2x00dev, 104, 0x38);
+			rt73usb_bbp_write(rt2x00dev, 75, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 86, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 88, 0xfe);
 		}
-		rt2x00_bbp_write(rt2x00dev, 35, 0x60);
-		rt2x00_bbp_write(rt2x00dev, 97, 0x58);
-		rt2x00_bbp_write(rt2x00dev, 98, 0x58);
+		rt73usb_bbp_write(rt2x00dev, 35, 0x60);
+		rt73usb_bbp_write(rt2x00dev, 97, 0x58);
+		rt73usb_bbp_write(rt2x00dev, 98, 0x58);
 
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG, 0);
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A, 1);
 	} else {
 		if (test_bit(CONFIG_EXTERNAL_LNA, &rt2x00dev->flags)) {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x30);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x68);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x3c);
-			rt2x00_bbp_write(rt2x00dev, 75, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 86, 0x80);
-			rt2x00_bbp_write(rt2x00dev, 88, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 17, 0x30);
+			rt73usb_bbp_write(rt2x00dev, 96, 0x68);
+			rt73usb_bbp_write(rt2x00dev, 104, 0x3c);
+			rt73usb_bbp_write(rt2x00dev, 75, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 86, 0x80);
+			rt73usb_bbp_write(rt2x00dev, 88, 0x80);
 		} else {
-			rt2x00_bbp_write(rt2x00dev, 17, 0x20);
-			rt2x00_bbp_write(rt2x00dev, 96, 0x48);
-			rt2x00_bbp_write(rt2x00dev, 104, 0x2c);
-			rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-			rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 17, 0x20);
+			rt73usb_bbp_write(rt2x00dev, 96, 0x48);
+			rt73usb_bbp_write(rt2x00dev, 104, 0x2c);
+			rt73usb_bbp_write(rt2x00dev, 75, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 86, 0xfe);
+			rt73usb_bbp_write(rt2x00dev, 88, 0xfe);
 		}
-		rt2x00_bbp_write(rt2x00dev, 35, 0x50);
-		rt2x00_bbp_write(rt2x00dev, 97, 0x48);
-		rt2x00_bbp_write(rt2x00dev, 98, 0x48);
+		rt73usb_bbp_write(rt2x00dev, 35, 0x50);
+		rt73usb_bbp_write(rt2x00dev, 97, 0x48);
+		rt73usb_bbp_write(rt2x00dev, 98, 0x48);
 
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_BG, 1);
 		rt2x00_set_field32(&reg, PHY_CSR0_PA_PE_A, 0);
 	}
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, PHY_CSR0, reg);
 
-	rt2x00_bbp_read(rt2x00dev, 3, &reg_r3);
-	rt2x00_bbp_read(rt2x00dev, 4, &reg_r4);
-	rt2x00_bbp_read(rt2x00dev, 77, &reg_r77);
-
-	reg_r3 &= ~0x01;
-	reg_r4 &= ~0x23;
-	frame_type = ~(test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags) << 5);
+	rt73usb_bbp_read(rt2x00dev, 3, &r3);
+	rt73usb_bbp_read(rt2x00dev, 4, &r4);
+	rt73usb_bbp_read(rt2x00dev, 77, &r77);
+
+	rt2x00_set_field8(&r3, BBP_R3_SMART_MODE, 0);
 
 	if (rt2x00_rf(&rt2x00dev->chip, RF5226) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF5225)) {
-		if (antenna_rx == 0) {		/* Diversity. */
-			reg_r4 |= 0x02;
+		if (antenna_rx == ANTENNA_DIVERSITY) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);
 			if (rt2x00dev->curr_hwmode != HWMODE_A)
-				reg_r4 |= 0x20;
-			reg_r4 &= frame_type;
-		} else if (antenna_rx == 1) {	/* RX: Antenna A */
-			reg_r4 |= 0x01;
-			reg_r4 &= frame_type;
+				rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+		} else if (antenna_rx == ANTENNA_A) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
 			if (rt2x00dev->curr_hwmode == HWMODE_A)
-				reg_r77 &= ~0x03;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
 			else
-				reg_r77 |= 0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
-		} else if (antenna_rx == 2) {	/* RX: Antenna B */
-			reg_r4 |= 0x01;
-			reg_r4 &= frame_type;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
+			rt73usb_bbp_write(rt2x00dev, 77, r77);
+		} else if (antenna_rx == ANTENNA_B) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
 			if (rt2x00dev->curr_hwmode == HWMODE_A)
-				reg_r77 |= 0x03;
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
 			else
-				reg_r77 &= ~0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
+				rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
+			rt73usb_bbp_write(rt2x00dev, 77, r77);
 		}
 	} else if (rt2x00_rf(&rt2x00dev->chip, RF2528) ||
 		   rt2x00_rf(&rt2x00dev->chip, RF2527)) {
-		if (antenna_rx == 0) {		/* Diversity. */
-			reg_r4 |= 0x22;
-			reg_r4 &= frame_type;
-		} else if (antenna_rx == 1) {	/* RX: Antenna A */
-			reg_r4 |= 0x21;
-			reg_r4 &= frame_type;
-			reg_r77 |= 0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
-		} else if (antenna_rx == 2) {	/* RX: Antenna B */
-			reg_r4 |= 0x21;
-			reg_r4 &= frame_type;
-			reg_r77 &= ~0x03;
-			rt2x00_bbp_write(rt2x00dev, 77, reg_r77);
+		if (antenna_rx == ANTENNA_DIVERSITY) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 2);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+		} else if (antenna_rx == ANTENNA_A) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+			rt2x00_set_field8(&r77, BBP_R77_PAIR, 3);
+			rt73usb_bbp_write(rt2x00dev, 77, r77);
+		} else if (antenna_rx == ANTENNA_B) {
+			rt2x00_set_field8(&r4, BBP_R4_RX_ANTENNA, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_BG_MODE, 1);
+			rt2x00_set_field8(&r4, BBP_R4_RX_FRAME_END,
+				test_bit(CONFIG_FRAME_TYPE, &rt2x00dev->flags));
+			rt2x00_set_field8(&r77, BBP_R77_PAIR, 0);
 		}
 	}
 
-	rt2x00_bbp_write(rt2x00dev, 3, reg_r3);
-	rt2x00_bbp_write(rt2x00dev, 4, reg_r4);
-
-	/*
-	 * Update active info for RX.
-	 */
-	rt2x00dev->rx_status.antenna = antenna_rx;
+	rt73usb_bbp_write(rt2x00dev, 3, r3);
+	rt73usb_bbp_write(rt2x00dev, 4, r4);
 }
 
 static void rt73usb_config_duration(struct rt2x00_dev *rt2x00dev,
-	int short_slot_time)
+	const int short_slot_time, const int beacon_int)
 {
 	u32 reg;
 
-	short_slot_time = short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME;
+	rt73usb_register_read(rt2x00dev, MAC_CSR9, &reg);
+	rt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME,
+		short_slot_time ? SHORT_SLOT_TIME : SLOT_TIME);
+	rt73usb_register_write(rt2x00dev, MAC_CSR9, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR9, &reg);
-	rt2x00_set_field32(&reg, MAC_CSR9_SLOT_TIME, short_slot_time);
-	rt2x00_register_write(rt2x00dev, MAC_CSR9, reg);
-
-	rt2x00_register_read(rt2x00dev, MAC_CSR8, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR8, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR8_SIFS, SIFS);
 	rt2x00_set_field32(&reg, MAC_CSR8_SIFS_AFTER_RX_OFDM, 3);
 	rt2x00_set_field32(&reg, MAC_CSR8_EIFS, EIFS);
-	rt2x00_register_write(rt2x00dev, MAC_CSR8, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR8, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR0_TSF_OFFSET, IEEE80211_HEADER);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_ENABLE, 1);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR4, reg);
+
+	rt73usb_register_read(rt2x00dev, TXRX_CSR9, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_INTERVAL, beacon_int * 16);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR9, reg);
 }
 
 static void rt73usb_config_rate(struct rt2x00_dev *rt2x00dev, const int rate)
@@ -745,21 +658,21 @@ static void rt73usb_config_rate(struct r
 
 	reg = DEVICE_GET_RATE_FIELD(rate, RATEMASK) & DEV_BASIC_RATE;
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR5, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR5, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	value = ((conf->flags & IEEE80211_CONF_SHORT_SLOT_TIME) ?
 		 SHORT_DIFS :  DIFS) +
 		PLCP + preamble + get_duration(ACK_SIZE, 10);
 	rt2x00_set_field32(&reg, TXRX_CSR0_RX_ACK_TIMEOUT, value);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	if (preamble == SHORT_PREAMBLE)
 		rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE, 1);
 	else
 		rt2x00_set_field32(&reg, TXRX_CSR4_AUTORESPOND_PREAMBLE, 0);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR4, reg);
 }
 
 static void rt73usb_config_phymode(struct rt2x00_dev *rt2x00dev,
@@ -768,12 +681,6 @@ static void rt73usb_config_phymode(struc
 	struct ieee80211_hw_mode *mode;
 	struct ieee80211_rate *rate;
 
-	/*
-	 * Only continue when there is something to be done.
-	 */
-	if (rt2x00dev->rx_status.phymode == phymode)
-		return;
-
 	if (phymode == MODE_IEEE80211A)
 		rt2x00dev->curr_hwmode = HWMODE_A;
 	else if (phymode == MODE_IEEE80211B)
@@ -785,11 +692,6 @@ static void rt73usb_config_phymode(struc
 	rate = &mode->rates[mode->num_rates - 1];
 
 	rt73usb_config_rate(rt2x00dev, rate->val2);
-
-	/*
-	 * Update physical mode for rx ring.
-	 */
-	rt2x00dev->rx_status.phymode = phymode;
 }
 
 static void rt73usb_config_mac_addr(struct rt2x00_dev *rt2x00dev, u8 *addr)
@@ -805,7 +707,7 @@ static void rt73usb_config_mac_addr(stru
 	 * The MAC address is passed to us as an array of bytes,
 	 * that array is little endian, so no need for byte ordering.
 	 */
-	rt2x00_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
+	rt73usb_register_multiwrite(rt2x00dev, MAC_CSR2, &reg, sizeof(reg));
 }
 
 /*
@@ -815,10 +717,10 @@ static void rt73usb_enable_led(struct rt
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR14, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR14, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR14_ON_PERIOD, 70);
 	rt2x00_set_field32(&reg, MAC_CSR14_OFF_PERIOD, 30);
-	rt2x00_register_write(rt2x00dev, MAC_CSR14, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR14, reg);
 
 	rt2x00_set_field16(&rt2x00dev->led_reg, MCU_LEDCS_RADIO_STATUS, 1);
 	if (rt2x00dev->rx_status.phymode == MODE_IEEE80211A)
@@ -828,7 +730,7 @@ static void rt73usb_enable_led(struct rt
 		rt2x00_set_field16(
 			&rt2x00dev->led_reg, MCU_LEDCS_LINK_BG_STATUS, 1);
 
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_LED_CONTROL, USB_VENDOR_REQUEST_OUT,
 		0x00, rt2x00dev->led_reg, NULL, 0, REGISTER_TIMEOUT);
 }
@@ -839,18 +741,24 @@ static void rt73usb_disable_led(struct r
 	rt2x00_set_field16(&rt2x00dev->led_reg, MCU_LEDCS_LINK_BG_STATUS, 0);
 	rt2x00_set_field16(&rt2x00dev->led_reg, MCU_LEDCS_LINK_A_STATUS, 0);
 
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_LED_CONTROL, USB_VENDOR_REQUEST_OUT,
 		0x00, rt2x00dev->led_reg, NULL, 0, REGISTER_TIMEOUT);
 }
 
-static void rt73usb_activity_led(struct rt2x00_dev *rt2x00dev, char rssi)
+static void rt73usb_activity_led(struct rt2x00_dev *rt2x00dev, int rssi)
 {
 	u32 led;
 
 	if (rt2x00dev->led_mode != LED_MODE_SIGNAL_STRENGTH)
 		return;
 
+	/*
+	 * Led handling requires a positive value for the rssi,
+	 * to do that correctly we need to add the correction.
+	 */
+	rssi += rt2x00dev->rssi_offset;
+
 	if (rssi <= 30)
 		led = 0;
 	else if (rssi <= 39)
@@ -864,7 +772,7 @@ static void rt73usb_activity_led(struct 
 	else
 		led = 5;
 
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_LED_CONTROL, USB_VENDOR_REQUEST_OUT,
 		led, rt2x00dev->led_reg, NULL, 0, REGISTER_TIMEOUT);
 }
@@ -872,8 +780,9 @@ static void rt73usb_activity_led(struct 
 /*
  * Link tuning
  */
-static void rt73usb_link_tuner(struct rt2x00_dev *rt2x00dev, int rssi)
+static void rt73usb_link_tuner(struct rt2x00_dev *rt2x00dev)
 {
+	int rssi = rt2x00_get_link_rssi(&rt2x00dev->link);
 	u32 reg;
 	u8 r17;
 	u8 up_bound;
@@ -884,7 +793,7 @@ static void rt73usb_link_tuner(struct rt
 	 */
 	rt73usb_activity_led(rt2x00dev, rssi);
 
-	rt2x00_bbp_read(rt2x00dev, 17, &r17);
+	rt73usb_bbp_read(rt2x00dev, 17, &r17);
 
 	/*
 	 * Determine r17 bounds.
@@ -920,7 +829,7 @@ static void rt73usb_link_tuner(struct rt
 	 */
 	if (rssi > -35) {
 		if (r17 != 0x60)
-			rt2x00_bbp_write(rt2x00dev, 17, 0x60);
+			rt73usb_bbp_write(rt2x00dev, 17, 0x60);
 		return;
 	}
 
@@ -929,7 +838,7 @@ static void rt73usb_link_tuner(struct rt
 	 */
 	if (rssi >= -58) {
 		if (r17 != up_bound)
-			rt2x00_bbp_write(rt2x00dev, 17, up_bound);
+			rt73usb_bbp_write(rt2x00dev, 17, up_bound);
 		return;
 	}
 
@@ -939,7 +848,7 @@ static void rt73usb_link_tuner(struct rt
 	if (rssi >= -66) {
 		low_bound += 0x10;
 		if (r17 != low_bound)
-			rt2x00_bbp_write(rt2x00dev, 17, low_bound);
+			rt73usb_bbp_write(rt2x00dev, 17, low_bound);
 		return;
 	}
 
@@ -948,7 +857,7 @@ static void rt73usb_link_tuner(struct rt
 	 */
 	if (rssi >= -74) {
 		if (r17 != (low_bound + 0x10))
-			rt2x00_bbp_write(rt2x00dev, 17, low_bound + 0x08);
+			rt73usb_bbp_write(rt2x00dev, 17, low_bound + 0x08);
 		return;
 	}
 
@@ -961,7 +870,7 @@ static void rt73usb_link_tuner(struct rt
 		up_bound = low_bound;
 
 	if (r17 > up_bound) {
-		rt2x00_bbp_write(rt2x00dev, 17, up_bound);
+		rt73usb_bbp_write(rt2x00dev, 17, up_bound);
 		return;
 	}
 
@@ -969,7 +878,7 @@ static void rt73usb_link_tuner(struct rt
 	 * r17 does not yet exceed upper limit, continue and base
 	 * the r17 tuning on the false CCA count.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR1, &reg);
+	rt73usb_register_read(rt2x00dev, STA_CSR1, &reg);
 	reg = rt2x00_get_field32(reg, STA_CSR1_FALSE_CCA_ERROR);
 	rt2x00dev->link.false_cca =
 		rt2x00_get_field32(reg, STA_CSR1_FALSE_CCA_ERROR);
@@ -978,12 +887,14 @@ static void rt73usb_link_tuner(struct rt
 		r17 += 4;
 		if (r17 > up_bound)
 			r17 = up_bound;
-		rt2x00_bbp_write(rt2x00dev, 17, r17);
+		rt73usb_bbp_write(rt2x00dev, 17, r17);
+		rt2x00dev->rx_status.noise = r17;
 	} else if (rt2x00dev->link.false_cca < 100 && r17 > low_bound) {
 		r17 -= 4;
 		if (r17 < low_bound)
 			r17 = low_bound;
-		rt2x00_bbp_write(rt2x00dev, 17, r17);
+		rt73usb_bbp_write(rt2x00dev, 17, r17);
+		rt2x00dev->rx_status.noise = r17;
 	}
 }
 
@@ -1012,7 +923,7 @@ static int rt73usb_load_firmware(struct 
 	 * Wait for stable hardware.
 	 */
 	for (i = 0; i < 100; i++) {
-		rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
+		rt73usb_register_read(rt2x00dev, MAC_CSR0, &reg);
 		if (reg)
 			break;
 		msleep(1);
@@ -1029,7 +940,7 @@ static int rt73usb_load_firmware(struct 
 	for (i = 0; i < len; i += sizeof(buf)) {
 		buflen = min(len - i, sizeof(buf));
 		memcpy(buf, ptr, buflen);
-		rt2x00_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE + i,
+		rt73usb_register_multiwrite(rt2x00dev, FIRMWARE_IMAGE_BASE + i,
 			buf, buflen);
 		ptr += buflen;
 	}
@@ -1038,7 +949,7 @@ static int rt73usb_load_firmware(struct 
 	 * Send firmware request to device to load firmware,
 	 * we need to specify a long timeout time.
 	 */
-	status = rt2x00_vendor_request(rt2x00dev, USB_DEVICE_MODE,
+	status = rt2x00usb_vendor_request(rt2x00dev, USB_DEVICE_MODE,
 		USB_VENDOR_REQUEST_OUT, 0x00, USB_MODE_FIRMWARE,
 		NULL, 0, REGISTER_TIMEOUT_FIRMWARE);
 	if (status  < 0) {
@@ -1051,57 +962,6 @@ static int rt73usb_load_firmware(struct 
 	return 0;
 }
 
-static void rt73usb_init_rxring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
-{
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
-	struct usb_device *usb_dev =
-		interface_to_usbdev(rt2x00dev_usb(rt2x00dev));
-	unsigned int i;
-
-	ring->type = ring_type;
-
-	for (i = 0; i < ring->stats.limit; i++) {
-		usb_fill_bulk_urb(
-			ring->entry[i].priv,
-			usb_dev,
-			usb_rcvbulkpipe(usb_dev, 1),
-			ring->entry[i].skb->data,
-			ring->entry[i].skb->len,
-			rt73usb_interrupt_rxdone,
-			&ring->entry[i]);
-	}
-
-	rt2x00_ring_index_clear(ring);
-}
-
-static void rt73usb_init_txring(struct rt2x00_dev *rt2x00dev,
-	enum ring_index ring_type)
-{
-	struct data_ring *ring = &rt2x00dev->ring[ring_type];
-	unsigned int i;
-
-	ring->type = ring_type;
-
-	for (i = 0; i < ring->stats.limit; i++)
-		ring->entry[i].flags = 0;
-
-	rt2x00_ring_index_clear(ring);
-}
-
-static int rt73usb_init_rings(struct rt2x00_dev *rt2x00dev)
-{
-	rt73usb_init_rxring(rt2x00dev, RING_RX);
-	rt73usb_init_txring(rt2x00dev, RING_AC_VO);
-	rt73usb_init_txring(rt2x00dev, RING_AC_VI);
-	rt73usb_init_txring(rt2x00dev, RING_AC_BE);
-	rt73usb_init_txring(rt2x00dev, RING_AC_BK);
-	rt73usb_init_txring(rt2x00dev, RING_PRIO);
-	rt73usb_init_txring(rt2x00dev, RING_BEACON);
-
-	return 0;
-}
-
 static int rt73usb_init_registers(struct rt2x00_dev *rt2x00dev)
 {
 	u32 reg;
@@ -1109,63 +969,64 @@ static int rt73usb_init_registers(struct
 	if (rt2x00dev->ops->lib->set_device_state(rt2x00dev, STATE_AWAKE))
 		return -EBUSY;
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR10, 0x00000718);
+	rt73usb_register_write(rt2x00dev, MAC_CSR10, 0x00000718);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, 0x025eb032);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_DROP_ACK_CTS, 1);
+	rt2x00_set_field32(&reg, TXRX_CSR0_TX_WITHOUT_WAITING, 0);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR1, 0x9eaa9eaf);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR2, 0x8a8b8c8d);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR3, 0x00858687);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR1, 0x9eaa9eaf);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR2, 0x8a8b8c8d);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR3, 0x00858687);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR7, 0x2e31353b);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR8, 0x2a2a2a2c);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR7, 0x2e31353b);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR8, 0x2a2a2a2c);
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR15, 0x0000000f);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);
+	rt73usb_register_write(rt2x00dev, MAC_CSR6, 0x00000fff);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR13, 0x00007f00);
+	rt73usb_register_write(rt2x00dev, MAC_CSR13, 0x00007f00);
 
-	rt2x00_register_write(rt2x00dev, SEC_CSR0, 0x00000000);
-	rt2x00_register_write(rt2x00dev, SEC_CSR1, 0x00000000);
-	rt2x00_register_write(rt2x00dev, SEC_CSR5, 0x00000000);
+	rt73usb_register_write(rt2x00dev, SEC_CSR0, 0x00000000);
+	rt73usb_register_write(rt2x00dev, SEC_CSR1, 0x00000000);
+	rt73usb_register_write(rt2x00dev, SEC_CSR5, 0x00000000);
 
 	reg = 0x000023b0;
 	if (rt2x00_rf(&rt2x00dev->chip, RF5225) ||
 	    rt2x00_rf(&rt2x00dev->chip, RF2527))
 		rt2x00_set_field32(&reg, PHY_CSR1_RF_RPI, 1);
-	rt2x00_register_write(rt2x00dev, PHY_CSR1, reg);
+	rt73usb_register_write(rt2x00dev, PHY_CSR1, reg);
 
-	rt2x00_register_write(rt2x00dev, PHY_CSR5, 0x00040a06);
-	rt2x00_register_write(rt2x00dev, PHY_CSR6, 0x00080606);
-	rt2x00_register_write(rt2x00dev, PHY_CSR7, 0x00000408);
+	rt73usb_register_write(rt2x00dev, PHY_CSR5, 0x00040a06);
+	rt73usb_register_write(rt2x00dev, PHY_CSR6, 0x00080606);
+	rt73usb_register_write(rt2x00dev, PHY_CSR7, 0x00000408);
 
-	rt2x00_register_read(rt2x00dev, AC_TXOP_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, AC_TXOP_CSR0, &reg);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR0_AC0_TX_OP, 0);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR0_AC1_TX_OP, 0);
-	rt2x00_register_write(rt2x00dev, AC_TXOP_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, AC_TXOP_CSR0, reg);
 
-	rt2x00_register_read(rt2x00dev, AC_TXOP_CSR1, &reg);
+	rt73usb_register_read(rt2x00dev, AC_TXOP_CSR1, &reg);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR1_AC2_TX_OP, 192);
 	rt2x00_set_field32(&reg, AC_TXOP_CSR1_AC3_TX_OP, 48);
-	rt2x00_register_write(rt2x00dev, AC_TXOP_CSR1, reg);
+	rt73usb_register_write(rt2x00dev, AC_TXOP_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR9, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR9, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR9_CW_SELECT, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR9, reg);
-
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
-	rt2x00_set_field32(&reg, TXRX_CSR0_AUTO_TX_SEQ, 1);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR9, reg);
 
 	/*
 	 * We must clear the error counters.
 	 * These registers are cleared on read,
 	 * so we may pass a useless variable to store the value.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR0, &reg);
-	rt2x00_register_read(rt2x00dev, STA_CSR1, &reg);
-	rt2x00_register_read(rt2x00dev, STA_CSR2, &reg);
+	rt73usb_register_read(rt2x00dev, STA_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, STA_CSR1, &reg);
+	rt73usb_register_read(rt2x00dev, STA_CSR2, &reg);
 
 	/*
 	 * Reset MAC and BBP registers.
@@ -1173,16 +1034,16 @@ static int rt73usb_init_registers(struct
 	reg = 0;
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 1);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_SOFT_RESET, 0);
 	rt2x00_set_field32(&reg, MAC_CSR1_BBP_RESET, 0);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR1, reg);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR1, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR1, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR1_HOST_READY, 1);
-	rt2x00_register_write(rt2x00dev, MAC_CSR1, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR1, reg);
 
 	return 0;
 }
@@ -1195,7 +1056,7 @@ static int rt73usb_init_bbp(struct rt2x0
 	u8 value;
 
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_bbp_read(rt2x00dev, 0, &value);
+		rt73usb_bbp_read(rt2x00dev, 0, &value);
 		if ((value != 0xff) && (value != 0x00))
 			goto continue_csr_init;
 		NOTICE(rt2x00dev, "Waiting for BBP register.\n");
@@ -1206,32 +1067,32 @@ static int rt73usb_init_bbp(struct rt2x0
 	return -EACCES;
 
 continue_csr_init:
-	rt2x00_bbp_write(rt2x00dev, 3, 0x80);
-	rt2x00_bbp_write(rt2x00dev, 15, 0x30);
-	rt2x00_bbp_write(rt2x00dev, 17, 0x20);
-	rt2x00_bbp_write(rt2x00dev, 21, 0xc8);
-	rt2x00_bbp_write(rt2x00dev, 22, 0x38);
-	rt2x00_bbp_write(rt2x00dev, 23, 0x06);
-	rt2x00_bbp_write(rt2x00dev, 24, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 25, 0x0a);
-	rt2x00_bbp_write(rt2x00dev, 26, 0x0d);
-	rt2x00_bbp_write(rt2x00dev, 32, 0x0b);
-	rt2x00_bbp_write(rt2x00dev, 34, 0x12);
-	rt2x00_bbp_write(rt2x00dev, 37, 0x07);
-	rt2x00_bbp_write(rt2x00dev, 39, 0xf8);
-	rt2x00_bbp_write(rt2x00dev, 41, 0x60);
-	rt2x00_bbp_write(rt2x00dev, 53, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 54, 0x18);
-	rt2x00_bbp_write(rt2x00dev, 60, 0x10);
-	rt2x00_bbp_write(rt2x00dev, 61, 0x04);
-	rt2x00_bbp_write(rt2x00dev, 62, 0x04);
-	rt2x00_bbp_write(rt2x00dev, 75, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 86, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 88, 0xfe);
-	rt2x00_bbp_write(rt2x00dev, 90, 0x0f);
-	rt2x00_bbp_write(rt2x00dev, 99, 0x00);
-	rt2x00_bbp_write(rt2x00dev, 102, 0x16);
-	rt2x00_bbp_write(rt2x00dev, 107, 0x04);
+	rt73usb_bbp_write(rt2x00dev, 3, 0x80);
+	rt73usb_bbp_write(rt2x00dev, 15, 0x30);
+	rt73usb_bbp_write(rt2x00dev, 17, 0x20);
+	rt73usb_bbp_write(rt2x00dev, 21, 0xc8);
+	rt73usb_bbp_write(rt2x00dev, 22, 0x38);
+	rt73usb_bbp_write(rt2x00dev, 23, 0x06);
+	rt73usb_bbp_write(rt2x00dev, 24, 0xfe);
+	rt73usb_bbp_write(rt2x00dev, 25, 0x0a);
+	rt73usb_bbp_write(rt2x00dev, 26, 0x0d);
+	rt73usb_bbp_write(rt2x00dev, 32, 0x0b);
+	rt73usb_bbp_write(rt2x00dev, 34, 0x12);
+	rt73usb_bbp_write(rt2x00dev, 37, 0x07);
+	rt73usb_bbp_write(rt2x00dev, 39, 0xf8);
+	rt73usb_bbp_write(rt2x00dev, 41, 0x60);
+	rt73usb_bbp_write(rt2x00dev, 53, 0x10);
+	rt73usb_bbp_write(rt2x00dev, 54, 0x18);
+	rt73usb_bbp_write(rt2x00dev, 60, 0x10);
+	rt73usb_bbp_write(rt2x00dev, 61, 0x04);
+	rt73usb_bbp_write(rt2x00dev, 62, 0x04);
+	rt73usb_bbp_write(rt2x00dev, 75, 0xfe);
+	rt73usb_bbp_write(rt2x00dev, 86, 0xfe);
+	rt73usb_bbp_write(rt2x00dev, 88, 0xfe);
+	rt73usb_bbp_write(rt2x00dev, 90, 0x0f);
+	rt73usb_bbp_write(rt2x00dev, 99, 0x00);
+	rt73usb_bbp_write(rt2x00dev, 102, 0x16);
+	rt73usb_bbp_write(rt2x00dev, 107, 0x04);
 
 	DEBUG(rt2x00dev, "Start initialization from EEPROM...\n");
 	for (i = 0; i < EEPROM_BBP_SIZE; i++) {
@@ -1242,7 +1103,7 @@ continue_csr_init:
 			value = rt2x00_get_field16(eeprom, EEPROM_BBP_VALUE);
 			DEBUG(rt2x00dev, "BBP: 0x%02x, value: 0x%02x.\n",
 				reg_id, value);
-			rt2x00_bbp_write(rt2x00dev, reg_id, value);
+			rt73usb_bbp_write(rt2x00dev, reg_id, value);
 		}
 	}
 	DEBUG(rt2x00dev, "...End initialization from EEPROM.\n");
@@ -1258,32 +1119,24 @@ static void rt73usb_toggle_rx(struct rt2
 {
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR0, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR0_DISABLE_RX,
 		state == STATE_RADIO_RX_OFF);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR0, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR0, reg);
 }
 
 static int rt73usb_enable_radio(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring;
-	unsigned int i;
-
 	/*
 	 * Initialize all registers.
 	 */
-	if (rt73usb_init_rings(rt2x00dev) ||
-	    rt73usb_init_registers(rt2x00dev) ||
+	if (rt73usb_init_registers(rt2x00dev) ||
 	    rt73usb_init_bbp(rt2x00dev)) {
 		ERROR(rt2x00dev, "Register initialization failed.\n");
 		return -EIO;
 	}
 
-	ring = &rt2x00dev->ring[RING_RX];
-	for (i = 0; i < ring->stats.limit; i++) {
-		__set_bit(ENTRY_OWNER_NIC, &ring->entry[i].flags);
-		usb_submit_urb(ring->entry[i].priv, GFP_ATOMIC);
-	}
+	rt2x00usb_enable_radio(rt2x00dev);
 
 	/*
 	 * Enable LED
@@ -1295,54 +1148,19 @@ static int rt73usb_enable_radio(struct r
 
 static void rt73usb_disable_radio(struct rt2x00_dev *rt2x00dev)
 {
-	struct data_ring *ring;
-	unsigned int i;
-
 	/*
 	 * Disable LED
 	 */
 	rt73usb_disable_led(rt2x00dev);
 
-	rt2x00_register_write(rt2x00dev, MAC_CSR10, 0x00001818);
+	rt73usb_register_write(rt2x00dev, MAC_CSR10, 0x00001818);
 
 	/*
 	 * Disable synchronisation.
 	 */
-	rt2x00_register_write(rt2x00dev, TXRX_CSR9, 0);
-
-	/*
-	 * Cancel RX and TX.
-	 */
-	rt2x00_vendor_request(rt2x00dev, USB_RX_CONTROL,
-		USB_VENDOR_REQUEST_OUT, 0x00, 0x00, NULL, 0, REGISTER_TIMEOUT);
-
-	ring = &rt2x00dev->ring[RING_RX];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_AC_VO];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_AC_VI];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_AC_BE];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_AC_BK];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
-
-	ring = &rt2x00dev->ring[RING_PRIO];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR9, 0);
 
-	ring = &rt2x00dev->ring[RING_BEACON];
-	for (i = 0; i < ring->stats.limit; i++)
-		usb_kill_urb(ring->entry[i].priv);
+	rt2x00usb_disable_radio(rt2x00dev);
 }
 
 static int rt73usb_set_state(struct rt2x00_dev *rt2x00dev,
@@ -1356,17 +1174,17 @@ static int rt73usb_set_state(struct rt2x
 	put_to_sleep = (state != STATE_AWAKE);
 
 	if (!put_to_sleep)
-		rt2x00_vendor_request(rt2x00dev,
+		rt2x00usb_vendor_request(rt2x00dev,
 			USB_DEVICE_MODE, USB_VENDOR_REQUEST_OUT,
 			0x00, USB_MODE_WAKEUP, NULL, 0, REGISTER_TIMEOUT);
 
-	rt2x00_register_read(rt2x00dev, MAC_CSR12, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR12, &reg);
 	rt2x00_set_field32(&reg, MAC_CSR12_FORCE_WAKEUP, !put_to_sleep);
 	rt2x00_set_field32(&reg, MAC_CSR12_PUT_TO_SLEEP, put_to_sleep);
-	rt2x00_register_write(rt2x00dev, MAC_CSR12, reg);
+	rt73usb_register_write(rt2x00dev, MAC_CSR12, reg);
 
 	if (put_to_sleep)
-		rt2x00_vendor_request(rt2x00dev,
+		rt2x00usb_vendor_request(rt2x00dev,
 			USB_DEVICE_MODE, USB_VENDOR_REQUEST_OUT,
 			0x00, USB_MODE_SLEEP, NULL, 0, REGISTER_TIMEOUT);
 
@@ -1376,7 +1194,7 @@ static int rt73usb_set_state(struct rt2x
 	 * device has entered the correct state.
 	 */
 	for (i = 0; i < REGISTER_BUSY_COUNT; i++) {
-		rt2x00_register_read(rt2x00dev, MAC_CSR12, &reg);
+		rt73usb_register_read(rt2x00dev, MAC_CSR12, &reg);
 		current_state = rt2x00_get_field32(reg,
 			MAC_CSR12_BBP_CURRENT_STATE);
 		if (current_state == !put_to_sleep)
@@ -1483,82 +1301,92 @@ static void rt73usb_kick_tx_queue(struct
 	if (queue != IEEE80211_TX_QUEUE_BEACON)
 		return;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR9, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR9, &reg);
 	if (!rt2x00_get_field32(reg, TXRX_CSR9_BEACON_GEN)) {
 		rt2x00_set_field32(&reg, TXRX_CSR9_BEACON_GEN, 1);
-		rt2x00_register_write(rt2x00dev, TXRX_CSR9, reg);
+		rt73usb_register_write(rt2x00dev, TXRX_CSR9, reg);
 	}
 }
 
 /*
- * Interrupt functions.
+ * RX control handlers
  */
-static void rt73usb_interrupt_rxdone(struct urb *urb)
+static int rt73usb_agc_to_rssi(struct rt2x00_dev *rt2x00dev, int rxd_w1)
+{
+	u16 eeprom;
+	char offset;
+	char lna;
+
+	lna = rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_LNA);
+	switch (lna) {
+		case 3:
+			offset = 90;
+		break;
+		case 2:
+			offset = 74;
+		break;
+		case 1:
+			offset = 64;
+		break;
+		default:
+			return 0;
+	}
+
+	if (rt2x00dev->rx_status.phymode == MODE_IEEE80211A) {
+		if (test_bit(CONFIG_EXTERNAL_LNA, &rt2x00dev->flags)) {
+			if (lna == 3 || lna == 2)
+				offset += 10;
+		} else {
+			if (lna == 3)
+				offset += 6;
+			else if (lna == 2)
+				offset += 8;
+		}
+
+		rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &eeprom);
+		offset -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_A_1);
+	} else {
+		if (test_bit(CONFIG_EXTERNAL_LNA, &rt2x00dev->flags))
+			offset += 14;
+
+		rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &eeprom);
+		offset -= rt2x00_get_field16(eeprom, EEPROM_RSSI_OFFSET_BG_1);
+	}
+
+	return rt2x00_get_field32(rxd_w1, RXD_W1_RSSI_AGC) * 2 - offset;
+}
+
+static int rt73usb_fill_rxdone(struct data_entry *entry,
+	int *signal, int *rssi, int *ofdm)
 {
-	struct data_entry *entry = (struct data_entry*)urb->context;
-	struct data_ring *ring = entry->ring;
-	struct rt2x00_dev *rt2x00dev = ring->rt2x00dev;
 	struct data_desc *rxd = (struct data_desc*)entry->skb->data;
 	u32 word0;
 	u32 word1;
-	int signal;
-	int rssi;
-	int ofdm;
-	u16 size;
-
-	if (!test_bit(DEVICE_ENABLED_RADIO, &rt2x00dev->flags) ||
-	    !__test_and_clear_bit(ENTRY_OWNER_NIC, &entry->flags))
-		return;
-
-	/*
-	 * Check if the received data is simply too small
-	 * to be actually valid, or if the urb is signaling
-	 * a problem.
-	 */
-	if (urb->actual_length < entry->ring->desc_size || urb->status)
-		goto skip_entry;
 
 	rt2x00_desc_read(rxd, 0, &word0);
 	rt2x00_desc_read(rxd, 1, &word1);
 
 	/*
 	 * TODO: Don't we need to keep statistics
-	 * updated about events like CRC and physical errors?
+	 * updated about these errors?
 	 */
 	if (rt2x00_get_field32(word0, RXD_W0_CRC) ||
 	    rt2x00_get_field32(word0, RXD_W0_CIPHER_ERROR))
-		goto skip_entry;
+		return -EINVAL;
 
 	/*
 	 * Obtain the status about this packet.
 	 */
-	size = rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
-	signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
-	rssi = rt2x00_get_field32(word1, RXD_W1_RSSI);
-	ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
+	*signal = rt2x00_get_field32(word1, RXD_W1_SIGNAL);
+	*rssi = rt73usb_agc_to_rssi(entry->ring->rt2x00dev, word1);
+	*ofdm = rt2x00_get_field32(word0, RXD_W0_OFDM);
 
 	/*
-	 * Trim the skb_buffer to only contain the valid
-	 * frame data (so ignore the device's descriptor).
+	 * Pull the skb to clear the descriptor area.
 	 */
-	skb_pull(entry->skb, ring->desc_size);
-	skb_trim(entry->skb, size);
+	skb_pull(entry->skb, entry->ring->desc_size);
 
-	/*
-	 * Send the packet to upper layer, and update urb.
-	 */
-	rt2x00lib_rxdone(entry, NULL, ring->data_size + ring->desc_size,
-		signal, rssi, ofdm);
-	urb->transfer_buffer = entry->skb->data;
-	urb->transfer_buffer_length = entry->skb->len;
-
-skip_entry:
-	if (test_bit(DEVICE_ENABLED_RADIO, &ring->rt2x00dev->flags)) {
-		__set_bit(ENTRY_OWNER_NIC, &rt2x00dev->flags);
-		usb_submit_urb(urb, GFP_ATOMIC);
-	}
-
-	rt2x00_ring_index_inc(ring);
+	return rt2x00_get_field32(word0, RXD_W0_DATABYTE_COUNT);
 }
 
 /*
@@ -1567,6 +1395,8 @@ skip_entry:
 static int rt73usb_alloc_eeprom(struct rt2x00_dev *rt2x00dev)
 {
 	u16 word;
+	u8 *mac;
+	char value;
 
 	/*
 	 * Allocate the eeprom memory, check the eeprom width
@@ -1576,7 +1406,7 @@ static int rt73usb_alloc_eeprom(struct r
 	if (!rt2x00dev->eeprom)
 		return -ENOMEM;
 
-	rt2x00_vendor_request(
+	rt2x00usb_vendor_request(
 		rt2x00dev, USB_EEPROM_READ, USB_VENDOR_REQUEST_IN,
 		EEPROM_BASE, 0x00, rt2x00dev->eeprom, EEPROM_SIZE,
 		REGISTER_TIMEOUT * (EEPROM_SIZE / sizeof(u16)));
@@ -1584,6 +1414,12 @@ static int rt73usb_alloc_eeprom(struct r
 	/*
 	 * Start validation of the data that has been read.
 	 */
+	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
+	if (!is_valid_ether_addr(mac)) {
+		random_ether_addr(mac);
+		EEPROM(rt2x00dev, "MAC: " MAC_FMT "\n", MAC_ARG(mac));
+	}
+
 	rt2x00_eeprom_read(rt2x00dev, EEPROM_ANTENNA, &word);
 	if (word == 0xffff) {
 		rt2x00_set_field16(&word, EEPROM_ANTENNA_NUM, 2);
@@ -1628,6 +1464,38 @@ static int rt73usb_alloc_eeprom(struct r
 		EEPROM(rt2x00dev, "Freq: 0x%04x\n", word);
 	}
 
+	rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_BG, &word);
+	if (word == 0xffff) {
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);
+		EEPROM(rt2x00dev, "RSSI OFFSET BG: 0x%04x\n", word);
+	} else {
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_1);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_1, 0);
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_BG_2);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_BG_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_BG, word);
+	}
+
+	rt2x00_eeprom_read(rt2x00dev, EEPROM_RSSI_OFFSET_A, &word);
+	if (word == 0xffff) {
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);
+		rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);
+		EEPROM(rt2x00dev, "RSSI OFFSET BG: 0x%04x\n", word);
+	} else {
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_1);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_1, 0);
+		value = rt2x00_get_field16(word, EEPROM_RSSI_OFFSET_A_2);
+		if (value < -10 || value > 10)
+			rt2x00_set_field16(&word, EEPROM_RSSI_OFFSET_A_2, 0);
+		rt2x00_eeprom_write(rt2x00dev, EEPROM_RSSI_OFFSET_A, word);
+	}
+
 	return 0;
 }
 
@@ -1646,7 +1514,7 @@ static int rt73usb_init_eeprom(struct rt
 	 * Identify RF chipset.
 	 */
 	value = rt2x00_get_field16(eeprom, EEPROM_ANTENNA_RF_TYPE);
-	rt2x00_register_read(rt2x00dev, MAC_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, MAC_CSR0, &reg);
 	rt2x00_set_chip(rt2x00dev, RT2571, value, reg);
 
 	if (!rt2x00_rf(&rt2x00dev->chip, RF5226) &&
@@ -1759,11 +1627,16 @@ static void rt73usb_init_hw_mode(struct 
 		IEEE80211_HW_WEP_INCLUDE_IV |
 		IEEE80211_HW_DATA_NULLFUNC_ACK |
 		IEEE80211_HW_NO_TKIP_WMM_HWACCEL |
-		IEEE80211_HW_MONITOR_DURING_OPER;
+		IEEE80211_HW_MONITOR_DURING_OPER |
+		IEEE80211_HW_NO_PROBE_FILTERING;
 	rt2x00dev->hw->extra_tx_headroom = TXD_DESC_SIZE;
 	rt2x00dev->hw->max_rssi = MAX_RX_SSI;
 	rt2x00dev->hw->max_noise = MAX_RX_NOISE;
-	rt2x00dev->hw->queues = RING_NUM_TX;
+	rt2x00dev->hw->queues = 5;
+
+	SET_IEEE80211_DEV(rt2x00dev->hw, &rt2x00dev_usb(rt2x00dev)->dev);
+	SET_IEEE80211_PERM_ADDR(rt2x00dev->hw,
+		rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0));
 
 	/*
 	 * Set device specific, but channel independent RF values.
@@ -1785,7 +1658,6 @@ static void rt73usb_init_hw_mode(struct 
 	/*
 	 * Initialize hw_mode information.
 	 */
-	spec->mac_addr = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
 	spec->num_modes = 2;
 	spec->num_rates = 12;
 	spec->num_channels = 14;
@@ -1830,10 +1702,15 @@ static int rt73usb_init_hw(struct rt2x00
 	rt73usb_init_hw_mode(rt2x00dev);
 
 	/*
-	 * rt73usb requires firmware
+	 * This device requires firmware
 	 */
 	__set_bit(FIRMWARE_REQUIRED, &rt2x00dev->flags);
 
+	/*
+	 * Set the rssi offset.
+	 */
+	rt2x00dev->rssi_offset = DEFAULT_RSSI_OFFSET;
+
 	return 0;
 }
 
@@ -1851,7 +1728,7 @@ static int rt73usb_get_stats(struct ieee
 	 * The dot11ACKFailureCount, dot11RTSFailureCount and
 	 * dot11RTSSuccessCount are updated in interrupt time.
 	 */
-	rt2x00_register_read(rt2x00dev, STA_CSR0, &reg);
+	rt73usb_register_read(rt2x00dev, STA_CSR0, &reg);
 	rt2x00dev->low_level_stats.dot11FCSErrorCount +=
 		rt2x00_get_field32(reg, STA_CSR0_FCS_ERROR);
 
@@ -1866,10 +1743,10 @@ static int rt73usb_set_retry_limit(struc
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR4, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR4, &reg);
 	rt2x00_set_field32(&reg, TXRX_CSR4_LONG_RETRY_LIMIT, long_retry);
 	rt2x00_set_field32(&reg, TXRX_CSR4_SHORT_RETRY_LIMIT, short_retry);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR4, reg);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR4, reg);
 
 	return 0;
 }
@@ -1880,9 +1757,9 @@ static u64 rt73usb_get_tsf(struct ieee80
 	u64 tsf;
 	u32 reg;
 
-	rt2x00_register_read(rt2x00dev, TXRX_CSR13, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR13, &reg);
 	tsf = (u64)rt2x00_get_field32(reg, TXRX_CSR13_HIGH_TSFTIMER) << 32;
-	rt2x00_register_read(rt2x00dev, TXRX_CSR12, &reg);
+	rt73usb_register_read(rt2x00dev, TXRX_CSR12, &reg);
 	tsf |= rt2x00_get_field32(reg, TXRX_CSR12_LOW_TSFTIMER);
 
 	return tsf;
@@ -1892,15 +1769,13 @@ static void rt73usb_reset_tsf(struct iee
 {
 	struct rt2x00_dev *rt2x00dev = hw->priv;
 
-	rt2x00_register_write(rt2x00dev, TXRX_CSR12, 0);
-	rt2x00_register_write(rt2x00dev, TXRX_CSR13, 0);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR12, 0);
+	rt73usb_register_write(rt2x00dev, TXRX_CSR13, 0);
 }
 
 static const struct ieee80211_ops rt73usb_mac80211_ops = {
 	.tx			= rt2x00lib_tx,
 	.reset			= rt2x00lib_reset,
-	.open			= rt2x00lib_open,
-	.stop			= rt2x00lib_stop,
 	.add_interface		= rt2x00lib_add_interface,
 	.remove_interface	= rt2x00lib_remove_interface,
 	.config			= rt2x00lib_config,
@@ -1926,6 +1801,7 @@ static const struct rt2x00lib_ops rt73us
 	.write_tx_desc		= rt73usb_write_tx_desc,
 	.write_tx_data		= rt2x00usb_write_tx_data,
 	.kick_tx_queue		= rt73usb_kick_tx_queue,
+	.fill_rxdone		= rt73usb_fill_rxdone,
 	.config_type		= rt73usb_config_type,
 	.config_phymode		= rt73usb_config_phymode,
 	.config_channel		= rt73usb_config_channel,
@@ -2015,12 +1891,6 @@ MODULE_DEVICE_TABLE(usb, rt73usb_device_
 MODULE_FIRMWARE(FIRMWARE_RT2571);
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RT2X00_DEBUG
-int rt2x00_debug_level = 0;
-module_param_named(debug, rt2x00_debug_level, bool, S_IWUSR | S_IRUGO);
-MODULE_PARM_DESC(debug, "Set this parameter to 1 to enable debug output.");
-#endif /* CONFIG_RT2X00_DEBUG */
-
 static struct usb_driver rt73usb_driver = {
 	.name		= DRV_NAME,
 	.id_table	= rt73usb_device_table,
@@ -2034,14 +1904,11 @@ static struct usb_driver rt73usb_driver 
 
 static int __init rt73usb_init(void)
 {
-	printk(KERN_INFO "Loading module: %s - %s by %s.\n",
-		DRV_NAME, DRV_VERSION, DRV_PROJECT);
 	return usb_register(&rt73usb_driver);
 }
 
 static void __exit rt73usb_exit(void)
 {
-	printk(KERN_INFO "Unloading module: %s.\n", DRV_NAME);
 	usb_deregister(&rt73usb_driver);
 }
 
--- a/drivers/net/wireless/mac80211/rt2x00/rt73usb.h	2007-07-09 14:29:36.000000000 +0200
+++ b/drivers/net/wireless/mac80211/rt2x00/rt73usb.h	2007-07-09 21:00:14.000000000 +0200
@@ -36,10 +36,11 @@
 #define RF2527				0x0004
 
 /*
- * Max RSSI value, required for RSSI <-> dBm conversion.
+ * Signal information.
  */
-#define MAX_RX_SSI			120
+#define MAX_RX_SSI			-1
 #define MAX_RX_NOISE			-110
+#define DEFAULT_RSSI_OFFSET		120
 
 /*
  * Register layout information.
@@ -749,6 +750,48 @@ struct hw_pairwise_ta_entry {
 #define EEPROM_TXPOWER_A_2		FIELD16(0xff00)
 
 /*
+ * EEPROM RSSI offset 802.11BG
+ */
+#define EEPROM_RSSI_OFFSET_BG		0x004d
+#define EEPROM_RSSI_OFFSET_BG_1		FIELD16(0x00ff)
+#define EEPROM_RSSI_OFFSET_BG_2		FIELD16(0xff00)
+
+/*
+ * EEPROM RSSI offset 802.11A
+ */
+#define EEPROM_RSSI_OFFSET_A		0x004e
+#define EEPROM_RSSI_OFFSET_A_1		FIELD16(0x00ff)
+#define EEPROM_RSSI_OFFSET_A_2		FIELD16(0xff00)
+
+/*
+ * BBP content.
+ * The wordsize of the BBP is 8 bits.
+ */
+
+/*
+ * BBP_R2
+ */
+#define BBP_R2_BG_MODE			FIELD8(0x20)
+
+/*
+ * BBP_R3
+ */
+#define BBP_R3_SMART_MODE		FIELD8(0x01)
+
+/*
+ * BBP_R4: RX antenna control
+ * FRAME_END: 1 - DPDT, 0 - SPDT (Only valid for 802.11G, RF2527 & RF2529)
+ */
+#define BBP_R4_RX_ANTENNA		FIELD8(0x03)
+#define BBP_R4_RX_FRAME_END		FIELD8(0x10)
+#define BBP_R4_RX_BG_MODE		FIELD8(0x20)
+
+/*
+ * BBP_R77
+ */
+#define BBP_R77_PAIR			FIELD8(0x03)
+
+/*
  * DMA descriptor defines.
  */
 #define TXD_DESC_SIZE			( 6 * sizeof(struct data_desc) )
@@ -858,7 +901,8 @@ struct hw_pairwise_ta_entry {
  * RSSI: RSSI reported by BBP.
  */
 #define RXD_W1_SIGNAL			FIELD32(0x000000ff)
-#define RXD_W1_RSSI			FIELD32(0x0000ff00)
+#define RXD_W1_RSSI_AGC			FIELD32(0x00001f00)
+#define RXD_W1_RSSI_LNA			FIELD32(0x00006000)
 #define RXD_W1_FRAME_OFFSET		FIELD32(0x7f000000)
 
 /*
@@ -891,21 +935,6 @@ struct hw_pairwise_ta_entry {
 #define RXD_W5_RESERVED			FIELD32(0xffffffff)
 
 /*
- * TX ring index number for rt2x00_dev structure.
- */
-enum ring_index {
-	RING_AC_VO = 0,
-	RING_AC_VI = 1,
-	RING_AC_BE = 2,
-	RING_AC_BK = 3,
-	RING_PRIO = 4,
-	RING_BEACON = 5,
-	RING_RX = 6,
-	RING_NUM = 7,
-	RING_NUM_TX = 5,
-};
-
-/*
  * Macro's for converting txpower from EEPROM to dscape value
  * and from dscape value to register value.
  */
@@ -926,9 +955,4 @@ enum ring_index {
 	(__txpower));					\
 })
 
-/*
- * Interrupt functions.
- */
-static void rt73usb_interrupt_rxdone(struct urb *urb);
-
 #endif /* RT73USB_H */
