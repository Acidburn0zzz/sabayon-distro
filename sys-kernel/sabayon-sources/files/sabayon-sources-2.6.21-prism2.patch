diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/Kconfig linux-2.6.20-sabayon-r2/drivers/net/wireless/Kconfig
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/Kconfig	2007-02-27 20:59:15.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/Kconfig	2007-02-27 23:44:58.000000000 +0100
@@ -539,6 +539,7 @@ config USB_ZD1201
 	  module will be called zd1201.
 
 source "drivers/net/wireless/hostap/Kconfig"
+source "drivers/net/wireless/prism2/Kconfig"
 source "drivers/net/wireless/bcm43xx/Kconfig"
 source "drivers/net/wireless/zd1211rw/Kconfig"
 source "drivers/net/wireless/d80211/Kconfig"
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/hfa384x.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/hfa384x.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/hfa384x.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/hfa384x.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,4014 @@
+/* src/prism2/driver/hfa384x.c
+*
+* Implements the functions of the Intersil hfa384x MAC
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file implements functions that correspond to the prism2/hfa384x
+* 802.11 MAC hardware and firmware host interface.
+*
+* The functions can be considered to represent several levels of 
+* abstraction.  The lowest level functions are simply C-callable wrappers
+* around the register accesses.  The next higher level represents C-callable
+* prism2 API functions that match the Intersil documentation as closely
+* as is reasonable.  The next higher layer implements common sequences 
+* of invokations of the API layer (e.g. write to bap, followed by cmd).
+*
+* Common sequences:
+* hfa384x_drvr_xxx	Highest level abstractions provided by the 
+*			hfa384x code.  They are driver defined wrappers 
+*			for common sequences.  These functions generally
+*			use the services of the lower levels.
+*
+* hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
+*			functions are wrappers for the RID get/set 
+*			sequence. They 	call copy_[to|from]_bap() and 
+*			cmd_access().	These functions operate on the 
+*			RIDs and buffers without validation.  The caller
+*			is responsible for that.
+*
+* API wrapper functions:
+* hfa384x_cmd_xxx	functions that provide access to the f/w commands.  
+*			The function arguments correspond to each command
+*			argument, even command arguments that get packed
+*			into single registers.  These functions _just_
+*			issue the command by setting the cmd/parm regs
+*			& reading the status/resp regs.  Additional
+*			activities required to fully use a command
+*			(read/write from/to bap, get/set int status etc.)
+*			are implemented separately.  Think of these as
+*			C-callable prism2 commands.
+*
+* Lowest Layer Functions:
+* hfa384x_docmd_xxx	These functions implement the sequence required
+*			to issue any prism2 command.  Primarily used by the
+*			hfa384x_cmd_xxx functions.
+*
+* hfa384x_bap_xxx	BAP read/write access functions.
+*			Note: we usually use BAP0 for non-interrupt context
+*			 and BAP1 for interrupt context.
+*
+* hfa384x_dl_xxx	download related functions.
+*                 	
+* Driver State Issues:
+* Note that there are two pairs of functions that manage the
+* 'initialized' and 'running' states of the hw/MAC combo.  The four
+* functions are create(), destroy(), start(), and stop().  create()
+* sets up the data structures required to support the hfa384x_*
+* functions and destroy() cleans them up.  The start() function gets
+* the actual hardware running and enables the interrupts.  The stop()
+* function shuts the hardware down.  The sequence should be:
+* create()
+*  .
+*  .  Self contained test routines can run here, particularly
+*  .  corereset() and test_hostif().
+*  .
+* start()
+*  .
+*  .  Do interesting things w/ the hardware
+*  .
+* stop()
+* destroy()
+*
+* Note that destroy() can be called without calling stop() first.
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+#include <wlan/version.h>
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <asm/semaphore.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <linux/list.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) )
+#include <pcmcia/version.h>
+#endif
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+#endif
+
+#if ((WLAN_HOSTIF == WLAN_PLX) || (WLAN_HOSTIF == WLAN_PCI))
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#endif
+
+#include <wlan/wlan_compat.h>
+
+// XXXX #define CMD_IRQ
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211req.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+#include <prism2/hfa384x.h>
+#include <prism2/prism2mgmt.h>
+
+/*================================================================*/
+/* Local Constants */
+
+const UINT16 crc16tab[256] =
+{
+	0x0000, 0xc0c1, 0xc181, 0x0140, 0xc301, 0x03c0, 0x0280, 0xc241,
+	0xc601, 0x06c0, 0x0780, 0xc741, 0x0500, 0xc5c1, 0xc481, 0x0440,
+	0xcc01, 0x0cc0, 0x0d80, 0xcd41, 0x0f00, 0xcfc1, 0xce81, 0x0e40,
+	0x0a00, 0xcac1, 0xcb81, 0x0b40, 0xc901, 0x09c0, 0x0880, 0xc841,
+	0xd801, 0x18c0, 0x1980, 0xd941, 0x1b00, 0xdbc1, 0xda81, 0x1a40,
+	0x1e00, 0xdec1, 0xdf81, 0x1f40, 0xdd01, 0x1dc0, 0x1c80, 0xdc41,
+	0x1400, 0xd4c1, 0xd581, 0x1540, 0xd701, 0x17c0, 0x1680, 0xd641,
+	0xd201, 0x12c0, 0x1380, 0xd341, 0x1100, 0xd1c1, 0xd081, 0x1040,
+	0xf001, 0x30c0, 0x3180, 0xf141, 0x3300, 0xf3c1, 0xf281, 0x3240,
+	0x3600, 0xf6c1, 0xf781, 0x3740, 0xf501, 0x35c0, 0x3480, 0xf441,
+	0x3c00, 0xfcc1, 0xfd81, 0x3d40, 0xff01, 0x3fc0, 0x3e80, 0xfe41,
+	0xfa01, 0x3ac0, 0x3b80, 0xfb41, 0x3900, 0xf9c1, 0xf881, 0x3840,
+	0x2800, 0xe8c1, 0xe981, 0x2940, 0xeb01, 0x2bc0, 0x2a80, 0xea41,
+	0xee01, 0x2ec0, 0x2f80, 0xef41, 0x2d00, 0xedc1, 0xec81, 0x2c40,
+	0xe401, 0x24c0, 0x2580, 0xe541, 0x2700, 0xe7c1, 0xe681, 0x2640,
+	0x2200, 0xe2c1, 0xe381, 0x2340, 0xe101, 0x21c0, 0x2080, 0xe041,
+	0xa001, 0x60c0, 0x6180, 0xa141, 0x6300, 0xa3c1, 0xa281, 0x6240,
+	0x6600, 0xa6c1, 0xa781, 0x6740, 0xa501, 0x65c0, 0x6480, 0xa441,
+	0x6c00, 0xacc1, 0xad81, 0x6d40, 0xaf01, 0x6fc0, 0x6e80, 0xae41,
+	0xaa01, 0x6ac0, 0x6b80, 0xab41, 0x6900, 0xa9c1, 0xa881, 0x6840,
+	0x7800, 0xb8c1, 0xb981, 0x7940, 0xbb01, 0x7bc0, 0x7a80, 0xba41,
+	0xbe01, 0x7ec0, 0x7f80, 0xbf41, 0x7d00, 0xbdc1, 0xbc81, 0x7c40,
+	0xb401, 0x74c0, 0x7580, 0xb541, 0x7700, 0xb7c1, 0xb681, 0x7640,
+	0x7200, 0xb2c1, 0xb381, 0x7340, 0xb101, 0x71c0, 0x7080, 0xb041,
+	0x5000, 0x90c1, 0x9181, 0x5140, 0x9301, 0x53c0, 0x5280, 0x9241,
+	0x9601, 0x56c0, 0x5780, 0x9741, 0x5500, 0x95c1, 0x9481, 0x5440,
+	0x9c01, 0x5cc0, 0x5d80, 0x9d41, 0x5f00, 0x9fc1, 0x9e81, 0x5e40,
+	0x5a00, 0x9ac1, 0x9b81, 0x5b40, 0x9901, 0x59c0, 0x5880, 0x9841,
+	0x8801, 0x48c0, 0x4980, 0x8941, 0x4b00, 0x8bc1, 0x8a81, 0x4a40,
+	0x4e00, 0x8ec1, 0x8f81, 0x4f40, 0x8d01, 0x4dc0, 0x4c80, 0x8c41,
+	0x4400, 0x84c1, 0x8581, 0x4540, 0x8701, 0x47c0, 0x4680, 0x8641,
+	0x8201, 0x42c0, 0x4380, 0x8341, 0x4100, 0x81c1, 0x8081, 0x4040
+};
+
+/*================================================================*/
+/* Local Macros */
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+extern int prism2_debug;
+
+/*================================================================*/
+/* Local Function Declarations */
+
+static void	hfa384x_int_dtim(wlandevice_t *wlandev);
+static void	hfa384x_int_infdrop(wlandevice_t *wlandev);
+
+static void     hfa384x_bap_tasklet(unsigned long data);
+
+static void	hfa384x_int_info(wlandevice_t *wlandev);
+static void	hfa384x_int_txexc(wlandevice_t *wlandev);
+static void	hfa384x_int_tx(wlandevice_t *wlandev);
+static void	hfa384x_int_rx(wlandevice_t *wlandev);
+
+#ifdef CMD_IRQ
+static void	hfa384x_int_cmd(wlandevice_t *wlandev);
+#endif
+static void	hfa384x_int_rxmonitor( wlandevice_t *wlandev, 
+			UINT16 rxfid, hfa384x_rx_frame_t *rxdesc);
+static void	hfa384x_int_alloc(wlandevice_t *wlandev);
+
+static int hfa384x_docmd_wait( hfa384x_t *hw, hfa384x_metacmd_t *cmd);
+
+static int hfa384x_dl_docmd_wait( hfa384x_t *hw, hfa384x_metacmd_t *cmd);
+
+static UINT16 
+hfa384x_mkcrc16(UINT8 *p, int len);
+
+int hfa384x_copy_to_bap4(hfa384x_t *hw, UINT16 bap, UINT16 id, UINT16 offset,
+			 void *buf, UINT len, void* buf2, UINT len2,
+			 void *buf3, UINT len3, void* buf4, UINT len4);
+
+/*================================================================*/
+/* Function Definitions */
+
+UINT16
+txfid_queue_empty(hfa384x_t *hw)
+{
+	return (hw->txfid_head == hw->txfid_tail) ? 1 : 0;
+}
+
+UINT16
+txfid_queue_remove(hfa384x_t *hw)
+{
+	UINT16 result= 0;
+
+	if (txfid_queue_empty(hw)) {
+		WLAN_LOG_DEBUG(3,"queue empty.\n");
+	} else {
+		result = hw->txfid_queue[hw->txfid_head];
+		hw->txfid_head = (hw->txfid_head + 1) % hw->txfid_N;
+	}
+
+	return (UINT16)result;
+}
+
+INT16
+txfid_queue_add(hfa384x_t *hw, UINT16 val)
+{
+	INT16 result = 0;
+
+	if (hw->txfid_head == ((hw->txfid_tail + 1) % hw->txfid_N)) {
+		result = -1;
+		WLAN_LOG_DEBUG(3,"queue full.\n");
+	} else {
+		hw->txfid_queue[hw->txfid_tail] = val;
+		result = hw->txfid_tail;
+		hw->txfid_tail = (hw->txfid_tail + 1) % hw->txfid_N;
+	}
+
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_create
+*
+* Initializes the hfa384x_t data structure for use.  Note this
+* does _not_ intialize the actual hardware, just the data structures
+* we use to keep track of its state.
+*
+* Arguments:
+*	hw		device structure
+*	irq		device irq number
+*	iobase		[pcmcia] i/o base address for register access
+*			[pci] zero
+*			[plx] i/o base address for register access
+*	membase		[pcmcia] pcmcia_cs "link" pointer
+*			[pci] memory base address for register access
+*			[plx] memory base address for card attribute memory
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+void hfa384x_create( hfa384x_t *hw, UINT irq, UINT32 iobase, UINT8 *membase)
+{
+	DBFENTER;
+	memset(hw, 0, sizeof(hfa384x_t));
+	hw->irq = irq;
+	hw->iobase = iobase;
+	hw->membase = membase;
+	spin_lock_init(&(hw->cmdlock));
+
+	/* BAP setup */
+ 	spin_lock_init(&(hw->baplock));
+	tasklet_init(&hw->bap_tasklet,
+		     hfa384x_bap_tasklet,
+		     (unsigned long) hw);
+
+	init_waitqueue_head(&hw->cmdq);
+	sema_init(&hw->infofid_sem, 1);
+
+        hw->txfid_head = 0;
+        hw->txfid_tail = 0;
+        hw->txfid_N = HFA384x_DRVR_FIDSTACKLEN_MAX;
+        memset(hw->txfid_queue, 0, sizeof(hw->txfid_queue));
+
+	hw->isram16 = 1;
+
+	/* Init the auth queue head */
+	skb_queue_head_init(&hw->authq);
+
+	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
+
+        INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
+
+	init_timer(&hw->commsqual_timer);
+	hw->commsqual_timer.data = (unsigned long) hw;
+	hw->commsqual_timer.function = prism2sta_commsqual_timer;
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_destroy
+*
+* Partner to hfa384x_create().  This function cleans up the hw
+* structure so that it can be freed by the caller using a simple
+* kfree.  Currently, this function is just a placeholder.  If, at some
+* point in the future, an hw in the 'shutdown' state requires a 'deep'
+* kfree, this is where it should be done.  Note that if this function
+* is called on a _running_ hw structure, the drvr_stop() function is
+* called.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	nothing, this function is not allowed to fail.
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+void
+hfa384x_destroy( hfa384x_t *hw)
+{
+	struct sk_buff *skb;
+
+	DBFENTER;
+
+	if ( hw->state == HFA384x_STATE_RUNNING ) {
+		hfa384x_drvr_stop(hw);
+	}
+	hw->state = HFA384x_STATE_PREINIT;		
+
+	if (hw->scanresults) {
+		kfree(hw->scanresults);
+		hw->scanresults = NULL;
+	}
+
+        /* Now to clean out the auth queue */
+        while ( (skb = skb_dequeue(&hw->authq)) ) {
+                dev_kfree_skb(skb);
+        }
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_getconfig
+*
+* Performs the sequence necessary to read a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (host order)
+*	buf		host side record buffer.  Upon return it will
+*			contain the body portion of the record (minus the 
+*			RID and len).
+*	len		buffer length (in bytes, should match record length)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ENODATA 	length mismatch between argument and retrieved
+*			record.
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_getconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	int 		result = 0;
+	DBFENTER;
+
+	result = hfa384x_cmd_access( hw, 0, rid, buf, len);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_setconfig
+*
+* Performs the sequence necessary to write a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (in host order)
+*	buf		host side record buffer
+*	len		buffer length (in bytes)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_setconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	int		result = 0;
+	DBFENTER;
+
+	result = hfa384x_cmd_access( hw, 1, rid, buf, len);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_readpda
+*
+* Performs the sequence to read the PDA space.  Note there is no
+* drvr_writepda() function.  Writing a PDA is
+* generally implemented by a calling component via calls to 
+* cmd_download and writing to the flash download buffer via the 
+* aux regs.
+*
+* Arguments:
+*	hw		device structure
+*	buf		buffer to store PDA in
+*	len		buffer length
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ETIMEOUT	timout waiting for the cmd regs to become
+*			available, or waiting for the control reg
+*			to indicate the Aux port is enabled.
+*	-ENODATA	the buffer does NOT contain a valid PDA.
+*			Either the card PDA is bad, or the auxdata
+*			reads are giving us garbage.
+
+*
+* Side effects:
+*
+* Call context:
+*	process thread or non-card interrupt.
+----------------------------------------------------------------*/
+int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, UINT len)
+{
+	int		result = 0;
+	UINT16		*pda = buf;
+	int		pdaok = 0;
+	int		morepdrs = 1;
+	int		currpdr = 0;	/* word offset of the current pdr */
+	int		i;
+	UINT16		pdrlen;		/* pdr length in bytes, host order */
+	UINT16		pdrcode;	/* pdr code, host order */
+	UINT16		crc;
+	UINT16		pdacrc;
+	struct pdaloc {
+		UINT32	cardaddr;
+		UINT16	auxctl;
+	} pdaloc[] =
+	{
+		{ HFA3842_PDA_BASE,		HFA384x_AUX_CTL_NV},
+		{ HFA3842_PDA_BASE,		HFA384x_AUX_CTL_EXTDS},
+		{ HFA3841_PDA_BASE,		HFA384x_AUX_CTL_NV}, 
+		{ HFA3841_PDA_BASE,		HFA384x_AUX_CTL_EXTDS}, 
+		{ HFA3841_PDA_BOGUS_BASE,	HFA384x_AUX_CTL_NV}
+	};
+
+	DBFENTER;
+	/* Check for aux available */
+	result = hfa384x_cmd_aux_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_DEBUG(1,"aux_enable() failed. result=%d\n", result);
+		goto failed;
+	}
+
+	/* Read the pda from each known address.  */
+	for ( i = 0; i < (sizeof(pdaloc)/sizeof(pdaloc[0])); i++) {
+		WLAN_LOG_DEBUG( 3, "Checking PDA@(0x%08x,%s)\n",
+			pdaloc[i].cardaddr,
+			pdaloc[i].auxctl == HFA384x_AUX_CTL_NV ?
+			"CTL_NV" : "CTL_EXTDS");
+
+		/* Copy bufsize bytes from our current pdaloc */
+		hfa384x_copy_from_aux(hw, 
+			pdaloc[i].cardaddr, 
+			pdaloc[i].auxctl, 
+			buf, 
+			len);
+
+		/* Test for garbage */
+		/* Traverse the PDR list Looking for PDA-END */
+		pdaok = 1;	/* intially assume good */
+		morepdrs = 1;
+		currpdr = 0;
+		while ( pdaok && morepdrs ) {
+			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
+			pdrcode = hfa384x2host_16(pda[currpdr+1]);
+				
+			/* Test for completion at END record */
+			if ( pdrcode == HFA384x_PDR_END_OF_PDA ) {
+				if ( pdrlen == 4 ) { 
+					morepdrs = 0;
+					/* Calculate CRC-16 and compare to PDA
+					 * value.  Note the addition of 2 words
+					 * for ENDREC.len and ENDREC.code
+					 * fields.
+					 */
+					crc = hfa384x_mkcrc16( (UINT8*)pda, 
+						(currpdr + 2) * sizeof(UINT16));
+					pdacrc =hfa384x2host_16(pda[currpdr+2]);
+					if ( crc != pdacrc ) {
+						WLAN_LOG_DEBUG(3,
+						"PDA crc failed:"
+						"calc_crc=0x%04x,"
+						"pdr_crc=0x%04x.\n",
+						crc, pdacrc);
+						pdaok = 0;
+					}
+				} else {
+					WLAN_LOG_DEBUG(3, 
+					"END record detected w/ "
+					"len(%d) != 2, assuming bad PDA\n",
+					pdrlen);
+					pdaok = 0;
+
+				}
+				break;
+			}
+	
+			/* Test the record length */
+			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
+				WLAN_LOG_DEBUG(3,
+					"pdrlen for address #%d "
+					"at %#x:%#x:%d\n",
+					i, pdaloc[i].cardaddr, 
+					pdaloc[i].auxctl, pdrlen);
+				WLAN_LOG_DEBUG(3,"pdrlen invalid=%d\n", 
+					pdrlen);
+				pdaok = 0;
+				break;
+			}
+
+			/* Move to the next pdr */
+			if ( morepdrs ) {
+				/* note the access to pda[], we need words */
+				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
+				if (currpdr*sizeof(UINT16) > len) {
+					WLAN_LOG_DEBUG(3,
+					"Didn't find PDA_END in buffer, "
+					"trying next location.\n");
+					pdaok = 0;
+					break;
+				}
+			}
+		}	
+		if ( pdaok ) {
+			WLAN_LOG_INFO(
+				"PDA Read from 0x%08x in %s space.\n",
+				pdaloc[i].cardaddr, 
+				pdaloc[i].auxctl == 0 ? "EXTDS" :
+				pdaloc[i].auxctl == 1 ? "NV" :
+				pdaloc[i].auxctl == 2 ? "PHY" :
+				pdaloc[i].auxctl == 3 ? "ICSRAM" : 
+				"<bogus auxctl>");
+			break;
+		} 
+	}
+	result = pdaok ? 0 : -ENODATA;
+
+	if ( result ) {
+		WLAN_LOG_DEBUG(3,"Failure: pda is not okay\n");
+	}
+
+	hfa384x_cmd_aux_disable(hw);
+failed:
+	DBFEXIT;
+	return result;
+}
+
+
+
+/*----------------------------------------------------------------
+* mkpda_crc
+*
+* Calculates the CRC16 for the given PDA and inserts the value
+* into the end record.
+*
+* Arguments:
+*	pda	ptr to the PDA data structure.
+*
+* Returns: 
+*	0	- success 
+*	~0	- failure (probably an errno)
+----------------------------------------------------------------*/
+static UINT16 
+hfa384x_mkcrc16(UINT8 *p, int len)
+{
+	UINT16	crc = 0;
+	UINT8	*lim = p + len;
+
+	while (p < lim) {	
+		crc = (crc >> 8 ) ^ crc16tab[(crc & 0xff) ^ *p++];
+	}
+
+	return crc;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_enable
+*
+* Begins the ram download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and calls cmd_download with the 
+* ENABLE_VOLATILE subcommand and the exeaddr argument.
+*
+* Arguments:
+*	hw		device structure
+*	exeaddr		the card execution address that will be 
+*                       jumped to when ramdl_disable() is called
+*			(host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_ramdl_enable(hfa384x_t *hw, UINT32 exeaddr)
+{
+	int		result = 0;
+	UINT16		lowaddr;
+	UINT16		hiaddr;
+	int		i;
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_DEBUG(1,"Can't download with a port enabled.\n");
+			result = -EINVAL; 
+			goto done;
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		WLAN_LOG_DEBUG(1,"Download state not disabled.\n");
+		result = -EINVAL;
+		goto done;
+	}
+
+	/* Are we supposed to go into genesis mode? */
+	if (exeaddr == 0x3f0000) {
+		UINT16 initseq[2] = { 0xe100, 0xffa1 };
+		UINT16 readbuf[2];
+		UINT8 hcr = 0x0f; /* Default to x16 SRAM */
+		hw->isram16 = 1;
+
+		WLAN_LOG_DEBUG(1, "Dropping into Genesis mode\n");
+
+		/* Issue card reset and enable aux port */
+		hfa384x_corereset(hw, prism2_reset_holdtime,
+				  prism2_reset_settletime, 0);
+		hfa384x_cmd_aux_enable(hw, 1);
+
+		/* Genesis set */
+		hfa384x_copy_to_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+				    initseq, sizeof(initseq));
+
+		hfa384x_corereset(hw, prism2_reset_holdtime,
+				  prism2_reset_settletime, hcr);
+
+		/* Validate memory config */
+		hfa384x_copy_to_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+				    initseq, sizeof(initseq));
+		hfa384x_copy_from_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+				    readbuf, sizeof(initseq));
+		WLAN_HEX_DUMP(3, "readback", readbuf, sizeof(readbuf));
+
+		if (memcmp(initseq, readbuf, sizeof(readbuf))) {
+			hcr = 0x1f; /* x8 SRAM */
+			hw->isram16 = 0;
+
+			hfa384x_copy_to_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+					    initseq, sizeof(initseq));
+			hfa384x_corereset(hw, prism2_reset_holdtime,
+					  prism2_reset_settletime, hcr);
+
+			hfa384x_copy_to_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+					    initseq, sizeof(initseq));
+			hfa384x_copy_from_aux(hw, 0x7E0038, HFA384x_AUX_CTL_EXTDS, 
+					    readbuf, sizeof(initseq));
+			WLAN_HEX_DUMP(2, "readback", readbuf, sizeof(readbuf));
+
+			if (memcmp(initseq, readbuf, sizeof(readbuf))) {
+				WLAN_LOG_ERROR("Genesis mode failed\n");
+				result = -1;
+				goto done;
+			}
+		}
+
+		/* Now we're in genesis mode */
+		hw->dlstate = HFA384x_DLSTATE_GENESIS;
+		goto done;
+	}
+
+	/* Retrieve the buffer loc&size and timeout */
+	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER, 
+				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+		goto done;
+	}
+	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
+	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
+	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
+	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME, 
+				&(hw->dltimeout))) ) {
+		goto done;
+	}
+	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
+
+	/* Enable the aux port */
+	if ( (result = hfa384x_cmd_aux_enable(hw, 0)) ) {
+		WLAN_LOG_DEBUG(1,"Aux enable failed, result=%d.\n", result);
+		goto done;
+	}
+
+	/* Call the download(1,addr) function */
+	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
+	hiaddr =  HFA384x_ADDR_CMD_MKPAGE(exeaddr);
+
+	result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM, 
+			lowaddr, hiaddr, 0);
+	if ( result == 0) {
+		/* Set the download state */
+		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
+	} else {
+		WLAN_LOG_DEBUG(1,"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+				lowaddr,hiaddr, result);
+		/* Disable  the aux port */
+		hfa384x_cmd_aux_disable(hw);
+	}
+
+ done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_disable
+*
+* Ends the ram download state.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) && 
+	     ( hw->dlstate != HFA384x_DLSTATE_GENESIS ) ) {
+		return -EINVAL;
+	}
+
+	if (hw->dlstate == HFA384x_DLSTATE_GENESIS) {
+		hfa384x_corereset(hw, prism2_reset_holdtime, 
+				  prism2_reset_settletime, 
+				  hw->isram16 ? 0x07: 0x17);
+		goto done;
+	}
+
+	/* Disable the aux port */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+
+ done:
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+	hfa384x_cmd_aux_disable(hw);
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_write
+*
+* Performs a RAM download of a chunk of data. First checks to see
+* that we're in the RAM download state, then uses the aux functions
+* to 1) copy the data, 2) readback and compare.  The download
+* state is unaffected.  When all data has been written using
+* this function, call drvr_ramdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_ramdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
+{
+	int		result = 0;
+	UINT8		*verbuf;
+	DBFENTER;
+	/* Check that we're in the ram download state */
+	if ( ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) && 
+	     ( hw->dlstate != HFA384x_DLSTATE_GENESIS ) ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Writing %d bytes to ram @0x%06x\n", len, daddr);
+#if 0
+WLAN_HEX_DUMP(1, "dldata", buf, len);
+#endif
+	/* Copy the data via the aux port */
+	hfa384x_copy_to_aux(hw, daddr, HFA384x_AUX_CTL_EXTDS, buf, len);
+
+	/* Create a buffer for the verify */
+	verbuf = kmalloc(len, GFP_KERNEL);
+	if (verbuf == NULL ) return 1;
+
+	/* Read back and compare */
+	hfa384x_copy_from_aux(hw, daddr, HFA384x_AUX_CTL_EXTDS, verbuf, len);
+
+	if ( memcmp(buf, verbuf, len) ) {
+		WLAN_LOG_DEBUG(1,"ramdl verify failed!\n");
+		result = -EINVAL;
+	}
+
+	kfree_s(verbuf, len);
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_enable
+*
+* Begins the flash download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and retrieves the flash download
+* buffer location, buffer size, and timeout length.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+{
+	int		result = 0;
+	int		i;
+
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_DEBUG(1,"called when port enabled.\n");
+			return -EINVAL; 
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		return -EINVAL;
+	}
+
+	/* Retrieve the buffer loc&size and timeout */
+	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER, 
+				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+		return result;
+	}
+	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
+	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
+	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
+	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME, 
+				&(hw->dltimeout))) ) {
+		return result;
+	}
+	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
+
+	/* Enable the aux port */
+	if ( (result = hfa384x_cmd_aux_enable(hw, 0)) ) {
+		return result;
+	}
+
+	hw->dlstate = HFA384x_DLSTATE_FLASHENABLED;
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_disable
+*
+* Ends the flash download state.  Note that this will cause the MAC
+* firmware to restart.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	/* There isn't much we can do at this point, so I don't */
+	/*  bother  w/ the return value */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+
+	/* Disable the aux port */
+	hfa384x_cmd_aux_disable(hw);
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_write
+*
+* Performs a FLASH download of a chunk of data. First checks to see
+* that we're in the FLASH download state, then sets the download
+* mode, uses the aux functions to 1) copy the data to the flash
+* buffer, 2) sets the download 'write flash' mode, 3) readback and 
+* compare.  Lather rinse, repeat as many times an necessary to get
+* all the given data into flash.  
+* When all data has been written using this function (possibly 
+* repeatedly), call drvr_flashdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
+{
+	int		result = 0;
+	UINT8		*verbuf;
+	UINT32		dlbufaddr;
+	UINT32		currlen;
+	UINT32		currdaddr;
+	UINT16		destlo;
+	UINT16		desthi;
+	int		nwrites;
+	int		i;
+
+	DBFENTER;
+	/* Check that we're in the flash download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Download %d bytes to flash @0x%06x\n", len, daddr);
+
+	/* Need a flat address for arithmetic */
+	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
+			hw->bufinfo.page,
+			hw->bufinfo.offset);
+	verbuf = kmalloc(hw->bufinfo.len, GFP_KERNEL);
+
+#if 0
+WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+#endif
+	/* Figure out how many times to to the flash prog */
+	nwrites = len / hw->bufinfo.len;
+	nwrites += (len % hw->bufinfo.len) ? 1 : 0;
+
+	if ( verbuf == NULL ) {
+		WLAN_LOG_ERROR("Failed to allocate flash verify buffer\n");
+		return 1;
+	}
+	/* For each */
+	for ( i = 0; i < nwrites; i++) {
+		/* Get the dest address and len */
+		currlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?
+				hw->bufinfo.len : 
+				(len - (hw->bufinfo.len * i));
+		currdaddr = daddr + (hw->bufinfo.len * i);
+		destlo = HFA384x_ADDR_CMD_MKOFF(currdaddr);
+		desthi = HFA384x_ADDR_CMD_MKPAGE(currdaddr);
+		WLAN_LOG_INFO("Writing %d bytes to flash @0x%06x\n", currlen, currdaddr);
+#if 0
+WLAN_HEX_DUMP(1, "dldata", buf+(hw->bufinfo.len*i), currlen);
+#endif
+		/* Set the download mode */
+		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV, 
+				destlo, desthi, currlen);
+		if ( result ) {
+			WLAN_LOG_ERROR("download(NV,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				destlo, desthi, currlen, result);
+			goto exit_proc;
+		}
+		/* copy the data to the flash buffer */
+		hfa384x_copy_to_aux(hw, dlbufaddr, HFA384x_AUX_CTL_EXTDS,
+					buf+(hw->bufinfo.len*i), currlen);
+		/* set the download 'write flash' mode */
+		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NVWRITE, 0,0,0);
+		if ( result ) {
+			WLAN_LOG_ERROR(
+				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				destlo, desthi, currlen, result);
+			goto exit_proc;
+		}
+		/* readback and compare, if fail...bail */
+		hfa384x_copy_from_aux(hw, 
+				currdaddr, HFA384x_AUX_CTL_NV, 
+				verbuf, currlen);
+
+		if ( memcmp(buf+(hw->bufinfo.len*i), verbuf, currlen) ) {
+			return -EINVAL;
+		}
+	}
+
+exit_proc:
+         /* DOH! This kfree's for you Mark :-) My forehead hurts... */
+         kfree(verbuf);
+
+	/* Leave the firmware in the 'post-prog' mode.  flashdl_disable will */
+	/*  actually disable programming mode.  Remember, that will cause the */
+	/*  the firmware to effectively reset itself. */
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_initialize
+*
+* Issues the initialize command and sets the hw->state based
+* on the result.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_initialize(hfa384x_t *hw)
+{
+	int result = 0;
+	int i;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	/* we don't want to be interrupted during the reset */
+	hfa384x_setreg(hw, 0, HFA384x_INTEN);
+	hfa384x_setreg(hw, 0xffff, HFA384x_EVACK);
+
+	cmd.cmd = HFA384x_CMDCODE_INIT;
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	if ( result == 0 ) {
+		for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+			hw->port_enabled[i] = 0;
+		}
+	}
+
+        hw->link_status = HFA384x_LINK_NOTCONNECTED;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_commtallies
+*
+* Send a commtallies inquiry to the MAC.  Note that this is an async
+* call that will result in an info frame arriving sometime later.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	zero		success.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_commtallies( hfa384x_t *hw )
+{
+	hfa384x_metacmd_t cmd;
+	int result;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMDCODE_INQ;
+	cmd.parm0 = HFA384x_IT_COMMTALLIES;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_enable
+*
+* Issues the enable command to enable communications on one of 
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also enable macports 1-6.  Only ports that are currently
+* disabled may be enabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) || 
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    (hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_enable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 1;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_enable
+*
+* Issues the the enable command to enable communications on one of the
+* MACs 'ports'.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_disable
+*
+* Issues the disable command to stop communications on one of 
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also disable macports 1-6.  Only ports that have been
+* previously enabled may be disabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) || 
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    !(hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_disable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 0;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_disable
+*
+* Issues the command to disable a port.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_diagnose
+*
+* Issues the diagnose command to test the: register interface,
+* MAC controller (including loopback), External RAM, Non-volatile
+* memory integrity, and synthesizers.  Following execution of this
+* command, MAC/firmware are in the 'initial state'.  Therefore,
+* the Initialize command should be issued after successful
+* completion of this command.  This function may only be called
+* when the MAC is in the 'communication disabled' state.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+#define DIAG_PATTERNA ((UINT16)0xaaaa)
+#define DIAG_PATTERNB ((UINT16)~0xaaaa)
+
+int hfa384x_cmd_diagnose(hfa384x_t *hw)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DIAG);
+	cmd.parm0 = DIAG_PATTERNA;
+	cmd.parm1 = DIAG_PATTERNB;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_allocate
+*
+* Issues the allocate command instructing the firmware to allocate
+* a 'frame structure buffer' in MAC controller RAM.  This command
+* does not provide the result, it only initiates one of the f/w's
+* asynchronous processes to construct the buffer.  When the 
+* allocation is complete, it will be indicated via the Alloc
+* bit in the EvStat register and the FID identifying the allocated
+* space will be available from the AllocFID register.  Some care
+* should be taken when waiting for the Alloc event.  If a Tx or 
+* Notify command w/ Reclaim has been previously executed, it's
+* possible the first Alloc event after execution of this command
+* will be for the reclaimed buffer and not the one you asked for.
+* This case must be handled in the Alloc event handler.
+*
+* Arguments:
+*	hw		device structure
+*	len		allocation length, must be an even value
+*			in the range [4-2400]. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_allocate(hfa384x_t *hw, UINT16 len)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	if ( (len % 2) || 
+	     len < HFA384x_CMD_ALLOC_LEN_MIN || 
+	     len > HFA384x_CMD_ALLOC_LEN_MAX ) {
+		result = -EINVAL;
+	} else {
+		cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ALLOC);
+		cmd.parm0 = len;
+		cmd.parm1 = 0;
+		cmd.parm2 = 0;
+
+		spin_lock_bh(&hw->cmdlock);
+		result = hfa384x_docmd_wait(hw, &cmd);
+		spin_unlock_bh(&hw->cmdlock);
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_transmit
+*
+* Instructs the firmware to transmit a frame previously copied
+* to a given buffer.  This function returns immediately, the Tx
+* results are available via the Tx or TxExc events (if the frame
+* control bits are set).  The reclaim argument specifies if the 
+* FID passed will be used by the f/w tx process or returned for
+* use w/ another transmit command.  If reclaim is set, expect an 
+* Alloc event signalling the availibility of the FID for reuse.
+*
+* NOTE: hw->cmdlock MUST BE HELD before calling this function!
+*
+* Arguments:
+*	hw		device structure
+*	reclaim		[0|1] indicates whether the given FID will
+*			be handed back (via Alloc event) for reuse.
+*			(host order)
+*	qos		[0-3] Value to put in the QoS field of the 
+*			tx command, identifies a queue to place the 
+*			outgoing frame in.
+*			(host order)
+*	fid		FID of buffer containing the frame that was
+*			previously copied to MAC memory via the bap.
+*			(host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*	hw->resp0 will contain the FID being used by async tx
+*	process.  If reclaim==0, resp0 will be the same as the fid
+*	argument.  If reclaim==1, resp0 will be the different and
+*	is the value to watch for in the Tx|TxExc to indicate completion
+*	of the frame passed in fid.
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_transmit(hfa384x_t *hw, UINT16 reclaim, UINT16 qos, UINT16 fid)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_TX) |
+		HFA384x_CMD_RECL_SET(reclaim) |
+		HFA384x_CMD_QOS_SET(qos);
+	cmd.parm0 = fid;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_clearpersist
+*
+* Instructs the firmware to clear the persistence bit in a given
+* FID.  This has the effect of telling the firmware to drop the
+* persistent frame.  The FID must be one that was previously used
+* to transmit a PRST frame.
+*
+* Arguments:
+*	hw		device structure
+*	fid		FID of the persistent frame (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_clearpersist(hfa384x_t *hw, UINT16 fid)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_CLRPRST);
+	cmd.parm0 = fid;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_notify
+*
+* Sends an info frame to the firmware to alter the behavior
+* of the f/w asynch processes.  Can only be called when the MAC
+* is in the enabled state.
+*
+* Arguments:
+*	hw		device structure
+*	reclaim		[0|1] indicates whether the given FID will
+*			be handed back (via Alloc event) for reuse.
+*			(host order)
+*	fid		FID of buffer containing the frame that was
+*			previously copied to MAC memory via the bap.
+*			(host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*	hw->resp0 will contain the FID being used by async notify
+*	process.  If reclaim==0, resp0 will be the same as the fid
+*	argument.  If reclaim==1, resp0 will be the different.
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_notify(hfa384x_t *hw, UINT16 reclaim, UINT16 fid,
+		       void *buf, UINT16 len)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_NOTIFY) |
+		HFA384x_CMD_RECL_SET(reclaim);
+	cmd.parm0 = fid;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+
+        /* Copy the record to FID */
+        result = hfa384x_copy_to_bap(hw, HFA384x_BAP_PROC, hw->infofid, 0, buf, len);
+        if ( result ) {
+                WLAN_LOG_DEBUG(1, 
+			"copy_to_bap(%04x, 0, %d) failed, result=0x%x\n",
+                        hw->infofid, len, result);
+		result = -EIO;
+                goto failed;
+        }
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+ failed:
+	spin_unlock_bh(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_inquiry
+*
+* Requests an info frame from the firmware.  The info frame will
+* be delivered asynchronously via the Info event.
+*
+* Arguments:
+*	hw		device structure
+*	fid		FID of the info frame requested. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_inquiry(hfa384x_t *hw, UINT16 fid)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_INQ);
+	cmd.parm0 = fid;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_access
+*
+* Requests that a given record be copied to/from the record 
+* buffer.  If we're writing from the record buffer, the contents
+* must previously have been written to the record buffer via the 
+* bap.  If we're reading into the record buffer, the record can
+* be read out of the record buffer after this call.
+*
+* Arguments:
+*	hw		device structure
+*	write		[0|1] copy the record buffer to the given
+*			configuration record. (host order)
+*	rid		RID of the record to read/write. (host order)
+*	buf		host side record buffer.  Upon return it will
+*			contain the body portion of the record (minus the 
+*			RID and len).
+*	len		buffer length (in bytes, should match record length)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_access(hfa384x_t *hw, UINT16 write, UINT16 rid, 
+		       void* buf, UINT16 len)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+	hfa384x_rec_t	rec;
+
+	DBFENTER;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0))
+	/* This should NOT be called in interrupt context! */
+	if (in_irq()) {
+		WLAN_LOG_ERROR("Krap, in Interrupt context!");
+#ifdef WLAN_INCLUDE_DEBUG
+		BUG();
+#endif
+	}
+#endif
+	spin_lock_bh(&hw->cmdlock);
+
+	if (write) {
+		rec.rid = host2hfa384x_16(rid);
+		rec.reclen = host2hfa384x_16((len/2) + 1); /* note conversion to words, +1 for rid field */
+		/* write the record */
+		result = hfa384x_copy_to_bap4( hw, HFA384x_BAP_PROC, rid, 0, 
+					       &rec, sizeof(rec),
+					       buf, len, 
+					       NULL, 0, NULL, 0);
+		if ( result ) {
+			WLAN_LOG_DEBUG(3,"Failure writing record header+data\n");
+			goto fail;
+		}
+
+	}
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ACCESS) |
+		HFA384x_CMD_WRITE_SET(write);
+	cmd.parm0 = rid;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+	if ( result ) {
+		WLAN_LOG_ERROR("Call to hfa384x_docmd_wait failed (%d %d)\n",
+				result, cmd.result.resp0);
+		goto fail;
+	}
+
+	if (!write) {
+		result = hfa384x_copy_from_bap( hw, HFA384x_BAP_PROC, rid, 0, &rec, sizeof(rec));
+		if ( result ) {
+			WLAN_LOG_DEBUG(3,"Call to hfa384x_copy_from_bap failed\n");
+			goto fail;
+		}
+		
+		/* Validate the record length */
+		if ( ((hfa384x2host_16(rec.reclen)-1)*2) != len ) {  /* note body len calculation in bytes */
+			WLAN_LOG_DEBUG(1, "RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+					rid, len, (hfa384x2host_16(rec.reclen)-1)*2);
+			result = -ENODATA;
+			goto fail;
+		}
+
+		result = hfa384x_copy_from_bap( hw, HFA384x_BAP_PROC, rid, sizeof(rec), buf, len);
+
+	}
+
+ fail:	
+	spin_unlock_bh(&hw->cmdlock);
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_monitor
+*
+* Enables the 'monitor mode' of the MAC.  Here's the description of
+* monitor mode that I've received thus far:
+*
+*  "The "monitor mode" of operation is that the MAC passes all 
+*  frames for which the PLCP checks are correct. All received 
+*  MPDUs are passed to the host with MAC Port = 7, with a  
+*  receive status of good, FCS error, or undecryptable. Passing 
+*  certain MPDUs is a violation of the 802.11 standard, but useful 
+*  for a debugging tool."  Normal communication is not possible
+*  while monitor mode is enabled.
+*
+* Arguments:
+*	hw		device structure
+*	enable		a code (0x0b|0x0f) that enables/disables
+*			monitor mode. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_monitor(hfa384x_t *hw, UINT16 enable)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
+		HFA384x_CMD_AINFO_SET(enable);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_download
+*
+* Sets the controls for the MAC controller code/data download
+* process.  The arguments set the mode and address associated 
+* with a download.  Note that the aux registers should be enabled
+* prior to setting one of the download enable modes.
+*
+* Arguments:
+*	hw		device structure
+*	mode		0 - Disable programming and begin code exec
+*			1 - Enable volatile mem programming
+*			2 - Enable non-volatile mem programming
+*			3 - Program non-volatile section from NV download
+*			    buffer. 
+*			(host order)
+*	lowaddr		
+*	highaddr	For mode 1, sets the high & low order bits of 
+*			the "destination address".  This address will be
+*			the execution start address when download is
+*			subsequently disabled.
+*			For mode 2, sets the high & low order bits of 
+*			the destination in NV ram.
+*			For modes 0 & 3, should be zero. (host order)
+*			NOTE: these address args are in CMD format
+*	codelen		Length of the data to write in mode 2, 
+*			zero otherwise. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_download(hfa384x_t *hw, UINT16 mode, UINT16 lowaddr, 
+				UINT16 highaddr, UINT16 codelen)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
+		HFA384x_CMD_PROGMODE_SET(mode);
+	cmd.parm0 = lowaddr;
+	cmd.parm1 = highaddr;
+	cmd.parm2 = codelen;
+
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_dl_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_aux_enable
+*
+* Goes through the process of enabling the auxilary port.  This 
+* is necessary prior to raw reads/writes to card data space.  
+* Direct access to the card data space is only used for downloading
+* code and debugging.
+* Note that a call to this function is required before attempting
+* a download.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_aux_enable(hfa384x_t *hw, int force)
+{
+	int		result = -ETIMEDOUT;
+	unsigned long	flags;
+	UINT32		retries_remaining;
+	UINT16		reg;
+	UINT		auxen_mirror = hw->auxen;
+
+	DBFENTER;
+
+	/* Check for existing enable */
+	if ( hw->auxen ) {
+		hw->auxen++;
+		return 0;
+	}
+
+	/* acquire the lock */
+	spin_lock_irqsave( &(hw->cmdlock), flags);
+	/* wait for cmd register busy bit to clear */
+	retries_remaining = 100000;
+	do {
+		reg = hfa384x_getreg(hw, HFA384x_CMD);
+		udelay(10);
+	}
+	while (HFA384x_CMD_ISBUSY(reg) && --retries_remaining);
+	if (retries_remaining != 0) {
+		/* busy bit clear, it's OK to write to ParamX regs */
+		hfa384x_setreg(hw, HFA384x_AUXPW0,
+			HFA384x_PARAM0);
+		hfa384x_setreg(hw, HFA384x_AUXPW1,
+			HFA384x_PARAM1);
+		hfa384x_setreg(hw, HFA384x_AUXPW2,
+			HFA384x_PARAM2);
+
+		/* Set the aux enable in the Control register */
+		hfa384x_setreg(hw, HFA384x_CONTROL_AUX_DOENABLE, 
+			HFA384x_CONTROL);
+
+		/* Now wait for completion */
+		retries_remaining = 100000;
+		do {
+			reg = hfa384x_getreg(hw, HFA384x_CONTROL);
+			udelay(10);
+		}
+		while ( ((reg & (BIT14|BIT15)) != HFA384x_CONTROL_AUX_ISENABLED) &&
+			--retries_remaining );
+		if (retries_remaining != 0) {
+			result = 0;
+			hw->auxen++;
+		}
+	}
+
+	/* Force it enabled even if the command failed, if told.. */
+	if ((hw->auxen == auxen_mirror) && force)
+		hw->auxen++;
+
+	spin_unlock_irqrestore( &(hw->cmdlock), flags);
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_aux_disable
+*
+* Goes through the process of disabling the auxilary port 
+* enabled with aux_enable().
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout)
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_cmd_aux_disable(hfa384x_t *hw)
+{
+	int		result = -ETIMEDOUT;
+	unsigned long   timeout;
+	UINT16		reg = 0;
+
+	DBFENTER;
+
+	/* See if there's more than one enable */
+	if (hw->auxen) hw->auxen--;
+	if (hw->auxen) return 0;
+
+	/* Clear the aux enable in the Control register */
+	hfa384x_setreg(hw, 0, HFA384x_PARAM0);
+	hfa384x_setreg(hw, 0, HFA384x_PARAM1);
+	hfa384x_setreg(hw, 0, HFA384x_PARAM2);
+	hfa384x_setreg(hw, HFA384x_CONTROL_AUX_DODISABLE, 
+		HFA384x_CONTROL);
+
+	/* Now wait for completion */
+	timeout = jiffies + 1*HZ;
+	reg = hfa384x_getreg(hw, HFA384x_CONTROL);
+	while ( ((reg & (BIT14|BIT15)) != HFA384x_CONTROL_AUX_ISDISABLED) &&
+		time_before(jiffies,timeout) ){
+		udelay(10);
+		reg = hfa384x_getreg(hw, HFA384x_CONTROL);
+	}
+	if ((reg & (BIT14|BIT15)) == HFA384x_CONTROL_AUX_ISDISABLED ) {
+		result = 0;
+	}
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_low_level
+*
+* Write test commands to the card.  Some test commands don't make
+* sense without prior set-up.  For example, continous TX isn't very
+* useful until you set the channel.  That functionality should be
+*
+* Side effects:
+*
+* Call context:
+*      process thread 
+* -----------------------------------------------------------------*/
+int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	int             result = 0;
+	DBFENTER;
+	
+	/* Do i need a host2hfa... conversion ? */
+#if 0
+	printk(KERN_INFO "%#x %#x %#x %#x\n", cmd->cmd, cmd->parm0, cmd->parm1, cmd->parm2);
+#endif
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/* TODO: determine if these will ever be needed */
+#if 0
+int hfa384x_cmd_readmif(hfa384x_t *hw)
+{
+	DBFENTER;
+	DBFEXIT;
+	return 0;
+}
+
+
+int hfa384x_cmd_writemif(hfa384x_t *hw)
+{
+	DBFENTER;
+	DBFEXIT;
+	return 0;
+}
+#endif
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_read
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       register        The test register to be accessed (must be even #).
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process thread
+----------------------------------------------------------------*/
+int hfa384x_drvr_mmi_read(hfa384x_t *hw, UINT32 addr, UINT32 *resp)
+{
+        int             result = 0;
+	hfa384x_metacmd_t cmd;
+
+        DBFENTER;
+	cmd.cmd = (UINT16) 0x30;
+	cmd.parm0 = (UINT16) addr;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+        /* Do i need a host2hfa... conversion ? */
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+	*resp = (UINT32) cmd.result.resp0;
+
+        DBFEXIT;
+        return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_write
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       addr            The test register to be accessed (must be even #).
+*       data            The data value to write to the register.
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process thread
+----------------------------------------------------------------*/
+
+int
+hfa384x_drvr_mmi_write(hfa384x_t *hw, UINT32 addr, UINT32 data)
+{
+        int             result = 0;
+	hfa384x_metacmd_t cmd;
+
+        DBFENTER;
+	cmd.cmd = (UINT16) 0x31;
+	cmd.parm0 = (UINT16) addr;
+	cmd.parm1 = (UINT16) data;
+	cmd.parm2 = 0;
+
+        WLAN_LOG_DEBUG(1,"mmi write : addr = 0x%08x\n", addr);
+        WLAN_LOG_DEBUG(1,"mmi write : data = 0x%08x\n", data);
+
+        /* Do i need a host2hfa... conversion ? */
+	spin_lock_bh(&hw->cmdlock);
+	result = hfa384x_docmd_wait(hw, &cmd);
+	spin_unlock_bh(&hw->cmdlock);
+
+        DBFEXIT;
+        return result;
+}
+
+
+/* TODO: determine if these will ever be needed */
+#if 0
+int hfa384x_cmd_readmif(hfa384x_t *hw)
+{
+        DBFENTER;
+        DBFEXIT;
+        return 0;
+}
+
+
+int hfa384x_cmd_writemif(hfa384x_t *hw)
+{
+        DBFENTER;
+        DBFEXIT;
+        return 0;
+}
+#endif
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_from_bap
+*
+* Copies a collection of bytes from the MAC controller memory via
+* one set of BAP registers.
+*
+* Arguments:
+*	hw		device structure
+*	bap		[0|1] which BAP to use
+*	id		FID or RID, destined for the select register (host order)
+*	offset		An _even_ offset into the buffer for the given
+*			FID/RID.  We haven't the means to validate this,
+*			so be careful. (host order)
+*	buf		ptr to array of bytes
+*	len		length of data to transfer in bytes
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - value of offset reg.
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+int hfa384x_copy_from_bap(hfa384x_t *hw, UINT16 bap, UINT16 id, UINT16 offset,
+				void *buf, UINT len)
+{
+	int		result = 0;
+	unsigned long	flags = 0;
+	UINT8		*d = (UINT8*)buf;
+	UINT		selectreg;
+	UINT		offsetreg;
+	UINT		datareg;
+	UINT		i;
+	UINT16		reg = 0;
+
+	DBFENTER;
+
+	/* Validate bap, offset, buf, and len */
+	if ( (bap > 1) || 
+	     (offset > HFA384x_BAP_OFFSET_MAX) || 
+	     (offset % 2) ||
+	     (buf == NULL) ||
+	     (len > HFA384x_BAP_DATALEN_MAX) ){
+	     	result = -EINVAL;
+	} else {
+		selectreg = (bap == 1) ?  HFA384x_SELECT1 : HFA384x_SELECT0 ;
+		offsetreg = (bap == 1) ?  HFA384x_OFFSET1 : HFA384x_OFFSET0 ;
+		datareg =   (bap == 1) ?  HFA384x_DATA1 : HFA384x_DATA0 ;
+
+		/* Obtain lock */
+		spin_lock_irqsave( &(hw->baplock), flags);
+		
+		/* Write id to select reg */
+		hfa384x_setreg(hw, id, selectreg);
+		/* Write offset to offset reg */
+		hfa384x_setreg(hw, offset, offsetreg);
+		/* Wait for offset[busy] to clear (see BAP_TIMEOUT) */
+		i = 0; 
+		do {
+			reg = hfa384x_getreg(hw, offsetreg);
+			if ( i > 0 ) udelay(10);
+			i++;
+		} while ( i < prism2_bap_timeout && HFA384x_OFFSET_ISBUSY(reg));
+#if (WLAN_HOSTIF != WLAN_PCI)
+		/* Release lock */
+		spin_unlock_irqrestore( &(hw->baplock), flags);
+#endif
+
+		if ( HFA384x_OFFSET_ISBUSY(reg) ){
+			/* If timeout, return -ETIMEDOUT */
+			result = reg;
+		} else if ( HFA384x_OFFSET_ISERR(reg) ){
+			/* If offset[err] == 1, return -EINVAL */
+			result = reg;
+		} else {
+			/* Read even(len) buf contents from data reg */
+			for ( i = 0; i < (len & 0xfffe); i+=2 ) {
+				*(UINT16*)(&(d[i])) = 
+					hfa384x_getreg_noswap(hw, datareg);
+			}
+			/* If len odd, handle last byte */
+			if ( len % 2 ){
+				reg = hfa384x_getreg_noswap(hw, datareg);
+				d[len-1] = ((UINT8*)(&reg))[0];
+			}
+		}
+
+		/* According to Intersil errata dated 9/16/02:
+	
+		"In PRISM PCI MAC host interface, if both BAPs are concurrently 
+		 requesing memory access, both will accept the Ack.   There is no
+		 firmware workaround possible.  To prevent BAP access failures or
+		 hang conditions the host MUST NOT access both BAPs in sucession
+		 unless at least 5us elapses between accesses.  The safest choice
+		 is to USE ONLY ONE BAP for all data movement operations."
+	
+		 What this means:
+	
+		 We have to serialize ALL BAP accesses, and furthermore, add a 5us
+		 delay after access if we're using a PCI platform.
+	
+		 Unfortunately, this means we have to lock out interrupts througout
+		 the entire BAP copy.
+	
+		 It remains to be seen if "BAP access" means "BAP setup" or the more
+		 literal definition of "copying data back and forth"  I'm erring for
+		 the latter, safer definition.  -- SLP.
+	
+		*/
+
+#if (WLAN_HOSTIF == WLAN_PCI)
+		udelay(5);
+		/* Release lock */
+		spin_unlock_irqrestore( &(hw->baplock), flags);
+#endif
+
+	}
+
+	if (result) {
+	  WLAN_LOG_DEBUG(1, 
+			  "copy_from_bap(0x%04x, 0, %d) failed, result=0x%x\n", 
+			  reg, len, result);
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_to_bap
+*
+* Copies a collection of bytes to the MAC controller memory via
+* one set of BAP registers.
+*
+* Arguments:
+*	hw		device structure
+*	bap		[0|1] which BAP to use
+*	id		FID or RID, destined for the select register (host order)
+*	offset		An _even_ offset into the buffer for the given
+*			FID/RID.  We haven't the means to validate this,
+*			so be careful. (host order)
+*	buf		ptr to array of bytes
+*	len		length of data to transfer (in bytes)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - value of offset reg.
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+int hfa384x_copy_to_bap(hfa384x_t *hw, UINT16 bap, UINT16 id, UINT16 offset,
+				void *buf, UINT len)
+{
+	return hfa384x_copy_to_bap4(hw, bap, id, offset, buf, len, NULL, 0, NULL, 0, NULL, 0);
+}
+
+int hfa384x_copy_to_bap4(hfa384x_t *hw, UINT16 bap, UINT16 id, UINT16 offset,
+			 void *buf, UINT len1, void* buf2, UINT len2,
+			 void *buf3, UINT len3, void *buf4, UINT len4)
+{
+	int		result = 0;
+	unsigned long	flags = 0;
+	UINT8		*d;
+	UINT		selectreg;
+	UINT		offsetreg;
+	UINT		datareg;
+	UINT		i;
+	UINT16		reg;
+
+	DBFENTER;
+
+//	printk(KERN_DEBUG "ctb1 %d id %04x o %d %d %d %d %d\n", bap, id, offset, len1, len2, len3, len4);
+
+	/* Validate bap, offset, buf, and len */
+	if ( (bap > 1) || 
+	     (offset > HFA384x_BAP_OFFSET_MAX) || 
+	     (offset % 2) ||
+	     (buf == NULL) ||
+	     (len1+len2+len3+len4 > HFA384x_BAP_DATALEN_MAX) ){
+	     	result = -EINVAL;
+	} else {
+		selectreg = (bap == 1) ? HFA384x_SELECT1 : HFA384x_SELECT0;
+		offsetreg = (bap == 1) ? HFA384x_OFFSET1 : HFA384x_OFFSET0;
+		datareg =   (bap == 1) ? HFA384x_DATA1   : HFA384x_DATA0;
+		/* Obtain lock */
+		spin_lock_irqsave( &(hw->baplock), flags);
+		
+		/* Write id to select reg */
+		hfa384x_setreg(hw, id, selectreg);
+		udelay(10);
+		/* Write offset to offset reg */
+		hfa384x_setreg(hw, offset, offsetreg);
+		/* Wait for offset[busy] to clear (see BAP_TIMEOUT) */
+		i = 0; 
+		do {
+			reg = hfa384x_getreg(hw, offsetreg);
+			if ( i > 0 ) udelay(10);
+			i++;
+		} while ( i < prism2_bap_timeout && HFA384x_OFFSET_ISBUSY(reg));
+	
+#if (WLAN_HOSTIF != WLAN_PCI)
+		/* Release lock */
+		spin_unlock_irqrestore( &(hw->baplock), flags);
+#endif
+
+		if ( HFA384x_OFFSET_ISBUSY(reg) ){
+			/* If timeout, return reg */
+			result = reg;
+		} else if ( HFA384x_OFFSET_ISERR(reg) ){
+			/* If offset[err] == 1, return reg */
+			result = reg;
+		} else {
+			d = (UINT8*)buf;
+			/* Write even(len1) buf contents to data reg */
+			for ( i = 0; i < (len1 & 0xfffe); i+=2 ) {
+				hfa384x_setreg_noswap(hw, 
+					*(UINT16*)(&(d[i])), datareg);
+			}
+			if (len1 & 1) {
+				UINT16 data;
+				UINT8 *b = (UINT8 *) &data;
+				b[0] = d[len1-1];
+				if (buf2 != NULL) {
+					d = (UINT8*)buf2;
+					b[1] = d[0];
+					len2--;		
+					buf2++;
+				}
+				hfa384x_setreg_noswap(hw, data, datareg);
+			}
+			if ((buf2 != NULL) && (len2 > 0)) {
+				/* Write even(len2) buf contents to data reg */
+				d = (UINT8*)buf2;
+				for ( i = 0; i < (len2 & 0xfffe); i+=2 ) {
+					hfa384x_setreg_noswap(hw, *(UINT16*)(&(d[i])), datareg);
+				}
+				if (len2 & 1) {
+					UINT16 data;
+					UINT8 *b = (UINT8 *) &data;
+					b[0] = d[len2-1];
+					if (buf3 != NULL) {
+						d = (UINT8*)buf3;
+						b[1] = d[0];
+						len3--;	
+						buf3++;
+					}
+					hfa384x_setreg_noswap(hw, data, datareg);
+				}
+			}
+
+			if ((buf3 != NULL) && (len3 > 0)) {
+				/* Write even(len3) buf contents to data reg */
+				d = (UINT8*)buf3;
+				for ( i = 0; i < (len3 & 0xfffe); i+=2 ) {
+					hfa384x_setreg_noswap(hw, *(UINT16*)(&(d[i])), datareg);
+				}
+				if (len3 & 1) {
+					UINT16 data;
+					UINT8 *b = (UINT8 *) &data;
+					b[0] = d[len3-1];
+					if (buf4 != NULL) {
+						d = (UINT8*)buf4;
+						b[1] = d[0];
+						len4--;
+						buf4++;
+					}
+					hfa384x_setreg_noswap(hw, data, datareg);
+				}
+			}
+			if ((buf4 != NULL) && (len4 > 0)) {
+				/* Write even(len4) buf contents to data reg */
+				d = (UINT8*)buf4;
+				for ( i = 0; i < (len4 & 0xfffe); i+=2 ) {
+					hfa384x_setreg_noswap(hw, *(UINT16*)(&(d[i])), datareg);
+				}
+				if (len4 & 1) {
+					UINT16 data;
+					UINT8 *b = (UINT8 *) &data;
+					b[0] = d[len4-1];
+					b[1] = 0;
+
+					hfa384x_setreg_noswap(hw, data, datareg);
+				}
+			}
+//			printk(KERN_DEBUG "ctb2 %d id %04x o %d %d %d %d %d\n", bap, id, offset, len1, len2, len3, len4);
+
+		}
+
+#if (WLAN_HOSTIF == WLAN_PCI)
+		udelay(5);
+		/* Release lock */
+		spin_unlock_irqrestore( &(hw->baplock), flags);
+#endif
+
+	}
+	
+	if (result)
+		WLAN_LOG_ERROR("copy_to_bap() failed.\n");
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_from_aux
+*
+* Copies a collection of bytes from the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	buf contains the data copied
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+void 
+hfa384x_copy_from_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	UINT16		currpage;
+	UINT16		curroffset;
+	UINT		i = 0;
+
+	DBFENTER;
+
+	if ( !(hw->auxen) ) {
+		WLAN_LOG_DEBUG(1,
+			"Attempt to read 0x%04x when aux not enabled\n",
+			cardaddr);
+		return;
+			
+	}
+	/* Build appropriate aux page and offset */
+	currpage = HFA384x_AUX_MKPAGE(cardaddr);
+	curroffset = HFA384x_AUX_MKOFF(cardaddr, auxctl);
+	hfa384x_setreg(hw, currpage, HFA384x_AUXPAGE);
+	hfa384x_setreg(hw, curroffset, HFA384x_AUXOFFSET);
+	udelay(5);	/* beat */
+
+	/* read the data */
+	while ( i < len) {
+		*((UINT16*)(buf+i)) = hfa384x_getreg_noswap(hw, HFA384x_AUXDATA);
+		i+=2;
+		curroffset+=2;
+		if ( (curroffset&HFA384x_ADDR_AUX_OFF_MASK) > 
+			HFA384x_ADDR_AUX_OFF_MAX ) {
+			currpage++;
+			curroffset = 0;
+			curroffset = HFA384x_AUX_MKOFF(curroffset, auxctl);
+			hfa384x_setreg(hw, currpage, HFA384x_AUXPAGE);
+			hfa384x_setreg(hw, curroffset, HFA384x_AUXOFFSET);
+			udelay(5);	/* beat */
+		}
+	}
+	/* Make sure the auxctl bits are clear */
+	hfa384x_setreg(hw, 0, HFA384x_AUXOFFSET);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_to_aux
+*
+* Copies a collection of bytes to the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	Controller memory now contains a copy of buf
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+void 
+hfa384x_copy_to_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	UINT16		currpage;
+	UINT16		curroffset;
+	UINT		i = 0;
+
+	DBFENTER;
+
+	if ( !(hw->auxen) ) {
+		WLAN_LOG_DEBUG(1,
+			"Attempt to read 0x%04x when aux not enabled\n",
+			cardaddr);
+		return;
+			
+	}
+	/* Build appropriate aux page and offset */
+	currpage = HFA384x_AUX_MKPAGE(cardaddr);
+	curroffset = HFA384x_AUX_MKOFF(cardaddr, auxctl);
+	hfa384x_setreg(hw, currpage, HFA384x_AUXPAGE);
+	hfa384x_setreg(hw, curroffset, HFA384x_AUXOFFSET);
+	udelay(5);	/* beat */
+
+	/* write the data */
+	while ( i < len) {
+		hfa384x_setreg_noswap(hw, 
+			*((UINT16*)(buf+i)), HFA384x_AUXDATA);
+		i+=2;
+		curroffset+=2;
+		if ( curroffset > HFA384x_ADDR_AUX_OFF_MAX ) {
+			currpage++;
+			curroffset = 0;
+			hfa384x_setreg(hw, currpage, HFA384x_AUXPAGE);
+			hfa384x_setreg(hw, curroffset, HFA384x_AUXOFFSET);
+			udelay(5);	/* beat */
+		}
+	}
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_wait
+*
+* Waits for availability of the Command register, then
+* issues the given command.  Then polls the Evstat register
+* waiting for command completion.  Timeouts shouldn't be 
+* possible since we're preventing overlapping commands and all
+* commands should be cleared and acknowledged.
+*
+* Arguments:
+*	wlandev		device structure
+*       cmd             cmd structure.  Includes all arguments and result
+*                       data points.  All in host order.
+*
+* Returns: 
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_docmd_wait( hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	int		result = -ETIMEDOUT;
+	UINT16		reg = 0;
+	UINT16          counter;
+
+	DBFENTER;
+
+	hw->cmdflag = 0;
+	hw->cmddata = cmd;
+
+	/* wait for the busy bit to clear */	
+	counter = 0;
+	reg = hfa384x_getreg(hw, HFA384x_CMD);
+	while ( HFA384x_CMD_ISBUSY(reg) && 
+		(counter < 10)) {
+		reg = hfa384x_getreg(hw, HFA384x_CMD);
+		counter++;
+		udelay(10);
+	}
+
+	if (HFA384x_CMD_ISBUSY(reg)) {
+		WLAN_LOG_ERROR("hfa384x_cmd timeout(1), reg=0x%0hx.\n", reg);
+		goto failed;
+	}
+	if (!HFA384x_CMD_ISBUSY(reg)) {
+		/* busy bit clear, write command */
+		hfa384x_setreg(hw, cmd->parm0, HFA384x_PARAM0);
+		hfa384x_setreg(hw, cmd->parm1, HFA384x_PARAM1);
+		hfa384x_setreg(hw, cmd->parm2, HFA384x_PARAM2);
+		hfa384x_setreg(hw, cmd->cmd, HFA384x_CMD);
+
+#ifdef CMD_IRQ
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,2,0))
+		while (! hw->cmdflag)
+			interruptible_sleep_on(&hw->cmdq);
+#else
+		wait_event_interruptible(hw->cmdq, hw->cmdflag);
+#endif
+		result = HFA384x_STATUS_RESULT_GET(cmd->status);
+#else // CMD_IRQ
+		/* Now wait for completion */
+		counter = 0;
+		reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+		/* Initialization is the problem.  It takes about
+                   100ms. "normal" commands are typically is about
+                   200-400 us (I've never seen less than 200).  Longer
+                   is better so that we're not hammering the bus. */
+		while ( !HFA384x_EVSTAT_ISCMD(reg) &&
+			(counter < 5000)) {
+			reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+			counter++;
+			udelay(200);
+		}
+
+		if ( HFA384x_EVSTAT_ISCMD(reg) ) {
+			result = 0;
+			cmd->result.status = hfa384x_getreg(hw, HFA384x_STATUS);
+			cmd->result.resp0 = hfa384x_getreg(hw, HFA384x_RESP0);
+			cmd->result.resp1 = hfa384x_getreg(hw, HFA384x_RESP1);
+			cmd->result.resp2 = hfa384x_getreg(hw, HFA384x_RESP2);
+			hfa384x_setreg(hw, HFA384x_EVACK_CMD, 
+				HFA384x_EVACK);
+			result = HFA384x_STATUS_RESULT_GET(cmd->result.status);
+		} else {
+			WLAN_LOG_ERROR("hfa384x_cmd timeout(2), reg=0x%0hx.\n", reg);
+		}
+#endif  /* CMD_IRQ */
+	}
+
+ failed:
+	hw->cmdflag = 0;
+	hw->cmddata = NULL;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_dl_docmd_wait
+*
+* Waits for availability of the Command register, then
+* issues the given command.  Then polls the Evstat register
+* waiting for command completion.  Timeouts shouldn't be 
+* possible since we're preventing overlapping commands and all
+* commands should be cleared and acknowledged.
+*
+* This routine is only used for downloads.  Since it doesn't lock out
+* interrupts the system response is much better.
+*
+* Arguments:
+*	wlandev		device structure
+*       cmd             cmd structure.  Includes all arguments and result
+*                       data points.  All in host order.
+*
+* Returns: 
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_dl_docmd_wait( hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	int		result = -ETIMEDOUT;
+	unsigned long	timeout;
+	UINT16		reg = 0;
+
+	DBFENTER;
+	/* wait for the busy bit to clear */	
+	timeout = jiffies + 1*HZ;
+	reg = hfa384x_getreg(hw, HFA384x_CMD);
+	while ( HFA384x_CMD_ISBUSY(reg) && time_before( jiffies, timeout) ) {
+		reg = hfa384x_getreg(hw, HFA384x_CMD);
+		udelay(10);
+	}
+	if (HFA384x_CMD_ISBUSY(reg)) {
+		WLAN_LOG_WARNING("Timed out waiting for cmd register.\n");
+		goto failed;
+	}
+
+	if (!HFA384x_CMD_ISBUSY(reg)) {
+		/* busy bit clear, write command */
+		hfa384x_setreg(hw, cmd->parm0, HFA384x_PARAM0);
+		hfa384x_setreg(hw, cmd->parm1, HFA384x_PARAM1);
+		hfa384x_setreg(hw, cmd->parm2, HFA384x_PARAM2);
+		hfa384x_setreg(hw, cmd->cmd, HFA384x_CMD);
+
+		/* Now wait for completion */
+		if ( (HFA384x_CMD_CMDCODE_GET(cmd->cmd) == HFA384x_CMDCODE_DOWNLD) ) { 
+			/* dltimeout is in ms */
+			timeout = (((UINT32)hw->dltimeout) / 1000UL) * HZ;
+			if ( timeout > 0 ) {
+				timeout += jiffies;
+			} else {
+				timeout = jiffies + 1*HZ;
+			}
+		} else {
+			timeout = jiffies + 1*HZ;
+		}
+		reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+		while ( !HFA384x_EVSTAT_ISCMD(reg) && time_before(jiffies,timeout) ) {
+			udelay(100);
+			reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+		}
+		if ( HFA384x_EVSTAT_ISCMD(reg) ) {
+			result = 0;
+			cmd->result.status = hfa384x_getreg(hw, HFA384x_STATUS);
+			cmd->result.resp0 = hfa384x_getreg(hw, HFA384x_RESP0);
+			cmd->result.resp1 = hfa384x_getreg(hw, HFA384x_RESP1);
+			cmd->result.resp2 = hfa384x_getreg(hw, HFA384x_RESP2);
+			hfa384x_setreg(hw, HFA384x_EVACK_CMD, HFA384x_EVACK);
+			result = HFA384x_STATUS_RESULT_GET(cmd->result.status);
+		}
+	}
+
+failed:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_start
+*
+* Issues the MAC initialize command, sets up some data structures,
+* and enables the interrupts.  After this function completes, the
+* low-level stuff should be ready for any/all commands.
+*
+* Arguments:
+*	hw		device structure
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_start(hfa384x_t *hw)
+{
+	int	result = 0;
+	UINT16			reg;
+	int			i;
+	int			j;
+	DBFENTER;
+
+	/* call initialize */
+	result = hfa384x_cmd_initialize(hw);
+	if (result != 0) {
+		WLAN_LOG_ERROR("Initialize command failed.\n");
+		goto failed;
+	}
+
+	/* make sure interrupts are disabled and any layabout events cleared */
+	hfa384x_setreg(hw, 0, HFA384x_INTEN);
+	hfa384x_setreg(hw, 0xffff, HFA384x_EVACK);
+
+        hw->txfid_head = 0;
+        hw->txfid_tail = 0;
+        hw->txfid_N = HFA384x_DRVR_FIDSTACKLEN_MAX;
+        memset(hw->txfid_queue, 0, sizeof(hw->txfid_queue));
+
+	/* Allocate tx and notify FIDs */
+	/* First, tx */
+	for ( i = 0; i < HFA384x_DRVR_FIDSTACKLEN_MAX-1; i++) {
+		result = hfa384x_cmd_allocate(hw, HFA384x_DRVR_TXBUF_MAX);
+		if (result != 0) {
+			WLAN_LOG_ERROR("Allocate(tx) command failed.\n");
+			goto failed;
+		}
+		j = 0;
+		do {
+			reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+			udelay(10);
+			j++;
+		} while ( !HFA384x_EVSTAT_ISALLOC(reg) && j < 50); /* 50 is timeout */
+		if ( j >= 50 ) {
+			WLAN_LOG_ERROR("Timed out waiting for evalloc(tx).\n");
+			result = -ETIMEDOUT;
+			goto failed;
+		}
+		reg = hfa384x_getreg(hw, HFA384x_ALLOCFID);
+
+		txfid_queue_add(hw, reg);
+
+		WLAN_LOG_DEBUG(4,"hw->txfid_queue[%d]=0x%04x\n",i,reg);
+
+		reg = HFA384x_EVACK_ALLOC_SET(1);
+		hfa384x_setreg(hw, reg, HFA384x_EVACK);
+
+	}
+
+	/* Now, the info frame fid */
+	result = hfa384x_cmd_allocate(hw, HFA384x_INFOFRM_MAXLEN);
+	if (result != 0) {
+		WLAN_LOG_ERROR("Allocate(tx) command failed.\n");
+		goto failed;
+	}
+	i = 0;
+	do {
+		reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+		udelay(10);
+		i++;
+	} while ( !HFA384x_EVSTAT_ISALLOC(reg) && i < 50); /* 50 is timeout */
+	if ( i >= 50 ) {
+		WLAN_LOG_ERROR("Timed out waiting for evalloc(info).\n");
+		result = -ETIMEDOUT;
+		goto failed;
+	}
+	hw->infofid = hfa384x_getreg(hw, HFA384x_ALLOCFID);
+	reg = HFA384x_EVACK_ALLOC_SET(1);
+	hfa384x_setreg(hw, reg, HFA384x_EVACK);
+	WLAN_LOG_DEBUG(4,"hw->infofid=0x%04x\n", hw->infofid);
+
+	/* Set swsupport regs to magic # for card presence detection */
+	hfa384x_setreg(hw, HFA384x_DRVR_MAGIC, HFA384x_SWSUPPORT0);
+
+	/* Now enable the interrupts and set the running state */
+	hfa384x_setreg(hw, 0xffff, HFA384x_EVSTAT);
+	hfa384x_events_all(hw);
+
+	hw->state = HFA384x_STATE_RUNNING;
+
+	goto done;
+failed:
+	WLAN_LOG_ERROR("Failed, result=%d\n", result);
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_stop
+*
+* Issues the initialize command to leave us in the 'reset' state.
+*
+* Arguments:
+*	hw		device structure
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread 
+----------------------------------------------------------------*/
+int hfa384x_drvr_stop(hfa384x_t *hw)
+{
+	int	result = 0;
+	int i;
+	DBFENTER;
+
+	del_timer_sync(&hw->commsqual_timer);
+
+	if ( hw->wlandev->hwremoved ) {
+		/* only flush when we're shutting down for good */
+		flush_scheduled_work();
+	}
+
+	if (hw->state == HFA384x_STATE_RUNNING) {
+		/* 
+		 * Send the MAC initialize cmd.
+		 */
+		hfa384x_cmd_initialize(hw);
+	
+		/* 
+		 * Make absolutely sure interrupts are disabled and any 
+		 * layabout events cleared 
+		 */ 
+		hfa384x_setreg(hw, 0, HFA384x_INTEN);
+		hfa384x_setreg(hw, 0xffff, HFA384x_EVACK);
+	}
+
+	tasklet_kill(&hw->bap_tasklet);
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+	/* Clear all the port status */
+	for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+		hw->port_enabled[i] = 0;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_txframe
+*
+* Takes a frame from prism2sta and queues it for transmission.
+*
+* Arguments:
+*	hw		device structure
+*	skb		packet buffer struct.  Contains an 802.11
+*			data frame.
+*       p80211_hdr      points to the 802.11 header for the packet.
+* Returns: 
+*	0		Success and more buffs available
+*	1		Success but no more buffs
+*	2		Allocation failure
+*	3		MAC Tx command failed
+*	4		Buffer full or queue busy
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+{
+	hfa384x_tx_frame_t	txdesc;
+	UINT16			macq = 0;
+	UINT16			fid;
+	int			result;
+
+	DBFENTER;
+
+	/* Build Tx frame structure */
+	/* Set up the control field */
+	memset(&txdesc, 0, sizeof(txdesc));
+
+/* Tx complete and Tx exception disable per dleach.  Might be causing 
+ * buf depletion 
+ */
+#define DOBOTH 1
+#if DOBOTH
+	txdesc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) | 
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);	
+#elif DOEXC
+	txdesc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);	
+#else
+	txdesc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);	
+#endif
+
+	/* if we're using host WEP, increase size by IV+ICV */
+	if (p80211_wep->data) {
+		txdesc.data_len = host2hfa384x_16(skb->len+8);
+		//		txdesc.tx_control |= HFA384x_TX_NOENCRYPT_SET(1);
+	} else {
+		txdesc.data_len =  host2hfa384x_16(skb->len);
+	}
+
+	txdesc.tx_control = host2hfa384x_16(txdesc.tx_control);
+	/* copy the header over to the txdesc */
+	memcpy(&(txdesc.frame_control), p80211_hdr, sizeof(p80211_hdr_t));
+
+	/* Since tbusy is set whenever the stack is empty, there should 
+	 * always be something on the stack if we get to this point.
+	 * [MSM]: NOT TRUE!!!!! so I added the test of fid below.
+	 */
+
+	/* Allocate FID */
+
+	fid = txfid_queue_remove(hw);
+
+	if ( fid == 0 ) { /* stack or queue was empty */
+		return 4;
+	}
+
+	/* now let's get the cmdlock */
+	spin_lock(&hw->cmdlock);
+
+	/* Copy descriptor+payload to FID */
+        if (p80211_wep->data) { 
+		result = hfa384x_copy_to_bap4(hw, HFA384x_BAP_PROC, fid, 0,
+					      &txdesc, sizeof(txdesc),
+					      p80211_wep->iv, sizeof(p80211_wep->iv),
+					      p80211_wep->data, skb->len,
+					      p80211_wep->icv, sizeof(p80211_wep->icv));
+	} else {
+		result = hfa384x_copy_to_bap4(hw, HFA384x_BAP_PROC, fid, 0,
+					      &txdesc, sizeof(txdesc),
+					      skb->data, skb->len,
+					      NULL, 0, NULL, 0);
+	}
+
+	if ( result ) {
+		WLAN_LOG_DEBUG(1,
+			"copy_to_bap(%04x, %d, %d) failed, result=0x%x\n", 
+			fid,
+		 	sizeof(txdesc), 
+	 		skb->len,
+			result);
+
+		/* put the fid back in the queue */
+		txfid_queue_add(hw, fid);
+
+		result = 3;
+		goto failed;
+	}
+
+	/* Issue Tx command */
+	result = hfa384x_cmd_transmit(hw, HFA384x_TXCMD_RECL, macq, fid);
+		
+	if ( result != 0 ) {
+		txfid_queue_add(hw, fid);
+
+		WLAN_LOG_DEBUG(1,"cmd_tx(%04x) failed, result=%d\n", 
+			fid, result);
+		result = 3;
+		goto failed;
+	}
+	
+	/* indicate we haven't any buffers, int_alloc will clear */
+	result = txfid_queue_empty(hw); 
+failed:
+
+	spin_unlock(&hw->cmdlock);
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_interrupt
+*
+* Driver interrupt handler.
+*
+* Arguments:
+*	irq		irq number
+*	dev_id		pointer to the device
+*	regs		registers
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	May result in a frame being passed up the stack or an info
+*	frame being handled.  
+*
+* Call context:
+*	Ummm, could it be interrupt?
+----------------------------------------------------------------*/
+irqreturn_t hfa384x_interrupt(int irq, void *dev_id)
+{
+	int			reg;
+	wlandevice_t		*wlandev = (wlandevice_t*)dev_id;
+	hfa384x_t		*hw = wlandev->priv;
+	int			ev_read = 0;
+	DBFENTER;
+
+	if (!wlandev || wlandev->hwremoved)
+		return IRQ_NONE;  /* Not much we can do w/o hardware */
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+	if (hw->iobase == 0)  /* XXX FIXME Properly */
+		return IRQ_NONE;
+#endif
+
+	for (;;ev_read++) {
+		if (ev_read >= prism2_irq_evread_max)
+			break;
+
+		/* Check swsupport reg magic # for card presence */
+		reg = hfa384x_getreg(hw, HFA384x_SWSUPPORT0);
+		if ( reg != HFA384x_DRVR_MAGIC) {
+			WLAN_LOG_DEBUG(2, "irq=%d, no magic.  Card removed?.\n", irq);
+			break;
+		}		
+
+		/* read the EvStat register for interrupt enabled events */
+		reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+		
+		/* AND with the enabled interrupts */
+		reg &= hfa384x_getreg(hw, HFA384x_INTEN);
+
+		/* Handle the events */
+		if ( HFA384x_EVSTAT_ISWTERR(reg) ){
+			WLAN_LOG_ERROR(
+			"Error: WTERR interrupt received (unhandled).\n");
+			hfa384x_setreg(hw, HFA384x_EVACK_WTERR_SET(1), 
+				HFA384x_EVACK);
+		}
+		
+		if ( HFA384x_EVSTAT_ISINFDROP(reg) ){
+			hfa384x_int_infdrop(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_INFDROP_SET(1), 
+				HFA384x_EVACK);
+		}
+	
+		if (HFA384x_EVSTAT_ISBAP_OP(reg)) {
+			/* Disable the BAP interrupts */
+			hfa384x_events_nobap(hw);
+			tasklet_schedule(&hw->bap_tasklet);
+		}
+
+		if ( HFA384x_EVSTAT_ISALLOC(reg) ){
+			hfa384x_int_alloc(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_ALLOC_SET(1),
+				HFA384x_EVACK);
+		}
+
+		if ( HFA384x_EVSTAT_ISDTIM(reg) ){
+			hfa384x_int_dtim(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_DTIM_SET(1),
+				HFA384x_EVACK);
+		}
+#ifdef CMD_IRQ
+		if ( HFA384x_EVSTAT_ISCMD(reg) ){
+			hfa384x_int_cmd(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_CMD_SET(1),
+				       HFA384x_EVACK);
+		}
+#endif
+
+		/* allow the evstat to be updated after the evack */
+		udelay(20);
+	}
+
+	DBFEXIT;
+	return IRQ_HANDLED;
+}
+
+#ifdef CMD_IRQ
+/*----------------------------------------------------------------
+* hfa384x_int_cmd
+*
+* Handles command completion event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_int_cmd(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	DBFENTER;
+
+	// check to make sure it's the right command?
+	if (hw->cmddata) {
+		hw->cmddata->status = hfa384x_getreg(hw, HFA384x_STATUS);
+		hw->cmddata->resp0 = hfa384x_getreg(hw, HFA384x_RESP0);
+		hw->cmddata->resp1 = hfa384x_getreg(hw, HFA384x_RESP1);
+		hw->cmddata->resp2 = hfa384x_getreg(hw, HFA384x_RESP2);
+	}
+	hw->cmdflag = 1;
+
+	printk(KERN_INFO "um. int_cmd\n");
+
+	wake_up_interruptible(&hw->cmdq);
+
+	// XXXX perform a bap copy too?
+
+	DBFEXIT;
+	return;
+}
+#endif
+
+/*----------------------------------------------------------------
+* hfa384x_int_dtim
+*
+* Handles the DTIM early warning event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_int_dtim(wlandevice_t *wlandev)
+{
+#if 0
+	hfa384x_t		*hw = wlandev->priv;
+#endif
+	DBFENTER;
+	prism2sta_ev_dtim(wlandev);
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_int_infdrop
+*
+* Handles the InfDrop event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_int_infdrop(wlandevice_t *wlandev)
+{
+#if 0
+	hfa384x_t		*hw = wlandev->priv;
+#endif
+	DBFENTER;
+	prism2sta_ev_infdrop(wlandev);
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_int_info
+*
+* Handles the Info event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	tasklet
+----------------------------------------------------------------*/
+void hfa384x_int_info(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16			reg;
+	hfa384x_InfFrame_t	inf;
+	int			result;
+	DBFENTER;
+	/* Retrieve the FID */
+	reg = hfa384x_getreg(hw, HFA384x_INFOFID);
+
+	/* Retrieve the length */
+	result = hfa384x_copy_from_bap( hw, 
+		HFA384x_BAP_INT, reg, 0, &inf.framelen, sizeof(UINT16));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1, 
+			"copy_from_bap(0x%04x, 0, %d) failed, result=0x%x\n", 
+			reg, sizeof(inf), result);
+		goto failed;
+	}
+	inf.framelen = hfa384x2host_16(inf.framelen);
+
+	/* Retrieve the rest */
+	result = hfa384x_copy_from_bap( hw, 
+		HFA384x_BAP_INT, reg, sizeof(UINT16),
+		&(inf.infotype), inf.framelen * sizeof(UINT16));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1, 
+			"copy_from_bap(0x%04x, 0, %d) failed, result=0x%x\n", 
+			reg, sizeof(inf), result);
+		goto failed;
+	}
+
+	prism2sta_ev_info(wlandev, &inf);
+failed:
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_int_txexc
+*
+* Handles the TxExc event.  A Transmit Exception event indicates
+* that the MAC's TX process was unsuccessful - so the packet did
+* not get transmitted.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	tasklet  
+----------------------------------------------------------------*/
+void hfa384x_int_txexc(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16			status;
+	UINT16			fid;
+	int			result = 0;
+	DBFENTER;
+	/* Collect the status and display */
+	fid = hfa384x_getreg(hw, HFA384x_TXCOMPLFID);
+	result = hfa384x_copy_from_bap(hw, HFA384x_BAP_INT, fid, 0, &status, sizeof(status));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1, 
+			"copy_from_bap(0x%04x, 0, %d) failed, result=0x%x\n", 
+			fid, sizeof(status), result);
+		goto failed;
+	}
+	status = hfa384x2host_16(status);
+	prism2sta_ev_txexc(wlandev, status);
+failed:
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_int_tx
+*
+* Handles the Tx event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	tasklet  
+----------------------------------------------------------------*/
+void hfa384x_int_tx(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16			fid;
+	UINT16			status;
+	int			result = 0;
+	DBFENTER;
+	fid = hfa384x_getreg(hw, HFA384x_TXCOMPLFID);
+	result = hfa384x_copy_from_bap(hw, HFA384x_BAP_INT, fid, 0, &status, sizeof(status));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1, 
+			"copy_from_bap(0x%04x, 0, %d) failed, result=0x%x\n", 
+			fid, sizeof(status), result);
+		goto failed;
+	}
+	status = hfa384x2host_16(status);
+	prism2sta_ev_tx(wlandev, status);
+failed:
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_int_rx
+*
+* Handles the Rx event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	tasklet  
+----------------------------------------------------------------*/
+void hfa384x_int_rx(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16			rxfid;
+	hfa384x_rx_frame_t	rxdesc;
+	int			result;
+	int                     hdrlen;
+	UINT16                  fc;
+	p80211_rxmeta_t	*rxmeta;
+	struct sk_buff          *skb = NULL;
+	UINT8 *datap;
+
+	DBFENTER;
+
+	/* Get the FID */
+	rxfid = hfa384x_getreg(hw, HFA384x_RXFID);
+	/* Get the descriptor (including headers) */
+	result = hfa384x_copy_from_bap(hw, 
+			HFA384x_BAP_INT, 
+			rxfid, 
+			0, 
+			&rxdesc, 
+			sizeof(rxdesc));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1, 
+			"copy_from_bap(0x%04x, %d, %d) failed, result=0x%x\n", 
+			rxfid, 
+			0, 
+			sizeof(rxdesc),
+			result);
+		goto done;
+	}
+
+	/* Byte order convert once up front. */
+	rxdesc.status =	hfa384x2host_16(rxdesc.status);
+	rxdesc.time =	hfa384x2host_32(rxdesc.time);
+
+	/* drop errors and whatnot in promisc mode */
+	if (( wlandev->netdev->flags & IFF_PROMISC ) &&
+	    (HFA384x_RXSTATUS_ISFCSERR(rxdesc.status) || 
+	     HFA384x_RXSTATUS_ISUNDECR(rxdesc.status))) 
+	  goto done;
+
+	/* Now handle frame based on port# */
+	switch( HFA384x_RXSTATUS_MACPORT_GET(rxdesc.status) )
+	{
+	case 0:
+
+		fc = ieee2host16(rxdesc.frame_control);
+
+		/* If exclude and we receive an unencrypted, drop it */
+		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) && 
+		     !WLAN_GET_FC_ISWEP(fc)) {
+			goto done;
+		}
+
+		hdrlen = p80211_headerlen(fc);
+
+		/* Allocate the buffer, note CRC (aka FCS). pballoc */
+		/* assumes there needs to be space for one */
+		skb = dev_alloc_skb(hfa384x2host_16(rxdesc.data_len) + hdrlen + WLAN_CRC_LEN + 2); /* a little extra */
+
+		if ( ! skb ) {
+			WLAN_LOG_ERROR("alloc_skb failed.\n");
+			goto done;
+                }
+
+		skb->dev = wlandev->netdev;
+
+		/* theoretically align the IP header on a 32-bit word. */
+		if ( hdrlen == WLAN_HDR_A4_LEN )
+			skb_reserve(skb, 2);
+
+		/* Copy the 802.11 hdr to the buffer */
+		datap = skb_put(skb, WLAN_HDR_A3_LEN);
+		memcpy(datap, &rxdesc.frame_control, WLAN_HDR_A3_LEN);
+		
+		/* Snag the A4 address if present */
+		if (hdrlen == WLAN_HDR_A4_LEN) {
+			datap = skb_put(skb, WLAN_ADDR_LEN);
+			memcpy(datap, &rxdesc.address4, WLAN_HDR_A3_LEN);
+		}
+
+		/* we can convert the data_len as we passed the original on */
+		rxdesc.data_len = hfa384x2host_16(rxdesc.data_len);
+
+		/* Copy the payload data to the buffer */
+		if ( rxdesc.data_len > 0 ) {
+			datap = skb_put(skb, rxdesc.data_len);
+			result = hfa384x_copy_from_bap(hw, 
+				HFA384x_BAP_INT, rxfid, HFA384x_RX_DATA_OFF, 
+				datap, rxdesc.data_len);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1, 
+					"copy_from_bap(0x%04x, %d, %d) failed, result=0x%x\n", 
+					rxfid, 
+					HFA384x_RX_DATA_OFF, 
+					rxdesc.data_len,
+					result);
+				goto failed;
+			}
+		}
+		/* the prism2 cards don't return the FCS */
+		datap = skb_put(skb, WLAN_CRC_LEN);
+		memset (datap, 0xff, WLAN_CRC_LEN);
+		skb->mac.raw = skb->data;
+
+		/* Attach the rxmeta, set some stuff */
+		p80211skb_rxmeta_attach(wlandev, skb);
+		rxmeta = P80211SKB_RXMETA(skb);
+		rxmeta->mactime = rxdesc.time;
+		rxmeta->rxrate = rxdesc.rate;
+		rxmeta->signal = rxdesc.signal - hw->dbmadjust;
+		rxmeta->noise = rxdesc.silence - hw->dbmadjust;
+
+		prism2sta_ev_rx(wlandev, skb);
+		goto done;
+	case 7:
+
+        	if ( ! HFA384x_RXSTATUS_ISFCSERR(rxdesc.status) ) {
+                        hfa384x_int_rxmonitor( wlandev, rxfid, &rxdesc);
+                } else {
+                        WLAN_LOG_DEBUG(3,"Received monitor frame: FCSerr set\n");
+                }
+		goto done;
+
+	default:
+
+		WLAN_LOG_WARNING("Received frame on unsupported port=%d\n",
+			HFA384x_RXSTATUS_MACPORT_GET(rxdesc.status) );
+		goto done;
+	}
+
+ failed:
+	dev_kfree_skb(skb);
+	
+ done:
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_int_rxmonitor
+*
+* Helper function for int_rx.  Handles monitor frames.
+* Note that this function allocates space for the FCS and sets it
+* to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
+* higher layers expect it.  0xffffffff is used as a flag to indicate
+* the FCS is bogus.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	rxfid		received FID
+*	rxdesc		rx descriptor read from card in int_rx
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	Allocates an skb and passes it up via the PF_PACKET interface.
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_int_rxmonitor( wlandevice_t *wlandev, UINT16 rxfid, hfa384x_rx_frame_t *rxdesc)
+{
+	hfa384x_t			*hw = wlandev->priv;
+	UINT				hdrlen = 0;
+	UINT				datalen = 0;
+	UINT				skblen = 0;
+	UINT				truncated = 0;
+	UINT8				*datap;
+	UINT16				fc;
+	struct sk_buff			*skb;
+
+	DBFENTER;
+	/* Don't forget the status, time, and data_len fields are in host order */
+	/* Figure out how big the frame is */
+	fc = ieee2host16(rxdesc->frame_control);
+	hdrlen = p80211_headerlen(fc);
+	datalen = hfa384x2host_16(rxdesc->data_len);
+
+	/* Allocate an ind message+framesize skb */
+	skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) + 
+		hdrlen + datalen + WLAN_CRC_LEN;
+	
+	/* sanity check the length */
+	if ( skblen > 
+		(sizeof(p80211msg_lnxind_wlansniffrm_t) + 
+		WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+		WLAN_LOG_DEBUG(1, "overlen frm: len=%d\n", 
+			skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+	}
+			
+	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
+		WLAN_LOG_ERROR("alloc_skb failed trying to allocate %d bytes\n", skblen);
+		return;
+	}
+
+	/* only prepend the prism header if in the right mode */
+	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+	    (hw->sniffhdr == 0)) {
+		p80211msg_lnxind_wlansniffrm_t	*msg;
+		datap = skb_put(skb, sizeof(p80211msg_lnxind_wlansniffrm_t));
+		msg = (p80211msg_lnxind_wlansniffrm_t*) datap;
+	  
+		/* Initialize the message members */
+		msg->msgcode = DIDmsg_lnxind_wlansniffrm;
+		msg->msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
+		strcpy(msg->devname, wlandev->name);
+		
+		msg->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+		msg->hosttime.status = 0;
+		msg->hosttime.len = 4;
+		msg->hosttime.data = jiffies;
+		
+		msg->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
+		msg->mactime.status = 0;
+		msg->mactime.len = 4;
+		msg->mactime.data = rxdesc->time * 1000;
+		
+		msg->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+		msg->channel.status = 0;
+		msg->channel.len = 4;
+		msg->channel.data = hw->sniff_channel;
+		
+		msg->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+		msg->rssi.status = P80211ENUM_msgitem_status_no_value;
+		msg->rssi.len = 4;
+		msg->rssi.data = 0;
+		
+		msg->sq.did = DIDmsg_lnxind_wlansniffrm_sq;
+		msg->sq.status = P80211ENUM_msgitem_status_no_value;
+		msg->sq.len = 4;
+		msg->sq.data = 0;
+		
+		msg->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
+		msg->signal.status = 0;
+		msg->signal.len = 4;
+		msg->signal.data = rxdesc->signal;
+		
+		msg->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
+		msg->noise.status = 0;
+		msg->noise.len = 4;
+		msg->noise.data = rxdesc->silence;
+		
+		msg->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
+		msg->rate.status = 0;
+		msg->rate.len = 4;
+		msg->rate.data = rxdesc->rate / 5; /* set to 802.11 units */
+		
+		msg->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+		msg->istx.status = 0;
+		msg->istx.len = 4;
+		msg->istx.data = P80211ENUM_truth_false;
+		
+		msg->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
+		msg->frmlen.status = 0;
+		msg->frmlen.len = 4;
+		msg->frmlen.data = hdrlen + datalen + WLAN_CRC_LEN;
+	} else if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+		   (hw->sniffhdr != 0)) {
+		p80211_caphdr_t		*caphdr;
+		/* The NEW header format! */
+		datap = skb_put(skb, sizeof(p80211_caphdr_t));
+		caphdr = (p80211_caphdr_t*) datap;
+
+		caphdr->version =	htonl(P80211CAPTURE_VERSION);
+		caphdr->length =	htonl(sizeof(p80211_caphdr_t));
+		caphdr->mactime =	__cpu_to_be64(rxdesc->time);
+		caphdr->hosttime =	__cpu_to_be64(jiffies);
+		caphdr->phytype =	htonl(4); /* dss_dot11_b */
+		caphdr->channel =	htonl(hw->sniff_channel);
+		caphdr->datarate =	htonl(rxdesc->rate);
+		caphdr->antenna =	htonl(0); /* unknown */
+		caphdr->priority =	htonl(0); /* unknown */
+		caphdr->ssi_type =	htonl(3); /* rssi_raw */
+		caphdr->ssi_signal =	htonl(rxdesc->signal);
+		caphdr->ssi_noise =	htonl(rxdesc->silence);
+		caphdr->preamble =	htonl(0); /* unknown */
+		caphdr->encoding =	htonl(1); /* cck */
+	}
+	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
+	datap = skb_put(skb, hdrlen);
+	memcpy( datap, &(rxdesc->frame_control), hdrlen);
+
+	/* If any, copy the data from the card to the skb */
+	if ( datalen > 0 )
+	{
+		/* Truncate the packet if the user wants us to */
+		UINT	dataread = datalen;
+		if(hw->sniff_truncate > 0 && dataread > hw->sniff_truncate) {
+			dataread = hw->sniff_truncate;
+			truncated = 1;
+		}
+
+		datap = skb_put(skb, dataread);
+		hfa384x_copy_from_bap(hw, 
+			HFA384x_BAP_INT, rxfid, HFA384x_RX_DATA_OFF, 
+			datap, dataread);
+
+		/* check for unencrypted stuff if WEP bit set. */
+		if (*(datap - hdrlen + 1) & 0x40) // wep set
+		  if ((*(datap) == 0xaa) && (*(datap+1) == 0xaa))
+		    *(datap - hdrlen + 1) &= 0xbf; // clear wep; it's the 802.2 header!
+	}
+
+	if (!truncated && hw->sniff_fcs) {
+		/* Set the FCS */
+		datap = skb_put(skb, WLAN_CRC_LEN);
+		memset( datap, 0xff, WLAN_CRC_LEN);
+	}
+
+	/* pass it back up */
+	prism2sta_ev_rx(wlandev, skb);
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_int_alloc
+*
+* Handles the Alloc event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_int_alloc(wlandevice_t *wlandev)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16			fid;
+	INT16			result;
+
+	DBFENTER;
+
+	/* Handle the reclaimed FID */
+	/*   collect the FID and push it onto the stack */
+	fid = hfa384x_getreg(hw, HFA384x_ALLOCFID);
+
+	if ( fid != hw->infofid ) { /* It's a transmit fid */
+		WLAN_LOG_DEBUG(5, "int_alloc(%#x)\n", fid);
+		result = txfid_queue_add(hw, fid);
+		if (result != -1) {
+			prism2sta_ev_alloc(wlandev);
+			WLAN_LOG_DEBUG(5, "q_add.\n");
+		} else {
+			WLAN_LOG_DEBUG(5, "q_full.\n");
+		}
+	} else {
+		/* unlock the info fid */
+		up(&hw->infofid_sem);
+	}
+
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_handover
+*
+* Sends a handover notification to the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	addr		address of station that's left
+*
+* Returns: 
+*	zero		success.
+*	-ERESTARTSYS	received signal while waiting for semaphore.
+*	-EIO		failed to write to bap, or failed in cmd.
+*
+* Side effects:
+*
+* Call context:
+*	process thread, NOTE: this call may block on a semaphore! 
+----------------------------------------------------------------*/
+int hfa384x_drvr_handover( hfa384x_t *hw, UINT8 *addr)
+{
+	int			result = 0;
+        hfa384x_HandoverAddr_t  rec;
+        UINT                    len;
+        DBFENTER;
+
+	/* Acquire the infofid */
+	if ( down_interruptible(&hw->infofid_sem) ) {
+		result = -ERESTARTSYS;
+		goto failed;
+	}
+
+        /* Set up the record */
+        len = sizeof(hfa384x_HandoverAddr_t);
+        rec.framelen = host2hfa384x_16(len/2 - 1);
+        rec.infotype = host2hfa384x_16(HFA384x_IT_HANDOVERADDR);
+        memcpy(rec.handover_addr, addr, sizeof(rec.handover_addr));
+
+        /* Issue the command */
+        result = hfa384x_cmd_notify(hw, 1, hw->infofid, &rec, len);
+
+        if ( result != 0 ) {
+                WLAN_LOG_DEBUG(1,"cmd_notify(%04x) failed, result=%d",
+                        hw->infofid, result);
+		result = -EIO;
+                goto failed;
+        }
+
+failed:
+	DBFEXIT;
+	return result;	
+}
+
+void hfa384x_tx_timeout(wlandevice_t *wlandev)
+{
+	DBFENTER;
+
+	WLAN_LOG_WARNING("Implement me.\n");
+
+	DBFEXIT;
+}
+
+/* Handles all "rx" BAP operations */
+static void     hfa384x_bap_tasklet(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t *) data;
+	wlandevice_t *wlandev = hw->wlandev;
+	int counter = prism2_irq_evread_max;
+	int			reg;
+
+	DBFENTER;
+
+	while (counter-- > 0) {
+		/* Get interrupt register */
+		reg = hfa384x_getreg(hw, HFA384x_EVSTAT);
+
+		if ((reg == 0xffff) || 
+		    !(reg & HFA384x_INT_BAP_OP)) {
+			break;
+		}
+
+		if ( HFA384x_EVSTAT_ISINFO(reg) ){
+			hfa384x_int_info(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_INFO_SET(1),
+				HFA384x_EVACK);
+		}
+		if ( HFA384x_EVSTAT_ISTXEXC(reg) ){
+			hfa384x_int_txexc(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_TXEXC_SET(1),
+				HFA384x_EVACK);
+		}
+		if ( HFA384x_EVSTAT_ISTX(reg) ){
+			hfa384x_int_tx(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_TX_SET(1),
+				HFA384x_EVACK);
+		}
+		if ( HFA384x_EVSTAT_ISRX(reg) ){
+			hfa384x_int_rx(wlandev);
+			hfa384x_setreg(hw, HFA384x_EVACK_RX_SET(1),
+				HFA384x_EVACK);
+		}
+	}
+         
+	/* re-enable interrupts */
+	hfa384x_events_all(hw);
+
+	DBFEXIT;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/hfa384x_usb.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/hfa384x_usb.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/hfa384x_usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/hfa384x_usb.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,5024 @@
+/* src/prism2/driver/hfa384x_usb.c
+*
+* Functions that talk to the USB variantof the Intersil hfa384x MAC
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file implements functions that correspond to the prism2/hfa384x
+* 802.11 MAC hardware and firmware host interface.
+*
+* The functions can be considered to represent several levels of 
+* abstraction.  The lowest level functions are simply C-callable wrappers
+* around the register accesses.  The next higher level represents C-callable
+* prism2 API functions that match the Intersil documentation as closely
+* as is reasonable.  The next higher layer implements common sequences 
+* of invokations of the API layer (e.g. write to bap, followed by cmd).
+*
+* Common sequences:
+* hfa384x_drvr_xxx	Highest level abstractions provided by the 
+*			hfa384x code.  They are driver defined wrappers 
+*			for common sequences.  These functions generally
+*			use the services of the lower levels.
+*
+* hfa384x_drvr_xxxconfig  An example of the drvr level abstraction. These
+*			functions are wrappers for the RID get/set 
+*			sequence. They 	call copy_[to|from]_bap() and 
+*			cmd_access().	These functions operate on the 
+*			RIDs and buffers without validation.  The caller
+*			is responsible for that.
+*
+* API wrapper functions:
+* hfa384x_cmd_xxx	functions that provide access to the f/w commands.  
+*			The function arguments correspond to each command
+*			argument, even command arguments that get packed
+*			into single registers.  These functions _just_
+*			issue the command by setting the cmd/parm regs
+*			& reading the status/resp regs.  Additional
+*			activities required to fully use a command
+*			(read/write from/to bap, get/set int status etc.)
+*			are implemented separately.  Think of these as
+*			C-callable prism2 commands.
+*
+* Lowest Layer Functions:
+* hfa384x_docmd_xxx	These functions implement the sequence required
+*			to issue any prism2 command.  Primarily used by the
+*			hfa384x_cmd_xxx functions.
+*
+* hfa384x_bap_xxx	BAP read/write access functions.
+*			Note: we usually use BAP0 for non-interrupt context
+*			 and BAP1 for interrupt context.
+*
+* hfa384x_dl_xxx	download related functions.
+*                 	
+* Driver State Issues:
+* Note that there are two pairs of functions that manage the
+* 'initialized' and 'running' states of the hw/MAC combo.  The four
+* functions are create(), destroy(), start(), and stop().  create()
+* sets up the data structures required to support the hfa384x_*
+* functions and destroy() cleans them up.  The start() function gets
+* the actual hardware running and enables the interrupts.  The stop()
+* function shuts the hardware down.  The sequence should be:
+* create()
+* start()
+*  .
+*  .  Do interesting things w/ the hardware
+*  .
+* stop()
+* destroy()
+*
+* Note that destroy() can be called without calling stop() first.
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include <wlan/version.h>
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/timer.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <asm/bitops.h>
+#include <linux/list.h>
+#include <linux/usb.h>
+
+#include <wlan/wlan_compat.h>
+
+#if (WLAN_HOSTIF != WLAN_USB)
+#error "This file is specific to USB"
+#endif
+
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+static int
+wait_for_completion_interruptible(struct completion *x)
+{
+  int ret = 0;
+
+  might_sleep();
+
+  spin_lock_irq(&x->wait.lock);
+  if (!x->done) {
+    DECLARE_WAITQUEUE(wait, current);
+
+    wait.flags |= WQ_FLAG_EXCLUSIVE;
+    __add_wait_queue_tail(&x->wait, &wait);
+    do {
+      if (signal_pending(current)) {
+        ret = -ERESTARTSYS;
+        __remove_wait_queue(&x->wait, &wait);
+        goto out;
+      }
+      __set_current_state(TASK_INTERRUPTIBLE);
+      spin_unlock_irq(&x->wait.lock);
+      schedule();
+      spin_lock_irq(&x->wait.lock);
+    } while (!x->done);
+    __remove_wait_queue(&x->wait, &wait);
+  }
+  x->done--;
+out:
+  spin_unlock_irq(&x->wait.lock);
+
+  return ret;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,69)
+static void
+usb_init_urb(struct urb *urb)
+{
+	memset(urb, 0, sizeof(*urb));
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
+	urb->count = (atomic_t)ATOMIC_INIT(1);
+#endif
+	spin_lock_init(&urb->lock);
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0) /* tune me! */
+#  define SUBMIT_URB(u,f)  usb_submit_urb(u,f)
+#else
+#  define SUBMIT_URB(u,f)  usb_submit_urb(u)
+#endif
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211req.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+#include <prism2/hfa384x.h>
+#include <prism2/prism2mgmt.h>
+
+/*================================================================*/
+/* Local Constants */
+
+enum cmd_mode
+{
+  DOWAIT = 0,
+  DOASYNC
+};
+typedef enum cmd_mode CMD_MODE;
+
+#define THROTTLE_JIFFIES	(HZ/8)
+
+/*================================================================*/
+/* Local Macros */
+
+#define ROUNDUP64(a) (((a)+63)&~63)
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+extern int prism2_debug;
+
+/*================================================================*/
+/* Local Function Declarations */
+
+#ifdef DEBUG_USB
+static void 
+dbprint_urb(struct urb* urb);
+#endif
+
+static void
+hfa384x_int_rxmonitor( 
+	wlandevice_t *wlandev, 
+	hfa384x_usb_rxfrm_t *rxfrm);
+
+static void
+hfa384x_usb_defer(struct work_struct *ws);
+
+static int
+submit_rx_urb(hfa384x_t *hw, int flags);
+
+static int
+submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, int flags);
+
+/*---------------------------------------------------*/
+/* Callbacks */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+static void 
+hfa384x_usbout_callback(struct urb *urb);
+static void
+hfa384x_ctlxout_callback(struct urb *urb);
+static void	
+hfa384x_usbin_callback(struct urb *urb);
+#else
+static void 
+hfa384x_usbout_callback(struct urb *urb);
+static void
+hfa384x_ctlxout_callback(struct urb *urb);
+static void	
+hfa384x_usbin_callback(struct urb *urb);
+#endif
+
+static void
+hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+
+static void
+hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb);
+
+static void
+hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin);
+
+static void
+hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout);
+
+static void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin, 
+			       int urb_status);
+
+/*---------------------------------------------------*/
+/* Functions to support the prism2 usb command queue */
+
+static void 
+hfa384x_usbctlxq_run(hfa384x_t *hw);
+
+static void 
+hfa384x_usbctlx_reqtimerfn(unsigned long data);
+
+static void 
+hfa384x_usbctlx_resptimerfn(unsigned long data);
+
+static void
+hfa384x_usb_throttlefn(unsigned long data);
+
+static void
+hfa384x_usbctlx_completion_task(unsigned long data);
+
+static void
+hfa384x_usbctlx_reaper_task(unsigned long data);
+
+static int
+hfa384x_usbctlx_submit(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+static void 
+unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+struct usbctlx_completor
+{
+	int (*complete)(struct usbctlx_completor*);
+};
+typedef struct usbctlx_completor usbctlx_completor_t;
+
+static int
+hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+                              hfa384x_usbctlx_t *ctlx,
+                              usbctlx_completor_t *completor);
+
+static int
+unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx);
+
+static void
+hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+
+static void
+hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx);
+
+static int
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result);
+
+static void
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+                       hfa384x_rridresult_t *result);
+
+/*---------------------------------------------------*/
+/* Low level req/resp CTLX formatters and submitters */
+static int
+hfa384x_docmd( 
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	hfa384x_metacmd_t *cmd,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dorrid(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dowrid(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dormem(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_dowmem(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data);
+
+static int
+hfa384x_isgood_pdrcode(UINT16 pdrcode);
+
+/*================================================================*/
+/* Function Definitions */
+static inline const char* ctlxstr(CTLX_STATE s)
+{
+	static const char* ctlx_str[] = {
+		"Initial state",
+		"Complete",
+		"Request failed",
+		"Request pending",
+		"Request packet submitted",
+		"Request packet completed",
+		"Response packet completed"
+	};
+
+	return ctlx_str[s];
+};
+
+
+static inline hfa384x_usbctlx_t*
+get_active_ctlx(hfa384x_t *hw)
+{
+	return list_entry(hw->ctlxq.active.next, hfa384x_usbctlx_t, list);
+}
+
+
+#ifdef DEBUG_USB
+void
+dbprint_urb(struct urb* urb)
+{
+	WLAN_LOG_DEBUG(3,"urb->pipe=0x%08x\n", urb->pipe);
+	WLAN_LOG_DEBUG(3,"urb->status=0x%08x\n", urb->status);
+	WLAN_LOG_DEBUG(3,"urb->transfer_flags=0x%08x\n", urb->transfer_flags);
+	WLAN_LOG_DEBUG(3,"urb->transfer_buffer=0x%08x\n", (UINT)urb->transfer_buffer);
+	WLAN_LOG_DEBUG(3,"urb->transfer_buffer_length=0x%08x\n", urb->transfer_buffer_length);
+	WLAN_LOG_DEBUG(3,"urb->actual_length=0x%08x\n", urb->actual_length);
+	WLAN_LOG_DEBUG(3,"urb->bandwidth=0x%08x\n", urb->bandwidth);
+	WLAN_LOG_DEBUG(3,"urb->setup_packet(ctl)=0x%08x\n", (UINT)urb->setup_packet);
+	WLAN_LOG_DEBUG(3,"urb->start_frame(iso/irq)=0x%08x\n", urb->start_frame);
+	WLAN_LOG_DEBUG(3,"urb->interval(irq)=0x%08x\n", urb->interval);
+	WLAN_LOG_DEBUG(3,"urb->error_count(iso)=0x%08x\n", urb->error_count);
+	WLAN_LOG_DEBUG(3,"urb->timeout=0x%08x\n", urb->timeout);
+	WLAN_LOG_DEBUG(3,"urb->context=0x%08x\n", (UINT)urb->context);
+	WLAN_LOG_DEBUG(3,"urb->complete=0x%08x\n", (UINT)urb->complete);
+}
+#endif
+
+
+/*----------------------------------------------------------------
+* submit_rx_urb
+*
+* Listen for input data on the BULK-IN pipe. If the pipe has
+* stalled then schedule it to be reset.
+*
+* Arguments:
+*	hw		device struct
+*	memflags	memory allocation flags
+*
+* Returns:
+*	error code from submission
+*
+* Call context:
+*	Any
+----------------------------------------------------------------*/
+static int
+submit_rx_urb(hfa384x_t *hw, int memflags)
+{
+	struct sk_buff *skb;
+	int result;
+
+	DBFENTER;
+	
+	skb = dev_alloc_skb(sizeof(hfa384x_usbin_t));
+	if (skb == NULL) {
+		result = -ENOMEM;
+		goto done;
+	}	
+
+	/* Post the IN urb */
+	usb_fill_bulk_urb(&hw->rx_urb, hw->usb,
+	              hw->endp_in,
+	              skb->data, sizeof(hfa384x_usbin_t),
+	              hfa384x_usbin_callback, hw->wlandev);
+
+	hw->rx_urb_skb = skb;
+
+	result = -ENOLINK;
+	if ( !hw->wlandev->hwremoved && !test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+		result = SUBMIT_URB(&hw->rx_urb, memflags);
+
+		/* Check whether we need to reset the RX pipe */
+		if (result == -EPIPE) {
+			WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+				schedule_work(&hw->usb_work);
+		}
+	}
+
+	/* Don't leak memory if anything should go wrong */
+	if (result != 0) {
+		dev_kfree_skb(skb);
+		hw->rx_urb_skb = NULL;
+	}
+
+ done:
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* submit_tx_urb
+*
+* Prepares and submits the URB of transmitted data. If the
+* submission fails then it will schedule the output pipe to
+* be reset.
+*
+* Arguments:
+*	hw		device struct
+*	tx_urb		URB of data for tranmission
+*	memflags	memory allocation flags
+*
+* Returns:
+*	error code from submission
+*
+* Call context:
+*	Any
+----------------------------------------------------------------*/
+static int
+submit_tx_urb(hfa384x_t *hw, struct urb *tx_urb, int memflags)
+{
+	struct net_device *netdev = hw->wlandev->netdev;
+	int result;
+
+	DBFENTER;
+
+	result = -ENOLINK;
+	if ( netif_running(netdev) ) {
+
+		if ( !hw->wlandev->hwremoved && !test_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+			result = SUBMIT_URB(tx_urb, memflags);
+
+			/* Test whether we need to reset the TX pipe */
+			if (result == -EPIPE) {
+				WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+				                 netdev->name);
+				set_bit(WORK_TX_HALT, &hw->usb_flags);
+				schedule_work(&hw->usb_work);
+			} else if (result == 0) {
+				netif_stop_queue(netdev);
+			}
+		}
+	}
+
+	DBFEXIT;
+
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa394x_usb_defer
+*
+* There are some things that the USB stack cannot do while
+* in interrupt context, so we arrange this function to run
+* in process context.
+*
+* Arguments:
+*	hw	device structure
+*
+* Returns:
+*	nothing
+*
+* Call context:
+*	process (by design)
+----------------------------------------------------------------*/
+static void
+hfa384x_usb_defer(struct work_struct *ws)
+{
+	hfa384x_t *hw = container_of(ws, hfa384x_t, usb_work);
+	struct net_device *netdev = hw->wlandev->netdev;
+
+	DBFENTER;
+
+	/* Don't bother trying to reset anything if the plug
+	 * has been pulled ...
+	 */
+	if ( hw->wlandev->hwremoved ) {
+		DBFEXIT;
+		return;
+	}
+
+	/* Reception has stopped: try to reset the input pipe */
+	if (test_bit(WORK_RX_HALT, &hw->usb_flags)) {
+		int ret;
+
+		usb_kill_urb(&hw->rx_urb);  /* Cannot be holding spinlock! */
+
+		ret = usb_clear_halt(hw->usb, hw->endp_in);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to clear rx pipe for %s: err=%d\n",
+			       netdev->name, ret);
+		} else {
+			printk(KERN_INFO "%s rx pipe reset complete.\n",
+			                 netdev->name);
+			clear_bit(WORK_RX_HALT, &hw->usb_flags);
+			set_bit(WORK_RX_RESUME, &hw->usb_flags);
+		}
+	}
+
+	/* Resume receiving data back from the device. */
+	if ( test_bit(WORK_RX_RESUME, &hw->usb_flags) ) {
+		int ret;
+
+		ret = submit_rx_urb(hw, GFP_KERNEL);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to resume %s rx pipe.\n", netdev->name); 
+		} else {
+			clear_bit(WORK_RX_RESUME, &hw->usb_flags);
+		}
+	}
+
+	/* Transmission has stopped: try to reset the output pipe */
+	if (test_bit(WORK_TX_HALT, &hw->usb_flags)) {
+		int ret;
+
+		usb_kill_urb(&hw->tx_urb);
+		ret = usb_clear_halt(hw->usb, hw->endp_out);
+		if (ret != 0) {
+			printk(KERN_ERR
+			       "Failed to clear tx pipe for %s: err=%d\n",
+			       netdev->name, ret);
+		} else {
+			printk(KERN_INFO "%s tx pipe reset complete.\n",
+			                 netdev->name);
+			clear_bit(WORK_TX_HALT, &hw->usb_flags);
+			set_bit(WORK_TX_RESUME, &hw->usb_flags);
+
+			/* Stopping the BULK-OUT pipe also blocked
+			 * us from sending any more CTLX URBs, so
+			 * we need to re-run our queue ...
+			 */
+			hfa384x_usbctlxq_run(hw);
+		}
+	}
+
+	/* Resume transmitting. */
+	if ( test_and_clear_bit(WORK_TX_RESUME, &hw->usb_flags) ) {
+		p80211netdev_wake_queue(hw->wlandev);
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_create
+*
+* Sets up the hfa384x_t data structure for use.  Note this
+* does _not_ intialize the actual hardware, just the data structures
+* we use to keep track of its state.
+*
+* Arguments:
+*	hw		device structure
+*	irq		device irq number
+*	iobase		i/o base address for register access
+*	membase		memory base address for register access
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+void
+hfa384x_create( hfa384x_t *hw, struct usb_device *usb)
+{
+	DBFENTER;
+
+	memset(hw, 0, sizeof(hfa384x_t));
+	hw->usb = usb;
+
+	/* set up the endpoints */
+	hw->endp_in = usb_rcvbulkpipe(usb, 1);
+	hw->endp_out = usb_sndbulkpipe(usb, 2);
+
+	/* Set up the waitq */
+	init_waitqueue_head(&hw->cmdq);
+
+	/* Initialize the command queue */
+	spin_lock_init(&hw->ctlxq.lock);
+	INIT_LIST_HEAD(&hw->ctlxq.pending);
+	INIT_LIST_HEAD(&hw->ctlxq.active);
+	INIT_LIST_HEAD(&hw->ctlxq.completing);
+	INIT_LIST_HEAD(&hw->ctlxq.reapable);
+
+	/* Initialize the authentication queue */
+	skb_queue_head_init(&hw->authq);
+
+	tasklet_init(&hw->reaper_bh,
+	             hfa384x_usbctlx_reaper_task,
+	             (unsigned long)hw);
+	tasklet_init(&hw->completion_bh,
+	             hfa384x_usbctlx_completion_task,
+	             (unsigned long)hw);
+	INIT_WORK(&hw->link_bh, prism2sta_processing_defer);
+	INIT_WORK(&hw->usb_work, hfa384x_usb_defer);
+
+	init_timer(&hw->throttle);
+	hw->throttle.function = hfa384x_usb_throttlefn;
+	hw->throttle.data = (unsigned long)hw;
+
+	init_timer(&hw->resptimer);
+	hw->resptimer.function = hfa384x_usbctlx_resptimerfn;
+	hw->resptimer.data = (unsigned long)hw;
+
+	init_timer(&hw->reqtimer);
+	hw->reqtimer.function = hfa384x_usbctlx_reqtimerfn;
+	hw->reqtimer.data = (unsigned long)hw;
+
+	usb_init_urb(&hw->rx_urb);
+	usb_init_urb(&hw->tx_urb);
+	usb_init_urb(&hw->ctlx_urb);
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+        INIT_WORK(&hw->commsqual_bh, prism2sta_commsqual_defer);
+	init_timer(&hw->commsqual_timer);
+	hw->commsqual_timer.data = (unsigned long) hw;
+	hw->commsqual_timer.function = prism2sta_commsqual_timer;
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_destroy
+*
+* Partner to hfa384x_create().  This function cleans up the hw
+* structure so that it can be freed by the caller using a simple
+* kfree.  Currently, this function is just a placeholder.  If, at some
+* point in the future, an hw in the 'shutdown' state requires a 'deep'
+* kfree, this is where it should be done.  Note that if this function
+* is called on a _running_ hw structure, the drvr_stop() function is
+* called.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	nothing, this function is not allowed to fail.
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+void
+hfa384x_destroy( hfa384x_t *hw)
+{
+	struct sk_buff *skb;
+
+	DBFENTER;
+
+	if ( hw->state == HFA384x_STATE_RUNNING ) {
+		hfa384x_drvr_stop(hw);
+	}
+	hw->state = HFA384x_STATE_PREINIT;		
+
+	if (hw->scanresults) {
+		kfree(hw->scanresults);
+		hw->scanresults = NULL;
+	}
+
+	/* Now to clean out the auth queue */
+        while ( (skb = skb_dequeue(&hw->authq)) ) {
+                dev_kfree_skb(skb);
+        }		
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+ */
+static hfa384x_usbctlx_t* usbctlx_alloc(void)
+{
+	hfa384x_usbctlx_t *ctlx;
+
+	ctlx = kmalloc(sizeof(*ctlx), in_interrupt() ? GFP_ATOMIC : GFP_KERNEL);
+	if (ctlx != NULL)
+	{
+		memset(ctlx, 0, sizeof(*ctlx));
+		init_completion(&ctlx->done);
+	}
+
+	return ctlx;
+}
+
+
+/*----------------------------------------------------------------
+ *
+----------------------------------------------------------------*/
+int
+usbctlx_get_status(const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result)
+{
+	DBFENTER;
+
+	result->status = hfa384x2host_16(cmdresp->status);
+	result->resp0 = hfa384x2host_16(cmdresp->resp0);
+	result->resp1 = hfa384x2host_16(cmdresp->resp1);
+	result->resp2 = hfa384x2host_16(cmdresp->resp2);
+
+	WLAN_LOG_DEBUG(4, "cmdresult:status=0x%04x "
+	                  "resp0=0x%04x resp1=0x%04x resp2=0x%04x\n",
+	                result->status,
+	                result->resp0,
+	                result->resp1,
+	                result->resp2);
+
+	DBFEXIT;
+	return (result->status & HFA384x_STATUS_RESULT);
+}
+
+void
+usbctlx_get_rridresult(const hfa384x_usb_rridresp_t *rridresp,
+                       hfa384x_rridresult_t *result)
+{
+	DBFENTER;
+
+	result->rid = hfa384x2host_16(rridresp->rid);
+	result->riddata = rridresp->data;
+	result->riddata_len = ((hfa384x2host_16(rridresp->frmlen) - 1) * 2);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* Completor object:
+* This completor must be passed to hfa384x_usbctlx_complete_sync()
+* when processing a CTLX that returns a hfa384x_cmdresult_t structure.
+----------------------------------------------------------------*/
+struct usbctlx_cmd_completor
+{
+	usbctlx_completor_t	head;
+
+	const hfa384x_usb_cmdresp_t	*cmdresp;
+	hfa384x_cmdresult_t	*result;
+};
+typedef struct usbctlx_cmd_completor usbctlx_cmd_completor_t;
+
+static int usbctlx_cmd_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_cmd_completor_t *complete = (usbctlx_cmd_completor_t*)head;
+	return usbctlx_get_status(complete->cmdresp, complete->result);
+}
+
+static inline usbctlx_completor_t*
+init_cmd_completor(usbctlx_cmd_completor_t *completor,
+                   const hfa384x_usb_cmdresp_t *cmdresp,
+                   hfa384x_cmdresult_t *result)
+{
+	completor->head.complete = usbctlx_cmd_completor_fn;
+	completor->cmdresp = cmdresp;
+	completor->result = result;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* Completor object:
+* This completor must be passed to hfa384x_usbctlx_complete_sync()
+* when processing a CTLX that reads a RID.
+----------------------------------------------------------------*/
+struct usbctlx_rrid_completor
+{
+	usbctlx_completor_t	head;
+
+	const hfa384x_usb_rridresp_t	*rridresp;
+	void			*riddata;
+	UINT			riddatalen;
+};
+typedef struct usbctlx_rrid_completor usbctlx_rrid_completor_t;
+
+static int usbctlx_rrid_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_rrid_completor_t *complete = (usbctlx_rrid_completor_t*)head;
+	hfa384x_rridresult_t rridresult;
+
+	usbctlx_get_rridresult(complete->rridresp, &rridresult);
+
+	/* Validate the length, note body len calculation in bytes */
+	if ( rridresult.riddata_len != complete->riddatalen ) {  
+		WLAN_LOG_WARNING(
+			"RID len mismatch, rid=0x%04x hlen=%d fwlen=%d\n",
+		        rridresult.rid,
+		        complete->riddatalen,
+		        rridresult.riddata_len);
+		return -ENODATA;
+	}
+
+	memcpy(complete->riddata,
+	       rridresult.riddata,
+	       complete->riddatalen);
+	return 0;
+}
+
+static inline usbctlx_completor_t*
+init_rrid_completor(usbctlx_rrid_completor_t *completor,
+                    const hfa384x_usb_rridresp_t *rridresp,
+                    void *riddata,
+                    UINT riddatalen)
+{
+	completor->head.complete = usbctlx_rrid_completor_fn;
+	completor->rridresp = rridresp;
+	completor->riddata = riddata;
+	completor->riddatalen = riddatalen;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous RID-write
+----------------------------------------------------------------*/
+typedef usbctlx_cmd_completor_t usbctlx_wrid_completor_t;
+#define init_wrid_completor  init_cmd_completor
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous memory-write
+----------------------------------------------------------------*/
+typedef usbctlx_cmd_completor_t usbctlx_wmem_completor_t;
+#define init_wmem_completor  init_cmd_completor
+
+/*----------------------------------------------------------------
+* Completor object:
+* Interprets the results of a synchronous memory-read
+----------------------------------------------------------------*/
+struct usbctlx_rmem_completor
+{
+        usbctlx_completor_t           head;
+                                                                                
+        const hfa384x_usb_rmemresp_t  *rmemresp;
+        void                          *data;
+        UINT                          len;
+};
+typedef struct usbctlx_rmem_completor usbctlx_rmem_completor_t;
+
+static int usbctlx_rmem_completor_fn(usbctlx_completor_t *head)
+{
+	usbctlx_rmem_completor_t *complete = (usbctlx_rmem_completor_t*)head;
+
+	WLAN_LOG_DEBUG(4,"rmemresp:len=%d\n", complete->rmemresp->frmlen);
+	memcpy(complete->data, complete->rmemresp->data, complete->len);
+	return 0;
+}
+
+static inline usbctlx_completor_t*
+init_rmem_completor(usbctlx_rmem_completor_t *completor,
+                    hfa384x_usb_rmemresp_t *rmemresp,
+                    void *data,
+                    UINT len)
+{
+	completor->head.complete = usbctlx_rmem_completor_fn;
+	completor->rmemresp = rmemresp;
+	completor->data = data;
+	completor->len = len;
+	return &(completor->head);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_cb_status
+*
+* Ctlx_complete handler for async CMD type control exchanges.
+* mark the hw struct as such.
+*
+* Note: If the handling is changed here, it should probably be 
+*       changed in docmd as well.
+*
+* Arguments:
+*	hw		hw struct
+*	ctlx		completed CTLX
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_cb_status(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	if ( ctlx->usercb != NULL ) {
+		hfa384x_cmdresult_t cmdresult;
+
+		if (ctlx->state != CTLX_COMPLETE) {
+			memset(&cmdresult, 0, sizeof(cmdresult));
+			cmdresult.status = HFA384x_STATUS_RESULT_SET(HFA384x_CMD_ERR);
+		} else {
+			usbctlx_get_status(&ctlx->inbuf.cmdresp, &cmdresult);
+		}
+
+		ctlx->usercb(hw, &cmdresult, ctlx->usercb_data);
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cb_rrid
+*
+* CTLX completion handler for async RRID type control exchanges.
+* 
+* Note: If the handling is changed here, it should probably be 
+*       changed in dorrid as well.
+*
+* Arguments:
+*	hw		hw struct
+*	ctlx		completed CTLX
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_cb_rrid(hfa384x_t *hw, const hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	if ( ctlx->usercb != NULL ) {
+		hfa384x_rridresult_t rridresult;
+
+		if (ctlx->state != CTLX_COMPLETE) {
+			memset(&rridresult, 0, sizeof(rridresult));
+			rridresult.rid = hfa384x2host_16(ctlx->outbuf.rridreq.rid);
+		} else {
+			usbctlx_get_rridresult(&ctlx->inbuf.rridresp, &rridresult);
+		}
+
+		ctlx->usercb(hw, &rridresult, ctlx->usercb_data);
+	}
+
+	DBFEXIT;
+}
+
+static inline int
+hfa384x_docmd_wait(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	return hfa384x_docmd(hw, DOWAIT, cmd, NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_docmd_async(hfa384x_t *hw,
+                    hfa384x_metacmd_t *cmd, 
+                    ctlx_cmdcb_t cmdcb,
+                    ctlx_usercb_t usercb,
+                    void *usercb_data)
+{
+	return hfa384x_docmd(hw, DOASYNC, cmd,
+	                        cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dorrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+{
+	return hfa384x_dorrid(hw, DOWAIT,
+	                      rid, riddata, riddatalen,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dorrid_async(hfa384x_t *hw,
+                     UINT16 rid, void *riddata, UINT riddatalen,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dorrid(hw, DOASYNC,
+	                      rid, riddata, riddatalen,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dowrid_wait(hfa384x_t *hw, UINT16 rid, void *riddata, UINT riddatalen)
+{
+	return hfa384x_dowrid(hw, DOWAIT,
+	                      rid, riddata, riddatalen,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dowrid_async(hfa384x_t *hw,
+                     UINT16 rid, void *riddata, UINT riddatalen,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dowrid(hw, DOASYNC,
+	                      rid, riddata, riddatalen,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dormem_wait(hfa384x_t *hw,
+                    UINT16 page, UINT16 offset, void *data, UINT len)
+{
+	return hfa384x_dormem(hw, DOWAIT,
+	                      page, offset, data, len,
+	                      NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dormem_async(hfa384x_t *hw,
+                     UINT16 page, UINT16 offset, void *data, UINT len,
+                     ctlx_cmdcb_t cmdcb,
+                     ctlx_usercb_t usercb,
+                     void *usercb_data)
+{
+	return hfa384x_dormem(hw, DOASYNC,
+	                      page, offset, data, len,
+	                      cmdcb, usercb, usercb_data);
+}
+
+static inline int
+hfa384x_dowmem_wait(
+        hfa384x_t *hw,
+        UINT16  page,
+        UINT16  offset,
+        void    *data,
+        UINT    len)
+{
+	return hfa384x_dowmem(hw, DOWAIT,
+                                  page, offset, data, len,
+	                          NULL, NULL, NULL);
+}
+
+static inline int
+hfa384x_dowmem_async(
+        hfa384x_t *hw,
+        UINT16  page,
+        UINT16  offset,
+        void    *data,
+        UINT    len,
+        ctlx_cmdcb_t cmdcb,
+        ctlx_usercb_t usercb,
+        void    *usercb_data)
+{
+	return hfa384x_dowmem(hw, DOASYNC,
+                                  page, offset, data, len,
+	                          cmdcb, usercb, usercb_data);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_initialize
+*
+* Issues the initialize command and sets the hw->state based
+* on the result.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int
+hfa384x_cmd_initialize(hfa384x_t *hw)
+{
+	int	result = 0;
+	int	i;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+
+	cmd.cmd = HFA384x_CMDCODE_INIT;
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+
+	WLAN_LOG_DEBUG(3,"cmdresp.init: "
+		"status=0x%04x, resp0=0x%04x, "
+		"resp1=0x%04x, resp2=0x%04x\n",
+		cmd.result.status,
+		cmd.result.resp0,
+		cmd.result.resp1,
+		cmd.result.resp2);
+	if ( result == 0 ) {
+		for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+			hw->port_enabled[i] = 0;
+		}
+	}
+
+        hw->link_status = HFA384x_LINK_NOTCONNECTED;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_disable
+*
+* Issues the disable command to stop communications on one of 
+* the MACs 'ports'.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DISABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_enable
+*
+* Issues the enable command to enable communications on one of 
+* the MACs 'ports'.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_ENABLE) |
+		  HFA384x_CMD_MACPORT_SET(macport);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_notify
+*
+* Sends an info frame to the firmware to alter the behavior
+* of the f/w asynch processes.  Can only be called when the MAC
+* is in the enabled state.
+*
+* Arguments:
+*	hw		device structure
+*	reclaim		[0|1] indicates whether the given FID will
+*			be handed back (via Alloc event) for reuse.
+*			(host order)
+*	fid		FID of buffer containing the frame that was
+*			previously copied to MAC memory via the bap.
+*			(host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*	hw->resp0 will contain the FID being used by async notify
+*	process.  If reclaim==0, resp0 will be the same as the fid
+*	argument.  If reclaim==1, resp0 will be the different.
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_notify(hfa384x_t *hw, UINT16 reclaim, UINT16 fid, 
+		       void *buf, UINT16 len)
+{
+#if 0
+	int	result = 0;
+	UINT16	cmd;
+	DBFENTER;
+	cmd =	HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_NOTIFY) |
+		HFA384x_CMD_RECL_SET(reclaim);
+	result = hfa384x_docmd_wait(hw, cmd);
+	
+	DBFEXIT;
+	return result;
+#endif
+return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_inquiry
+*
+* Requests an info frame from the firmware.  The info frame will
+* be delivered asynchronously via the Info event.
+*
+* Arguments:
+*	hw		device structure
+*	fid		FID of the info frame requested. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_inquiry(hfa384x_t *hw, UINT16 fid)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_INQ);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_monitor
+*
+* Enables the 'monitor mode' of the MAC.  Here's the description of
+* monitor mode that I've received thus far:
+*
+*  "The "monitor mode" of operation is that the MAC passes all 
+*  frames for which the PLCP checks are correct. All received 
+*  MPDUs are passed to the host with MAC Port = 7, with a  
+*  receive status of good, FCS error, or undecryptable. Passing 
+*  certain MPDUs is a violation of the 802.11 standard, but useful 
+*  for a debugging tool."  Normal communication is not possible
+*  while monitor mode is enabled.
+*
+* Arguments:
+*	hw		device structure
+*	enable		a code (0x0b|0x0f) that enables/disables
+*			monitor mode. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_monitor(hfa384x_t *hw, UINT16 enable)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_MONITOR) |
+		HFA384x_CMD_AINFO_SET(enable);
+	cmd.parm0 = 0;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_cmd_download
+*
+* Sets the controls for the MAC controller code/data download
+* process.  The arguments set the mode and address associated 
+* with a download.  Note that the aux registers should be enabled
+* prior to setting one of the download enable modes.
+*
+* Arguments:
+*	hw		device structure
+*	mode		0 - Disable programming and begin code exec
+*			1 - Enable volatile mem programming
+*			2 - Enable non-volatile mem programming
+*			3 - Program non-volatile section from NV download
+*			    buffer. 
+*			(host order)
+*	lowaddr		
+*	highaddr	For mode 1, sets the high & low order bits of 
+*			the "destination address".  This address will be
+*			the execution start address when download is
+*			subsequently disabled.
+*			For mode 2, sets the high & low order bits of 
+*			the destination in NV ram.
+*			For modes 0 & 3, should be zero. (host order)
+*			NOTE: these are CMD format.
+*	codelen		Length of the data to write in mode 2, 
+*			zero otherwise. (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_cmd_download(hfa384x_t *hw, UINT16 mode, UINT16 lowaddr, 
+				UINT16 highaddr, UINT16 codelen)
+{
+	int	result = 0;
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5,
+		"mode=%d, lowaddr=0x%04x, highaddr=0x%04x, codelen=%d\n",
+		mode, lowaddr, highaddr, codelen);
+
+	cmd.cmd = (HFA384x_CMD_CMDCODE_SET(HFA384x_CMDCODE_DOWNLD) |
+		   HFA384x_CMD_PROGMODE_SET(mode));
+
+	cmd.parm0 = lowaddr;
+	cmd.parm1 = highaddr;
+	cmd.parm2 = codelen;
+
+	result = hfa384x_docmd_wait(hw, &cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_from_aux
+*
+* Copies a collection of bytes from the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	buf contains the data copied
+*
+* Call context:
+*	process
+*	interrupt
+----------------------------------------------------------------*/
+void 
+hfa384x_copy_from_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	DBFENTER;
+	WLAN_LOG_ERROR("not used in USB.\n");
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_copy_to_aux
+*
+* Copies a collection of bytes to the controller memory.  The
+* Auxiliary port MUST be enabled prior to calling this function.
+* We _might_ be in a download state.
+*
+* Arguments:
+*	hw		device structure
+*	cardaddr	address in hfa384x data space to read
+*	auxctl		address space select
+*	buf		ptr to destination host buffer
+*	len		length of data to transfer (in bytes)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	Controller memory now contains a copy of buf
+*
+* Call context:
+*	process
+*	interrupt
+----------------------------------------------------------------*/
+void 
+hfa384x_copy_to_aux(
+	hfa384x_t *hw, UINT32 cardaddr, UINT32 auxctl, void *buf, UINT len)
+{
+	DBFENTER;
+	WLAN_LOG_ERROR("not used in USB.\n");
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_corereset
+*
+* Perform a reset of the hfa38xx MAC core.  We assume that the hw 
+* structure is in its "created" state.  That is, it is initialized
+* with proper values.  Note that if a reset is done after the 
+* device has been active for awhile, the caller might have to clean 
+* up some leftover cruft in the hw structure.
+*
+* Arguments:
+*	hw		device structure
+*	holdtime	how long (in ms) to hold the reset
+*	settletime	how long (in ms) to wait after releasing
+*			the reset
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+{
+#if 0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	struct usb_device	*parent = hw->usb->parent;
+	int			i;
+	int			port = -1;
+#endif
+#endif
+	int 			result = 0;
+
+
+#define P2_USB_RT_PORT		(USB_TYPE_CLASS | USB_RECIP_OTHER)
+#define P2_USB_FEAT_RESET	4
+#define P2_USB_FEAT_C_RESET	20
+
+	DBFENTER;
+
+#if 0
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	/* Find the hub port */
+	for ( i = 0; i < parent->maxchild; i++) {
+		if (parent->children[i] == hw->usb) {
+			port = i;
+			break;
+		}
+	}
+	if (port < 0) return -ENOENT;
+
+	/* Set and clear the reset */
+	usb_control_msg(parent, usb_sndctrlpipe(parent, 0), 
+		USB_REQ_SET_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_RESET, 
+		port+1, NULL, 0, 1*HZ);
+	wait_ms(holdtime);
+	usb_control_msg(parent, usb_sndctrlpipe(parent, 0), 
+		USB_REQ_CLEAR_FEATURE, P2_USB_RT_PORT, P2_USB_FEAT_C_RESET, 
+		port+1, NULL, 0, 1*HZ);
+	wait_ms(settletime);
+
+	/* Set the device address */
+	result=usb_set_address(hw->usb);
+	if (result < 0) {
+		WLAN_LOG_ERROR("reset_usbdev: Dev not accepting address, "
+			"result=%d\n", result);
+		clear_bit(hw->usb->devnum, &hw->usb->bus->devmap.devicemap);
+		hw->usb->devnum = -1;
+		goto done;
+	}
+	/* Let the address settle */
+	wait_ms(20);
+
+	/* Assume we're reusing the original descriptor data */
+	
+	/* Set the configuration. */
+	WLAN_LOG_DEBUG(3, "Setting Configuration %d\n", 
+		hw->usb->config[0].bConfigurationValue);
+	result=usb_set_configuration(hw->usb, hw->usb->config[0].bConfigurationValue);
+	if ( result ) {
+		WLAN_LOG_ERROR("usb_set_configuration() failed, result=%d.\n",
+				result);
+		goto done;
+	}	
+	/* Let the configuration settle */
+	wait_ms(20);
+
+ done:	
+#else
+	result=usb_reset_device(hw->usb);
+	if(result<0) {
+		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
+	}
+#endif
+#endif
+
+	result=usb_reset_device(hw->usb);
+	if(result<0) {
+		WLAN_LOG_ERROR("usb_reset_device() failed, result=%d.\n",result);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_complete_sync
+*
+* Waits for a synchronous CTLX object to complete,
+* and then handles the response.
+*
+* Arguments:
+*	hw		device structure
+*	ctlx	 	CTLX ptr
+*	completor	functor object to decide what to
+*			do with the CTLX's result.
+*
+* Returns:
+*	0		Success
+*	-ERESTARTSYS	Interrupted by a signal
+*	-EIO		CTLX failed
+*	-ENODEV		Adapter was unplugged
+*	???		Result from completor
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_usbctlx_complete_sync(hfa384x_t *hw,
+                                  hfa384x_usbctlx_t *ctlx,
+                                  usbctlx_completor_t *completor)
+{
+	unsigned long flags;
+	int result;
+
+	DBFENTER;
+
+	result = wait_for_completion_interruptible(&ctlx->done);
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/*
+	 * We can only handle the CTLX if the USB disconnect
+	 * function has not run yet ...
+	 */
+	cleanup:
+	if ( hw->wlandev->hwremoved )
+	{
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		result = -ENODEV;
+	}
+	else if ( result != 0 )
+	{
+		int runqueue = 0;
+
+		/*
+		 * We were probably interrupted, so delete
+		 * this CTLX asynchronously, kill the timers
+		 * and the URB, and then start the next
+		 * pending CTLX.
+		 *
+		 * NOTE: We can only delete the timers and
+		 *       the URB if this CTLX is active.
+		 */
+		if (ctlx == get_active_ctlx(hw))
+		{
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+			del_singleshot_timer_sync(&hw->reqtimer);
+			del_singleshot_timer_sync(&hw->resptimer);
+			hw->req_timer_done = 1;
+			hw->resp_timer_done = 1;
+			usb_kill_urb(&hw->ctlx_urb);
+
+			spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+			runqueue = 1;
+
+			/*
+			 * This scenario is so unlikely that I'm
+			 * happy with a grubby "goto" solution ...
+			 */
+			if ( hw->wlandev->hwremoved )
+				goto cleanup;
+		}
+
+		/*
+		 * The completion task will send this CTLX
+		 * to the reaper the next time it runs. We
+		 * are no longer in a hurry.
+		 */
+		ctlx->reapable = 1;
+		ctlx->state = CTLX_REQ_FAILED;
+		list_move_tail(&ctlx->list, &hw->ctlxq.completing);
+
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+		if (runqueue)
+			hfa384x_usbctlxq_run(hw);
+	} else {
+		if (ctlx->state == CTLX_COMPLETE) {
+			result = completor->complete(completor);
+		} else {
+			WLAN_LOG_WARNING("CTLX[%d] error: state(%s)\n",
+			                 hfa384x2host_16(ctlx->outbuf.type),
+			                 ctlxstr(ctlx->state));
+			result = -EIO;
+		}
+
+		list_del(&ctlx->list);
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		kfree(ctlx);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_docmd
+*
+* Constructs a command CTLX and submits it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function 
+*       need to be carried over to hfa384x_cbcmd() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*       cmd             cmd structure.  Includes all arguments and result
+*                       data points.  All in host order. in host order
+*	cmdcb		command-specific callback
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls, NULL
+*			for DOASYNC calls
+*
+* Returns: 
+*	0		success
+*	-EIO		CTLX failure
+*	-ERESTARTSYS	Awakened on signal
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+static int 
+hfa384x_docmd( 
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	hfa384x_metacmd_t *cmd,
+	ctlx_cmdcb_t	cmdcb,
+	ctlx_usercb_t	usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.cmdreq.type = 	host2hfa384x_16(HFA384x_USB_CMDREQ);
+	ctlx->outbuf.cmdreq.cmd =	host2hfa384x_16(cmd->cmd);
+	ctlx->outbuf.cmdreq.parm0 =	host2hfa384x_16(cmd->parm0);
+	ctlx->outbuf.cmdreq.parm1 =	host2hfa384x_16(cmd->parm1);
+	ctlx->outbuf.cmdreq.parm2 =	host2hfa384x_16(cmd->parm2);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.cmdreq);
+
+	WLAN_LOG_DEBUG(4, "cmdreq: cmd=0x%04x "
+		"parm0=0x%04x parm1=0x%04x parm2=0x%04x\n",
+		cmd->cmd,
+		cmd->parm0,
+		cmd->parm1,
+		cmd->parm2);
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {	
+		usbctlx_cmd_completor_t completor;
+
+		result = hfa384x_usbctlx_complete_sync(
+		             hw, ctlx, init_cmd_completor(&completor,
+		                                          &ctlx->inbuf.cmdresp,
+		                                          &cmd->result) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_dorrid
+*
+* Constructs a read rid CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function 
+*       need to be carried over to hfa384x_cbrrid() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	rid		Read RID number (host order)
+*	riddata		Caller supplied buffer that MAC formatted RID.data 
+*			record will be written to for DOWAIT calls. Should
+*			be NULL for DOASYNC calls.
+*	riddatalen	Buffer length for DOWAIT calls. Zero for DOASYNC calls.
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls, NULL
+*			for DOWAIT calls
+*
+* Returns: 
+*	0		success
+*	-EIO		CTLX failure
+*	-ERESTARTSYS	Awakened on signal
+*	-ENODATA	riddatalen != macdatalen
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+static int
+hfa384x_dorrid(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+        ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.rridreq.type =   host2hfa384x_16(HFA384x_USB_RRIDREQ);
+	ctlx->outbuf.rridreq.frmlen = 
+		host2hfa384x_16(sizeof(ctlx->outbuf.rridreq.rid));
+	ctlx->outbuf.rridreq.rid =    host2hfa384x_16(rid);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.rridreq);
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	/* Submit the CTLX */
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {
+		usbctlx_rrid_completor_t completor;
+
+		result = hfa384x_usbctlx_complete_sync(
+		           hw, ctlx, init_rrid_completor(&completor,
+		                                         &ctlx->inbuf.rridresp,
+		                                         riddata,
+		                                         riddatalen) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_dowrid
+*
+* Constructs a write rid CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function 
+*       need to be carried over to hfa384x_cbwrid() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	CMD_MODE	DOWAIT or DOASYNC
+*	rid		RID code
+*	riddata		Data portion of RID formatted for MAC
+*	riddatalen	Length of the data portion in bytes
+*       cmdcb           command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls
+*
+* Returns: 
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+int
+hfa384x_dowrid(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	rid,
+	void	*riddata,
+	UINT	riddatalen,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.wridreq.type =   host2hfa384x_16(HFA384x_USB_WRIDREQ);
+	ctlx->outbuf.wridreq.frmlen = host2hfa384x_16(
+					(sizeof(ctlx->outbuf.wridreq.rid) + 
+					riddatalen + 1) / 2);
+	ctlx->outbuf.wridreq.rid =    host2hfa384x_16(rid);
+	memcpy(ctlx->outbuf.wridreq.data, riddata, riddatalen);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.wridreq.type) +
+	                   sizeof(ctlx->outbuf.wridreq.frmlen) +
+	                   sizeof(ctlx->outbuf.wridreq.rid) +
+	                   riddatalen;
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	/* Submit the CTLX */
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if (mode == DOWAIT) {
+		usbctlx_wrid_completor_t completor;
+		hfa384x_cmdresult_t wridresult;
+
+		result = hfa384x_usbctlx_complete_sync(
+		               hw,
+		               ctlx,
+		               init_wrid_completor(&completor,
+		                                   &ctlx->inbuf.wridresp,
+		                                   &wridresult) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_dormem
+*
+* Constructs a readmem CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function 
+*       need to be carried over to hfa384x_cbrmem() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	page		MAC address space page (CMD format)
+*	offset		MAC address space offset
+*	data		Ptr to data buffer to receive read
+*	len		Length of the data to read (max == 2048)
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls
+*
+* Returns: 
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+* Call context:
+*	interrupt (DOASYNC)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+int
+hfa384x_dormem(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.rmemreq.type =    host2hfa384x_16(HFA384x_USB_RMEMREQ);
+	ctlx->outbuf.rmemreq.frmlen =  host2hfa384x_16(
+					sizeof(ctlx->outbuf.rmemreq.offset) +
+					sizeof(ctlx->outbuf.rmemreq.page) +
+					len);
+	ctlx->outbuf.rmemreq.offset =	host2hfa384x_16(offset);
+	ctlx->outbuf.rmemreq.page =	host2hfa384x_16(page);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.rmemreq);
+
+	WLAN_LOG_DEBUG(4,
+		"type=0x%04x frmlen=%d offset=0x%04x page=0x%04x\n",
+		ctlx->outbuf.rmemreq.type,
+		ctlx->outbuf.rmemreq.frmlen,
+		ctlx->outbuf.rmemreq.offset,
+		ctlx->outbuf.rmemreq.page);
+
+	WLAN_LOG_DEBUG(4,"pktsize=%zd\n", 
+		ROUNDUP64(sizeof(ctlx->outbuf.rmemreq)));
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if ( mode == DOWAIT ) {
+                usbctlx_rmem_completor_t completor;
+                                                                                
+                result = hfa384x_usbctlx_complete_sync(
+                           hw, ctlx, init_rmem_completor(&completor,
+                                                         &ctlx->inbuf.rmemresp,
+                                                         data,
+                                                         len) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+	
+/*----------------------------------------------------------------
+* hfa384x_dowmem
+*
+* Constructs a writemem CTLX and issues it.
+*
+* NOTE: Any changes to the 'post-submit' code in this function 
+*       need to be carried over to hfa384x_cbwmem() since the handling
+*       is virtually identical.
+*
+* Arguments:
+*	hw		device structure
+*	mode		DOWAIT or DOASYNC
+*	page		MAC address space page (CMD format)
+*	offset		MAC address space offset
+*	data		Ptr to data buffer containing write data
+*	len		Length of the data to read (max == 2048)
+*	cmdcb		command callback for async calls, NULL for DOWAIT calls
+*	usercb		user callback for async calls, NULL for DOWAIT calls
+*	usercb_data	user supplied data pointer for async calls.
+*
+* Returns: 
+*	0		success
+*	-ETIMEDOUT	timed out waiting for register ready or
+*			command completion
+*	>0		command indicated error, Status and Resp0-2 are
+*			in hw structure.
+*
+* Side effects:
+*	
+* Call context:
+*	interrupt (DOWAIT)
+*	process (DOWAIT or DOASYNC)
+----------------------------------------------------------------*/
+int
+hfa384x_dowmem(
+	hfa384x_t *hw, 
+	CMD_MODE mode,
+	UINT16	page,
+	UINT16	offset,
+	void	*data,
+	UINT	len,
+	ctlx_cmdcb_t cmdcb,
+	ctlx_usercb_t usercb,
+	void	*usercb_data)
+{
+	int			result;
+	hfa384x_usbctlx_t	*ctlx;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5, "page=0x%04x offset=0x%04x len=%d\n",
+		page,offset,len);
+
+	ctlx = usbctlx_alloc();
+	if ( ctlx == NULL ) {
+		result = -ENOMEM;
+		goto done;
+	}
+
+	/* Initialize the command */
+	ctlx->outbuf.wmemreq.type =   host2hfa384x_16(HFA384x_USB_WMEMREQ);
+	ctlx->outbuf.wmemreq.frmlen = host2hfa384x_16(
+					sizeof(ctlx->outbuf.wmemreq.offset) +
+					sizeof(ctlx->outbuf.wmemreq.page) +
+					len);
+	ctlx->outbuf.wmemreq.offset = host2hfa384x_16(offset);
+	ctlx->outbuf.wmemreq.page =   host2hfa384x_16(page);
+	memcpy(ctlx->outbuf.wmemreq.data, data, len);
+
+	ctlx->outbufsize = sizeof(ctlx->outbuf.wmemreq.type) +
+	                   sizeof(ctlx->outbuf.wmemreq.frmlen) +
+	                   sizeof(ctlx->outbuf.wmemreq.offset) +
+	                   sizeof(ctlx->outbuf.wmemreq.page) +
+	                   len;
+
+	ctlx->reapable = mode;
+	ctlx->cmdcb = cmdcb;
+	ctlx->usercb = usercb;
+	ctlx->usercb_data = usercb_data;
+
+	result = hfa384x_usbctlx_submit(hw, ctlx);
+	if (result != 0) {
+		kfree(ctlx);
+	} else if ( mode == DOWAIT ) {
+                usbctlx_wmem_completor_t completor;
+                hfa384x_cmdresult_t wmemresult;
+                                                                                
+                result = hfa384x_usbctlx_complete_sync(
+                               hw,
+                               ctlx,
+                               init_wmem_completor(&completor,
+                                                   &ctlx->inbuf.wmemresp,
+                                                   &wmemresult) );
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+	
+/*----------------------------------------------------------------
+* hfa384x_drvr_commtallies
+*
+* Send a commtallies inquiry to the MAC.  Note that this is an async
+* call that will result in an info frame arriving sometime later.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	zero		success.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_commtallies( hfa384x_t *hw )
+{
+	hfa384x_metacmd_t cmd;
+
+	DBFENTER;
+
+	cmd.cmd = HFA384x_CMDCODE_INQ;
+	cmd.parm0 = HFA384x_IT_COMMTALLIES;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+	hfa384x_docmd_async(hw, &cmd, NULL, NULL, NULL);
+	
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_disable
+*
+* Issues the disable command to stop communications on one of 
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also disable macports 1-6.  Only ports that have been
+* previously enabled may be disabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number (host order)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_disable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) || 
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    !(hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_disable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 0;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_enable
+*
+* Issues the enable command to enable communications on one of 
+* the MACs 'ports'.  Only macport 0 is valid  for stations.
+* APs may also enable macports 1-6.  Only ports that are currently
+* disabled may be enabled.
+*
+* Arguments:
+*	hw		device structure
+*	macport		MAC port number
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported failure - f/w status code
+*	<0		driver reported error (timeout|bad arg)
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_enable(hfa384x_t *hw, UINT16 macport)
+{
+	int	result = 0;
+
+	DBFENTER;
+	if ((!hw->isap && macport != 0) || 
+	    (hw->isap && !(macport <= HFA384x_PORTID_MAX)) ||
+	    (hw->port_enabled[macport]) ){
+		result = -EINVAL;
+	} else {
+		result = hfa384x_cmd_enable(hw, macport);
+		if ( result == 0 ) {
+			hw->port_enabled[macport] = 1;
+		}
+	}
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_enable
+*
+* Begins the flash download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and retrieves the flash download
+* buffer location, buffer size, and timeout length.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_enable(hfa384x_t *hw)
+{
+	int		result = 0;
+	int		i;
+
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_DEBUG(1,"called when port enabled.\n");
+			return -EINVAL; 
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		return -EINVAL;
+	}
+
+	/* Retrieve the buffer loc&size and timeout */
+	if ( (result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DOWNLOADBUFFER, 
+				&(hw->bufinfo), sizeof(hw->bufinfo))) ) {
+		return result;
+	}
+	hw->bufinfo.page = hfa384x2host_16(hw->bufinfo.page);
+	hw->bufinfo.offset = hfa384x2host_16(hw->bufinfo.offset);
+	hw->bufinfo.len = hfa384x2host_16(hw->bufinfo.len);
+	if ( (result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_MAXLOADTIME, 
+				&(hw->dltimeout))) ) {
+		return result;
+	}
+	hw->dltimeout = hfa384x2host_16(hw->dltimeout);
+
+	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+
+	hw->dlstate = HFA384x_DLSTATE_FLASHENABLED;
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_disable
+*
+* Ends the flash download state.  Note that this will cause the MAC
+* firmware to restart.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_flashdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(1,"flashdl_enable\n");
+
+	/* There isn't much we can do at this point, so I don't */
+	/*  bother  w/ the return value */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_flashdl_write
+*
+* Performs a FLASH download of a chunk of data. First checks to see
+* that we're in the FLASH download state, then sets the download
+* mode, uses the aux functions to 1) copy the data to the flash
+* buffer, 2) sets the download 'write flash' mode, 3) readback and 
+* compare.  Lather rinse, repeat as many times an necessary to get
+* all the given data into flash.  
+* When all data has been written using this function (possibly 
+* repeatedly), call drvr_flashdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_flashdl_write(
+	hfa384x_t	*hw, 
+	UINT32		daddr, 
+	void		*buf, 
+	UINT32		len)
+{
+	int		result = 0;
+	UINT32		dlbufaddr;
+	int		nburns;
+	UINT32		burnlen;
+	UINT32		burndaddr;
+	UINT16		burnlo;
+	UINT16		burnhi;
+	int		nwrites;
+	UINT8		*writebuf;
+	UINT16		writepage;
+	UINT16		writeoffset;
+	UINT32		writelen;
+	int		i;
+	int		j;
+
+	DBFENTER;
+	WLAN_LOG_DEBUG(5,"daddr=0x%08x len=%d\n", daddr, len);
+
+	/* Check that we're in the flash download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_FLASHENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Download %d bytes to flash @0x%06x\n", len, daddr);
+
+	/* Convert to flat address for arithmetic */
+	/* NOTE: dlbuffer RID stores the address in AUX format */
+	dlbufaddr = HFA384x_ADDR_AUX_MKFLAT(
+			hw->bufinfo.page, hw->bufinfo.offset);
+	WLAN_LOG_DEBUG(5,
+		"dlbuf.page=0x%04x dlbuf.offset=0x%04x dlbufaddr=0x%08x\n",
+		hw->bufinfo.page, hw->bufinfo.offset, dlbufaddr);
+
+#if 0
+WLAN_LOG_WARNING("dlbuf@0x%06lx len=%d to=%d\n", dlbufaddr, hw->bufinfo.len, hw->dltimeout);
+#endif
+	/* Calculations to determine how many fills of the dlbuffer to do
+	 * and how many USB wmemreq's to do for each fill.  At this point
+	 * in time, the dlbuffer size and the wmemreq size are the same.
+	 * Therefore, nwrites should always be 1.  The extra complexity
+	 * here is a hedge against future changes.
+	 */
+
+	/* Figure out how many times to do the flash programming */
+	nburns = len / hw->bufinfo.len;
+	nburns += (len % hw->bufinfo.len) ? 1 : 0;
+
+	/* For each flash program cycle, how many USB wmemreq's are needed? */
+	nwrites = hw->bufinfo.len / HFA384x_USB_RWMEM_MAXLEN;
+	nwrites += (hw->bufinfo.len % HFA384x_USB_RWMEM_MAXLEN) ? 1 : 0;
+
+	/* For each burn */
+	for ( i = 0; i < nburns; i++) {
+		/* Get the dest address and len */
+		burnlen = (len - (hw->bufinfo.len * i)) > hw->bufinfo.len ?
+				hw->bufinfo.len : 
+				(len - (hw->bufinfo.len * i));
+		burndaddr = daddr + (hw->bufinfo.len * i);
+		burnlo = HFA384x_ADDR_CMD_MKOFF(burndaddr);
+		burnhi = HFA384x_ADDR_CMD_MKPAGE(burndaddr);
+
+		WLAN_LOG_INFO("Writing %d bytes to flash @0x%06x\n", 
+			burnlen, burndaddr);
+
+		/* Set the download mode */
+		result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_NV, 
+				burnlo, burnhi, burnlen);
+		if ( result ) {
+			WLAN_LOG_ERROR("download(NV,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				burnlo, burnhi, burnlen, result);
+			goto exit_proc;
+		}
+
+		/* copy the data to the flash download buffer */
+		for ( j=0; j < nwrites; j++) {
+			writebuf = buf + 
+				(i*hw->bufinfo.len) + 
+				(j*HFA384x_USB_RWMEM_MAXLEN);
+			
+			writepage = HFA384x_ADDR_CMD_MKPAGE(
+					dlbufaddr + 
+					(j*HFA384x_USB_RWMEM_MAXLEN));
+			writeoffset = HFA384x_ADDR_CMD_MKOFF(
+					dlbufaddr + 
+					(j*HFA384x_USB_RWMEM_MAXLEN));
+
+			writelen = burnlen-(j*HFA384x_USB_RWMEM_MAXLEN);
+			writelen = writelen  > HFA384x_USB_RWMEM_MAXLEN ?
+					HFA384x_USB_RWMEM_MAXLEN :
+					writelen;
+
+			result = hfa384x_dowmem_wait( hw,
+					writepage, 
+					writeoffset, 
+					writebuf, 
+					writelen );
+#if 0
+
+Comment out for debugging, assume the write was successful.
+			if (result) {
+				WLAN_LOG_ERROR(
+					"Write to dl buffer failed, "
+					"result=0x%04x. Aborting.\n", 
+					result);
+				goto exit_proc;
+			}
+#endif
+
+		}
+
+		/* set the download 'write flash' mode */
+		result = hfa384x_cmd_download(hw, 
+				HFA384x_PROGMODE_NVWRITE, 
+				0,0,0);
+		if ( result ) {
+			WLAN_LOG_ERROR(
+				"download(NVWRITE,lo=%x,hi=%x,len=%x) "
+				"cmd failed, result=%d. Aborting d/l\n",
+				burnlo, burnhi, burnlen, result);
+			goto exit_proc;
+		}
+
+		/* TODO: We really should do a readback and compare. */
+	}
+
+exit_proc:
+
+	/* Leave the firmware in the 'post-prog' mode.  flashdl_disable will */
+	/*  actually disable programming mode.  Remember, that will cause the */
+	/*  the firmware to effectively reset itself. */
+	
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_getconfig
+*
+* Performs the sequence necessary to read a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (host order)
+*	buf		host side record buffer.  Upon return it will
+*			contain the body portion of the record (minus the 
+*			RID and len).
+*	len		buffer length (in bytes, should match record length)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ENODATA 	length mismatch between argument and retrieved
+*			record.
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_getconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	int 			result;
+	DBFENTER;
+
+	result = hfa384x_dorrid_wait(hw, rid, buf, len);
+
+	DBFEXIT;
+	return result;
+}
+
+/*---------------------------------------------------------------- 	 
+ * hfa384x_drvr_getconfig_async 	 
+ * 	 
+ * Performs the sequence necessary to perform an async read of 	 
+ * of a config/info item. 	 
+ * 	 
+ * Arguments: 	 
+ *       hw              device structure 	 
+ *       rid             config/info record id (host order) 	 
+ *       buf             host side record buffer.  Upon return it will 	 
+ *                       contain the body portion of the record (minus the  
+ *                       RID and len). 	 
+ *       len             buffer length (in bytes, should match record length) 
+ *       cbfn            caller supplied callback, called when the command 
+ *                       is done (successful or not). 	 
+ *       cbfndata        pointer to some caller supplied data that will be
+ *                       passed in as an argument to the cbfn. 	 
+ * 	 
+ * Returns: 	 
+ *       nothing         the cbfn gets a status argument identifying if     
+ *                       any errors occur. 	 
+ * Side effects: 	 
+ *       Queues an hfa384x_usbcmd_t for subsequent execution. 	 
+ * 	 
+ * Call context: 	 
+ *       Any 	 
+ ----------------------------------------------------------------*/ 	 
+int 	 
+hfa384x_drvr_getconfig_async( 	 
+         hfa384x_t               *hw, 	 
+         UINT16                  rid, 	 
+         ctlx_usercb_t           usercb, 	 
+         void                    *usercb_data) 	 
+{ 	 
+         return hfa384x_dorrid_async(hw, rid, NULL, 0, 	 
+				     hfa384x_cb_rrid, usercb, usercb_data); 
+} 	 
+
+/*---------------------------------------------------------------- 	 
+ * hfa384x_drvr_setconfig_async 	 
+ * 	 
+ * Performs the sequence necessary to write a config/info item. 	 
+ * 	 
+ * Arguments: 	 
+ *       hw              device structure 	 
+ *       rid             config/info record id (in host order) 	 
+ *       buf             host side record buffer 	 
+ *       len             buffer length (in bytes) 	 
+ *       usercb          completion callback 	 
+ *       usercb_data     completion callback argument 	 
+ * 	 
+ * Returns: 	 
+ *       0               success 	 
+ *       >0              f/w reported error - f/w status code 	 
+ *       <0              driver reported error 	 
+ * 	 
+ * Side effects: 	 
+ * 	 
+ * Call context: 	 
+ *       process 	 
+ ----------------------------------------------------------------*/ 	 
+int 	 
+hfa384x_drvr_setconfig_async( 	 
+         hfa384x_t       *hw, 	 
+         UINT16          rid, 	 
+         void            *buf, 	 
+         UINT16          len, 	 
+         ctlx_usercb_t   usercb, 	 
+         void            *usercb_data) 	 
+{ 	 
+	return hfa384x_dowrid_async(hw, rid, buf, len, 	 
+				    hfa384x_cb_status, usercb, usercb_data); 
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_handover
+*
+* Sends a handover notification to the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	addr		address of station that's left
+*
+* Returns: 
+*	zero		success.
+*	-ERESTARTSYS	received signal while waiting for semaphore.
+*	-EIO		failed to write to bap, or failed in cmd.
+*
+* Side effects:
+*
+* Call context:
+*	process
+----------------------------------------------------------------*/
+int hfa384x_drvr_handover( hfa384x_t *hw, UINT8 *addr)
+{
+        DBFENTER;
+	WLAN_LOG_ERROR("Not currently supported in USB!\n");
+	DBFEXIT;
+	return -EIO;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_low_level
+*
+* Write test commands to the card.  Some test commands don't make
+* sense without prior set-up.  For example, continous TX isn't very
+* useful until you set the channel.  That functionality should be
+*
+* Side effects:
+*
+* Call context:
+*      process thread 
+* -----------------------------------------------------------------*/
+int hfa384x_drvr_low_level(hfa384x_t *hw, hfa384x_metacmd_t *cmd)
+{
+	int             result;
+	DBFENTER;
+	
+	/* Do i need a host2hfa... conversion ? */
+
+	result = hfa384x_docmd_wait(hw, cmd);
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_read
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       register        The test register to be accessed (must be even #).
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process
+----------------------------------------------------------------*/
+int hfa384x_drvr_mmi_read(hfa384x_t *hw, UINT32 addr, UINT32 *resp)
+{
+#if 0
+        int             result = 0;
+        UINT16  cmd_code = (UINT16) 0x30;
+        UINT16 param = (UINT16) addr;
+        DBFENTER;
+
+        /* Do i need a host2hfa... conversion ? */
+        result = hfa384x_docmd_wait(hw, cmd_code);
+
+        DBFEXIT;
+        return result;
+#endif
+return 0;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_mmi_write
+*
+* Read mmi registers.  mmi is intersil-speak for the baseband
+* processor registers.
+*
+* Arguments:
+*       hw              device structure
+*       addr            The test register to be accessed (must be even #).
+*       data            The data value to write to the register.
+*
+* Returns:
+*       0               success
+*       >0              f/w reported error - f/w status code
+*       <0              driver reported error
+*
+* Side effects:
+*
+* Call context:
+*       process
+----------------------------------------------------------------*/
+
+int
+hfa384x_drvr_mmi_write(hfa384x_t *hw, UINT32 addr, UINT32 data)
+{
+#if 0
+        int             result = 0;
+        UINT16  cmd_code = (UINT16) 0x31;
+        UINT16 param0 = (UINT16) addr;
+        UINT16 param1 = (UINT16) data;
+        DBFENTER;
+
+        WLAN_LOG_DEBUG(1,"mmi write : addr = 0x%08lx\n", addr);
+        WLAN_LOG_DEBUG(1,"mmi write : data = 0x%08lx\n", data);
+
+        /* Do i need a host2hfa... conversion ? */
+        result = hfa384x_docmd_wait(hw, cmd_code);
+
+        DBFEXIT;
+        return result;
+#endif
+return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_disable
+*
+* Ends the ram download state.
+*
+* Arguments:
+*	hw		device structure
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int 
+hfa384x_drvr_ramdl_disable(hfa384x_t *hw)
+{
+	DBFENTER;
+	/* Check that we're already in the download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(3,"ramdl_disable()\n");
+
+	/* There isn't much we can do at this point, so I don't */
+	/*  bother  w/ the return value */
+	hfa384x_cmd_download(hw, HFA384x_PROGMODE_DISABLE, 0, 0 , 0);
+	hw->dlstate = HFA384x_DLSTATE_DISABLED;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_enable
+*
+* Begins the ram download state.  Checks to see that we're not
+* already in a download state and that a port isn't enabled.
+* Sets the download state and calls cmd_download with the 
+* ENABLE_VOLATILE subcommand and the exeaddr argument.
+*
+* Arguments:
+*	hw		device structure
+*	exeaddr		the card execution address that will be 
+*                       jumped to when ramdl_disable() is called
+*			(host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_ramdl_enable(hfa384x_t *hw, UINT32 exeaddr)
+{
+	int		result = 0;
+	UINT16		lowaddr;
+	UINT16		hiaddr;
+	int		i;
+	DBFENTER;
+	/* Check that a port isn't active */
+	for ( i = 0; i < HFA384x_PORTID_MAX; i++) {
+		if ( hw->port_enabled[i] ) {
+			WLAN_LOG_ERROR(
+				"Can't download with a macport enabled.\n");
+			return -EINVAL; 
+		}
+	}
+
+	/* Check that we're not already in a download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_DISABLED ) {
+		WLAN_LOG_ERROR(
+			"Download state not disabled.\n");
+		return -EINVAL;
+	}
+
+	WLAN_LOG_DEBUG(3,"ramdl_enable, exeaddr=0x%08x\n", exeaddr);
+
+	/* Call the download(1,addr) function */
+	lowaddr = HFA384x_ADDR_CMD_MKOFF(exeaddr);
+	hiaddr =  HFA384x_ADDR_CMD_MKPAGE(exeaddr);
+
+	result = hfa384x_cmd_download(hw, HFA384x_PROGMODE_RAM, 
+			lowaddr, hiaddr, 0);
+
+	if ( result == 0) {
+		/* Set the download state */
+		hw->dlstate = HFA384x_DLSTATE_RAMENABLED;
+	} else {
+		WLAN_LOG_DEBUG(1,
+			"cmd_download(0x%04x, 0x%04x) failed, result=%d.\n",
+			lowaddr,
+			hiaddr, 
+			result);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_ramdl_write
+*
+* Performs a RAM download of a chunk of data. First checks to see
+* that we're in the RAM download state, then uses the [read|write]mem USB
+* commands to 1) copy the data, 2) readback and compare.  The download
+* state is unaffected.  When all data has been written using
+* this function, call drvr_ramdl_disable() to end the download state
+* and restart the MAC.
+*
+* Arguments:
+*	hw		device structure
+*	daddr		Card address to write to. (host order)
+*	buf		Ptr to data to write.
+*	len		Length of data (host order).
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_ramdl_write(hfa384x_t *hw, UINT32 daddr, void* buf, UINT32 len)
+{
+	int		result = 0;
+	int		nwrites;
+	UINT8		*data = buf;
+	int		i;
+	UINT32		curraddr;
+	UINT16		currpage;
+	UINT16		curroffset;
+	UINT16		currlen;
+	DBFENTER;
+	/* Check that we're in the ram download state */
+	if ( hw->dlstate != HFA384x_DLSTATE_RAMENABLED ) {
+		return -EINVAL;
+	}
+
+	WLAN_LOG_INFO("Writing %d bytes to ram @0x%06x\n", len, daddr);
+
+	/* How many dowmem calls?  */
+	nwrites = len / HFA384x_USB_RWMEM_MAXLEN;
+	nwrites += len % HFA384x_USB_RWMEM_MAXLEN ? 1 : 0;
+
+	/* Do blocking wmem's */
+	for(i=0; i < nwrites; i++) {
+		/* make address args */
+		curraddr = daddr + (i * HFA384x_USB_RWMEM_MAXLEN);
+		currpage = HFA384x_ADDR_CMD_MKPAGE(curraddr);
+		curroffset = HFA384x_ADDR_CMD_MKOFF(curraddr);
+		currlen = len - (i * HFA384x_USB_RWMEM_MAXLEN);
+		if ( currlen > HFA384x_USB_RWMEM_MAXLEN) {
+			currlen = HFA384x_USB_RWMEM_MAXLEN;
+		}
+
+	 	/* Do blocking ctlx */
+		result = hfa384x_dowmem_wait( hw,
+				currpage, 
+				curroffset, 
+				data + (i*HFA384x_USB_RWMEM_MAXLEN), 
+				currlen );
+
+		if (result) break;
+
+		/* TODO: We really should have a readback. */
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_readpda
+*
+* Performs the sequence to read the PDA space.  Note there is no
+* drvr_writepda() function.  Writing a PDA is
+* generally implemented by a calling component via calls to 
+* cmd_download and writing to the flash download buffer via the 
+* aux regs.
+*
+* Arguments:
+*	hw		device structure
+*	buf		buffer to store PDA in
+*	len		buffer length
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*	-ETIMEOUT	timout waiting for the cmd regs to become
+*			available, or waiting for the control reg
+*			to indicate the Aux port is enabled.
+*	-ENODATA	the buffer does NOT contain a valid PDA.
+*			Either the card PDA is bad, or the auxdata
+*			reads are giving us garbage.
+
+*
+* Side effects:
+*
+* Call context:
+*	process or non-card interrupt.
+----------------------------------------------------------------*/
+int hfa384x_drvr_readpda(hfa384x_t *hw, void *buf, UINT len)
+{
+	int		result = 0;
+	UINT16		*pda = buf;
+	int		pdaok = 0;
+	int		morepdrs = 1;
+	int		currpdr = 0;	/* word offset of the current pdr */
+	size_t		i;
+	UINT16		pdrlen;		/* pdr length in bytes, host order */
+	UINT16		pdrcode;	/* pdr code, host order */
+	UINT16		currpage;
+	UINT16		curroffset;
+	struct pdaloc {
+		UINT32	cardaddr;
+		UINT16	auxctl;
+	} pdaloc[] =
+	{
+		{ HFA3842_PDA_BASE,		0},
+		{ HFA3841_PDA_BASE,		0}, 
+		{ HFA3841_PDA_BOGUS_BASE,	0}
+	};
+
+	DBFENTER;
+
+	/* Read the pda from each known address.  */
+	for ( i = 0; i < ARRAY_SIZE(pdaloc); i++) {
+		/* Make address */
+		currpage = HFA384x_ADDR_CMD_MKPAGE(pdaloc[i].cardaddr);
+		curroffset = HFA384x_ADDR_CMD_MKOFF(pdaloc[i].cardaddr);
+	
+		result = hfa384x_dormem_wait(hw,
+			currpage,
+			curroffset,
+			buf,
+			len);		/* units of bytes */
+
+		if (result) {
+			WLAN_LOG_WARNING(
+					  "Read from index %zd failed, continuing\n",
+				i );
+			continue;
+		}
+
+		/* Test for garbage */
+		pdaok = 1;	/* initially assume good */
+		morepdrs = 1;
+		while ( pdaok && morepdrs ) {
+			pdrlen = hfa384x2host_16(pda[currpdr]) * 2;
+			pdrcode = hfa384x2host_16(pda[currpdr+1]);
+			/* Test the record length */
+			if ( pdrlen > HFA384x_PDR_LEN_MAX || pdrlen == 0) {
+				WLAN_LOG_ERROR("pdrlen invalid=%d\n", 
+					pdrlen);
+				pdaok = 0;
+				break;
+			}
+			/* Test the code */
+			if ( !hfa384x_isgood_pdrcode(pdrcode) ) {
+				WLAN_LOG_ERROR("pdrcode invalid=%d\n", 
+					pdrcode);
+				pdaok = 0;
+				break;
+			}
+			/* Test for completion */
+			if ( pdrcode == HFA384x_PDR_END_OF_PDA) {
+				morepdrs = 0;
+			}
+	
+			/* Move to the next pdr (if necessary) */
+			if ( morepdrs ) {
+				/* note the access to pda[], need words here */
+				currpdr += hfa384x2host_16(pda[currpdr]) + 1;
+			}
+		}	
+		if ( pdaok ) {
+			WLAN_LOG_INFO(
+				"PDA Read from 0x%08x in %s space.\n",
+				pdaloc[i].cardaddr, 
+				pdaloc[i].auxctl == 0 ? "EXTDS" :
+				pdaloc[i].auxctl == 1 ? "NV" :
+				pdaloc[i].auxctl == 2 ? "PHY" :
+				pdaloc[i].auxctl == 3 ? "ICSRAM" : 
+				"<bogus auxctl>");
+			break;
+		} 
+	}
+	result = pdaok ? 0 : -ENODATA;
+
+	if ( result ) {
+		WLAN_LOG_DEBUG(3,"Failure: pda is not okay\n");
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_setconfig
+*
+* Performs the sequence necessary to write a config/info item.
+*
+* Arguments:
+*	hw		device structure
+*	rid		config/info record id (in host order)
+*	buf		host side record buffer
+*	len		buffer length (in bytes)
+*
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_setconfig(hfa384x_t *hw, UINT16 rid, void *buf, UINT16 len)
+{
+	return hfa384x_dowrid_wait(hw, rid, buf, len);
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_start
+*
+* Issues the MAC initialize command, sets up some data structures,
+* and enables the interrupts.  After this function completes, the
+* low-level stuff should be ready for any/all commands.
+*
+* Arguments:
+*	hw		device structure
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int hfa384x_drvr_start(hfa384x_t *hw)
+{
+	int		result;
+	DBFENTER;
+
+	might_sleep();
+
+	if (usb_clear_halt(hw->usb, hw->endp_in)) {
+		WLAN_LOG_ERROR(
+			"Failed to reset bulk in endpoint.\n");
+	}
+
+	if (usb_clear_halt(hw->usb, hw->endp_out)) {
+		WLAN_LOG_ERROR(
+			"Failed to reset bulk out endpoint.\n");
+	}
+
+	/* Synchronous unlink, in case we're trying to restart the driver */
+	usb_kill_urb(&hw->rx_urb);
+
+	/* Post the IN urb */
+	result = submit_rx_urb(hw, GFP_KERNEL);
+	if (result != 0) {
+		WLAN_LOG_ERROR(
+			"Fatal, failed to submit RX URB, result=%d\n",
+			result);
+		goto done;
+	}
+
+	/* call initialize */
+	result = hfa384x_cmd_initialize(hw);
+	if (result != 0) {
+		usb_kill_urb(&hw->rx_urb);
+		WLAN_LOG_ERROR(
+			"cmd_initialize() failed, result=%d\n",
+			result);
+		goto done;
+	}
+
+	hw->state = HFA384x_STATE_RUNNING;
+	
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_stop
+*
+* Shuts down the MAC to the point where it is safe to unload the
+* driver.  Any subsystem that may be holding a data or function
+* ptr into the driver must be cleared/deinitialized.
+*
+* Arguments:
+*	hw		device structure
+* Returns: 
+*	0		success
+*	>0		f/w reported error - f/w status code
+*	<0		driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process 
+----------------------------------------------------------------*/
+int
+hfa384x_drvr_stop(hfa384x_t *hw)
+{
+	int	result = 0;
+	int	i;
+	DBFENTER;
+
+	might_sleep();
+
+	/* There's no need for spinlocks here. The USB "disconnect"
+	 * function sets this "removed" flag and then calls us.
+	 */
+	if ( !hw->wlandev->hwremoved ) {
+		/* Call initialize to leave the MAC in its 'reset' state */
+		hfa384x_cmd_initialize(hw);
+
+		/* Cancel the rxurb */
+		usb_kill_urb(&hw->rx_urb);
+	}
+
+	hw->link_status = HFA384x_LINK_NOTCONNECTED;
+	hw->state = HFA384x_STATE_INIT;
+
+	del_timer_sync(&hw->commsqual_timer);
+
+	/* Clear all the port status */
+	for ( i = 0; i < HFA384x_NUMPORTS_MAX; i++) {
+		hw->port_enabled[i] = 0;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_drvr_txframe
+*
+* Takes a frame from prism2sta and queues it for transmission.
+*
+* Arguments:
+*	hw		device structure
+*	skb		packet buffer struct.  Contains an 802.11
+*			data frame.
+*       p80211_hdr      points to the 802.11 header for the packet.
+* Returns: 
+*	0		Success and more buffs available
+*	1		Success but no more buffs
+*	2		Allocation failure
+*	4		Buffer full or queue busy
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+int hfa384x_drvr_txframe(hfa384x_t *hw, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+
+{
+	int		usbpktlen = sizeof(hfa384x_tx_frame_t);
+	int		result;
+	int		ret;
+	char		*ptr;
+
+	DBFENTER;
+
+	if (hw->tx_urb.status == -EINPROGRESS) {
+		WLAN_LOG_WARNING("TX URB already in use\n");
+		result = 3; 
+		goto exit;
+	}
+
+	/* Build Tx frame structure */
+	/* Set up the control field */
+	memset(&hw->txbuff.txfrm.desc, 0, sizeof(hw->txbuff.txfrm.desc));
+
+	/* Setup the usb type field */
+	hw->txbuff.type = host2hfa384x_16(HFA384x_USB_TXFRM);
+
+	/* Set up the sw_support field to identify this frame */
+	hw->txbuff.txfrm.desc.sw_support = 0x0123;
+
+/* Tx complete and Tx exception disable per dleach.  Might be causing 
+ * buf depletion 
+ */
+//#define DOEXC  SLP -- doboth breaks horribly under load, doexc less so.
+#if defined(DOBOTH)
+	hw->txbuff.txfrm.desc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) | 
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(1);	
+#elif defined(DOEXC)
+	hw->txbuff.txfrm.desc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(1) | HFA384x_TX_TXOK_SET(0);	
+#else
+	hw->txbuff.txfrm.desc.tx_control = 
+		HFA384x_TX_MACPORT_SET(0) | HFA384x_TX_STRUCTYPE_SET(1) |
+		HFA384x_TX_TXEX_SET(0) | HFA384x_TX_TXOK_SET(0);	
+#endif
+	hw->txbuff.txfrm.desc.tx_control = 
+		host2hfa384x_16(hw->txbuff.txfrm.desc.tx_control);
+
+	/* copy the header over to the txdesc */
+	memcpy(&(hw->txbuff.txfrm.desc.frame_control), p80211_hdr, sizeof(p80211_hdr_t));
+
+	/* if we're using host WEP, increase size by IV+ICV */
+	if (p80211_wep->data) {
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len+8);
+		// hw->txbuff.txfrm.desc.tx_control |= HFA384x_TX_NOENCRYPT_SET(1);
+		usbpktlen+=8;
+	} else {
+		hw->txbuff.txfrm.desc.data_len = host2hfa384x_16(skb->len);
+	}
+
+	usbpktlen += skb->len;
+
+	/* copy over the WEP IV if we are using host WEP */
+	ptr = hw->txbuff.txfrm.data;
+	if (p80211_wep->data) {
+		memcpy(ptr, p80211_wep->iv, sizeof(p80211_wep->iv));
+		ptr+= sizeof(p80211_wep->iv);
+		memcpy(ptr, p80211_wep->data, skb->len);
+	} else {
+		memcpy(ptr, skb->data, skb->len);
+	}
+	/* copy over the packet data */
+	ptr+= skb->len;
+
+	/* copy over the WEP ICV if we are using host WEP */
+	if (p80211_wep->data) {
+		memcpy(ptr, p80211_wep->icv, sizeof(p80211_wep->icv));
+	}
+
+	/* Send the USB packet */	
+	usb_fill_bulk_urb( &(hw->tx_urb), hw->usb,
+	               hw->endp_out,
+	               &(hw->txbuff), ROUNDUP64(usbpktlen),
+	               hfa384x_usbout_callback, hw->wlandev );
+	hw->tx_urb.transfer_flags |= USB_QUEUE_BULK;
+
+	result = 1;
+	ret = submit_tx_urb(hw, &hw->tx_urb, GFP_ATOMIC);
+	if ( ret != 0 ) {
+		WLAN_LOG_ERROR(
+			"submit_tx_urb() failed, error=%d\n", ret);
+		result = 3;
+	}
+
+ exit:
+	DBFEXIT;
+	return result;
+}
+
+void hfa384x_tx_timeout(wlandevice_t *wlandev)
+{
+	hfa384x_t	*hw = wlandev->priv;
+	unsigned long flags;
+	
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	if ( !hw->wlandev->hwremoved &&
+	     /* Note the bitwise OR, not the logical OR. */
+	     ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) |
+	       !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) ) )
+	{
+		schedule_work(&hw->usb_work);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_reaper_task
+*
+* Tasklet to delete dead CTLX objects
+*
+* Arguments:
+*	data	ptr to a hfa384x_t
+*
+* Returns:
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbctlx_reaper_task(unsigned long data)
+{
+	hfa384x_t	*hw = (hfa384x_t*)data;
+	struct list_head *entry;
+	struct list_head *temp;
+	unsigned long	flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* This list is guaranteed to be empty if someone
+	 * has unplugged the adapter.
+	 */
+	list_for_each_safe(entry, temp, &hw->ctlxq.reapable) {
+		hfa384x_usbctlx_t	*ctlx;
+
+		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+		list_del(&ctlx->list);
+		kfree(ctlx);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_completion_task
+*
+* Tasklet to call completion handlers for returned CTLXs
+*
+* Arguments:
+*	data	ptr to hfa384x_t
+*
+* Returns:
+*	Nothing
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbctlx_completion_task(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	struct list_head *entry;
+	struct list_head *temp;
+	unsigned long flags;
+
+	int reap = 0;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* This list is guaranteed to be empty if someone
+	 * has unplugged the adapter ...
+	 */
+	list_for_each_safe(entry, temp, &hw->ctlxq.completing) {
+		hfa384x_usbctlx_t *ctlx;
+
+		ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+
+		/* Call the completion function that this
+		 * command was assigned, assuming it has one.
+		 */
+		if ( ctlx->cmdcb != NULL ) {
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			ctlx->cmdcb(hw, ctlx);
+			spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+			/* Make sure we don't try and complete
+			 * this CTLX more than once!
+			 */
+			ctlx->cmdcb = NULL;
+
+			/* Did someone yank the adapter out
+			 * while our list was (briefly) unlocked?
+			 */
+			if ( hw->wlandev->hwremoved )
+			{
+				reap = 0;
+				break;
+			}
+		}
+
+		/*
+		 * "Reapable" CTLXs are ones which don't have any
+		 * threads waiting for them to die. Hence they must
+		 * be delivered to The Reaper!
+		 */
+		if ( ctlx->reapable ) {
+			/* Move the CTLX off the "completing" list (hopefully)
+			 * on to the "reapable" list where the reaper task
+			 * can find it. And "reapable" means that this CTLX
+			 * isn't sitting on a wait-queue somewhere.
+			 */
+			list_move_tail(&ctlx->list, &hw->ctlxq.reapable);
+			reap = 1;
+		}
+
+		complete(&ctlx->done);
+	}
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if (reap)
+		tasklet_schedule(&hw->reaper_bh);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* unlocked_usbctlx_cancel_async
+*
+* Mark the CTLX dead asynchronously, and ensure that the
+* next command on the queue is run afterwards.
+*
+* Arguments:
+*	hw	ptr to the hfa384x_t structure
+*	ctlx	ptr to a CTLX structure
+*
+* Returns:
+*	0	the CTLX's URB is inactive
+* -EINPROGRESS	the URB is currently being unlinked
+*
+* Call context:
+*	Either process or interrupt, but presumably interrupt
+----------------------------------------------------------------*/
+int unlocked_usbctlx_cancel_async(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+{
+	int ret;
+
+	DBFENTER;
+
+	/*
+	 * Try to delete the URB containing our request packet.
+	 * If we succeed, then its completion handler will be
+	 * called with a status of -ECONNRESET.
+	 */
+	hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
+	ret = usb_unlink_urb(&hw->ctlx_urb);
+
+	if (ret != -EINPROGRESS) {
+		/*
+		 * The OUT URB had either already completed
+		 * or was still in the pending queue, so the
+		 * URB's completion function will not be called.
+		 * We will have to complete the CTLX ourselves.
+		 */
+		ctlx->state = CTLX_REQ_FAILED;
+		unlocked_usbctlx_complete(hw, ctlx);
+		ret = 0;
+	}
+
+	DBFEXIT;
+
+	return ret;
+}
+
+/*----------------------------------------------------------------
+* unlocked_usbctlx_complete
+*
+* A CTLX has completed.  It may have been successful, it may not
+* have been. At this point, the CTLX should be quiescent.  The URBs
+* aren't active and the timers should have been stopped.
+*
+* The CTLX is migrated to the "completing" queue, and the completing
+* tasklet is scheduled.
+*
+* Arguments:
+*	hw		ptr to a hfa384x_t structure
+*	ctlx		ptr to a ctlx structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	Either, assume interrupt
+----------------------------------------------------------------*/
+void unlocked_usbctlx_complete(hfa384x_t *hw, hfa384x_usbctlx_t *ctlx)
+{
+	DBFENTER;
+
+	/* Timers have been stopped, and ctlx should be in 
+	 * a terminal state. Retire it from the "active"
+	 * queue.
+	 */
+	list_move_tail(&ctlx->list, &hw->ctlxq.completing);
+	tasklet_schedule(&hw->completion_bh);
+
+	switch (ctlx->state) {
+	case CTLX_COMPLETE:
+	case CTLX_REQ_FAILED:
+		/* This are the correct terminating states. */
+		break;
+
+	default:
+		WLAN_LOG_ERROR("CTLX[%d] not in a terminating state(%s)\n",
+		               hfa384x2host_16(ctlx->outbuf.type),
+		               ctlxstr(ctlx->state));
+		break;
+	} /* switch */
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlxq_run
+*
+* Checks to see if the head item is running.  If not, starts it.
+*
+* Arguments:
+*	hw	ptr to hfa384x_t
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	any
+----------------------------------------------------------------*/
+void
+hfa384x_usbctlxq_run(hfa384x_t	*hw)
+{
+	unsigned long		flags;
+	DBFENTER;
+
+	/* acquire lock */
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* Only one active CTLX at any one time, because there's no
+	 * other (reliable) way to match the response URB to the
+	 * correct CTLX.
+	 *
+	 * Don't touch any of these CTLXs if the hardware
+	 * has been removed or the USB subsystem is stalled.
+	 */
+	if ( !list_empty(&hw->ctlxq.active) ||
+	     test_bit(WORK_TX_HALT, &hw->usb_flags) ||
+	     hw->wlandev->hwremoved )
+		goto unlock;
+
+	while ( !list_empty(&hw->ctlxq.pending) ) {
+		hfa384x_usbctlx_t	*head;
+		int			result;
+
+		/* This is the first pending command */
+		head = list_entry(hw->ctlxq.pending.next,
+		                  hfa384x_usbctlx_t,
+		                  list);
+
+		/* We need to split this off to avoid a race condition */
+		list_move_tail(&head->list, &hw->ctlxq.active);
+
+		/* Fill the out packet */
+		usb_fill_bulk_urb( &(hw->ctlx_urb), hw->usb,
+		                   hw->endp_out,
+		                   &(head->outbuf), ROUNDUP64(head->outbufsize),
+		                   hfa384x_ctlxout_callback, hw);
+		hw->ctlx_urb.transfer_flags |= USB_QUEUE_BULK;
+
+		/* Now submit the URB and update the CTLX's state
+		 */
+		if ((result = SUBMIT_URB(&hw->ctlx_urb, GFP_ATOMIC)) == 0) {
+			/* This CTLX is now running on the active queue */
+			head->state = CTLX_REQ_SUBMITTED;
+
+			/* Start the OUT wait timer */
+			hw->req_timer_done = 0;
+			hw->reqtimer.expires = jiffies + HZ;
+			add_timer(&hw->reqtimer);
+
+			/* Start the IN wait timer */
+			hw->resp_timer_done = 0;
+			hw->resptimer.expires = jiffies + 2*HZ;
+			add_timer(&hw->resptimer);
+
+			break;
+		}
+
+		if (result == -EPIPE) {
+			/* The OUT pipe needs resetting, so put
+			 * this CTLX back in the "pending" queue
+			 * and schedule a reset ...
+			 */
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			list_move(&head->list, &hw->ctlxq.pending);
+			set_bit(WORK_TX_HALT, &hw->usb_flags);
+			schedule_work(&hw->usb_work);
+			break;
+		}
+		
+		if (result == -ESHUTDOWN) {
+			WLAN_LOG_WARNING("%s urb shutdown!\n",
+					 hw->wlandev->netdev->name);
+			break;
+		}
+
+		WLAN_LOG_ERROR("Failed to submit CTLX[%d]: error=%d\n",
+		               hfa384x2host_16(head->outbuf.type), result);
+		unlocked_usbctlx_complete(hw, head);
+	} /* while */
+
+	unlock:
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_callback
+*
+* Callback for URBs on the BULKIN endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void hfa384x_usbin_callback(struct urb *urb)
+#else
+void hfa384x_usbin_callback(struct urb *urb)
+#endif
+{
+	wlandevice_t		*wlandev = urb->context;
+	hfa384x_t		*hw;
+	hfa384x_usbin_t		*usbin = (hfa384x_usbin_t *) urb->transfer_buffer;
+	struct sk_buff          *skb = NULL;
+	int			result;
+	int                     urb_status;
+	UINT16			type;
+
+	enum USBIN_ACTION {
+		HANDLE,
+		RESUBMIT,
+		ABORT
+	} action;
+
+	DBFENTER;
+
+	if ( !wlandev ||
+	     !wlandev->netdev || 
+	     !netif_device_present(wlandev->netdev) )
+		goto exit;
+
+	hw = wlandev->priv;
+	if (!hw)
+		goto exit;
+
+	skb = hw->rx_urb_skb;
+	if (!skb || (skb->data != urb->transfer_buffer)) {
+		BUG();
+	}
+	hw->rx_urb_skb = NULL;
+
+	/* Check for error conditions within the URB */
+	switch (urb->status) {
+	case 0:
+		action = HANDLE;
+
+		/* Check for short packet */
+		if ( urb->actual_length == 0 ) {
+			++(wlandev->linux_stats.rx_errors);
+			++(wlandev->linux_stats.rx_length_errors);
+			action = RESUBMIT;
+		}
+		break;
+
+	case -EPIPE:
+		WLAN_LOG_WARNING("%s rx pipe stalled: requesting reset\n",
+		                 wlandev->netdev->name);
+		if ( !test_and_set_bit(WORK_RX_HALT, &hw->usb_flags) )
+			schedule_work(&hw->usb_work);
+		++(wlandev->linux_stats.rx_errors);
+		action = ABORT;
+		break;
+
+	case -EILSEQ:
+	case -ETIMEDOUT:
+	case -EPROTO:
+		if ( !test_and_set_bit(THROTTLE_RX, &hw->usb_flags) &&
+		     !timer_pending(&hw->throttle) ) {
+			mod_timer(&hw->throttle, jiffies + THROTTLE_JIFFIES);
+		}
+		++(wlandev->linux_stats.rx_errors);
+		action = ABORT;
+		break;
+
+	case -EOVERFLOW:
+		++(wlandev->linux_stats.rx_over_errors);
+		action = RESUBMIT;
+		break;
+
+	case -ENODEV:
+	case -ESHUTDOWN:
+		WLAN_LOG_DEBUG(3,"status=%d, device removed.\n", urb->status);
+		action = ABORT;
+		break;
+
+	case -ENOENT:
+	case -ECONNRESET:
+		WLAN_LOG_DEBUG(3,"status=%d, urb explicitly unlinked.\n", urb->status);
+		action = ABORT;
+		break;
+
+	default:
+		WLAN_LOG_DEBUG(3,"urb status=%d, transfer flags=0x%x\n",
+		                 urb->status, urb->transfer_flags);
+		++(wlandev->linux_stats.rx_errors);
+		action = RESUBMIT;
+		break;
+	}
+
+	urb_status = urb->status;
+
+	if (action != ABORT) {
+		/* Repost the RX URB */
+		result = submit_rx_urb(hw, GFP_ATOMIC);
+		
+		if (result != 0) {
+			WLAN_LOG_ERROR(
+				"Fatal, failed to resubmit rx_urb. error=%d\n",
+				result);
+		}
+	}
+
+	/* Handle any USB-IN packet */
+	/* Note: the check of the sw_support field, the type field doesn't 
+	 *       have bit 12 set like the docs suggest. 
+	 */
+	type = hfa384x2host_16(usbin->type);
+	if (HFA384x_USB_ISRXFRM(type)) {
+		if (action == HANDLE) {
+			if (usbin->txfrm.desc.sw_support == 0x0123) {
+				hfa384x_usbin_txcompl(wlandev, usbin);
+			} else {
+				skb_put(skb, sizeof(*usbin));
+				hfa384x_usbin_rx(wlandev, skb);
+				skb = NULL;
+			}
+		}
+		goto exit;
+	}
+	if (HFA384x_USB_ISTXFRM(type)) {
+		if (action == HANDLE)
+			hfa384x_usbin_txcompl(wlandev, usbin);
+		goto exit;
+	}
+	switch (type) {
+	case HFA384x_USB_INFOFRM:
+		if (action == ABORT)
+			goto exit;
+		if (action == HANDLE)
+			hfa384x_usbin_info(wlandev, usbin);
+		break;
+
+	case HFA384x_USB_CMDRESP:
+	case HFA384x_USB_WRIDRESP:
+	case HFA384x_USB_RRIDRESP:
+	case HFA384x_USB_WMEMRESP:
+	case HFA384x_USB_RMEMRESP:
+		/* ALWAYS, ALWAYS, ALWAYS handle this CTLX!!!! */
+		hfa384x_usbin_ctlx(hw, usbin, urb_status);
+		break;
+
+	case HFA384x_USB_BUFAVAIL:
+		WLAN_LOG_DEBUG(3,"Received BUFAVAIL packet, frmlen=%d\n",
+			usbin->bufavail.frmlen);
+		break;
+
+	case HFA384x_USB_ERROR:
+		WLAN_LOG_DEBUG(3,"Received USB_ERROR packet, errortype=%d\n",
+			usbin->usberror.errortype);
+		break;
+
+	default:
+		WLAN_LOG_DEBUG(3,"Unrecognized USBIN packet, type=%x, status=%d\n", 
+			usbin->type, urb_status);
+		break;
+	} /* switch */
+
+exit:
+
+	if (skb)
+		dev_kfree_skb(skb);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_ctlx
+*
+* We've received a URB containing a Prism2 "response" message.
+* This message needs to be matched up with a CTLX on the active
+* queue and our state updated accordingly.
+*
+* Arguments:
+*	hw		ptr to hfa384x_t
+*	usbin		ptr to USB IN packet
+*	urb_status	status of this Bulk-In URB
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbin_ctlx(hfa384x_t *hw, hfa384x_usbin_t *usbin, 
+			int urb_status)
+{
+	hfa384x_usbctlx_t	*ctlx;
+	int			run_queue = 0;
+	unsigned long		flags;
+
+	DBFENTER;
+
+retry:
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/* There can be only one CTLX on the active queue
+	 * at any one time, and this is the CTLX that the
+	 * timers are waiting for.
+	 */
+	if ( list_empty(&hw->ctlxq.active) ) {
+		goto unlock;
+	}
+
+	/* Remove the "response timeout". It's possible that 	 
+	 * we are already too late, and that the timeout is 	 
+	 * already running. And that's just too bad for us, 	 
+	 * because we could lose our CTLX from the active 	 
+	 * queue here ... 	 
+	 */ 	 
+	if (del_timer(&hw->resptimer) == 0) {
+		if (hw->resp_timer_done == 0) {
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			goto retry;
+		}
+	}
+	else {
+		hw->resp_timer_done = 1;
+	}
+
+	ctlx = get_active_ctlx(hw);
+
+	if (urb_status != 0) {
+		/*
+		 * Bad CTLX, so get rid of it. But we only
+		 * remove it from the active queue if we're no
+		 * longer expecting the OUT URB to complete.
+		 */
+		if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
+			run_queue = 1;
+	} else {
+		const UINT16 intype = (usbin->type&~host2hfa384x_16(0x8000));
+
+		/*
+		 * Check that our message is what we're expecting ...
+		 */
+		if (ctlx->outbuf.type != intype) {
+			WLAN_LOG_WARNING("Expected IN[%d], received IN[%d] - ignored.\n",
+			                 hfa384x2host_16(ctlx->outbuf.type),
+			                 hfa384x2host_16(intype));
+			goto unlock;
+		}
+
+		/* This URB has succeeded, so grab the data ... */
+		memcpy(&ctlx->inbuf, usbin, sizeof(ctlx->inbuf));
+
+		switch (ctlx->state) {
+		case CTLX_REQ_SUBMITTED:
+			/*
+			 * We have received our response URB before
+			 * our request has been acknowledged. Odd,
+			 * but our OUT URB is still alive...
+			 */
+			WLAN_LOG_DEBUG(0, "Causality violation: please reboot Universe, or email linux-wlan-devel@lists.linux-wlan.com\n");
+			ctlx->state = CTLX_RESP_COMPLETE;
+			break;
+
+		case CTLX_REQ_COMPLETE:
+			/*
+			 * This is the usual path: our request
+			 * has already been acknowledged, and
+			 * now we have received the reply too.
+			 */
+			ctlx->state = CTLX_COMPLETE;
+			unlocked_usbctlx_complete(hw, ctlx);
+			run_queue = 1;
+			break;
+
+		default:
+			/*
+			 * Throw this CTLX away ...
+			 */
+			WLAN_LOG_ERROR("Matched IN URB, CTLX[%d] in invalid state(%s)."
+			               " Discarded.\n",
+			               hfa384x2host_16(ctlx->outbuf.type),
+			               ctlxstr(ctlx->state));
+			if (unlocked_usbctlx_cancel_async(hw, ctlx) == 0)
+				run_queue = 1;
+			break;
+		} /* switch */
+	}
+
+unlock:
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if (run_queue)
+		hfa384x_usbctlxq_run(hw);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_txcompl
+*
+* At this point we have the results of a previous transmit.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbin_txcompl(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+{
+	UINT16			status;
+	DBFENTER;
+
+	status = hfa384x2host_16(usbin->type); /* yeah I know it says type...*/
+
+	/* Was there an error? */
+	if (HFA384x_TXSTATUS_ISERROR(status)) {
+		prism2sta_ev_txexc(wlandev, status);
+	} else {
+		prism2sta_ev_tx(wlandev, status);
+	}
+	// prism2sta_ev_alloc(wlandev);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_rx
+*
+* At this point we have a successful received a rx frame packet.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbin_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+{
+	hfa384x_usbin_t         *usbin = (hfa384x_usbin_t *) skb->data;
+	hfa384x_t               *hw = wlandev->priv;
+	int                     hdrlen;
+	p80211_rxmeta_t         *rxmeta;
+	UINT16                  data_len;
+	UINT16                  fc;
+
+	DBFENTER;
+
+	/* Byte order convert once up front. */
+	usbin->rxfrm.desc.status =
+		hfa384x2host_16(usbin->rxfrm.desc.status);
+	usbin->rxfrm.desc.time =
+		hfa384x2host_32(usbin->rxfrm.desc.time);
+
+	/* Now handle frame based on port# */
+	switch( HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) )
+	{
+	case 0:
+		fc = ieee2host16(usbin->rxfrm.desc.frame_control);
+
+		/* If exclude and we receive an unencrypted, drop it */
+		if ( (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) &&
+		     !WLAN_GET_FC_ISWEP(fc)){
+			goto done;
+		}
+
+		data_len = hfa384x2host_16(usbin->rxfrm.desc.data_len);
+
+		/* How much header data do we have? */
+		hdrlen = p80211_headerlen(fc);
+
+		/* Pull off the descriptor */
+		skb_pull(skb, sizeof(hfa384x_rx_frame_t));
+
+		/* Now shunt the header block up against the data block
+		 * with an "overlapping" copy
+		 */
+		memmove(skb_push(skb, hdrlen),
+		        &usbin->rxfrm.desc.frame_control,
+		        hdrlen);
+
+		skb->dev = wlandev->netdev;
+		skb->dev->last_rx = jiffies;
+
+		/* And set the frame length properly */
+		skb_trim(skb, data_len + hdrlen);
+
+		/* The prism2 series does not return the CRC */
+		memset(skb_put(skb, WLAN_CRC_LEN), 0xff, WLAN_CRC_LEN);
+
+		skb->mac.raw = skb->data;
+
+		/* Attach the rxmeta, set some stuff */
+		p80211skb_rxmeta_attach(wlandev, skb);
+		rxmeta = P80211SKB_RXMETA(skb);
+		rxmeta->mactime = usbin->rxfrm.desc.time;
+		rxmeta->rxrate = usbin->rxfrm.desc.rate;
+		rxmeta->signal = usbin->rxfrm.desc.signal - hw->dbmadjust;
+		rxmeta->noise = usbin->rxfrm.desc.silence - hw->dbmadjust;
+
+		prism2sta_ev_rx(wlandev, skb);
+
+		break;
+
+	case 7:
+		if ( ! HFA384x_RXSTATUS_ISFCSERR(usbin->rxfrm.desc.status) ) {
+			/* Copy to wlansnif skb */
+			hfa384x_int_rxmonitor( wlandev, &usbin->rxfrm);
+			dev_kfree_skb(skb);
+		} else {
+			WLAN_LOG_DEBUG(3,"Received monitor frame: FCSerr set\n");
+		}
+		break;
+
+	default:
+		WLAN_LOG_WARNING("Received frame on unsupported port=%d\n",
+			HFA384x_RXSTATUS_MACPORT_GET(usbin->rxfrm.desc.status) );
+		goto done;
+		break;
+	}
+	
+done:
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_int_rxmonitor
+*
+* Helper function for int_rx.  Handles monitor frames.
+* Note that this function allocates space for the FCS and sets it
+* to 0xffffffff.  The hfa384x doesn't give us the FCS value but the
+* higher layers expect it.  0xffffffff is used as a flag to indicate
+* the FCS is bogus.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	rxfrm		rx descriptor read from card in int_rx
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	Allocates an skb and passes it up via the PF_PACKET interface.
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+static void hfa384x_int_rxmonitor( wlandevice_t *wlandev, hfa384x_usb_rxfrm_t *rxfrm)
+{
+	hfa384x_rx_frame_t              *rxdesc = &(rxfrm->desc);
+	UINT				hdrlen = 0;
+	UINT				datalen = 0;
+	UINT				skblen = 0;
+	p80211msg_lnxind_wlansniffrm_t	*msg;
+	UINT8				*datap;
+	UINT16				fc;
+	struct sk_buff			*skb;
+	hfa384x_t		        *hw = wlandev->priv;
+
+
+	DBFENTER;
+	/* Don't forget the status, time, and data_len fields are in host order */
+	/* Figure out how big the frame is */
+	fc = ieee2host16(rxdesc->frame_control);
+	hdrlen = p80211_headerlen(fc);
+	datalen = hfa384x2host_16(rxdesc->data_len);
+
+	/* Allocate an ind message+framesize skb */
+	skblen = sizeof(p80211msg_lnxind_wlansniffrm_t) + 
+		hdrlen + datalen + WLAN_CRC_LEN;
+	
+	/* sanity check the length */
+	if ( skblen > 
+		(sizeof(p80211msg_lnxind_wlansniffrm_t) + 
+		WLAN_HDR_A4_LEN + WLAN_DATA_MAXLEN + WLAN_CRC_LEN) ) {
+		WLAN_LOG_DEBUG(1, "overlen frm: len=%zd\n", 
+			skblen - sizeof(p80211msg_lnxind_wlansniffrm_t));
+	}
+			
+	if ( (skb = dev_alloc_skb(skblen)) == NULL ) {
+		WLAN_LOG_ERROR("alloc_skb failed trying to allocate %d bytes\n", skblen);
+		return;
+	}
+
+	/* only prepend the prism header if in the right mode */
+	if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+	    (hw->sniffhdr == 0)) {
+		datap = skb_put(skb, sizeof(p80211msg_lnxind_wlansniffrm_t));
+		msg = (p80211msg_lnxind_wlansniffrm_t*) datap;
+	  
+		/* Initialize the message members */
+		msg->msgcode = DIDmsg_lnxind_wlansniffrm;
+		msg->msglen = sizeof(p80211msg_lnxind_wlansniffrm_t);
+		strcpy(msg->devname, wlandev->name);
+		
+		msg->hosttime.did = DIDmsg_lnxind_wlansniffrm_hosttime;
+		msg->hosttime.status = 0;
+		msg->hosttime.len = 4;
+		msg->hosttime.data = jiffies;
+		
+		msg->mactime.did = DIDmsg_lnxind_wlansniffrm_mactime;
+		msg->mactime.status = 0;
+		msg->mactime.len = 4;
+		msg->mactime.data = rxdesc->time;
+		
+		msg->channel.did = DIDmsg_lnxind_wlansniffrm_channel;
+		msg->channel.status = 0;
+		msg->channel.len = 4;
+		msg->channel.data = hw->sniff_channel;
+		
+		msg->rssi.did = DIDmsg_lnxind_wlansniffrm_rssi;
+		msg->rssi.status = P80211ENUM_msgitem_status_no_value;
+		msg->rssi.len = 4;
+		msg->rssi.data = 0;
+		
+		msg->sq.did = DIDmsg_lnxind_wlansniffrm_sq;
+		msg->sq.status = P80211ENUM_msgitem_status_no_value;
+		msg->sq.len = 4;
+		msg->sq.data = 0;
+		
+		msg->signal.did = DIDmsg_lnxind_wlansniffrm_signal;
+		msg->signal.status = 0;
+		msg->signal.len = 4;
+		msg->signal.data = rxdesc->signal;
+		
+		msg->noise.did = DIDmsg_lnxind_wlansniffrm_noise;
+		msg->noise.status = 0;
+		msg->noise.len = 4;
+		msg->noise.data = rxdesc->silence;
+		
+		msg->rate.did = DIDmsg_lnxind_wlansniffrm_rate;
+		msg->rate.status = 0;
+		msg->rate.len = 4;
+		msg->rate.data = rxdesc->rate / 5; /* set to 802.11 units */
+		
+		msg->istx.did = DIDmsg_lnxind_wlansniffrm_istx;
+		msg->istx.status = 0;
+		msg->istx.len = 4;
+		msg->istx.data = P80211ENUM_truth_false;
+		
+		msg->frmlen.did = DIDmsg_lnxind_wlansniffrm_frmlen;
+		msg->frmlen.status = 0;
+		msg->frmlen.len = 4;
+		msg->frmlen.data = hdrlen + datalen + WLAN_CRC_LEN;
+	} else if ((wlandev->netdev->type == ARPHRD_IEEE80211_PRISM) &&
+		   (hw->sniffhdr != 0)) {
+		p80211_caphdr_t		*caphdr;
+		/* The NEW header format! */
+		datap = skb_put(skb, sizeof(p80211_caphdr_t));
+		caphdr = (p80211_caphdr_t*) datap;
+
+		caphdr->version =	htonl(P80211CAPTURE_VERSION);
+		caphdr->length =	htonl(sizeof(p80211_caphdr_t));
+		caphdr->mactime =	__cpu_to_be64(rxdesc->time) * 1000;
+		caphdr->hosttime =	__cpu_to_be64(jiffies);
+		caphdr->phytype =	htonl(4); /* dss_dot11_b */
+		caphdr->channel =	htonl(hw->sniff_channel);
+		caphdr->datarate =	htonl(rxdesc->rate);
+		caphdr->antenna =	htonl(0); /* unknown */
+		caphdr->priority =	htonl(0); /* unknown */
+		caphdr->ssi_type =	htonl(3); /* rssi_raw */
+		caphdr->ssi_signal =	htonl(rxdesc->signal);
+		caphdr->ssi_noise =	htonl(rxdesc->silence);
+		caphdr->preamble =	htonl(0); /* unknown */
+		caphdr->encoding =	htonl(1); /* cck */
+	}
+
+	/* Copy the 802.11 header to the skb (ctl frames may be less than a full header) */
+	datap = skb_put(skb, hdrlen);
+	memcpy( datap, &(rxdesc->frame_control), hdrlen);
+
+	/* If any, copy the data from the card to the skb */
+	if ( datalen > 0 )
+	{
+		datap = skb_put(skb, datalen);
+		memcpy(datap, rxfrm->data, datalen);
+
+		/* check for unencrypted stuff if WEP bit set. */
+		if (*(datap - hdrlen + 1) & 0x40) // wep set
+		  if ((*(datap) == 0xaa) && (*(datap+1) == 0xaa))
+		    *(datap - hdrlen + 1) &= 0xbf; // clear wep; it's the 802.2 header!
+	}
+
+	if (hw->sniff_fcs) {
+		/* Set the FCS */
+		datap = skb_put(skb, WLAN_CRC_LEN);
+		memset( datap, 0xff, WLAN_CRC_LEN);
+	}
+
+	/* pass it back up */
+	prism2sta_ev_rx(wlandev, skb);
+
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbin_info
+*
+* At this point we have a successful received a Prism2 info frame.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbin		ptr to the usb transfer buffer
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbin_info(wlandevice_t *wlandev, hfa384x_usbin_t *usbin)
+{
+	DBFENTER;
+
+	usbin->infofrm.info.framelen = hfa384x2host_16(usbin->infofrm.info.framelen);
+	prism2sta_ev_info(wlandev, &usbin->infofrm.info);
+
+	DBFEXIT;
+}
+
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbout_callback
+*
+* Callback for URBs on the BULKOUT endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void hfa384x_usbout_callback(struct urb *urb)
+#else
+void hfa384x_usbout_callback(struct urb *urb)
+#endif
+{
+	wlandevice_t		*wlandev = urb->context;
+	hfa384x_usbout_t	*usbout = urb->transfer_buffer;
+	DBFENTER;
+
+#ifdef DEBUG_USB
+	dbprint_urb(urb);
+#endif
+
+	if ( wlandev &&
+	     wlandev->netdev ) {
+
+		switch(urb->status) {
+		case 0:
+			hfa384x_usbout_tx(wlandev, usbout);
+			break;
+
+		case -EPIPE:
+		{
+			hfa384x_t *hw = wlandev->priv;
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 wlandev->netdev->name);
+			if ( !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) )
+				schedule_work(&hw->usb_work);
+			++(wlandev->linux_stats.tx_errors);
+			break;
+		}
+
+		case -EPROTO:
+		case -ETIMEDOUT:
+		case -EILSEQ:
+		{
+			hfa384x_t *hw = wlandev->priv;
+
+			if ( !test_and_set_bit(THROTTLE_TX, &hw->usb_flags)
+			     && !timer_pending(&hw->throttle) ) {
+				mod_timer(&hw->throttle,
+				          jiffies + THROTTLE_JIFFIES);
+			}
+			++(wlandev->linux_stats.tx_errors);
+			netif_stop_queue(wlandev->netdev);
+			break;
+		}
+
+		case -ENOENT:
+		case -ESHUTDOWN:
+			/* Ignorable errors */
+			break;
+
+		default:
+			WLAN_LOG_INFO("unknown urb->status=%d\n", urb->status);
+			++(wlandev->linux_stats.tx_errors);
+			break;
+		} /* switch */
+	}
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_ctlxout_callback
+*
+* Callback for control data on the BULKOUT endpoint.
+*
+* Arguments:
+*	urb		ptr to the completed urb
+*
+* Returns:
+* nothing
+*
+* Side effects:
+*
+* Call context:
+* interrupt
+----------------------------------------------------------------*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void hfa384x_ctlxout_callback(struct urb *urb)
+#else
+void hfa384x_ctlxout_callback(struct urb *urb)
+#endif
+{
+	hfa384x_t	*hw = urb->context;
+	int             delete_resptimer = 0; 	 
+	int             timer_ok = 1;
+	int		run_queue = 0;
+	hfa384x_usbctlx_t	*ctlx;
+	unsigned long	flags;
+
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(3,"urb->status=%d\n", urb->status);
+#ifdef DEBUG_USB
+	dbprint_urb(urb);
+#endif
+	if ( (urb->status == -ESHUTDOWN) ||
+	     (urb->status == -ENODEV) ||
+	     (hw == NULL) )
+		goto done;
+
+retry: 
+	spin_lock_irqsave(&hw->ctlxq.lock, flags); 	 
+  	 
+	/*
+	 * Only one CTLX at a time on the "active" list, and
+	 * none at all if we are unplugged. However, we can
+	 * rely on the disconnect function to clean everything
+	 * up if someone unplugged the adapter.
+	 */
+	if ( list_empty(&hw->ctlxq.active) ) {
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags); 	 
+		goto done;
+	}
+
+	/*
+	 * Having something on the "active" queue means
+	 * that we have timers to worry about ...
+	 */
+	if (del_timer(&hw->reqtimer) == 0) {
+		if (hw->req_timer_done == 0) { 
+			/* 	 
+			 * This timer was actually running while we 	 
+			 * were trying to delete it. Let it terminate 	 
+			 * gracefully instead. 	 
+			 */ 	 
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			goto retry;
+		}
+	}
+	else {
+		hw->req_timer_done = 1;
+	}
+
+	ctlx = get_active_ctlx(hw);
+
+	if ( urb->status == 0 ) {
+		/* Request portion of a CTLX is successful */
+		switch ( ctlx->state ) {
+		case CTLX_REQ_SUBMITTED:
+			/* This OUT-ACK received before IN */
+			ctlx->state = CTLX_REQ_COMPLETE;
+			break;
+
+		case CTLX_RESP_COMPLETE:
+			/* IN already received before this OUT-ACK,
+			 * so this command must now be complete.
+			 */
+			ctlx->state = CTLX_COMPLETE;
+			unlocked_usbctlx_complete(hw, ctlx);
+			run_queue = 1;
+			break;
+
+		default:
+			/* This is NOT a valid CTLX "success" state! */
+			WLAN_LOG_ERROR(
+			    "Illegal CTLX[%d] success state(%s, %d) in OUT URB\n",
+			    hfa384x2host_16(ctlx->outbuf.type),
+			    ctlxstr(ctlx->state), urb->status);
+			break;
+		} /* switch */
+	} else {
+		/* If the pipe has stalled then we need to reset it */
+		if ( (urb->status == -EPIPE) &&
+		      !test_and_set_bit(WORK_TX_HALT, &hw->usb_flags) ) {
+			WLAN_LOG_WARNING("%s tx pipe stalled: requesting reset\n",
+			                 hw->wlandev->netdev->name);
+			schedule_work(&hw->usb_work);
+		}
+
+		/* If someone cancels the OUT URB then its status
+		 * should be either -ECONNRESET or -ENOENT.
+		 */
+		ctlx->state = CTLX_REQ_FAILED;
+		unlocked_usbctlx_complete(hw, ctlx);
+		delete_resptimer = 1;
+		run_queue = 1;
+	}
+
+ delresp:
+	if (delete_resptimer) {
+		if ((timer_ok = del_timer(&hw->resptimer)) != 0) {
+			hw->resp_timer_done = 1;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	if ( !timer_ok && (hw->resp_timer_done == 0) ) { 
+		spin_lock_irqsave(&hw->ctlxq.lock, flags);
+		goto delresp; 	 
+	}
+
+	if (run_queue)
+		hfa384x_usbctlxq_run(hw);
+
+ done:
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_reqtimerfn
+*
+* Timer response function for CTLX request timeouts.  If this 
+* function is called, it means that the callback for the OUT
+* URB containing a Prism2.x XXX_Request was never called.
+*
+* Arguments:
+*	data		a ptr to the hfa384x_t
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_usbctlx_reqtimerfn(unsigned long data)
+{
+	hfa384x_t	*hw = (hfa384x_t*)data;
+	unsigned long   flags;
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	hw->req_timer_done = 1;
+
+	/* Removing the hardware automatically empties
+	 * the active list ...
+	 */
+	if ( !list_empty(&hw->ctlxq.active) )
+	{
+		/*
+		 * We must ensure that our URB is removed from
+		 * the system, if it hasn't already expired.
+		 */
+		hw->ctlx_urb.transfer_flags |= URB_ASYNC_UNLINK;
+		if (usb_unlink_urb(&hw->ctlx_urb) == -EINPROGRESS)
+		{
+			hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+
+			ctlx->state = CTLX_REQ_FAILED;
+
+			/* This URB was active, but has now been
+			 * cancelled. It will now have a status of
+			 * -ECONNRESET in the callback function.
+			 *
+			 * We are cancelling this CTLX, so we're
+			 * not going to need to wait for a response.
+			 * The URB's callback function will check
+			 * that this timer is truly dead.
+			 */
+			if (del_timer(&hw->resptimer) != 0)
+				hw->resp_timer_done = 1;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_resptimerfn
+*
+* Timer response function for CTLX response timeouts.  If this 
+* function is called, it means that the callback for the IN
+* URB containing a Prism2.x XXX_Response was never called.
+*
+* Arguments:
+*	data		a ptr to the hfa384x_t
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_usbctlx_resptimerfn(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	unsigned long   flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	hw->resp_timer_done = 1;
+
+	/* The active list will be empty if the
+	 * adapter has been unplugged ...
+	 */
+	if ( !list_empty(&hw->ctlxq.active) )
+	{
+		hfa384x_usbctlx_t *ctlx = get_active_ctlx(hw);
+
+		if ( unlocked_usbctlx_cancel_async(hw, ctlx) == 0 )
+		{
+			spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+			hfa384x_usbctlxq_run(hw);
+			goto done;
+		}
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+ done:
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_usb_throttlefn
+*
+*
+* Arguments:
+*	data	ptr to hw
+*
+* Returns:
+*	Nothing
+*
+* Side effects:
+*
+* Call context:
+*	Interrupt
+----------------------------------------------------------------*/
+void
+hfa384x_usb_throttlefn(unsigned long data)
+{
+	hfa384x_t *hw = (hfa384x_t*)data;
+	unsigned long   flags;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	/*
+	 * We need to check BOTH the RX and the TX throttle controls,
+	 * so we use the bitwise OR instead of the logical OR.
+	 */
+	WLAN_LOG_DEBUG(3, "flags=0x%lx\n", hw->usb_flags);
+	if ( !hw->wlandev->hwremoved &&
+	     (
+	       (test_and_clear_bit(THROTTLE_RX, &hw->usb_flags) &&
+	       !test_and_set_bit(WORK_RX_RESUME, &hw->usb_flags))
+	       |
+	       (test_and_clear_bit(THROTTLE_TX, &hw->usb_flags) &&
+	        !test_and_set_bit(WORK_TX_RESUME, &hw->usb_flags))
+	     ) )
+	{
+		schedule_work(&hw->usb_work);
+	}
+
+	spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbctlx_submit
+*
+* Called from the doxxx functions to submit a CTLX to the queue
+*
+* Arguments:
+*	hw		ptr to the hw struct
+*	ctlx		ctlx structure to enqueue		
+*
+* Returns: 
+*	-ENODEV if the adapter is unplugged
+*	0
+*
+* Side effects:
+*
+* Call context:
+*	process or interrupt
+----------------------------------------------------------------*/
+int
+hfa384x_usbctlx_submit(
+	hfa384x_t		*hw, 
+	hfa384x_usbctlx_t	*ctlx)
+{
+	unsigned long flags;
+	int ret;
+
+	DBFENTER;
+
+	spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+	if (hw->wlandev->hwremoved) {
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		ret = -ENODEV;
+	} else {
+		ctlx->state = CTLX_PENDING;
+		list_add_tail(&ctlx->list, &hw->ctlxq.pending);
+
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+		hfa384x_usbctlxq_run(hw);
+		ret = 0;
+	}
+
+	DBFEXIT;
+	return ret;
+}
+
+
+/*----------------------------------------------------------------
+* hfa384x_usbout_tx
+*
+* At this point we have finished a send of a frame.  Mark the URB
+* as available and call ev_alloc to notify higher layers we're
+* ready for more.
+*
+* Arguments:
+*	wlandev		wlan device
+*	usbout		ptr to the usb transfer buffer
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void hfa384x_usbout_tx(wlandevice_t *wlandev, hfa384x_usbout_t *usbout)
+{
+	DBFENTER;
+
+	prism2sta_ev_alloc(wlandev);
+	
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* hfa384x_isgood_pdrcore
+*
+* Quick check of PDR codes.
+*
+* Arguments:
+*	pdrcode		PDR code number (host order)
+*
+* Returns: 
+*	zero		not good.
+*	one		is good.
+*
+* Side effects:
+*
+* Call context:
+----------------------------------------------------------------*/
+int
+hfa384x_isgood_pdrcode(UINT16 pdrcode)
+{
+	switch(pdrcode) {
+	case HFA384x_PDR_END_OF_PDA:
+	case HFA384x_PDR_PCB_PARTNUM:
+	case HFA384x_PDR_PDAVER:
+	case HFA384x_PDR_NIC_SERIAL:
+	case HFA384x_PDR_MKK_MEASUREMENTS:
+	case HFA384x_PDR_NIC_RAMSIZE:
+	case HFA384x_PDR_MFISUPRANGE:
+	case HFA384x_PDR_CFISUPRANGE:
+	case HFA384x_PDR_NICID:
+	case HFA384x_PDR_MAC_ADDRESS:
+	case HFA384x_PDR_REGDOMAIN:
+	case HFA384x_PDR_ALLOWED_CHANNEL:
+	case HFA384x_PDR_DEFAULT_CHANNEL:
+	case HFA384x_PDR_TEMPTYPE:
+	case HFA384x_PDR_IFR_SETTING:
+	case HFA384x_PDR_RFR_SETTING:
+	case HFA384x_PDR_HFA3861_BASELINE:
+	case HFA384x_PDR_HFA3861_SHADOW:
+	case HFA384x_PDR_HFA3861_IFRF:
+	case HFA384x_PDR_HFA3861_CHCALSP:
+	case HFA384x_PDR_HFA3861_CHCALI:
+	case HFA384x_PDR_3842_NIC_CONFIG:
+	case HFA384x_PDR_USB_ID:
+	case HFA384x_PDR_PCI_ID:
+	case HFA384x_PDR_PCI_IFCONF:
+	case HFA384x_PDR_PCI_PMCONF:
+	case HFA384x_PDR_RFENRGY:
+	case HFA384x_PDR_HFA3861_MANF_TESTSP:
+	case HFA384x_PDR_HFA3861_MANF_TESTI:
+		/* code is OK */
+		return 1;
+		break;
+	default:
+		if ( pdrcode < 0x1000 ) {
+			/* code is OK, but we don't know exactly what it is */
+			WLAN_LOG_DEBUG(3,
+				"Encountered unknown PDR#=0x%04x, "
+				"assuming it's ok.\n", 
+				pdrcode);
+			return 1;
+		} else {
+			/* bad code */
+			WLAN_LOG_DEBUG(3,
+				"Encountered unknown PDR#=0x%04x, "
+				"(>=0x1000), assuming it's bad.\n",
+				pdrcode);
+			return 0;
+		}
+		break;
+	}
+	return 0; /* avoid compiler warnings */
+}
+
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/Kconfig linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/Kconfig
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/Kconfig	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,24 @@
+config WLAN_NG
+	tristate "Wireless LAN NG Support"
+	select WLAN_80211
+	default n
+
+config PRISM2
+        bool "Prism2 Support"
+        depends on WLAN_NG
+
+config PRISM2_USB
+	tristate "Prism2 USB Support"
+	depends on PRISM2 && USB
+
+config PRISM2_PCI
+	tristate "Prism2 PCI Support"
+	depends on PRISM2 && PCI
+
+config PRISM2_PLX
+	tristate "Prism2 PLX Support"
+	depends on PRISM2 && PCI && !PPC
+
+config PRISM2_CS
+	tristate "Prism2 CS Support"
+	depends on PRISM2 && PCMCIA && !PPC
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/Makefile linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/Makefile
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/Makefile	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,5 @@
+obj-$(CONFIG_WLAN_NG)		+= p80211/
+obj-$(CONFIG_PRISM2_PCI)	+= prism2_pci.o
+obj-$(CONFIG_PRISM2_USB)	+= prism2_usb.o
+obj-$(CONFIG_PRISM2_PLX)	+= prism2_plx.o
+obj-$(CONFIG_PRISM2_CS)		+= prism2_cs.o
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/Makefile linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/Makefile
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/Makefile	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,6 @@
+p80211-objs := p80211mod.o p80211conv.o p80211req.o p80211wep.o p80211wext.o p80211netdev.o
+
+EXTRA_CFLAGS += -DWLAN_HOSTIF=WLAN_NONE -DWLAN_TXMGMT_MINBRATE \
+	-DRSN_INTERNAL_ROAM
+
+obj-$(CONFIG_WLAN_NG) := p80211.o
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211conv.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211conv.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211conv.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211conv.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,681 @@
+/* src/p80211/p80211conv.c
+*
+* Ether/802.11 conversions and packet buffer routines
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file defines the functions that perform Ethernet to/from
+* 802.11 frame conversions. 
+*
+* --------------------------------------------------------------------
+*/
+/*================================================================*/
+/* System Includes */
+
+#define __NO_VERSION__		/* prevent the static definition */
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/if_ether.h>
+
+#include <asm/byteorder.h>
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211ioctl.h>
+#include <wlan/p80211req.h>
+
+
+/*================================================================*/
+/* Local Constants */
+
+/*================================================================*/
+/* Local Macros */
+
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+static UINT8	oui_rfc1042[] = {0x00, 0x00, 0x00};
+static UINT8	oui_8021h[] = {0x00, 0x00, 0xf8};
+
+/*================================================================*/
+/* Local Function Declarations */
+
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* p80211pb_ether_to_80211
+*
+* Uses the contents of the ether frame and the etherconv setting
+* to build the elements of the 802.11 frame.  
+*
+* We don't actually set 
+* up the frame header here.  That's the MAC's job.  We're only handling
+* conversion of DIXII or 802.3+LLC frames to something that works
+* with 802.11.
+*
+* Note -- 802.11 header is NOT part of the skb.  Likewise, the 802.11
+*         FCS is also not present and will need to be added elsewhere.
+*
+* Arguments:
+*	ethconv		Conversion type to perform
+*	skb		skbuff containing the ether frame
+*       p80211_hdr      802.11 header
+*
+* Returns: 
+*	0 on success, non-zero otherwise
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int skb_ether_to_p80211( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+{
+
+	UINT16          fc;
+	UINT16          proto;
+	wlan_ethhdr_t   e_hdr; 
+	wlan_llc_t      *e_llc;
+	wlan_snap_t     *e_snap;
+	int foo;
+
+	DBFENTER;
+	memcpy(&e_hdr, skb->data, sizeof(e_hdr)); 
+
+	if (skb->len <= 0) {
+		WLAN_LOG_DEBUG(1, "zero-length skb!\n");
+		return 1;
+	}
+
+	if ( ethconv == WLAN_ETHCONV_ENCAP ) { /* simplest case */
+	        WLAN_LOG_DEBUG(3, "ENCAP len: %d\n", skb->len);
+		/* here, we don't care what kind of ether frm. Just stick it */
+		/*  in the 80211 payload */
+		/* which is to say, leave the skb alone. */
+	} else {
+		/* step 1: classify ether frame, DIX or 802.3? */
+		proto = ntohs(e_hdr.type);
+		if ( proto <= 1500 ) { 
+		        WLAN_LOG_DEBUG(3, "802.3 len: %d\n", skb->len);
+                        /* codes <= 1500 reserved for 802.3 lengths */
+			/* it's 802.3, pass ether payload unchanged,  */
+
+			/* trim off ethernet header */
+			skb_pull(skb, WLAN_ETHHDR_LEN);
+
+			/*   leave off any PAD octets.  */
+			skb_trim(skb, proto);
+		} else {
+		        WLAN_LOG_DEBUG(3, "DIXII len: %d\n", skb->len);
+			/* it's DIXII, time for some conversion */
+
+			/* trim off ethernet header */
+			skb_pull(skb, WLAN_ETHHDR_LEN);
+
+			/* tack on SNAP */
+			e_snap = (wlan_snap_t *) skb_push(skb, sizeof(wlan_snap_t));
+			e_snap->type = htons(proto);
+			if ( ethconv == WLAN_ETHCONV_8021h && p80211_stt_findproto(proto) ) {
+				memcpy( e_snap->oui, oui_8021h, WLAN_IEEE_OUI_LEN);
+			} else {
+				memcpy( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN);
+			}
+
+			/* tack on llc */
+			e_llc = (wlan_llc_t *) skb_push(skb, sizeof(wlan_llc_t));
+			e_llc->dsap = 0xAA;	/* SNAP, see IEEE 802 */
+			e_llc->ssap = 0xAA;
+			e_llc->ctl = 0x03;
+			
+		}
+	}
+
+	/* Set up the 802.11 header */
+	/* It's a data frame */
+	fc = host2ieee16( WLAN_SET_FC_FTYPE(WLAN_FTYPE_DATA) |  
+			  WLAN_SET_FC_FSTYPE(WLAN_FSTYPE_DATAONLY));
+
+	switch ( wlandev->macmode ) {
+	case WLAN_MACMODE_IBSS_STA:
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, wlandev->bssid, WLAN_ADDR_LEN);
+		break;
+	case WLAN_MACMODE_ESS_STA:
+		fc |= host2ieee16(WLAN_SET_FC_TODS(1));
+		memcpy(p80211_hdr->a3.a1, wlandev->bssid, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.daddr, WLAN_ADDR_LEN);
+		break;
+	case WLAN_MACMODE_ESS_AP:
+		fc |= host2ieee16(WLAN_SET_FC_FROMDS(1));
+		memcpy(p80211_hdr->a3.a1, &e_hdr.daddr, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a2, wlandev->bssid, WLAN_ADDR_LEN);
+		memcpy(p80211_hdr->a3.a3, &e_hdr.saddr, WLAN_ADDR_LEN);
+		break;
+	default:
+		WLAN_LOG_ERROR("Error: Converting eth to wlan in unknown mode.\n");
+		return 1;
+		break;
+	}
+
+	p80211_wep->data = NULL;
+
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && (wlandev->hostwep & HOSTWEP_ENCRYPT)) {
+		// XXXX need to pick keynum other than default?
+
+#if 1
+		p80211_wep->data = kmalloc(skb->len, GFP_ATOMIC);
+#else
+		p80211_wep->data = skb->data;
+#endif
+
+		if ((foo = wep_encrypt(wlandev, skb->data, p80211_wep->data, 
+				       skb->len, 
+				(wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK),
+				p80211_wep->iv, p80211_wep->icv))) {
+			WLAN_LOG_WARNING("Host en-WEP failed, dropping frame (%d).\n", foo);
+			return 2;
+		}
+		fc |= host2ieee16(WLAN_SET_FC_ISWEP(1));
+	}
+	
+
+	//	skb->nh.raw = skb->data;
+
+	p80211_hdr->a3.fc = fc;
+	p80211_hdr->a3.dur = 0;
+	p80211_hdr->a3.seq = 0;
+
+	DBFEXIT;
+	return 0;
+}
+
+/* jkriegl: from orinoco, modified */
+void orinoco_spy_gather(wlandevice_t *wlandev, char *mac, p80211_rxmeta_t *rxmeta)
+{
+        int i;
+
+        /* Gather wireless spy statistics: for each packet, compare the
+         * source address with out list, and if match, get the stats... */
+
+        for (i = 0; i < wlandev->spy_number; i++) {
+
+                if (!memcmp(wlandev->spy_address[i], mac, ETH_ALEN)) {
+			memcpy(wlandev->spy_address[i], mac, ETH_ALEN);
+                        wlandev->spy_stat[i].level = rxmeta->signal;
+                        wlandev->spy_stat[i].noise = rxmeta->noise;
+                        wlandev->spy_stat[i].qual = (rxmeta->signal > rxmeta->noise) ? \
+                                                     (rxmeta->signal - rxmeta->noise) : 0;
+                        wlandev->spy_stat[i].updated = 0x7;
+                }
+        }
+}
+
+/*----------------------------------------------------------------
+* p80211pb_80211_to_ether
+*
+* Uses the contents of a received 802.11 frame and the etherconv 
+* setting to build an ether frame.
+*
+* This function extracts the src and dest address from the 802.11
+* frame to use in the construction of the eth frame.
+*
+* Arguments:
+*	ethconv		Conversion type to perform
+*	skb		Packet buffer containing the 802.11 frame
+*
+* Returns: 
+*	0 on success, non-zero otherwise
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int skb_p80211_to_ether( wlandevice_t *wlandev, UINT32 ethconv, struct sk_buff *skb)
+{
+	netdevice_t     *netdev = wlandev->netdev;
+	UINT16          fc;
+	UINT            payload_length;
+	UINT            payload_offset;
+	UINT8		daddr[WLAN_ETHADDR_LEN];
+	UINT8		saddr[WLAN_ETHADDR_LEN];
+	p80211_hdr_t    *w_hdr;
+	wlan_ethhdr_t   *e_hdr;
+	wlan_llc_t      *e_llc;
+	wlan_snap_t     *e_snap;
+
+	int foo;
+
+	DBFENTER;
+	
+	payload_length = skb->len - WLAN_HDR_A3_LEN - WLAN_CRC_LEN;
+	payload_offset = WLAN_HDR_A3_LEN;
+
+	w_hdr = (p80211_hdr_t *) skb->data;
+
+        /* setup some vars for convenience */
+	fc = ieee2host16(w_hdr->a3.fc);
+	if ( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+	} else if( (WLAN_GET_FC_TODS(fc) == 0) && (WLAN_GET_FC_FROMDS(fc) == 1) ) {
+		memcpy(daddr, w_hdr->a3.a1, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
+	} else if( (WLAN_GET_FC_TODS(fc) == 1) && (WLAN_GET_FC_FROMDS(fc) == 0) ) {
+		memcpy(daddr, w_hdr->a3.a3, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a3.a2, WLAN_ETHADDR_LEN);
+	} else {
+		payload_offset = WLAN_HDR_A4_LEN;
+		payload_length -= ( WLAN_HDR_A4_LEN - WLAN_HDR_A3_LEN );
+		if (payload_length < 0 ) {
+			WLAN_LOG_ERROR("A4 frame too short!\n");
+			return 1;
+		}
+		memcpy(daddr, w_hdr->a4.a3, WLAN_ETHADDR_LEN);
+		memcpy(saddr, w_hdr->a4.a4, WLAN_ETHADDR_LEN);
+	}
+
+	/* perform de-wep if necessary.. */
+	if ((wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) && WLAN_GET_FC_ISWEP(fc) && (wlandev->hostwep & HOSTWEP_DECRYPT)) {
+		if (payload_length <= 8) {
+			WLAN_LOG_ERROR("WEP frame too short (%u).\n",
+					skb->len);
+			return 1;
+		}
+		if ((foo = wep_decrypt(wlandev, skb->data + payload_offset + 4,
+				       payload_length - 8, -1, 
+				       skb->data + payload_offset, 
+				       skb->data + payload_offset + payload_length - 4))) {
+			/* de-wep failed, drop skb. */
+			WLAN_LOG_DEBUG(1, "Host de-WEP failed, dropping frame (%d).\n", foo);
+			wlandev->rx.decrypt_err++;
+			return 2;
+		}
+
+		/* subtract the IV+ICV length off the payload */
+		payload_length -= 8;
+		/* chop off the IV */
+		skb_pull(skb, 4);
+		/* chop off the ICV. */
+		skb_trim(skb, skb->len - 4);
+		
+		wlandev->rx.decrypt++;
+	}
+
+	e_hdr = (wlan_ethhdr_t *) (skb->data + payload_offset);
+
+	e_llc = (wlan_llc_t *) (skb->data + payload_offset);
+	e_snap = (wlan_snap_t *) (skb->data + payload_offset + sizeof(wlan_llc_t));
+
+	/* Test for the various encodings */
+	if ( (payload_length >= sizeof(wlan_ethhdr_t)) &&
+	     ( e_llc->dsap != 0xaa || e_llc->ssap != 0xaa ) &&
+	     ((memcmp(daddr, e_hdr->daddr, WLAN_ETHADDR_LEN) == 0) ||
+	     (memcmp(saddr, e_hdr->saddr, WLAN_ETHADDR_LEN) == 0))) {
+		WLAN_LOG_DEBUG(3, "802.3 ENCAP len: %d\n", payload_length);
+		/* 802.3 Encapsulated */
+		/* Test for an overlength frame */
+		if ( payload_length > (netdev->mtu + WLAN_ETHHDR_LEN)) {
+			/* A bogus length ethfrm has been encap'd. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("ENCAP frame too large (%d > %d)\n", 
+				payload_length, netdev->mtu + WLAN_ETHHDR_LEN);
+			return 1;
+		}
+
+		/* Chop off the 802.11 header.  it's already sane. */
+		skb_pull(skb, payload_offset);
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	} else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
+		   (e_llc->dsap == 0xaa) &&
+		   (e_llc->ssap == 0xaa) &&
+		   (e_llc->ctl == 0x03) && 
+		   (((memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)==0) &&
+		    (ethconv == WLAN_ETHCONV_8021h) && 
+		    (p80211_stt_findproto(ieee2host16(e_snap->type)))) || 
+		    (memcmp( e_snap->oui, oui_rfc1042, WLAN_IEEE_OUI_LEN)!=0)))
+	{
+		WLAN_LOG_DEBUG(3, "SNAP+RFC1042 len: %d\n", payload_length);
+		/* it's a SNAP + RFC1042 frame && protocol is in STT */
+		/* build 802.3 + RFC1042 */
+		
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("SNAP frame too large (%d > %d)\n", 
+				payload_length, netdev->mtu);
+			return 1;
+		}
+
+		/* chop 802.11 header from skb. */
+		skb_pull(skb, payload_offset);
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN); 
+		e_hdr->type = htons(payload_length);
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	}  else if ((payload_length >= sizeof(wlan_llc_t) + sizeof(wlan_snap_t)) &&
+		    (e_llc->dsap == 0xaa) &&
+		    (e_llc->ssap == 0xaa) &&
+		    (e_llc->ctl == 0x03) ) {
+		WLAN_LOG_DEBUG(3, "802.1h/RFC1042 len: %d\n", payload_length);
+		/* it's an 802.1h frame || (an RFC1042 && protocol is not in STT) */
+		/* build a DIXII + RFC894 */
+		
+		/* Test for an overlength frame */
+		if ((payload_length - sizeof(wlan_llc_t) - sizeof(wlan_snap_t))
+		    > netdev->mtu) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("DIXII frame too large (%ld > %d)\n",
+					(long int) (payload_length - sizeof(wlan_llc_t) - 
+						    sizeof(wlan_snap_t)),
+					netdev->mtu);
+			return 1;
+		}
+
+		/* chop 802.11 header from skb. */
+		skb_pull(skb, payload_offset);
+
+		/* chop llc header from skb. */
+		skb_pull(skb, sizeof(wlan_llc_t));
+
+		/* chop snap header from skb. */
+		skb_pull(skb, sizeof(wlan_snap_t));
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		e_hdr->type = e_snap->type;
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN); 
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+	} else {
+		WLAN_LOG_DEBUG(3, "NON-ENCAP len: %d\n", payload_length);
+		/* any NON-ENCAP */
+		/* it's a generic 80211+LLC or IPX 'Raw 802.3' */
+		/*  build an 802.3 frame */
+		/* allocate space and setup hostbuf */
+
+		/* Test for an overlength frame */
+		if ( payload_length > netdev->mtu ) {
+			/* A bogus length ethfrm has been sent. */
+			/* Is someone trying an oflow attack? */
+			WLAN_LOG_ERROR("OTHER frame too large (%d > %d)\n",
+				payload_length,
+				netdev->mtu);
+			return 1;
+		}
+
+		/* Chop off the 802.11 header. */
+		skb_pull(skb, payload_offset);
+
+		/* create 802.3 header at beginning of skb. */
+		e_hdr = (wlan_ethhdr_t *) skb_push(skb, WLAN_ETHHDR_LEN);
+		memcpy(e_hdr->daddr, daddr, WLAN_ETHADDR_LEN);
+		memcpy(e_hdr->saddr, saddr, WLAN_ETHADDR_LEN); 
+		e_hdr->type = htons(payload_length);
+
+		/* chop off the 802.11 CRC */
+		skb_trim(skb, skb->len - WLAN_CRC_LEN);
+
+	}
+
+	skb->protocol = eth_type_trans(skb, netdev);
+	skb->mac.raw = (unsigned char *) e_hdr; /* new MAC header */
+
+        /* jkriegl: process signal and noise as set in hfa384x_int_rx() */
+	/* jkriegl: only process signal/noise if requested by iwspy */
+        if (wlandev->spy_number)
+                orinoco_spy_gather(wlandev, eth_hdr(skb)->h_source, P80211SKB_RXMETA(skb));
+
+	/* Free the metadata */
+	p80211skb_rxmeta_detach(skb);
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* p80211_stt_findproto
+*
+* Searches the 802.1h Selective Translation Table for a given 
+* protocol.
+*
+* Arguments:
+*	proto	protocl number (in host order) to search for.
+*
+* Returns: 
+*	1 - if the table is empty or a match is found.
+*	0 - if the table is non-empty and a match is not found.
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int p80211_stt_findproto(UINT16 proto)
+{
+	/* Always return found for now.  This is the behavior used by the */
+	/*  Zoom Win95 driver when 802.1h mode is selected */
+	/* TODO: If necessary, add an actual search we'll probably
+		 need this to match the CMAC's way of doing things.
+		 Need to do some testing to confirm.
+	*/
+
+	if (proto == 0x80f3)  /* APPLETALK */
+		return 1;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_rxmeta_detach
+*
+* Disconnects the frmmeta and rxmeta from an skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns: 
+*	0 on success, non-zero otherwise
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+void
+p80211skb_rxmeta_detach(struct sk_buff *skb)
+{
+	p80211_rxmeta_t		*rxmeta;
+	p80211_frmmeta_t	*frmmeta;
+
+	DBFENTER;
+	/* Sanity checks */
+	if ( skb==NULL ) {			/* bad skb */
+		WLAN_LOG_DEBUG(1, "Called w/ null skb.\n");
+		goto exit;
+	}
+	frmmeta = P80211SKB_FRMMETA(skb);
+	if ( frmmeta == NULL ) { 		/* no magic */
+		WLAN_LOG_DEBUG(1, "Called w/ bad frmmeta magic.\n");
+		goto exit;
+	}
+	rxmeta = frmmeta->rx;
+	if ( rxmeta == NULL ) {			/* bad meta ptr */
+		WLAN_LOG_DEBUG(1, "Called w/ bad rxmeta ptr.\n");
+		goto exit;
+	}
+	
+	/* Free rxmeta */
+	kfree(rxmeta);
+
+	/* Clear skb->cb */
+	memset(skb->cb, 0, sizeof(skb->cb));
+exit:
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_rxmeta_attach
+*
+* Allocates a p80211rxmeta structure, initializes it, and attaches
+* it to an skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns: 
+*	0 on success, non-zero otherwise
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+int
+p80211skb_rxmeta_attach(struct wlandevice *wlandev, struct sk_buff *skb)
+{
+	int			result = 0;
+	p80211_rxmeta_t		*rxmeta;
+	p80211_frmmeta_t	*frmmeta;
+
+	DBFENTER;
+
+	/* If these already have metadata, we error out! */
+	if (P80211SKB_RXMETA(skb) != NULL) {
+		WLAN_LOG_ERROR("%s: RXmeta already attached!\n", 
+				wlandev->name);	
+		result = 0;
+		goto exit;
+	}
+
+	/* Allocate the rxmeta */
+	rxmeta = kmalloc(sizeof(p80211_rxmeta_t), GFP_ATOMIC);
+ 
+	if ( rxmeta == NULL ) {
+		WLAN_LOG_ERROR("%s: Failed to allocate rxmeta.\n", 
+				wlandev->name);
+		result = 1;
+		goto exit;
+	}
+
+	/* Initialize the rxmeta */
+	memset(rxmeta, 0, sizeof(p80211_rxmeta_t));
+	rxmeta->wlandev = wlandev;
+	rxmeta->hosttime = jiffies;
+
+	/* Overlay a frmmeta_t onto skb->cb */
+	memset(skb->cb, 0, sizeof(p80211_frmmeta_t));
+	frmmeta = (p80211_frmmeta_t*)(skb->cb);
+	frmmeta->magic = P80211_FRMMETA_MAGIC;
+	frmmeta->rx = rxmeta;
+exit:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* p80211skb_free
+*
+* Frees an entire p80211skb by checking and freeing the meta struct
+* and then freeing the skb.
+*
+* Arguments:
+*	wlandev		The wlandev this skb belongs to.
+*	skb		The skb we're attaching to.
+*
+* Returns: 
+*	0 on success, non-zero otherwise
+*	
+* Call context:
+*	May be called in interrupt or non-interrupt context
+----------------------------------------------------------------*/
+void
+p80211skb_free(struct wlandevice *wlandev, struct sk_buff *skb)
+{
+	p80211_frmmeta_t	*meta;
+	DBFENTER;
+	meta = P80211SKB_FRMMETA(skb);
+	if ( meta && meta->rx) {
+		p80211skb_rxmeta_detach(skb);
+	} else {
+		WLAN_LOG_ERROR("Freeing an skb (%p) w/ no frmmeta.\n", skb);
+	}
+
+	dev_kfree_skb(skb);
+	DBFEXIT;
+	return;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211mod.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211mod.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211mod.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211mod.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,215 @@
+/* src/p80211/p80211mod.c
+*
+* Module entry and exit for p80211
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file contains the p80211.o entry and exit points defined for linux
+* kernel modules.
+*
+* Notes: 
+* - all module parameters for  p80211.o should be defined here.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,25))
+#include <linux/moduleparam.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211req.h>
+
+/*================================================================*/
+/* Local Constants */
+
+
+/*================================================================*/
+/* Local Macros */
+
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+static char *version = "p80211.o: " WLAN_RELEASE;
+
+
+/*----------------------------------------------------------------*/
+/* --Module Parameters */
+
+int wlan_watchdog = 5000;
+module_param(wlan_watchdog, int, 0644);
+MODULE_PARM_DESC(wlan_watchdog, "transmit timeout in milliseconds");
+
+int wlan_wext_write = 0;
+#if WIRELESS_EXT > 12
+module_param(wlan_wext_write, int, 0644);
+MODULE_PARM_DESC(wlan_wext_write, "enable write wireless extensions");
+#endif
+
+#ifdef WLAN_INCLUDE_DEBUG
+int wlan_debug=0;
+module_param(wlan_debug, int, 0644); 
+MODULE_PARM_DESC(wlan_debug, "p80211 debug level"); 
+#endif
+
+MODULE_LICENSE("Dual MPL/GPL");
+
+/*================================================================*/
+/* Local Function Declarations */
+
+int	init_module(void);
+void	cleanup_module(void);
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* init_module
+*
+* Module initialization routine, called once at module load time.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	0	- success 
+*	~0	- failure, module is unloaded.
+*
+* Side effects:
+*	TODO: define
+*
+* Call context:
+*	process thread (insmod or modprobe)
+----------------------------------------------------------------*/
+int init_module(void)
+{
+        DBFENTER;
+
+#if 0
+        printk(KERN_NOTICE "%s (%s) Loaded\n", version, WLAN_BUILD_DATE);
+#endif
+
+	p80211netdev_startup();
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(NULL, WLAN_HOTPLUG_STARTUP);
+#endif
+
+        DBFEXIT;
+        return 0;
+}
+
+
+/*----------------------------------------------------------------
+* cleanup_module
+*
+* Called at module unload time.  This is our last chance to
+* clean up after ourselves.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	TODO: define
+*
+* Call context:
+*	process thread
+*
+----------------------------------------------------------------*/
+void cleanup_module(void)
+{
+        DBFENTER;
+
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(NULL, WLAN_HOTPLUG_SHUTDOWN);
+#endif
+	p80211netdev_shutdown();
+        printk(KERN_NOTICE "%s Unloaded\n", version);
+
+        DBFEXIT;
+        return;
+}
+
+EXPORT_SYMBOL(p80211netdev_hwremoved);
+EXPORT_SYMBOL(register_wlandev);
+EXPORT_SYMBOL(p80211netdev_rx);
+EXPORT_SYMBOL(unregister_wlandev);
+EXPORT_SYMBOL(wlan_setup);
+EXPORT_SYMBOL(wlan_unsetup);
+EXPORT_SYMBOL(p80211_suspend);
+EXPORT_SYMBOL(p80211_resume);
+
+EXPORT_SYMBOL(p80211skb_free);
+EXPORT_SYMBOL(p80211skb_rxmeta_attach);
+
+EXPORT_SYMBOL(p80211wext_event_associated);
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211netdev.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211netdev.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211netdev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211netdev.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,1500 @@
+/* src/p80211/p80211knetdev.c
+*
+* Linux Kernel net device interface
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* The functions required for a Linux network device are defined here.
+*
+* --------------------------------------------------------------------
+*/
+
+
+/*================================================================*/
+/* System Includes */
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/proc_fs.h>
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/kmod.h>
+#include <linux/if_arp.h>
+#include <linux/wireless.h>
+#include <linux/sockios.h>
+#include <linux/etherdevice.h>
+
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+
+#ifdef SIOCETHTOOL
+#include <linux/ethtool.h>
+#endif
+
+#if WIRELESS_EXT > 12
+#include <net/iw_handler.h>
+#endif
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211ioctl.h>
+#include <wlan/p80211req.h>
+#include <wlan/p80211metastruct.h>
+#include <wlan/p80211metadef.h>
+
+/*================================================================*/
+/* Local Constants */
+
+/*================================================================*/
+/* Local Macros */
+
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+
+#define __NO_VERSION__		/* prevent the static definition */
+
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry	*proc_p80211;
+#endif
+
+/*================================================================*/
+/* Local Function Declarations */
+
+/* Support functions */
+static void p80211netdev_rx_bh(unsigned long arg);
+
+/* netdevice method functions */
+static int p80211knetdev_init( netdevice_t *netdev);
+static struct net_device_stats* p80211knetdev_get_stats(netdevice_t *netdev);
+static int p80211knetdev_open( netdevice_t *netdev);
+static int p80211knetdev_stop( netdevice_t *netdev );
+static int p80211knetdev_hard_start_xmit( struct sk_buff *skb, netdevice_t *netdev);
+static void p80211knetdev_set_multicast_list(netdevice_t *dev);
+static int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd);
+static int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr);
+static void p80211knetdev_tx_timeout(netdevice_t *netdev);
+static int p80211_rx_typedrop( wlandevice_t *wlandev, UINT16 fc);
+
+#ifdef CONFIG_PROC_FS
+static int
+p80211netdev_proc_read(
+	char	*page, 
+	char	**start, 
+	off_t	offset, 
+	int	count,
+	int	*eof,
+	void	*data);
+#endif
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* p80211knetdev_startup
+*
+* Initialize the wlandevice/netdevice part of 802.11 services at 
+* load time.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	nothing
+----------------------------------------------------------------*/
+void p80211netdev_startup(void)
+{
+	DBFENTER;
+
+#ifdef CONFIG_PROC_FS
+	if (proc_net != NULL) {
+		proc_p80211 = create_proc_entry(
+				"p80211", 
+				(S_IFDIR|S_IRUGO|S_IXUGO),
+				proc_net);
+	}
+#endif
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* p80211knetdev_shutdown
+*
+* Shutdown the wlandevice/netdevice part of 802.11 services at 
+* unload time.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	nothing
+----------------------------------------------------------------*/
+void
+p80211netdev_shutdown(void)
+{
+	DBFENTER;
+#ifdef CONFIG_PROC_FS
+	if (proc_p80211 != NULL) {
+		remove_proc_entry("p80211", proc_net);
+	}
+#endif
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* p80211knetdev_init
+*
+* Init method for a Linux netdevice.  Called in response to
+* register_netdev.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	nothing
+----------------------------------------------------------------*/
+int p80211knetdev_init( netdevice_t *netdev)
+{
+	DBFENTER;
+	/* Called in response to register_netdev */
+	/* This is usually the probe function, but the probe has */
+	/* already been done by the MSD and the create_kdev */
+	/* function.  All we do here is return success */
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* p80211knetdev_get_stats
+*
+* Statistics retrieval for linux netdevices.  Here we're reporting
+* the Linux i/f level statistics.  Hence, for the primary numbers,
+* we don't want to report the numbers from the MIB.  Eventually,
+* it might be useful to collect some of the error counters though.
+*
+* Arguments:
+*	netdev		Linux netdevice
+*
+* Returns: 
+*	the address of the statistics structure
+----------------------------------------------------------------*/
+struct net_device_stats*
+p80211knetdev_get_stats(netdevice_t *netdev)
+{
+	wlandevice_t	*wlandev = (wlandevice_t*)netdev->priv;
+	DBFENTER;
+
+	/* TODO: review the MIB stats for items that correspond to 
+		linux stats */
+
+	DBFEXIT;
+	return &(wlandev->linux_stats);
+}
+
+
+/*----------------------------------------------------------------
+* p80211knetdev_open
+*
+* Linux netdevice open method.  Following a successful call here,
+* the device is supposed to be ready for tx and rx.  In our
+* situation that may not be entirely true due to the state of the
+* MAC below.
+*
+* Arguments:
+*	netdev		Linux network device structure
+*
+* Returns: 
+*	zero on success, non-zero otherwise
+----------------------------------------------------------------*/
+int p80211knetdev_open( netdevice_t *netdev )
+{
+	int 		result = 0; /* success */
+	wlandevice_t	*wlandev = (wlandevice_t*)(netdev->priv);
+
+	DBFENTER;
+
+	/* Check to make sure the MSD is running */
+	if ( wlandev->msdstate != WLAN_MSD_RUNNING ) {
+		return -ENODEV;
+	}
+
+	/* Tell the MSD to open */
+	if ( wlandev->open != NULL) {
+		result = wlandev->open(wlandev);
+		if ( result == 0 ) {
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,3,43) )
+			netdev->interrupt = 0;
+#endif
+			p80211netdev_start_queue(wlandev);
+			wlandev->state = WLAN_DEVICE_OPEN;
+		}
+	} else {
+		result = -EAGAIN;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* p80211knetdev_stop
+*
+* Linux netdevice stop (close) method.  Following this call,
+* no frames should go up or down through this interface.
+*
+* Arguments:
+*	netdev		Linux network device structure
+*
+* Returns: 
+*	zero on success, non-zero otherwise
+----------------------------------------------------------------*/
+int p80211knetdev_stop( netdevice_t *netdev )
+{
+	int		result = 0;
+	wlandevice_t	*wlandev = (wlandevice_t*)(netdev->priv);
+
+	DBFENTER;
+
+	if ( wlandev->close != NULL ) {
+		result = wlandev->close(wlandev);
+	}
+
+	p80211netdev_stop_queue(wlandev);
+	wlandev->state = WLAN_DEVICE_CLOSED;
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* p80211netdev_rx
+*
+* Frame receive function called by the mac specific driver.
+*
+* Arguments:
+*	wlandev		WLAN network device structure
+*	skb		skbuff containing a full 802.11 frame.
+* Returns: 
+*	nothing
+* Side effects:
+*	
+----------------------------------------------------------------*/
+void 
+p80211netdev_rx(wlandevice_t *wlandev, struct sk_buff *skb ) 
+{
+	DBFENTER;
+
+	/* Enqueue for post-irq processing */
+	skb_queue_tail(&wlandev->nsd_rxq, skb);
+	
+	tasklet_schedule(&wlandev->rx_bh);
+	
+        DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* p80211netdev_rx_bh
+*
+* Deferred processing of all received frames.
+*
+* Arguments:
+*	wlandev		WLAN network device structure
+*	skb		skbuff containing a full 802.11 frame.
+* Returns: 
+*	nothing
+* Side effects:
+*	
+----------------------------------------------------------------*/
+void p80211netdev_rx_bh(unsigned long arg)
+{
+	wlandevice_t *wlandev = (wlandevice_t *) arg;
+	struct sk_buff *skb = NULL; 
+	netdevice_t     *dev = wlandev->netdev;
+	p80211_hdr_a3_t *hdr;
+	UINT16 fc;
+
+        DBFENTER;
+
+	/* Let's empty our our queue */
+	while ( (skb = skb_dequeue(&wlandev->nsd_rxq)) ) {
+		if (wlandev->state == WLAN_DEVICE_OPEN) {
+
+			if (dev->type != ARPHRD_ETHER) {
+				/* RAW frame; we shouldn't convert it */
+				// XXX Append the Prism Header here instead.
+
+				/* set up various data fields */
+				skb->dev = dev;
+				skb->mac.raw = skb->data ;
+				skb->ip_summed = CHECKSUM_NONE;
+				skb->pkt_type = PACKET_OTHERHOST;
+				skb->protocol = htons(ETH_P_80211_RAW); 
+				dev->last_rx = jiffies;
+
+				wlandev->linux_stats.rx_packets++;
+				wlandev->linux_stats.rx_bytes += skb->len;
+				netif_rx_ni(skb);
+				continue;
+			} else {
+				hdr = (p80211_hdr_a3_t *)skb->data;
+				fc = ieee2host16(hdr->fc);
+				if (p80211_rx_typedrop(wlandev, fc)) {
+					dev_kfree_skb(skb);
+					continue;
+				}
+
+				/* perform mcast filtering */
+				if (wlandev->netdev->flags & IFF_ALLMULTI) {
+					/* allow my local address through */ 
+					if (memcmp(hdr->a1, wlandev->netdev->dev_addr, WLAN_ADDR_LEN) != 0) {
+						/* but reject anything else that isn't multicast */
+						if (!(hdr->a1[0] & 0x01)) {
+							dev_kfree_skb(skb);
+							continue;
+						}
+					}
+				}
+
+				if ( skb_p80211_to_ether(wlandev, wlandev->ethconv, skb) == 0 ) {
+					skb->dev->last_rx = jiffies;
+					wlandev->linux_stats.rx_packets++;
+					wlandev->linux_stats.rx_bytes += skb->len;
+					netif_rx_ni(skb);
+					continue;
+				} 
+				WLAN_LOG_DEBUG(1, "p80211_to_ether failed.\n");
+			}
+		}
+		dev_kfree_skb(skb);
+	}
+
+        DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* p80211knetdev_hard_start_xmit
+*
+* Linux netdevice method for transmitting a frame.
+*
+* Arguments:
+*	skb	Linux sk_buff containing the frame.
+*	netdev	Linux netdevice.
+*
+* Side effects:
+*	If the lower layers report that buffers are full. netdev->tbusy
+*	will be set to prevent higher layers from sending more traffic.
+*
+*	Note: If this function returns non-zero, higher layers retain
+*	      ownership of the skb.
+*
+* Returns: 
+*	zero on success, non-zero on failure.
+----------------------------------------------------------------*/
+int p80211knetdev_hard_start_xmit( struct sk_buff *skb, netdevice_t *netdev)
+{
+	int		result = 0;
+	int		txresult = -1;
+	wlandevice_t	*wlandev = (wlandevice_t*)netdev->priv;
+	p80211_hdr_t    p80211_hdr;
+	p80211_metawep_t p80211_wep;
+
+	DBFENTER;
+
+	if (skb == NULL) {
+		return 0;
+	}
+
+        if (wlandev->state != WLAN_DEVICE_OPEN) {
+		result = 1;
+		goto failed;
+	}
+
+	memset(&p80211_hdr, 0, sizeof(p80211_hdr_t));
+	memset(&p80211_wep, 0, sizeof(p80211_metawep_t));
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,38) )
+	if ( test_and_set_bit(0, (void*)&(netdev->tbusy)) != 0 ) {
+		/* We've been called w/ tbusy set, has the tx */
+		/* path stalled?   */
+		WLAN_LOG_DEBUG(1, "called when tbusy set\n");
+		result = 1;
+		goto failed;
+	} 
+#else
+	if ( netif_queue_stopped(netdev) ) {
+		WLAN_LOG_DEBUG(1, "called when queue stopped.\n");
+		result = 1;
+		goto failed;
+	}
+
+	netif_stop_queue(netdev);
+
+	/* No timeout handling here, 2.3.38+ kernels call the 
+	 * timeout function directly.
+	 * TODO: Add timeout handling.
+	*/
+#endif
+
+	/* Check to see that a valid mode is set */
+	switch( wlandev->macmode ) {
+	case WLAN_MACMODE_IBSS_STA: 
+	case WLAN_MACMODE_ESS_STA:
+	case WLAN_MACMODE_ESS_AP:
+		break;
+	default:
+		/* Mode isn't set yet, just drop the frame 
+		 * and return success .
+		 * TODO: we need a saner way to handle this 
+		 */
+		if(skb->protocol != ETH_P_80211_RAW) {
+			p80211netdev_start_queue(wlandev);
+			WLAN_LOG_NOTICE(
+				"Tx attempt prior to association, frame dropped.\n");
+			wlandev->linux_stats.tx_dropped++;
+			result = 0;
+			goto failed;
+		}
+		break;
+	}
+		
+	/* Check for raw transmits */
+	if(skb->protocol == ETH_P_80211_RAW) {
+		if (!capable(CAP_NET_ADMIN)) {
+			result = 1;
+			goto failed;
+		}
+		/* move the header over */
+		memcpy(&p80211_hdr, skb->data, sizeof(p80211_hdr_t));
+		skb_pull(skb, sizeof(p80211_hdr_t));
+	} else {
+		if ( skb_ether_to_p80211(wlandev, wlandev->ethconv, skb, &p80211_hdr, &p80211_wep) != 0 ) {
+			/* convert failed */
+			WLAN_LOG_DEBUG(1, "ether_to_80211(%d) failed.\n", 
+					wlandev->ethconv);
+			result = 1;
+			goto failed;
+		}
+	}
+	if ( wlandev->txframe == NULL ) {
+		result = 1;
+		goto failed;
+	}
+
+	netdev->trans_start = jiffies;
+
+	wlandev->linux_stats.tx_packets++;
+	/* count only the packet payload */
+	wlandev->linux_stats.tx_bytes += skb->len;
+	
+	txresult = wlandev->txframe(wlandev, skb, &p80211_hdr, &p80211_wep);
+
+	if ( txresult == 0) {
+		/* success and more buf */
+		/* avail, re: hw_txdata */
+		p80211netdev_wake_queue(wlandev);
+		result = 0;
+	} else if ( txresult == 1 ) { 
+		/* success, no more avail */
+		WLAN_LOG_DEBUG(3, "txframe success, no more bufs\n");
+		/* netdev->tbusy = 1;  don't set here, irqhdlr */
+		/*   may have already cleared it */
+		result = 0;
+	} else if ( txresult == 2 ) { 
+		/* alloc failure, drop frame */
+		WLAN_LOG_DEBUG(3, "txframe returned alloc_fail\n");
+		result = 1;
+	} else { 
+		/* buffer full or queue busy, drop frame. */
+		WLAN_LOG_DEBUG(3, "txframe returned full or busy\n");
+		result = 1;
+	}
+
+ failed:
+	/* Free up the WEP buffer if it's not the same as the skb */
+	if ((p80211_wep.data) && (p80211_wep.data != skb->data))
+		kfree(p80211_wep.data);
+
+	/* we always free the skb here, never in a lower level. */
+	if (!result)
+		dev_kfree_skb(skb);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* p80211knetdev_set_multicast_list
+*
+* Called from higher lavers whenever there's a need to set/clear
+* promiscuous mode or rewrite the multicast list.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	nothing
+----------------------------------------------------------------*/
+void p80211knetdev_set_multicast_list(netdevice_t *dev)
+{
+	wlandevice_t	*wlandev = (wlandevice_t*)dev->priv;
+
+	DBFENTER;
+
+	/* TODO:  real multicast support as well */
+  
+	if (wlandev->set_multicast_list)
+		wlandev->set_multicast_list(wlandev, dev);
+	
+	DBFEXIT;
+}
+
+#ifdef SIOCETHTOOL
+
+static int p80211netdev_ethtool(wlandevice_t *wlandev, void __user *useraddr)
+{
+	UINT32 ethcmd;
+	struct ethtool_drvinfo info;
+	struct ethtool_value edata;
+
+	memset(&info, 0, sizeof(info));
+	memset(&edata, 0, sizeof(edata));
+
+	if (copy_from_user(&ethcmd, useraddr, sizeof(ethcmd)))
+		return -EFAULT;
+
+	switch (ethcmd) {
+	case ETHTOOL_GDRVINFO:
+		info.cmd = ethcmd;
+		snprintf(info.driver, sizeof(info.driver), "p80211_%s", 
+			 wlandev->nsdname);
+		snprintf(info.version, sizeof(info.version), "%s", 
+			 WLAN_RELEASE);
+
+		// info.fw_version
+		// info.bus_info
+
+		if (copy_to_user(useraddr, &info, sizeof(info)))
+			return -EFAULT;
+		return 0;
+#ifdef ETHTOOL_GLINK
+	case ETHTOOL_GLINK:
+		edata.cmd = ethcmd;
+
+		if (wlandev->linkstatus && 
+		    (wlandev->macmode != WLAN_MACMODE_NONE)) {
+			edata.data = 1;
+		} else {
+			edata.data = 0;
+		}
+
+		if (copy_to_user(useraddr, &edata, sizeof(edata)))
+                        return -EFAULT;
+		return 0;
+	}
+#endif
+
+	return -EOPNOTSUPP;
+}
+
+#endif
+
+/*----------------------------------------------------------------
+* p80211knetdev_do_ioctl
+*
+* Handle an ioctl call on one of our devices.  Everything Linux
+* ioctl specific is done here.  Then we pass the contents of the
+* ifr->data to the request message handler.
+*
+* Arguments:
+*	dev	Linux kernel netdevice
+*	ifr	Our private ioctl request structure, typed for the
+*		generic struct ifreq so we can use ptr to func
+*		w/o cast.
+*
+* Returns: 
+*	zero on success, a negative errno on failure.  Possible values:
+*		-ENETDOWN Device isn't up.
+*		-EBUSY	cmd already in progress
+*		-ETIME	p80211 cmd timed out (MSD may have its own timers)
+*		-EFAULT memory fault copying msg from user buffer
+*		-ENOMEM unable to allocate kernel msg buffer
+*		-ENOSYS	bad magic, it the cmd really for us?
+*		-EINTR	sleeping on cmd, awakened by signal, cmd cancelled.
+*
+* Call Context:
+*	Process thread (ioctl caller).  TODO: SMP support may require
+*	locks.
+----------------------------------------------------------------*/
+int p80211knetdev_do_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
+{
+	int			result = 0;
+	p80211ioctl_req_t	*req = (p80211ioctl_req_t*)ifr;
+	wlandevice_t		*wlandev = (wlandevice_t*)dev->priv;
+	UINT8			*msgbuf;
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(2, "rx'd ioctl, cmd=%d, len=%d\n", cmd, req->len);
+
+#if WIRELESS_EXT < 13
+	/* Is this a wireless extensions ioctl? */
+	if ((cmd >= SIOCIWFIRST) && (cmd <= SIOCIWLAST)) {
+		if ((result = p80211wext_support_ioctl(dev, ifr, cmd)) 
+		    != (-EOPNOTSUPP)) {
+			goto bail;
+		}
+	}
+#endif
+
+#ifdef SIOCETHTOOL
+	if (cmd == SIOCETHTOOL) {
+		result = p80211netdev_ethtool(wlandev, (void __user *) ifr->ifr_data);
+		goto bail;
+	}
+#endif
+
+	/* Test the magic, assume ifr is good if it's there */
+	if ( req->magic != P80211_IOCTL_MAGIC ) {
+		result = -ENOSYS;
+		goto bail;
+	}
+
+	if ( cmd == P80211_IFTEST ) {
+		result = 0;
+		goto bail;
+	} else if ( cmd != P80211_IFREQ ) {
+		result = -ENOSYS;
+		goto bail;
+	}
+
+	/* Allocate a buf of size req->len */
+	if ((msgbuf = kmalloc( req->len, GFP_KERNEL))) {
+		if ( copy_from_user( msgbuf, (void __user *) req->data, req->len) ) {
+			result = -EFAULT;
+		} else {
+			result = p80211req_dorequest( wlandev, msgbuf);
+		}
+
+		if ( result == 0 ) {
+			if ( copy_to_user( (void __user *) req->data, msgbuf, req->len)) {
+				result = -EFAULT;
+			}
+		}
+		kfree(msgbuf);
+	} else {
+		result = -ENOMEM;
+	}
+bail:
+	DBFEXIT;
+
+	return result; /* If allocate,copyfrom or copyto fails, return errno */
+}
+
+/*----------------------------------------------------------------
+* p80211knetdev_set_mac_address
+*
+* Handles the ioctl for changing the MACAddress of a netdevice
+* 
+* references: linux/netdevice.h and drivers/net/net_init.c
+*
+* NOTE: [MSM] We only prevent address changes when the netdev is
+* up.  We don't control anything based on dot11 state.  If the 
+* address is changed on a STA that's currently associated, you
+* will probably lose the ability to send and receive data frames.
+* Just be aware.  Therefore, this should usually only be done
+* prior to scan/join/auth/assoc.
+*
+* Arguments:
+*	dev	netdevice struct
+*	addr	the new MACAddress (a struct)
+*
+* Returns:
+*	zero on success, a negative errno on failure.  Possible values:
+*		-EBUSY	device is bussy (cmd not possible)
+*		-and errors returned by: p80211req_dorequest(..)
+*
+* by: Collin R. Mulliner <collin@mulliner.org>
+----------------------------------------------------------------*/
+int p80211knetdev_set_mac_address(netdevice_t *dev, void *addr)
+{
+	struct sockaddr			*new_addr = addr;
+	p80211msg_dot11req_mibset_t	dot11req;
+	p80211item_unk392_t		*mibattr;
+	p80211item_pstr6_t		*macaddr;
+	p80211item_uint32_t		*resultcode;
+	int result = 0;
+	
+	DBFENTER;
+	/* If we're running, we don't allow MAC address changes */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,38) )
+	if ( dev->start) {
+		return -EBUSY;
+	}
+#else
+	if (netif_running(dev)) {
+		return -EBUSY;
+	}
+#endif
+
+	/* Set up some convenience pointers. */
+	mibattr = &dot11req.mibattribute;
+	macaddr = (p80211item_pstr6_t*)&mibattr->data;
+	resultcode = &dot11req.resultcode;
+
+	/* Set up a dot11req_mibset */
+	memset(&dot11req, 0, sizeof(p80211msg_dot11req_mibset_t));
+	dot11req.msgcode = DIDmsg_dot11req_mibset;
+	dot11req.msglen = sizeof(p80211msg_dot11req_mibset_t);
+	memcpy(dot11req.devname, 
+		((wlandevice_t*)(dev->priv))->name, 
+		WLAN_DEVNAMELEN_MAX - 1);
+
+	/* Set up the mibattribute argument */
+	mibattr->did = DIDmsg_dot11req_mibset_mibattribute;
+	mibattr->status = P80211ENUM_msgitem_status_data_ok;
+	mibattr->len = sizeof(mibattr->data);
+	
+	macaddr->did = DIDmib_dot11mac_dot11OperationTable_dot11MACAddress;
+	macaddr->status = P80211ENUM_msgitem_status_data_ok;
+	macaddr->len = sizeof(macaddr->data);
+	macaddr->data.len = WLAN_ADDR_LEN;
+	memcpy(&macaddr->data.data, new_addr->sa_data, WLAN_ADDR_LEN);
+
+	/* Set up the resultcode argument */
+	resultcode->did = DIDmsg_dot11req_mibset_resultcode;
+	resultcode->status = P80211ENUM_msgitem_status_no_value;
+	resultcode->len = sizeof(resultcode->data);
+	resultcode->data = 0;
+	
+	/* now fire the request */
+	result = p80211req_dorequest(dev->priv, (UINT8*)&dot11req);
+
+	/* If the request wasn't successful, report an error and don't
+	 * change the netdev address
+	 */
+	if ( result != 0 || resultcode->data != P80211ENUM_resultcode_success) {
+		WLAN_LOG_ERROR(
+		"Low-level driver failed dot11req_mibset(dot11MACAddress).\n");
+		result = -EADDRNOTAVAIL;
+	} else {
+		/* everything's ok, change the addr in netdev */
+		memcpy(dev->dev_addr, new_addr->sa_data, dev->addr_len);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+int wlan_change_mtu(netdevice_t *dev, int new_mtu)
+{
+	DBFENTER;
+	// 2312 is max 802.11 payload, 20 is overhead, (ether + llc +snap)
+	// and another 8 for wep.
+        if ( (new_mtu < 68) || (new_mtu > (2312 - 20 - 8)))
+                return -EINVAL;
+
+        dev->mtu = new_mtu;
+
+	DBFEXIT;
+
+        return 0;
+}
+
+
+
+/*----------------------------------------------------------------
+* wlan_setup
+*
+* Roughly matches the functionality of ether_setup.  Here
+* we set up any members of the wlandevice structure that are common
+* to all devices.  Additionally, we allocate a linux 'struct device'
+* and perform the same setup as ether_setup.
+*
+* Note: It's important that the caller have setup the wlandev->name
+*	ptr prior to calling this function.
+*
+* Arguments:
+*	wlandev		ptr to the wlandev structure for the
+*			interface.
+* Returns: 
+*	zero on success, non-zero otherwise.
+* Call Context:
+*	Should be process thread.  We'll assume it might be
+*	interrupt though.  When we add support for statically
+*	compiled drivers, this function will be called in the 
+*	context of the kernel startup code.
+----------------------------------------------------------------*/
+int wlan_setup(wlandevice_t *wlandev)
+{
+	int		result = 0;
+	netdevice_t	*dev;
+
+	DBFENTER;
+
+	/* Set up the wlandev */
+	wlandev->state = WLAN_DEVICE_CLOSED;
+	wlandev->ethconv = WLAN_ETHCONV_8021h;
+	wlandev->macmode = WLAN_MACMODE_NONE;
+	
+	/* Set up the rx queue */
+	skb_queue_head_init(&wlandev->nsd_rxq);
+	tasklet_init(&wlandev->rx_bh, 
+		     p80211netdev_rx_bh, 
+		     (unsigned long)wlandev);
+
+	/* Allocate and initialize the struct device */
+	dev = kmalloc(sizeof(netdevice_t), GFP_ATOMIC);
+	if ( dev == NULL ) {
+		WLAN_LOG_ERROR("Failed to alloc netdev.\n");
+		result = 1;
+	} else {
+		memset( dev, 0, sizeof(netdevice_t));
+		ether_setup(dev);
+		wlandev->netdev = dev;
+		dev->priv = wlandev;
+		dev->hard_start_xmit =	p80211knetdev_hard_start_xmit;
+		dev->get_stats =	p80211knetdev_get_stats;
+#ifdef HAVE_PRIVATE_IOCTL
+		dev->do_ioctl = 	p80211knetdev_do_ioctl;
+#endif
+#ifdef HAVE_MULTICAST
+		dev->set_multicast_list = p80211knetdev_set_multicast_list;
+#endif
+		dev->init =		p80211knetdev_init;
+		dev->open =		p80211knetdev_open;
+		dev->stop =		p80211knetdev_stop;
+
+#ifdef CONFIG_NET_WIRELESS
+#if ((WIRELESS_EXT < 17) && (WIRELESS_EXT < 21))
+		dev->get_wireless_stats = p80211wext_get_wireless_stats;
+#endif
+#if WIRELESS_EXT > 12
+		dev->wireless_handlers = &p80211wext_handler_def;
+#endif
+#endif
+			
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,3,38) )
+		dev->tbusy = 1;
+		dev->start = 0;
+#else
+		netif_stop_queue(dev);
+#endif
+#ifdef HAVE_CHANGE_MTU		
+		dev->change_mtu = wlan_change_mtu;
+#endif
+#ifdef HAVE_SET_MAC_ADDR
+		dev->set_mac_address =	p80211knetdev_set_mac_address;
+#endif
+#ifdef HAVE_TX_TIMEOUT
+		dev->tx_timeout      =  &p80211knetdev_tx_timeout;
+		dev->watchdog_timeo  =  (wlan_watchdog * HZ) / 1000;
+#endif		
+		netif_carrier_off(dev);
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* wlan_unsetup
+*
+* This function is paired with the wlan_setup routine.  It should
+* be called after unregister_wlandev.  Basically, all it does is
+* free the 'struct device' that's associated with the wlandev.
+* We do it here because the 'struct device' isn't allocated 
+* explicitly in the driver code, it's done in wlan_setup.  To
+* do the free in the driver might seem like 'magic'.
+*
+* Arguments:
+*	wlandev		ptr to the wlandev structure for the
+*			interface.
+* Returns: 
+*	zero on success, non-zero otherwise.
+* Call Context:
+*	Should be process thread.  We'll assume it might be
+*	interrupt though.  When we add support for statically
+*	compiled drivers, this function will be called in the 
+*	context of the kernel startup code.
+----------------------------------------------------------------*/
+int wlan_unsetup(wlandevice_t *wlandev)
+{
+	int		result = 0;
+
+	DBFENTER;
+
+	tasklet_kill(&wlandev->rx_bh);
+
+	if (wlandev->netdev == NULL ) {
+		WLAN_LOG_ERROR("called without wlandev->netdev set.\n");
+		result = 1;
+	} else {
+		free_netdev(wlandev->netdev);
+		wlandev->netdev = NULL;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+
+/*----------------------------------------------------------------
+* register_wlandev
+*
+* Roughly matches the functionality of register_netdev.  This function
+* is called after the driver has successfully probed and set up the
+* resources for the device.  It's now ready to become a named device
+* in the Linux system.
+*
+* First we allocate a name for the device (if not already set), then
+* we call the Linux function register_netdevice.
+*
+* Arguments:
+*	wlandev		ptr to the wlandev structure for the
+*			interface.
+* Returns: 
+*	zero on success, non-zero otherwise.
+* Call Context:
+*	Can be either interrupt or not.
+----------------------------------------------------------------*/
+int register_wlandev(wlandevice_t *wlandev)
+{
+	int		i = 0;
+	netdevice_t	*dev = wlandev->netdev;
+
+	DBFENTER;
+
+	i = dev_alloc_name(wlandev->netdev, "wlan%d");
+	if (i >= 0) {
+		i = register_netdev(wlandev->netdev);
+	} 
+	if (i != 0) {
+		return -EIO;
+	}
+
+#if ( LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0) )
+	dev->name = wlandev->name;
+#else
+	strcpy(wlandev->name, dev->name);
+#endif
+
+#ifdef CONFIG_PROC_FS
+	if (proc_p80211) {
+		wlandev->procdir = proc_mkdir(wlandev->name, proc_p80211);
+		if ( wlandev->procdir )
+			wlandev->procwlandev = 
+				create_proc_read_entry("wlandev", 0,
+						       wlandev->procdir,
+						       p80211netdev_proc_read,
+						       wlandev);
+		if (wlandev->nsd_proc_read)
+			create_proc_read_entry("nsd", 0,
+					       wlandev->procdir,
+					       wlandev->nsd_proc_read,
+					       wlandev);
+	}
+#endif
+
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(wlandev, WLAN_HOTPLUG_REGISTER);
+#endif
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* unregister_wlandev
+*
+* Roughly matches the functionality of unregister_netdev.  This
+* function is called to remove a named device from the system.
+*
+* First we tell linux that the device should no longer exist.
+* Then we remove it from the list of known wlan devices.
+*
+* Arguments:
+*	wlandev		ptr to the wlandev structure for the
+*			interface.
+* Returns: 
+*	zero on success, non-zero otherwise.
+* Call Context:
+*	Can be either interrupt or not.
+----------------------------------------------------------------*/
+int unregister_wlandev(wlandevice_t *wlandev)
+{
+	struct sk_buff *skb;
+
+	DBFENTER;
+
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(wlandev, WLAN_HOTPLUG_REMOVE);
+#endif
+
+#ifdef CONFIG_PROC_FS
+	if ( wlandev->procwlandev ) {
+		remove_proc_entry("wlandev", wlandev->procdir);
+	}
+	if ( wlandev->nsd_proc_read ) {
+		remove_proc_entry("nsd", wlandev->procdir);
+	}
+	if (wlandev->procdir) {
+		remove_proc_entry(wlandev->name, proc_p80211);
+	}
+#endif
+
+	unregister_netdev(wlandev->netdev);
+
+	/* Now to clean out the rx queue */
+	while ( (skb = skb_dequeue(&wlandev->nsd_rxq)) ) {
+		dev_kfree_skb(skb);
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+/*----------------------------------------------------------------
+* proc_read
+*
+* Read function for /proc/net/p80211/<device>/wlandev
+*
+* Arguments:
+*	buf
+*	start 
+*	offset 
+*	count
+*	eof
+*	data
+* Returns: 
+*	zero on success, non-zero otherwise.
+* Call Context:
+*	Can be either interrupt or not.
+----------------------------------------------------------------*/
+static int
+p80211netdev_proc_read(
+	char	*page, 
+	char	**start, 
+	off_t	offset, 
+	int	count,
+	int	*eof,
+	void	*data)
+{
+	char	 *p = page;
+	wlandevice_t *wlandev = (wlandevice_t *) data;
+
+	DBFENTER;
+	if (offset != 0) {
+		*eof = 1;
+		goto exit;
+	} 
+
+	p += sprintf(p, "p80211 version: %s (%s)\n\n", 
+		     WLAN_RELEASE, WLAN_BUILD_DATE);
+	p += sprintf(p, "name       : %s\n", wlandev->name);
+	p += sprintf(p, "nsd name   : %s\n", wlandev->nsdname);
+	p += sprintf(p, "address    : %02x:%02x:%02x:%02x:%02x:%02x\n",
+		     wlandev->netdev->dev_addr[0], wlandev->netdev->dev_addr[1], wlandev->netdev->dev_addr[2],
+		     wlandev->netdev->dev_addr[3], wlandev->netdev->dev_addr[4], wlandev->netdev->dev_addr[5]);
+	p += sprintf(p, "nsd caps   : %s%s%s%s%s%s%s%s%s%s\n",  
+		     (wlandev->nsdcaps & P80211_NSDCAP_HARDWAREWEP) ? "wep_hw " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_TIEDWEP) ? "wep_tied " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_NOHOSTWEP) ? "wep_hw_only " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_PBCC) ? "pbcc " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_SHORT_PREAMBLE) ? "short_preamble " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_AGILITY) ? "agility " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_AP_RETRANSMIT) ? "ap_retransmit " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_HWFRAGMENT) ? "hw_frag " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_AUTOJOIN) ? "autojoin " : "",
+		     (wlandev->nsdcaps & P80211_NSDCAP_NOSCAN) ? "" : "scan ");
+
+
+	p += sprintf(p, "bssid      : %02x:%02x:%02x:%02x:%02x:%02x\n",
+		     wlandev->bssid[0], wlandev->bssid[1], wlandev->bssid[2],
+		     wlandev->bssid[3], wlandev->bssid[4], wlandev->bssid[5]);
+
+	p += sprintf(p, "Enabled    : %s%s\n", 
+		     (wlandev->shortpreamble) ? "short_preamble " : "",
+		     (wlandev->hostwep & HOSTWEP_PRIVACYINVOKED) ? "privacy" : "");
+
+
+ exit:
+	DBFEXIT;
+	return (p - page);
+}
+#endif
+
+/*----------------------------------------------------------------
+* p80211netdev_hwremoved
+*
+* Hardware removed notification. This function should be called
+* immediately after an MSD has detected that the underlying hardware
+* has been yanked out from under us.  The primary things we need
+* to do are:
+*   - Mark the wlandev
+*   - Prevent any further traffic from the knetdev i/f
+*   - Prevent any further requests from mgmt i/f
+*   - If there are any waitq'd mgmt requests or mgmt-frame exchanges,
+*     shut them down.
+*   - Call the MSD hwremoved function.
+*
+* The remainder of the cleanup will be handled by unregister().
+* Our primary goal here is to prevent as much tickling of the MSD
+* as possible since the MSD is already in a 'wounded' state.
+*
+* TODO: As new features are added, this function should be 
+*       updated.
+*
+* Arguments:
+*	wlandev		WLAN network device structure
+* Returns: 
+*	nothing
+* Side effects:
+*
+* Call context:
+*	Usually interrupt.
+----------------------------------------------------------------*/
+void p80211netdev_hwremoved(wlandevice_t *wlandev)
+{
+	DBFENTER;
+	wlandev->hwremoved = 1;
+	if ( wlandev->state == WLAN_DEVICE_OPEN) {
+		p80211netdev_stop_queue(wlandev);
+	}
+
+	netif_device_detach(wlandev->netdev);
+
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* p80211_rx_typedrop
+*
+* Classifies the frame, increments the appropriate counter, and
+* returns 0|1|2 indicating whether the driver should handle, ignore, or
+* drop the frame
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	fc		frame control field
+*
+* Returns: 
+*	zero if the frame should be handled by the driver,
+*       one if the frame should be ignored
+*       anything else means we drop it.
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+int p80211_rx_typedrop( wlandevice_t *wlandev, UINT16 fc)
+{
+	UINT16	ftype;
+	UINT16	fstype;
+	int	drop = 0;
+	/* Classify frame, increment counter */
+	ftype = WLAN_GET_FC_FTYPE(fc);
+	fstype = WLAN_GET_FC_FSTYPE(fc);
+#if 0
+	WLAN_LOG_DEBUG(4, 
+		"rx_typedrop : ftype=%d fstype=%d.\n", ftype, fstype);
+#endif
+	switch ( ftype ) {
+	case WLAN_FTYPE_MGMT:
+		if ((wlandev->netdev->flags & IFF_PROMISC) ||
+			(wlandev->netdev->flags & IFF_ALLMULTI)) {
+			drop = 1;
+			break;
+		}
+		WLAN_LOG_DEBUG(3, "rx'd mgmt:\n");
+		wlandev->rx.mgmt++;
+		switch( fstype ) {
+		case WLAN_FSTYPE_ASSOCREQ:
+			/* printk("assocreq"); */
+			wlandev->rx.assocreq++;
+			break;
+		case WLAN_FSTYPE_ASSOCRESP:
+			/* printk("assocresp"); */
+			wlandev->rx.assocresp++;
+			break;
+		case WLAN_FSTYPE_REASSOCREQ:
+			/* printk("reassocreq"); */
+			wlandev->rx.reassocreq++;
+			break;
+		case WLAN_FSTYPE_REASSOCRESP:
+			/* printk("reassocresp"); */
+			wlandev->rx.reassocresp++;
+			break;
+		case WLAN_FSTYPE_PROBEREQ:
+			/* printk("probereq"); */
+			wlandev->rx.probereq++;
+			break;
+		case WLAN_FSTYPE_PROBERESP:
+			/* printk("proberesp"); */
+			wlandev->rx.proberesp++;
+			break;
+		case WLAN_FSTYPE_BEACON:
+			/* printk("beacon"); */
+			wlandev->rx.beacon++;
+			break;
+		case WLAN_FSTYPE_ATIM:
+			/* printk("atim"); */
+			wlandev->rx.atim++;
+			break;
+		case WLAN_FSTYPE_DISASSOC:
+			/* printk("disassoc"); */
+			wlandev->rx.disassoc++;
+			break;
+		case WLAN_FSTYPE_AUTHEN:
+			/* printk("authen"); */
+			wlandev->rx.authen++;
+			break;
+		case WLAN_FSTYPE_DEAUTHEN:
+			/* printk("deauthen"); */
+			wlandev->rx.deauthen++;
+			break;
+		default:
+			/* printk("unknown"); */
+			wlandev->rx.mgmt_unknown++;
+			break;
+		}
+		/* printk("\n"); */
+		drop = 2;
+		break;
+
+	case WLAN_FTYPE_CTL:
+		if ((wlandev->netdev->flags & IFF_PROMISC) ||
+			(wlandev->netdev->flags & IFF_ALLMULTI)) {
+			drop = 1;
+			break;
+		}
+		WLAN_LOG_DEBUG(3, "rx'd ctl:\n");
+		wlandev->rx.ctl++;
+		switch( fstype ) {
+		case WLAN_FSTYPE_PSPOLL:
+			/* printk("pspoll"); */
+			wlandev->rx.pspoll++;
+			break;
+		case WLAN_FSTYPE_RTS:
+			/* printk("rts"); */
+			wlandev->rx.rts++;
+			break;
+		case WLAN_FSTYPE_CTS:
+			/* printk("cts"); */
+			wlandev->rx.cts++;
+			break;
+		case WLAN_FSTYPE_ACK:
+			/* printk("ack"); */
+			wlandev->rx.ack++;
+			break;
+		case WLAN_FSTYPE_CFEND:
+			/* printk("cfend"); */
+			wlandev->rx.cfend++;
+			break;
+		case WLAN_FSTYPE_CFENDCFACK:
+			/* printk("cfendcfack"); */
+			wlandev->rx.cfendcfack++;
+			break;
+		default:
+			/* printk("unknown"); */
+			wlandev->rx.ctl_unknown++;
+			break;
+		}
+		/* printk("\n"); */
+		drop = 2;
+		break;
+
+	case WLAN_FTYPE_DATA:
+		wlandev->rx.data++;
+		switch( fstype ) {
+		case WLAN_FSTYPE_DATAONLY:
+			wlandev->rx.dataonly++;
+			break;
+		case WLAN_FSTYPE_DATA_CFACK:
+			wlandev->rx.data_cfack++;
+			break;
+		case WLAN_FSTYPE_DATA_CFPOLL:
+			wlandev->rx.data_cfpoll++;
+			break;
+		case WLAN_FSTYPE_DATA_CFACK_CFPOLL:
+			wlandev->rx.data__cfack_cfpoll++;
+			break;
+		case WLAN_FSTYPE_NULL:
+			WLAN_LOG_DEBUG(3, "rx'd data:null\n");
+			wlandev->rx.null++;
+			break;
+		case WLAN_FSTYPE_CFACK:
+			WLAN_LOG_DEBUG(3, "rx'd data:cfack\n");
+			wlandev->rx.cfack++;
+			break;
+		case WLAN_FSTYPE_CFPOLL:
+			WLAN_LOG_DEBUG(3, "rx'd data:cfpoll\n");
+			wlandev->rx.cfpoll++;
+			break;
+		case WLAN_FSTYPE_CFACK_CFPOLL:
+			WLAN_LOG_DEBUG(3, "rx'd data:cfack_cfpoll\n");
+			wlandev->rx.cfack_cfpoll++;
+			break;
+		default:
+			/* printk("unknown"); */
+			wlandev->rx.data_unknown++;
+			break;
+		}
+
+		break;
+	}
+	return drop;
+}
+
+#ifdef CONFIG_HOTPLUG
+/* Notify userspace when a netdevice event occurs,
+ * by running '/sbin/hotplug net' with certain
+ * environment variables set.
+ */
+int p80211_run_sbin_hotplug(wlandevice_t *wlandev, char *action)
+{
+        char *argv[3], *envp[7], ifname[12 + IFNAMSIZ], action_str[32];
+	char nsdname[32], wlan_wext[32];
+        int i;
+
+	if (wlandev) {
+		sprintf(ifname, "INTERFACE=%s", wlandev->name);
+		sprintf(nsdname, "NSDNAME=%s", wlandev->nsdname);
+	} else {
+		sprintf(ifname, "INTERFACE=null");
+		sprintf(nsdname, "NSDNAME=null");
+	}
+
+	sprintf(wlan_wext, "WLAN_WEXT=%s", wlan_wext_write ? "y" : "");
+        sprintf(action_str, "ACTION=%s", action);
+
+        i = 0;
+        argv[i++] = hotplug_path;
+        argv[i++] = "wlan";
+        argv[i] = NULL;
+
+        i = 0;
+        /* minimal command environment */
+        envp [i++] = "HOME=/";
+        envp [i++] = "PATH=/sbin:/bin:/usr/sbin:/usr/bin";
+        envp [i++] = ifname;
+        envp [i++] = action_str;
+        envp [i++] = nsdname;
+        envp [i++] = wlan_wext;
+        envp [i] = NULL;
+        
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,62)) 
+        return call_usermodehelper(argv [0], argv, envp);
+#else
+        return call_usermodehelper(argv [0], argv, envp, 0);
+#endif
+}
+
+#endif
+
+
+void    p80211_suspend(wlandevice_t *wlandev)
+{
+	DBFENTER;
+      
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(wlandev, WLAN_HOTPLUG_SUSPEND);
+#endif
+ 
+	DBFEXIT;
+}
+ 
+void    p80211_resume(wlandevice_t *wlandev)
+{
+	DBFENTER;
+
+#ifdef CONFIG_HOTPLUG
+	p80211_run_sbin_hotplug(wlandev, WLAN_HOTPLUG_RESUME);
+#endif
+
+	DBFEXIT;
+}
+
+void p80211knetdev_tx_timeout( netdevice_t *netdev) 
+{
+	wlandevice_t	*wlandev = (wlandevice_t*)netdev->priv;
+	DBFENTER;
+
+	if (wlandev->tx_timeout) {
+		wlandev->tx_timeout(wlandev);
+	} else {
+		WLAN_LOG_WARNING("Implement tx_timeout for %s\n",
+				 wlandev->nsdname);
+		p80211netdev_wake_queue(wlandev);
+	}
+
+	DBFEXIT;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211req.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211req.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211req.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211req.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,325 @@
+/* src/p80211/p80211req.c
+*
+* Request/Indication/MacMgmt interface handling functions
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file contains the functions, types, and macros to support the
+* MLME request interface that's implemented via the device ioctls.
+* 
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <net/sock.h>
+#include <linux/netlink.h>
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211ioctl.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+
+/*================================================================*/
+/* Local Constants */
+
+/* Maximum amount of time we'll wait for a request to complete */
+#define P80211REQ_MAXTIME	3*HZ	/* 3 seconds */
+
+/*================================================================*/
+/* Local Macros */
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+
+/*================================================================*/
+/* Local Function Declarations */
+
+static void p80211req_handlemsg( wlandevice_t *wlandev, p80211msg_t *msg);
+static int p80211req_mibset_mibget(wlandevice_t *wlandev, p80211msg_dot11req_mibget_t *mib_msg, int isget);
+
+/*================================================================*/
+/* Function Definitions */
+
+
+/*----------------------------------------------------------------
+* p80211req_dorequest
+*
+* Handles an MLME reqest/confirm message.
+* 
+* Arguments:
+*	wlandev		WLAN device struct
+*	msgbuf		Buffer containing a request message
+*
+* Returns: 
+*	0 on success, an errno otherwise
+*	
+* Call context:
+*	Potentially blocks the caller, so it's a good idea to 
+*	not call this function from an interrupt context.
+----------------------------------------------------------------*/
+int p80211req_dorequest( wlandevice_t *wlandev, UINT8 *msgbuf)
+{
+	int		result = 0;
+	p80211msg_t	*msg = (p80211msg_t*)msgbuf;
+
+	DBFENTER;
+
+	/* Check to make sure the MSD is running */
+	if ( 
+	!((wlandev->msdstate == WLAN_MSD_HWPRESENT &&
+	msg->msgcode == DIDmsg_lnxreq_ifstate) ||
+	wlandev->msdstate == WLAN_MSD_RUNNING || 
+	wlandev->msdstate == WLAN_MSD_FWLOAD) ) {
+		return -ENODEV;
+	}
+
+	/* Check Permissions */
+	if (!capable(CAP_NET_ADMIN) && 
+	    (msg->msgcode != DIDmsg_dot11req_mibget)) {
+		WLAN_LOG_ERROR("%s: only dot11req_mibget allowed for non-root.\n", wlandev->name);
+		return -EPERM;
+	}
+
+	/* Check for busy status */
+	if ( test_and_set_bit(1, &(wlandev->request_pending))) {
+		return -EBUSY;
+	}
+
+	/* Allow p80211 to look at msg and handle if desired. */
+	/* So far, all p80211 msgs are immediate, no waitq/timer necessary */
+	/* This may change. */
+	p80211req_handlemsg(wlandev, msg);
+
+	/* Pass it down to wlandev via wlandev->mlmerequest */
+	if ( wlandev->mlmerequest != NULL ) 
+		wlandev->mlmerequest(wlandev, msg);
+
+	clear_bit( 1, &(wlandev->request_pending));
+	DBFEXIT;
+	return result;	/* if result==0, msg->status still may contain an err */
+}
+
+/*----------------------------------------------------------------
+* p80211req_handlemsg
+*
+* p80211 message handler.  Primarily looks for messages that
+* belong to p80211 and then dispatches the appropriate response.
+* TODO: we don't do anything yet.  Once the linuxMIB is better
+*	defined we'll need a get/set handler.  
+* 
+* Arguments:
+*	wlandev		WLAN device struct
+*	msg		message structure
+*
+* Returns: 
+*	nothing (any results are set in the status field of the msg)
+*	
+* Call context:
+*	Process thread
+----------------------------------------------------------------*/
+void p80211req_handlemsg( wlandevice_t *wlandev, p80211msg_t *msg)
+{
+        DBFENTER;
+        
+	switch (msg->msgcode) {
+
+	case DIDmsg_lnxreq_hostwep: {
+		p80211msg_lnxreq_hostwep_t *req = (p80211msg_lnxreq_hostwep_t*) msg;
+		wlandev->hostwep &= ~(HOSTWEP_DECRYPT|HOSTWEP_ENCRYPT);
+		if (req->decrypt.data == P80211ENUM_truth_true)
+			wlandev->hostwep |= HOSTWEP_DECRYPT;
+		if (req->encrypt.data == P80211ENUM_truth_true)
+			wlandev->hostwep |= HOSTWEP_ENCRYPT;
+
+		break;
+	}
+	case DIDmsg_dot11req_mibget:
+	case DIDmsg_dot11req_mibset: {
+		int isget = (msg->msgcode == DIDmsg_dot11req_mibget);
+		p80211msg_dot11req_mibget_t  *mib_msg = (p80211msg_dot11req_mibget_t *) msg;
+		p80211req_mibset_mibget (wlandev, mib_msg, isget);
+	}
+	default:
+		// XXX do nothing!
+		;
+	} /* switch msg->msgcode */
+
+	DBFEXIT;
+
+	return;
+}
+
+int p80211req_mibset_mibget(wlandevice_t *wlandev, p80211msg_dot11req_mibget_t *mib_msg, int isget)
+{
+	p80211itemd_t   *mibitem = (p80211itemd_t *) mib_msg->mibattribute.data;
+	p80211pstrd_t  *pstr = (p80211pstrd_t*) mibitem->data;
+	UINT8 *key = mibitem->data + sizeof(p80211pstrd_t);
+
+	DBFENTER;
+
+	switch (mibitem->did) {
+	case DIDmib_dot11smt_p80211Table_p80211_ifstate: {
+		UINT32 *data = (UINT32 *) mibitem->data;
+		if (isget)
+			switch (wlandev->msdstate) {
+			case WLAN_MSD_HWPRESENT:
+				*data = P80211ENUM_ifstate_disable;
+				break;
+			case WLAN_MSD_FWLOAD:
+				*data = P80211ENUM_ifstate_fwload;
+				break;
+			case WLAN_MSD_RUNNING:
+				*data = P80211ENUM_ifstate_enable;
+				break;
+			default:
+				*data = P80211ENUM_ifstate_enable;
+			}
+		break;
+	}		
+	case DIDmib_dot11phy_dot11PhyOperationTable_dot11ShortPreambleEnabled: {
+		UINT32 *data = (UINT32 *) mibitem->data;
+
+		if (isget)
+			*data = wlandev->shortpreamble;
+		else
+			wlandev->shortpreamble = *data;
+		break;	
+	}
+	case DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0: {
+		if (!isget)
+			wep_change_key(wlandev, 0, key, pstr->len);
+		break;
+	}
+	case DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1: {
+		if (!isget)
+			wep_change_key(wlandev, 1, key, pstr->len);
+		break;
+	}
+	case DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2: {
+		if (!isget)
+			wep_change_key(wlandev, 2, key, pstr->len);
+		break;
+	}
+	case DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3: {
+		if (!isget)
+			wep_change_key(wlandev, 3, key, pstr->len);
+		break;
+	}
+	case DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID: {
+		UINT32 *data = (UINT32 *) mibitem->data;
+		
+		if (isget) {
+			*data = wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK;
+			} else {
+				wlandev->hostwep &= ~(HOSTWEP_DEFAULTKEY_MASK);
+				
+				wlandev->hostwep |= (*data & HOSTWEP_DEFAULTKEY_MASK);
+			}
+		break;
+	}
+	case DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked: {
+		UINT32 *data = (UINT32 *) mibitem->data;
+		
+		if (isget) {
+			if (wlandev->hostwep & HOSTWEP_PRIVACYINVOKED)
+				*data = P80211ENUM_truth_true;
+			else
+				*data = P80211ENUM_truth_false;
+		} else {
+				wlandev->hostwep &= ~(HOSTWEP_PRIVACYINVOKED);
+				if (*data == P80211ENUM_truth_true)
+					wlandev->hostwep |= HOSTWEP_PRIVACYINVOKED;
+		}
+		break;
+	}
+	case DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted: {
+		UINT32 *data = (UINT32 *) mibitem->data;
+
+		if (isget) {
+			if (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED)
+				*data = P80211ENUM_truth_true;
+			else
+				*data = P80211ENUM_truth_false;
+		} else {			
+			wlandev->hostwep &= ~(HOSTWEP_EXCLUDEUNENCRYPTED);
+			if (*data == P80211ENUM_truth_true)
+				wlandev->hostwep |= HOSTWEP_EXCLUDEUNENCRYPTED;
+		}
+		break;
+	}
+	default:
+		// XXXX do nothing!
+		;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211wep.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211wep.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211wep.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211wep.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,316 @@
+/* src/p80211/p80211wep.c
+*
+* WEP encode/decode for P80211.
+*
+* Copyright (C) 2002 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+
+#include <linux/version.h>
+
+#include <linux/netdevice.h>
+#include <linux/wireless.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+
+// #define WEP_DEBUG
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/version.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211types.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211netdev.h>
+
+/*================================================================*/
+/* Local Constants */
+
+#define SSWAP(a,b) {UINT8 tmp = s[a]; s[a] = s[b]; s[b] = tmp;}
+#define WEP_KEY(x)       (((x) & 0xC0) >> 6)
+
+/*================================================================*/
+/* Local Macros */
+
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+static const UINT32 wep_crc32_table[256] = {
+        0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+        0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+        0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+        0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+        0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+        0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+        0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+        0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+        0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+        0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+        0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+        0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+        0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+        0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+        0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+        0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+        0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+        0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+        0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+        0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+        0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+        0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+        0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+        0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+        0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+        0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+        0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+        0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+        0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+        0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+        0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+        0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+        0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+        0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+        0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+        0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+        0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+        0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+        0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+        0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+        0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+        0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+        0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+        0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+        0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+        0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+        0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+        0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+        0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+        0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+        0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+        0x2d02ef8dL
+};
+
+/*================================================================*/
+/* Local Function Declarations */
+
+/*================================================================*/
+/* Function Definitions */
+
+/* keylen in bytes! */
+
+int wep_change_key(wlandevice_t *wlandev, int keynum, UINT8* key, int keylen)
+{
+	if (keylen < 0)  return -1;
+	if (keylen >= MAX_KEYLEN) return -1;
+	if (key == NULL) return -1;
+	if (keynum < 0)  return -1;
+	if (keynum >= NUM_WEPKEYS) return -1;
+
+
+#ifdef WEP_DEBUG
+	printk(KERN_DEBUG "WEP key %d len %d = %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", keynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7]);
+#endif
+
+	wlandev->wep_keylens[keynum] = keylen;
+	memcpy(wlandev->wep_keys[keynum], key, keylen);
+
+	return 0;
+}
+
+/*
+  4-byte IV at start of buffer, 4-byte ICV at end of buffer.
+  if successful, buf start is payload begin, length -= 8;
+ */
+int wep_decrypt(wlandevice_t *wlandev, UINT8 *buf, UINT32 len, int key_override, UINT8 *iv, UINT8 *icv)
+{
+	UINT32 i, j, k, crc, keylen;
+	UINT8 s[256], key[64], c_crc[4];
+	UINT8 keyidx;
+	
+	/* Needs to be at least 8 bytes of payload */
+	if (len <= 0) return -1;
+	
+	/* initialize the first bytes of the key from the IV */
+	key[0] = iv[0];
+	key[1] = iv[1];
+	key[2] = iv[2];
+	keyidx = WEP_KEY(iv[3]);
+
+	if (key_override >= 0)
+		keyidx = key_override;
+	
+	if (keyidx >= NUM_WEPKEYS) return -2;
+	
+	keylen = wlandev->wep_keylens[keyidx];
+	
+	if (keylen == 0) return -3;
+
+	/* copy the rest of the key over from the designated key */
+	memcpy(key+3, wlandev->wep_keys[keyidx], keylen);
+
+	keylen+=3;  /* add in IV bytes */
+
+#ifdef WEP_DEBUG
+	printk(KERN_DEBUG "D %d: %02x %02x %02x (%d %d) %02x:%02x:%02x:%02x:%02x\n", len, key[0], key[1], key[2], keyidx, keylen, key[3], key[4], key[5], key[6], key[7]);
+#endif
+
+	/* set up the RC4 state */
+	for (i = 0; i < 256; i++)
+		s[i] = i;
+	j = 0;
+	for (i = 0; i < 256; i++) {
+		j = (j + s[i] + key[i % keylen]) & 0xff;
+		SSWAP(i,j);
+	}
+
+	/* Apply the RC4 to the data, update the CRC32 */
+	crc = ~0;
+	i = j = 0;
+	for (k = 0; k < len; k++) {
+		i = (i+1) & 0xff;
+		j = (j+s[i]) & 0xff;
+		SSWAP(i,j);
+		buf[k] ^= s[(s[i] + s[j]) & 0xff];
+		crc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);
+	}
+	crc = ~crc;
+	
+	/* now let's check the crc */
+	c_crc[0] = crc;
+	c_crc[1] = crc >> 8;
+	c_crc[2] = crc >> 16;
+	c_crc[3] = crc >> 24;
+
+	for (k = 0; k < 4; k++) {
+		i = (i + 1) & 0xff;
+		j = (j+s[i]) & 0xff;
+		SSWAP(i,j);
+		if ((c_crc[k] ^ s[(s[i] + s[j]) & 0xff]) != icv[k])
+			return -(4 | (k << 4)) ; /* ICV mismatch */
+	}
+
+	return 0;
+}
+
+/* encrypts in-place. */
+int wep_encrypt(wlandevice_t *wlandev, UINT8 *buf, UINT8 *dst, UINT32 len, int keynum, UINT8 *iv, UINT8 *icv)
+{
+	UINT32 i, j, k, crc, keylen;
+	UINT8 s[256], key[64];
+
+	/* no point in WEPping an empty frame */
+	if (len <= 0) return -1;
+
+	/* we need to have a real key.. */
+	if (keynum >= NUM_WEPKEYS) return -2;
+	keylen = wlandev->wep_keylens[keynum];
+	if (keylen <= 0) return -3;
+
+	/* use a random IV.  And skip known weak ones. */
+	get_random_bytes(iv, 3);
+	while ((iv[1] == 0xff) && (iv[0] >= 3) && (iv[0] < keylen))
+		get_random_bytes(iv, 3);
+
+	iv[3] = (keynum & 0x03) << 6;  
+
+	key[0] = iv[0];
+	key[1] = iv[1];
+	key[2] = iv[2];
+
+	/* copy the rest of the key over from the designated key */
+	memcpy(key+3, wlandev->wep_keys[keynum], keylen);
+
+	keylen+=3;  /* add in IV bytes */
+
+#ifdef WEP_DEBUG
+	printk(KERN_DEBUG "E %d (%d/%d %d) %02x %02x %02x %02x:%02x:%02x:%02x:%02x\n", len,  iv[3], keynum, keylen, key[0], key[1], key[2], key[3], key[4], key[5], key[6], key[7]);
+#endif
+
+	/* set up the RC4 state */
+	for (i = 0; i < 256; i++)
+		s[i] = i;
+	j = 0;
+	for (i = 0; i < 256; i++) {
+		j = (j + s[i] + key[i % keylen]) & 0xff;
+		SSWAP(i,j);
+	}
+
+	/* Update CRC32 then apply RC4 to the data */
+	crc = ~0;
+	i = j = 0;
+	for (k = 0; k < len; k++) {
+		crc = wep_crc32_table[(crc ^ buf[k]) & 0xff] ^ (crc >> 8);
+		i = (i+1) & 0xff;
+		j = (j+s[i]) & 0xff;
+		SSWAP(i,j);
+		dst[k] = buf[k] ^ s[(s[i] + s[j]) & 0xff];
+	}
+	crc = ~crc;
+
+	/* now let's encrypt the crc */
+	icv[0] = crc;
+	icv[1] = crc >> 8;
+	icv[2] = crc >> 16;
+	icv[3] = crc >> 24;
+
+	for (k = 0; k < 4; k++) {
+		i = (i + 1) & 0xff;
+		j = (j+s[i]) & 0xff;
+		SSWAP(i,j);
+		icv[k] ^= s[(s[i] + s[j]) & 0xff];
+	}
+
+	return 0;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211wext.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211wext.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/p80211/p80211wext.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/p80211/p80211wext.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,1786 @@
+/* src/p80211/p80211wext.c
+* 
+* Glue code to make linux-wlan-ng a happy wireless extension camper.
+* 
+* original author:  Reyk Floeter <reyk@synack.de>
+* Completely re-written by Solomon Peachy <solomon@linux-wlan.com>
+*
+* Copyright (C) 2002 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+
+#include <linux/version.h>
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/wireless.h>
+#if WIRELESS_EXT > 12
+#include <net/iw_handler.h>
+#endif
+#include <linux/if_arp.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/byteorder.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/version.h>
+#include <wlan/wlan_compat.h>
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211metastruct.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211ioctl.h>
+#include <wlan/p80211req.h>
+
+static int p80211wext_giwrate(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_param *rrq, char *extra);
+static int p80211wext_giwessid(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_point *data, char *essid);
+/* compatibility to wireless extensions */
+#ifdef WIRELESS_EXT
+
+UINT8 p80211_mhz_to_channel(UINT16 mhz)
+{
+	if (mhz >= 5000) {
+		return ((mhz - 5000) / 5);
+	} 
+
+	if (mhz == 2482)
+		return 14;
+	
+	if (mhz >= 2407) {
+		return ((mhz - 2407) / 5);
+	}
+
+	return 0;
+}
+
+UINT16 p80211_channel_to_mhz(UINT8 ch, int dot11a)
+{
+
+	if (ch == 0)
+		return 0;
+	if (ch > 200)
+		return 0;
+
+	/* 5G */
+
+	if (dot11a) {
+		return (5000 + (5 * ch));
+	}
+	
+	/* 2.4G */
+
+	if (ch == 14)
+		return 2484;
+	
+	if ((ch < 14) && (ch > 0)) {
+		return (2407 + (5 * ch));
+	}
+	
+	return 0;
+}
+
+/* taken from orinoco.c ;-) */
+const long p80211wext_channel_freq[] = {
+	2412, 2417, 2422, 2427, 2432, 2437, 2442,
+	2447, 2452, 2457, 2462, 2467, 2472, 2484
+};
+#define NUM_CHANNELS (sizeof(p80211wext_channel_freq) / sizeof(p80211wext_channel_freq[0])) 
+
+/** function declarations =============== */
+
+static int p80211wext_dorequest(wlandevice_t *wlandev, UINT32 did, UINT32 data)
+{
+	p80211msg_dot11req_mibset_t	msg;
+	p80211item_uint32_t		mibitem;
+	int	result;
+	
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did = did;
+	mibitem.data = data;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	DBFEXIT;
+	return result;
+}
+
+static int p80211wext_autojoin(wlandevice_t *wlandev)
+{
+	p80211msg_lnxreq_autojoin_t     msg;
+	struct iw_point			data;
+	char ssid[IW_ESSID_MAX_SIZE];
+        
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	/* Get ESSID */
+	result = p80211wext_giwessid(wlandev->netdev, NULL, &data, ssid);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+//#warning "make a smarter sharedkey/opensystem auth decision"
+	/* Get WEPDef */
+	if (wlandev->hostwep & HOSTWEP_PRIVACYINVOKED ||
+	    wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED) {
+		msg.authtype.data = P80211ENUM_authalg_sharedkey;
+	}
+	else {
+		msg.authtype.data = P80211ENUM_authalg_opensystem;
+	}
+
+	msg.msgcode = DIDmsg_lnxreq_autojoin;		
+
+	/* Trim the last '\0' to fit the SSID format */
+
+	if (ssid[data.length-1] == '\0') {
+		data.length = data.length - 1;
+	}
+	
+	memcpy(msg.ssid.data.data, ssid, data.length);
+	msg.ssid.data.len = data.length;
+
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+exit:
+
+	DBFEXIT;
+	return err;	
+
+}
+
+/* called by /proc/net/wireless */
+struct iw_statistics* p80211wext_get_wireless_stats (netdevice_t *dev) 
+{
+	p80211msg_lnxreq_commsquality_t  quality;
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	struct iw_statistics* wstats = &wlandev->wstats;
+	int retval;
+	
+	DBFENTER;
+	
+	/* Check */
+	if ( (wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING) )
+		return NULL;
+
+	/* XXX Only valid in station mode */
+	wstats->status = 0;
+
+	/* build request message */
+	quality.msgcode = DIDmsg_lnxreq_commsquality;
+	quality.dbm.data = P80211ENUM_truth_true;
+	quality.dbm.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* send message to nsd */
+	if ( wlandev->mlmerequest == NULL )
+		return NULL;
+
+	retval = wlandev->mlmerequest(wlandev, (p80211msg_t*) &quality);
+
+	wstats->qual.qual = quality.link.data;    /* overall link quality */
+	wstats->qual.level = quality.level.data;  /* instant signal level */
+	wstats->qual.noise = quality.noise.data;  /* instant noise level */
+
+	wstats->qual.updated = 7;
+	wstats->discard.code = wlandev->rx.decrypt_err;
+	wstats->discard.nwid = 0;
+	wstats->discard.misc = 0;
+
+#if WIRELESS_EXT > 11	
+	wstats->discard.fragment = 0;  // incomplete fragments
+	wstats->discard.retries = 0;   // tx retries.
+	wstats->miss.beacon = 0;
+#endif
+
+	DBFEXIT;
+	
+	return wstats;
+}
+
+static int p80211wext_giwname(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      char *name, char *extra)
+{
+	struct iw_param rate;
+	int result;
+	int err = 0;
+	
+	DBFENTER;
+
+	result = p80211wext_giwrate(dev, NULL, &rate, NULL);
+ 
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+	
+	switch (rate.value) {
+	case 1000000:
+	case 2000000:
+		strcpy(name, "IEEE 802.11-DS");
+		break;
+	case 5500000:
+	case 11000000:
+		strcpy(name, "IEEE 802.11-b");
+		break;
+	}
+exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_giwfreq(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_freq *freq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+	
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+	
+	if (mibitem.data > NUM_CHANNELS) {
+		err = -EFAULT;
+		goto exit;
+	}
+	
+	/* convert into frequency instead of a channel */
+	freq->e = 1;		
+	freq->m = p80211_channel_to_mhz(mibitem.data, 0) * 100000;
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_siwfreq(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_freq *freq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did = DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel;
+	mibitem.status = P80211ENUM_msgitem_status_data_ok;
+	
+	if ( (freq->e == 0) && (freq->m <= 1000) )
+		mibitem.data = freq->m;
+	else
+		mibitem.data = p80211_mhz_to_channel(freq->m);
+  
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+	
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+#if WIRELESS_EXT > 8
+
+static int p80211wext_giwmode(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      __u32 *mode, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+
+	DBFENTER;
+
+	switch (wlandev->macmode) {
+	case WLAN_MACMODE_IBSS_STA: 
+		*mode = IW_MODE_ADHOC;
+		break;
+	case WLAN_MACMODE_ESS_STA:
+		*mode = IW_MODE_INFRA;
+		break;
+	case WLAN_MACMODE_ESS_AP:
+		*mode = IW_MODE_MASTER;
+		break;
+	default:
+		/* Not set yet. */
+		*mode = IW_MODE_AUTO;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+static int p80211wext_siwmode(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      __u32 *mode, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int 	result;
+	int     err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	if (*mode != IW_MODE_ADHOC && *mode != IW_MODE_INFRA &&
+	    *mode != IW_MODE_MASTER) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	/* Operation mode is the same with current mode */
+	if (*mode == wlandev->macmode)
+		goto exit;
+
+	switch (*mode) {
+	case IW_MODE_ADHOC:
+		wlandev->macmode = WLAN_MACMODE_IBSS_STA;
+		break;
+	case IW_MODE_INFRA:
+		wlandev->macmode = WLAN_MACMODE_ESS_STA;
+		break;
+	case IW_MODE_MASTER:
+		wlandev->macmode = WLAN_MACMODE_ESS_AP;
+		break;
+	default:
+		/* Not set yet. */
+		WLAN_LOG_INFO("Operation mode: %d not support\n", *mode);
+		return -EOPNOTSUPP;
+	}
+
+	/* Set Operation mode to the PORT TYPE RID */
+
+//#warning "get rid of p2mib here"
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did = DIDmib_p2_p2Static_p2CnfPortType;
+	mibitem.data = (*mode == IW_MODE_ADHOC) ? 0 : 1;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result)
+		err = -EFAULT;
+
+ exit:
+	DBFEXIT;
+
+	return err;
+}
+
+
+static int p80211wext_giwrange(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_point *data, char *extra)
+{
+        struct iw_range *range = (struct iw_range *) extra;
+	int i, val;
+
+	DBFENTER;
+
+#if WIRELESS_EXT > 9
+	range->txpower_capa = IW_TXPOW_DBM;
+	// XXX what about min/max_pmp, min/max_pmt, etc.
+#endif
+
+#if WIRELESS_EXT > 10
+	range->we_version_compiled = WIRELESS_EXT;
+	range->we_version_source = 13;
+	
+	range->retry_capa = IW_RETRY_LIMIT;
+	range->retry_flags = IW_RETRY_LIMIT;
+	range->min_retry = 0;
+	range->max_retry = 255;
+#endif /* WIRELESS_EXT > 10 */
+
+#if WIRELESS_EXT > 16
+        range->event_capa[0] = (IW_EVENT_CAPA_K_0 |  //mode/freq/ssid 
+                                IW_EVENT_CAPA_MASK(SIOCGIWAP) | 
+                                IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+        range->event_capa[1] = IW_EVENT_CAPA_K_1;  //encode
+        range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVQUAL) |
+                                IW_EVENT_CAPA_MASK(IWEVCUSTOM) );
+#endif
+
+	range->num_channels = NUM_CHANNELS;
+
+	/* XXX need to filter against the regulatory domain &| active set */
+	val = 0;
+	for (i = 0; i < NUM_CHANNELS ; i++) {
+		range->freq[val].i = i + 1;
+		range->freq[val].m = p80211wext_channel_freq[i] * 100000;
+		range->freq[val].e = 1;
+		val++;
+	}
+
+	range->num_frequency = val;
+	
+	/* Max of /proc/net/wireless */
+	range->max_qual.qual = 92;
+	range->max_qual.level = 154;
+	range->max_qual.noise = 154;
+	range->sensitivity = 3;
+	// XXX these need to be nsd-specific!
+
+	range->min_rts = 0;
+	range->max_rts = 2347;
+	range->min_frag = 256;
+	range->max_frag = 2346;
+	
+	range->max_encoding_tokens = NUM_WEPKEYS;
+	range->num_encoding_sizes = 2;
+	range->encoding_size[0] = 5;
+	range->encoding_size[1] = 13;
+	
+	// XXX what about num_bitrates/throughput?
+	range->num_bitrates = 0;
+
+	/* estimated max throughput */
+	// XXX need to cap it if we're running at ~2Mbps..
+	range->throughput = 5500000;
+
+	DBFEXIT;
+	return 0;
+}
+#endif
+
+static int p80211wext_giwap(netdevice_t *dev,
+			    struct iw_request_info *info,
+			    struct sockaddr *ap_addr, char *extra)
+{
+
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+
+	DBFENTER;
+
+	memcpy(ap_addr->sa_data, wlandev->bssid, WLAN_BSSID_LEN);
+	ap_addr->sa_family = ARPHRD_ETHER;
+
+	DBFEXIT;
+	return 0;
+}
+
+#if WIRELESS_EXT > 8
+static int p80211wext_giwencode(netdevice_t *dev,
+				struct iw_request_info *info,
+				struct iw_point *erq, char *key)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	int err = 0;
+	int i;
+
+	DBFENTER;
+
+	if (wlandev->hostwep & HOSTWEP_PRIVACYINVOKED)
+		erq->flags = IW_ENCODE_ENABLED;
+	else
+		erq->flags = IW_ENCODE_DISABLED;	
+
+	if (wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED)
+		erq->flags |= IW_ENCODE_RESTRICTED;
+	else
+		erq->flags |= IW_ENCODE_OPEN;
+
+	i = (erq->flags & IW_ENCODE_INDEX) - 1;
+
+	if (i == -1)
+		i = wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK;
+
+	if ((i < 0) || (i >= NUM_WEPKEYS)) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	erq->flags |= i + 1;
+
+	/* copy the key from the driver cache as the keys are read-only MIBs */
+	erq->length = wlandev->wep_keylens[i];
+	memcpy(key, wlandev->wep_keys[i], erq->length);
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_siwencode(netdevice_t *dev,
+				struct iw_request_info *info,
+				struct iw_point *erq, char *key)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211msg_dot11req_mibset_t	msg;
+	p80211item_pstr32_t		pstr;
+
+	int err = 0;
+	int result = 0;
+	int enable = 0;
+	int i;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	/* Check the Key index first. */
+	if((i = (erq->flags & IW_ENCODE_INDEX))) {
+		
+		if ((i < 1) || (i > NUM_WEPKEYS)) {
+			err = -EINVAL;
+			goto exit;	
+		}		
+		else
+			i--;
+
+		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, i);
+		
+		if (result) {
+			err = -EFAULT;
+			goto exit;
+		}
+		else {
+			enable = 1;
+		}
+
+	}
+	else {
+		// Do not thing when no Key Index
+	}
+
+	/* Check if there is no key information in the iwconfig request */
+	if((erq->flags & IW_ENCODE_NOKEY) == 0 && enable == 1) {
+
+		/*------------------------------------------------------------ 
+		 * If there is WEP Key for setting, check the Key Information 
+		 * and then set it to the firmware.
+		 -------------------------------------------------------------*/
+	
+		if (erq->length > 0) {
+
+			/* copy the key from the driver cache as the keys are read-only MIBs */
+			wlandev->wep_keylens[i] = erq->length;
+			memcpy(wlandev->wep_keys[i], key, erq->length);
+
+			/* Prepare data struture for p80211req_dorequest. */
+			memcpy(pstr.data.data, key, erq->length);
+			pstr.data.len = erq->length;
+
+			switch(i)
+			{
+				case 0:
+					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
+					break;
+			
+				case 1:
+					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
+					break;
+				
+				case 2: 
+					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
+					break;
+	
+				case 3:
+					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
+					break;
+		
+				default:
+					err = -EINVAL;
+					goto exit;
+			}
+
+			msg.msgcode = DIDmsg_dot11req_mibset;
+			memcpy(&msg.mibattribute.data, &pstr, sizeof(pstr));
+			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+			if (result) {
+				err = -EFAULT;
+				goto exit;
+			}
+		}
+
+	}
+	
+	/* Check the PrivacyInvoked flag */
+	if (erq->flags & IW_ENCODE_DISABLED) {
+		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_false);
+	}
+	else if((erq->flags & IW_ENCODE_ENABLED) || enable == 1) {
+		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_true);
+	}
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	/* Check the ExcludeUnencrypted flag */
+	if (erq->flags & IW_ENCODE_RESTRICTED) {
+		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_true);
+	}
+	else if (erq->flags & IW_ENCODE_OPEN) {
+		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_false);
+	}
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+ exit:
+
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_giwessid(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_point *data, char *essid)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+
+	DBFENTER;
+
+	if (wlandev->ssid.len) {
+		data->length = wlandev->ssid.len;
+		data->flags = 1;
+		memcpy(essid, wlandev->ssid.data, data->length);
+		essid[data->length] = 0;
+#if (WIRELESS_EXT < 21)
+		data->length++;
+#endif
+	} else {
+		memset(essid, 0, sizeof(wlandev->ssid.data));
+		data->length = 0;
+		data->flags = 0;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+static int p80211wext_siwessid(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_point *data, char *essid)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211msg_dot11req_mibset_t     msg;
+	p80211item_pstr32_t             pstr;
+
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	memset(&msg, 0, sizeof(msg));
+	memset(&pstr, 0, sizeof(pstr));  
+	msg.msgcode = DIDmsg_dot11req_mibset;
+
+//#warning "Get rid of p2mib here!"
+
+	if (wlandev->macmode == WLAN_MACMODE_ESS_AP)
+		pstr.did = DIDmib_p2_p2Static_p2CnfOwnSSID;
+	else
+		pstr.did = DIDmib_dot11smt_dot11StationConfigTable_dot11DesiredSSID;
+
+        if (data->flags == 0) {
+		pstr.data.len = 0;
+		memset(pstr.data.data, 0, sizeof(pstr.data.data));
+	} else {
+#if (WIRELESS_EXT < 21)
+		pstr.data.len = data->length - 1;
+#else
+		pstr.data.len = data->length;
+#endif
+		memcpy(pstr.data.data, essid, pstr.data.len);
+	}
+
+	memcpy(&msg.mibattribute.data, &pstr, sizeof(pstr));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	/* Auto Join */
+	err = p80211wext_autojoin(wlandev); 
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+
+static int p80211wext_siwcommit(netdevice_t *dev,
+				struct iw_request_info *info,
+				struct iw_point *data, char *essid)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	/* Auto Join */
+	err = p80211wext_autojoin(wlandev); 
+
+ exit:
+ 	DBFEXIT;
+	return err;
+}
+
+
+static int p80211wext_giwrate(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_param *rrq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_p2_p2MAC_p2CurrentTxRate;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	rrq->fixed = 0;   /* can it change? */
+	rrq->disabled = 0; 
+	rrq->value = 0;
+
+#define		HFA384x_RATEBIT_1			((UINT16)1)
+#define		HFA384x_RATEBIT_2			((UINT16)2)
+#define		HFA384x_RATEBIT_5dot5			((UINT16)4)
+#define		HFA384x_RATEBIT_11			((UINT16)8)
+
+	switch (mibitem.data) {
+	case HFA384x_RATEBIT_1:
+		rrq->value = 1000000;
+		break;
+	case HFA384x_RATEBIT_2:
+		rrq->value = 2000000;
+		break;
+	case HFA384x_RATEBIT_5dot5:
+		rrq->value = 5500000;
+		break;
+	case HFA384x_RATEBIT_11:
+		rrq->value = 11000000;
+		break;
+	default:
+		err = -EINVAL;
+	}
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_giwrts(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *rts, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	rts->value = mibitem.data;
+	rts->disabled = (rts->value == 2347);
+	rts->fixed = 1;
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+
+static int p80211wext_siwrts(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_param *rts, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold;
+	if (rts->disabled)
+		mibitem.data = 2347;
+	else
+		mibitem.data = rts->value;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_giwfrag(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_param *frag, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	frag->value = mibitem.data;
+	frag->disabled = (frag->value == 2346);
+	frag->fixed = 1;
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+static int p80211wext_siwfrag(netdevice_t *dev,
+			      struct iw_request_info *info,
+			      struct iw_param *frag, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+
+	if (frag->disabled)
+		mibitem.data = 2346;
+	else
+		mibitem.data = frag->value;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+#endif  /* WIRELESS_EXT > 8 */
+
+#if WIRELESS_EXT > 10
+
+#ifndef IW_RETRY_LONG
+#define IW_RETRY_LONG IW_RETRY_MAX
+#endif
+
+#ifndef IW_RETRY_SHORT
+#define IW_RETRY_SHORT IW_RETRY_MIN
+#endif
+
+static int p80211wext_giwretry(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_param *rrq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+	UINT16 shortretry, longretry, lifetime;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	shortretry = mibitem.data;
+
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	longretry = mibitem.data;
+
+	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	lifetime = mibitem.data;
+	
+	rrq->disabled = 0;
+
+	if ((rrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {
+		rrq->flags = IW_RETRY_LIFETIME;
+		rrq->value = lifetime * 1024;
+	} else {
+		if (rrq->flags & IW_RETRY_LONG) {
+			rrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
+			rrq->value = longretry;
+		} else {
+			rrq->flags = IW_RETRY_LIMIT;
+			rrq->value = shortretry;
+			if (shortretry != longretry)
+				rrq->flags |= IW_RETRY_SHORT;
+		}
+	}
+
+ exit:
+	DBFEXIT;
+	return err;
+
+}
+
+static int p80211wext_siwretry(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_param *rrq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	if (rrq->disabled) {
+		err = -EINVAL;
+		goto exit;
+	}
+
+	msg.msgcode = DIDmsg_dot11req_mibset;
+
+	if ((rrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {
+		mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+		mibitem.data =  rrq->value /= 1024;
+		
+		memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+		result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+		
+		if (result) {
+			err = -EFAULT;
+			goto exit;
+		}
+	} else {
+		if (rrq->flags & IW_RETRY_LONG) {
+			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
+			mibitem.data = rrq->value;
+
+			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+			
+			if (result) {
+				err = -EFAULT;
+				goto exit;
+			}
+		}
+
+		if (rrq->flags & IW_RETRY_SHORT) {
+			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
+			mibitem.data = rrq->value;
+
+			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+			
+			if (result) {
+				err = -EFAULT;
+				goto exit;
+			}
+		}
+	}
+
+ exit:
+	DBFEXIT;
+	return err;
+
+}
+
+#endif /* WIRELESS_EXT > 10 */
+
+#if WIRELESS_EXT > 9
+static int p80211wext_siwtxpow(netdevice_t *dev,
+                               struct iw_request_info *info,
+                               struct iw_param *rrq, char *extra)
+{
+        wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+        p80211item_uint32_t             mibitem;
+        p80211msg_dot11req_mibset_t     msg;
+        int result;
+        int err = 0;
+                              
+        DBFENTER;
+	
+       if (!wlan_wext_write) {
+                err = (-EOPNOTSUPP); 
+                goto exit;    
+        }
+
+        msg.msgcode = DIDmsg_dot11req_mibset;
+
+        switch (rrq->value) {
+
+          case 1 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel1; break;
+          case 2 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel2; break;
+          case 3 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel3; break;
+          case 4 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel4; break;
+          case 5 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel5; break;
+          case 6 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel6; break;
+          case 7 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel7; break;
+          case 8 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel8; break;
+          default: mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel8; break;
+	}
+
+        memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+        result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+        if (result) {
+                err = -EFAULT;
+                goto exit;
+        }
+
+ exit:
+        DBFEXIT;
+        return err;
+}
+
+static int p80211wext_giwtxpow(netdevice_t *dev,
+			       struct iw_request_info *info,
+			       struct iw_param *rrq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211item_uint32_t             mibitem;
+	p80211msg_dot11req_mibset_t     msg;
+	int result;
+	int err = 0;
+
+	DBFENTER;
+
+	msg.msgcode = DIDmsg_dot11req_mibget;
+	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+	memcpy(&mibitem, &msg.mibattribute.data, sizeof(mibitem));
+
+	// XXX handle OFF by setting disabled = 1;
+
+	rrq->flags = 0; // IW_TXPOW_DBM;
+	rrq->disabled = 0;
+	rrq->fixed = 0;
+	rrq->value = mibitem.data;
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+#endif /* WIRELESS_EXT > 9 */
+
+static int p80211wext_siwspy(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *srq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+        struct sockaddr address[IW_MAX_SPY];
+        int number = srq->length;
+        int i;
+
+	DBFENTER;
+
+	/* Copy the data from the input buffer */
+	memcpy(address, extra, sizeof(struct sockaddr)*number); 
+
+        wlandev->spy_number = 0;
+
+        if (number > 0) {
+
+                /* extract the addresses */
+                for (i = 0; i < number; i++) {
+
+                        memcpy(wlandev->spy_address[i], address[i].sa_data, ETH_ALEN);
+		}
+
+                /* reset stats */
+                memset(wlandev->spy_stat, 0, sizeof(struct iw_quality) * IW_MAX_SPY);
+
+                /* set number of addresses */
+                wlandev->spy_number = number;
+        }
+
+	DBFEXIT;
+	return 0;
+}
+
+/* jkriegl: from orinoco, modified */
+static int p80211wext_giwspy(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *srq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+
+        struct sockaddr address[IW_MAX_SPY];
+        struct iw_quality spy_stat[IW_MAX_SPY];
+        int number;
+        int i;
+
+	DBFENTER;
+
+        number = wlandev->spy_number;
+
+        if (number > 0) {
+
+                /* populate address and spy struct's */
+                for (i = 0; i < number; i++) {
+                        memcpy(address[i].sa_data, wlandev->spy_address[i], ETH_ALEN);
+                        address[i].sa_family = AF_UNIX;
+                	memcpy(&spy_stat[i], &wlandev->spy_stat[i], sizeof(struct iw_quality));
+                }
+
+		/* reset update flag */
+                for (i=0; i < number; i++)
+                        wlandev->spy_stat[i].updated = 0;
+        }
+
+        /* push stuff to user space */
+        srq->length = number;
+	memcpy(extra, address, sizeof(struct sockaddr)*number); 
+	memcpy(extra+sizeof(struct sockaddr)*number, spy_stat, sizeof(struct iw_quality)*number); 
+
+	DBFEXIT;
+	return 0;
+}
+
+int prism2_result2err (int prism2_result)
+{
+	int err = 0;
+
+	switch (prism2_result) {
+		case P80211ENUM_resultcode_invalid_parameters:
+			err = -EINVAL;
+			break;
+		case P80211ENUM_resultcode_implementation_failure:
+			err = -EIO;
+			break;
+		case P80211ENUM_resultcode_not_supported:
+			err = -EOPNOTSUPP;
+			break;
+		default:
+			err = 0;
+			break;
+	}
+
+	return err;
+}
+
+#if WIRELESS_EXT > 13
+static int p80211wext_siwscan(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *srq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211msg_dot11req_scan_t	msg;	
+	int result;
+	int err = 0;
+	int i = 0;
+
+	DBFENTER;
+
+	if (wlandev->macmode == WLAN_MACMODE_ESS_AP) {
+		WLAN_LOG_ERROR("Can't scan in AP mode\n");
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
+
+	memset(&msg, 0x00, sizeof(p80211msg_dot11req_scan_t));
+	msg.msgcode = DIDmsg_dot11req_scan;
+	msg.bsstype.data = P80211ENUM_bsstype_any;
+
+	memset(&(msg.bssid.data), 0xFF, sizeof (p80211item_pstr6_t));
+	msg.bssid.data.len = 6;
+
+	msg.scantype.data = P80211ENUM_scantype_active;
+	msg.probedelay.data = 0;
+
+	for (i = 0; i < 14; i++)
+		msg.channellist.data.data[i] = i;
+	msg.channellist.data.len = 14;
+
+	msg.maxchanneltime.data = 250;
+	msg.minchanneltime.data = 200;
+
+	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	if (result)
+		err = prism2_result2err (msg.resultcode.data);
+
+ exit:
+	DBFEXIT;
+	return err;
+}
+
+
+/* Helper to translate scan into Wireless Extensions scan results.
+ * Inspired by the prism54 code, which was in turn inspired by the
+ * airo driver code.
+ */
+static char *
+wext_translate_bss(char *current_ev, char *end_buf, p80211msg_dot11req_scan_results_t *bss)
+{
+	struct iw_event iwe;	/* Temporary buffer */
+
+	/* The first entry must be the MAC address */
+	memcpy(iwe.u.ap_addr.sa_data, bss->bssid.data.data, WLAN_BSSID_LEN);
+	iwe.u.ap_addr.sa_family = ARPHRD_ETHER;
+	iwe.cmd = SIOCGIWAP;
+	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+
+	/* The following entries will be displayed in the same order we give them */
+
+	/* The ESSID. */
+	if (bss->ssid.data.len > 0) {
+		char essid[IW_ESSID_MAX_SIZE + 1];
+		int size;
+
+		size = wlan_min(IW_ESSID_MAX_SIZE, bss->ssid.data.len);
+		memset(&essid, 0, sizeof (essid));
+		memcpy(&essid, bss->ssid.data.data, size);
+		WLAN_LOG_DEBUG(1, " essid size = %d\n", size);
+		iwe.u.data.length = size;
+		iwe.u.data.flags = 1;
+		iwe.cmd = SIOCGIWESSID;
+		current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, &essid[0]);
+		WLAN_LOG_DEBUG(1, " essid size OK.\n");
+	}
+
+	switch (bss->bsstype.data) {
+		case P80211ENUM_bsstype_infrastructure:
+			iwe.u.mode = IW_MODE_MASTER;
+			break;
+
+		case P80211ENUM_bsstype_independent:
+			iwe.u.mode = IW_MODE_ADHOC;
+			break;
+
+		default:
+			iwe.u.mode = 0;	
+			break;
+	}
+	iwe.cmd = SIOCGIWMODE;
+	if (iwe.u.mode)
+		current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+
+	/* Encryption capability */
+	if (bss->privacy.data == P80211ENUM_truth_true)
+		iwe.u.data.flags = IW_ENCODE_ENABLED | IW_ENCODE_NOKEY;
+	else
+		iwe.u.data.flags = IW_ENCODE_DISABLED;
+	iwe.u.data.length = 0;
+	iwe.cmd = SIOCGIWENCODE;
+	current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, NULL);
+
+	/* Add frequency. (short) bss->channel is the frequency in MHz */
+	iwe.u.freq.m = bss->dschannel.data;
+	iwe.u.freq.e = 0;
+	iwe.cmd = SIOCGIWFREQ;
+	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+
+	/* Add quality statistics */
+	iwe.u.qual.level = bss->signal.data;
+	iwe.u.qual.noise = bss->noise.data;
+	/* do a simple SNR for quality */
+	iwe.u.qual.qual = bss->signal.data - bss->noise.data;
+	iwe.cmd = IWEVQUAL;
+	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+
+	return current_ev;
+}
+
+
+static int p80211wext_giwscan(netdevice_t *dev,
+			     struct iw_request_info *info,
+			     struct iw_point *srq, char *extra)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	p80211msg_dot11req_scan_results_t	msg;
+	int result = 0;
+	int err = 0;
+	int i = 0;
+	int scan_good = 0;
+	char *current_ev = extra;
+
+	DBFENTER;
+
+	/* Since wireless tools doesn't really have a way of passing how
+	 * many scan results results there were back here, keep grabbing them
+	 * until we fail.
+	 */
+	do {
+		memset(&msg, 0, sizeof(msg));
+		msg.msgcode = DIDmsg_dot11req_scan_results;
+		msg.bssindex.data = i;
+
+		result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+		if ((result != 0) || 
+		    (msg.resultcode.data != P80211ENUM_resultcode_success)) {
+			break;
+		}
+		  
+		current_ev = wext_translate_bss(current_ev, extra + IW_SCAN_MAX_DATA, &msg);
+		scan_good = 1;
+		i++;
+	} while (i < IW_MAX_AP);
+
+	srq->length = (current_ev - extra);
+	srq->flags = 0;	/* todo */
+
+	if (result && !scan_good)
+		err = prism2_result2err (msg.resultcode.data);
+
+	DBFEXIT;
+	return err;
+}
+#endif
+
+
+/*
+typedef int (*iw_handler)(netdevice_t *dev, struct iw_request_info *info,
+                          union iwreq_data *wrqu, char *extra);
+*/
+
+#if WIRELESS_EXT > 12
+static iw_handler p80211wext_handlers[] =  {
+	(iw_handler) p80211wext_siwcommit,		/* SIOCSIWCOMMIT */
+	(iw_handler) p80211wext_giwname,		/* SIOCGIWNAME */
+	(iw_handler) NULL,				/* SIOCSIWNWID */
+	(iw_handler) NULL,				/* SIOCGIWNWID */
+	(iw_handler) p80211wext_siwfreq,  		/* SIOCSIWFREQ */
+	(iw_handler) p80211wext_giwfreq,  		/* SIOCGIWFREQ */
+	(iw_handler) p80211wext_siwmode,       		/* SIOCSIWMODE */
+	(iw_handler) p80211wext_giwmode,       		/* SIOCGIWMODE */
+	(iw_handler) NULL,                 		/* SIOCSIWSENS */
+	(iw_handler) NULL,                		/* SIOCGIWSENS */
+	(iw_handler) NULL, /* not used */     		/* SIOCSIWRANGE */
+	(iw_handler) p80211wext_giwrange,      		/* SIOCGIWRANGE */
+	(iw_handler) NULL, /* not used */     		/* SIOCSIWPRIV */
+	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWPRIV */
+	(iw_handler) NULL, /* not used */     		/* SIOCSIWSTATS */
+	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWSTATS */
+	(iw_handler) p80211wext_siwspy,			/* SIOCSIWSPY */
+	(iw_handler) p80211wext_giwspy,			/* SIOCGIWSPY */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,              		/* SIOCSIWAP */
+	(iw_handler) p80211wext_giwap,         		/* SIOCGIWAP */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,                  		/* SIOCGIWAPLIST */
+#if WIRELESS_EXT > 13
+	(iw_handler) p80211wext_siwscan,			/* SIOCSIWSCAN */
+	(iw_handler) p80211wext_giwscan,			/* SIOCGIWSCAN */
+#else /* WIRELESS_EXT > 13 */
+	(iw_handler) NULL,	/* null */		/* SIOCSIWSCAN */
+	(iw_handler) NULL,	/* null */		/* SIOCGIWSCAN */
+#endif /* WIRELESS_EXT > 13 */
+	(iw_handler) p80211wext_siwessid,  		/* SIOCSIWESSID */
+	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWESSID */
+	(iw_handler) NULL,                 		/* SIOCSIWNICKN */
+	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWNICKN */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,				/* -- hole -- */
+	(iw_handler) NULL,                		/* SIOCSIWRATE */
+	(iw_handler) p80211wext_giwrate,      		/* SIOCGIWRATE */
+	(iw_handler) p80211wext_siwrts,  		/* SIOCSIWRTS */
+	(iw_handler) p80211wext_giwrts,        		/* SIOCGIWRTS */
+	(iw_handler) p80211wext_siwfrag,      		/* SIOCSIWFRAG */
+	(iw_handler) p80211wext_giwfrag,   		/* SIOCGIWFRAG */
+	(iw_handler) p80211wext_siwtxpow,           	/* SIOCSIWTXPOW */
+	(iw_handler) p80211wext_giwtxpow,  		/* SIOCGIWTXPOW */
+	(iw_handler) p80211wext_siwretry,     		/* SIOCSIWRETRY */
+	(iw_handler) p80211wext_giwretry,  		/* SIOCGIWRETRY */
+	(iw_handler) p80211wext_siwencode,     		/* SIOCSIWENCODE */
+	(iw_handler) p80211wext_giwencode,  		/* SIOCGIWENCODE */
+	(iw_handler) NULL,                 		/* SIOCSIWPOWER */
+	(iw_handler) NULL,                  		/* SIOCGIWPOWER */
+};
+
+struct iw_handler_def p80211wext_handler_def = {
+	.num_standard = sizeof(p80211wext_handlers) / sizeof(iw_handler),
+	.num_private = 0,
+	.num_private_args = 0,
+        .standard = p80211wext_handlers,
+	.private = NULL,
+	.private_args = NULL,
+#if WIRELESS_EXT > 16
+	.get_wireless_stats = p80211wext_get_wireless_stats
+#endif
+};
+
+#endif
+
+/* wireless extensions' ioctls */ 
+int p80211wext_support_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
+{
+	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+
+#if WIRELESS_EXT < 13
+	struct iwreq *iwr = (struct iwreq*)ifr;
+#endif
+
+	p80211item_uint32_t             mibitem;
+	int err = 0;
+
+	DBFENTER;
+
+	mibitem.status = P80211ENUM_msgitem_status_data_ok;
+	
+	if ( wlandev->msdstate != WLAN_MSD_RUNNING ) {
+		err = -ENODEV;
+		goto exit;
+	}
+
+	WLAN_LOG_DEBUG(1, "Received wireless extension ioctl #%d.\n", cmd);
+
+	switch (cmd) {
+#if WIRELESS_EXT < 13
+	case SIOCSIWNAME:  /* unused  */
+		err = (-EOPNOTSUPP);
+		break;
+	case SIOCGIWNAME: /* get name == wireless protocol */
+                err = p80211wext_giwname(dev, NULL, (char *) &iwr->u, NULL);
+		break;	
+	case SIOCSIWNWID:
+	case SIOCGIWNWID:
+		err = (-EOPNOTSUPP);
+		break;
+	case SIOCSIWFREQ: /* set channel */
+                err = p80211wext_siwfreq(dev, NULL, &(iwr->u.freq), NULL);
+		break;
+	case SIOCGIWFREQ: /* get channel */
+                err = p80211wext_giwfreq(dev, NULL, &(iwr->u.freq), NULL);
+		break;
+	case SIOCSIWRANGE:
+	case SIOCSIWPRIV:	
+	case SIOCSIWAP: /* set access point MAC addresses (BSSID) */	
+		err = (-EOPNOTSUPP);
+		break;
+
+	case SIOCGIWAP:	/* get access point MAC addresses (BSSID) */
+                err = p80211wext_giwap(dev, NULL, &(iwr->u.ap_addr), NULL);
+		break;
+
+#if WIRELESS_EXT > 8
+	case SIOCSIWMODE: /* set operation mode */
+	case SIOCSIWESSID: /* set SSID (network name) */
+	case SIOCSIWRATE: /* set default bit rate (bps) */	
+		err = (-EOPNOTSUPP);
+		break;
+		
+	case SIOCGIWMODE: /* get operation mode */
+		err = p80211wext_giwmode(dev, NULL, &iwr->u.mode, NULL);
+
+		break;
+	case SIOCGIWNICKN: /* get node name/nickname */
+	case SIOCGIWESSID: /* get SSID */
+		if(iwr->u.essid.pointer) {
+                        char ssid[IW_ESSID_MAX_SIZE+1];
+			memset(ssid, 0, sizeof(ssid));
+
+			err = p80211wext_giwessid(dev, NULL, &iwr->u.essid, ssid);
+			if(copy_to_user(iwr->u.essid.pointer, ssid, sizeof(ssid)))
+				err = (-EFAULT);
+		}
+		break;
+	case SIOCGIWRATE:
+                err = p80211wext_giwrate(dev, NULL, &iwr->u.bitrate, NULL);
+		break;
+	case SIOCGIWRTS:	
+		err = p80211wext_giwrts(dev, NULL, &iwr->u.rts, NULL);	
+		break;
+	case SIOCGIWFRAG:
+		err = p80211wext_giwfrag(dev, NULL, &iwr->u.rts, NULL);	
+		break;
+	case SIOCGIWENCODE:
+		if (!capable(CAP_NET_ADMIN))
+			err = -EPERM;
+		else if (iwr->u.encoding.pointer) {
+			char keybuf[MAX_KEYLEN];
+			err = p80211wext_giwencode(dev, NULL,
+						     &iwr->u.encoding, keybuf);
+			if (copy_to_user(iwr->u.encoding.pointer, keybuf,
+					 iwr->u.encoding.length))
+				err = -EFAULT;
+		}
+		break;
+	case SIOCGIWAPLIST:	
+	case SIOCSIWRTS:
+	case SIOCSIWFRAG:	
+	case SIOCSIWSENS:
+	case SIOCGIWSENS:
+	case SIOCSIWNICKN: /* set node name/nickname */	
+	case SIOCSIWENCODE: /* set encoding token & mode */	
+	case SIOCSIWSPY:
+	case SIOCGIWSPY:
+	case SIOCSIWPOWER:	
+	case SIOCGIWPOWER:
+	case SIOCGIWPRIV:
+		err = (-EOPNOTSUPP);
+		break;
+	case SIOCGIWRANGE:
+		if(iwr->u.data.pointer != NULL) {
+                        struct iw_range range;
+                        err = p80211wext_giwrange(dev, NULL, &iwr->u.data,
+						  (char *) &range);
+			/* Push that up to the caller */
+			if (copy_to_user(iwr->u.data.pointer, &range, sizeof(range)))
+				err = -EFAULT;
+		}
+		break;
+#endif /* WIRELESS_EXT > 8 */
+#if WIRELESS_EXT > 9
+	case SIOCSIWTXPOW:
+		err = (-EOPNOTSUPP);
+		break;	
+	case SIOCGIWTXPOW:	
+		err = p80211wext_giwtxpow(dev, NULL, &iwr->u.txpower, NULL);
+		break;
+#endif /* WIRELESS_EXT > 9 */		
+#if WIRELESS_EXT > 10
+	case SIOCSIWRETRY:	
+		err = (-EOPNOTSUPP);
+		break;
+	case SIOCGIWRETRY:	
+		err = p80211wext_giwretry(dev, NULL, &iwr->u.retry, NULL);
+		break;
+#endif /* WIRELESS_EXT > 10 */		
+
+#endif /* WIRELESS_EXT <= 12 */
+
+	default:
+		err = (-EOPNOTSUPP);
+		break;
+	}
+
+ exit:
+	DBFEXIT;
+	return (err);
+}
+
+int p80211wext_event_associated(wlandevice_t *wlandev, int assoc)
+{
+        union iwreq_data data;
+
+        DBFENTER;
+
+#if WIRELESS_EXT > 13
+        /* Send the association state first */
+        data.ap_addr.sa_family = ARPHRD_ETHER;
+        if (assoc) {
+                memcpy(data.ap_addr.sa_data, wlandev->bssid, WLAN_ADDR_LEN);
+        } else {
+                memset(data.ap_addr.sa_data, 0, WLAN_ADDR_LEN);
+        }       
+
+        if (wlan_wext_write)
+                wireless_send_event(wlandev->netdev, SIOCGIWAP, &data, NULL);
+
+        if (!assoc) goto done;
+
+        // XXX send association data, like IEs, etc etc.
+#endif
+ done:
+        DBFEXIT;
+        return 0;
+}
+
+
+#endif /* compatibility to wireless extensions */
+
+
+
+
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_cs.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_cs.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_cs.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_cs.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,1487 @@
+#define WLAN_HOSTIF WLAN_PCMCIA
+#include "hfa384x.c"
+#include "prism2mgmt.c"
+#include "prism2mib.c"
+#include "prism2sta.c"
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,4,21) )
+#if (WLAN_CPU_FAMILY == WLAN_Ix86)
+#ifndef CONFIG_ISA
+#warning "You may need to enable ISA support in your kernel."
+#endif
+#endif
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11) )
+static u_int	irq_mask = 0xdeb8;		/* Interrupt mask */
+static int	irq_list[4] = { -1 };		/* Interrupt list */
+#endif
+static u_int	prism2_ignorevcc=1;		/* Boolean, if set, we
+						 * ignore what the Vcc
+						 * is set to and what the CIS
+						 * says.
+						 */
+module_param( prism2_ignorevcc, int, 0644);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11) )
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9))
+static int numlist = 4;
+module_param_array(irq_list, int, numlist, 0444);
+#else
+module_param_array(irq_list, int, NULL, 0444);
+#endif
+module_param( irq_mask, int, 0644);
+#endif
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
+static int prism2_cs_suspend(struct pcmcia_device *pdev);
+static int prism2_cs_resume(struct pcmcia_device *pdev);
+static void prism2_cs_remove(struct pcmcia_device *pdev);
+static int prism2_cs_probe(struct pcmcia_device *pdev);
+#else
+dev_link_t	*prism2sta_attach(void);
+static void	prism2sta_detach(dev_link_t *link);
+static int	prism2sta_config(dev_link_t *link);
+static void	prism2sta_release(u_long arg);
+static int 	prism2sta_event (event_t event, int priority, event_callback_args_t *args);
+
+static dev_link_t	*dev_list = NULL;	/* head of instance list */
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,68))
+/*----------------------------------------------------------------
+* cs_error
+*
+* Utility function to print card services error messages.
+*
+* Arguments:
+*	handle	client handle identifying this CS client
+*	func	CS function number that generated the error
+*	ret	CS function return code
+*
+* Returns: 
+*	nothing
+* Side effects:
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+static void cs_error(client_handle_t handle, int func, int ret)
+{
+#if (defined(CS_RELEASE_CODE) && (CS_RELEASE_CODE < 0x2911))
+	CardServices(ReportError, dev_info, (void *)func, (void *)ret);
+#else
+	error_info_t err = { func, ret };
+	pcmcia_report_error(handle, &err);
+#endif
+}
+#else // kernel_version
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+static struct pcmcia_device_id prism2_cs_ids[] = {
+	PCMCIA_DEVICE_PROD_ID12("INTERSIL",  "HFA384x/IEEE", 0x74c5e40d, 0xdb472a18), // Intersil PRISM2 Reference Design 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x0138, 0x0002), // Compaq WL100/200 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x028a, 0x0002), // Compaq iPaq HNW-100 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x0250, 0x0002), // Samsung SWL2000-N 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0xd601, 0x0002), // Z-Com XI300 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID12("ZoomAir 11Mbps High",  "Rate wireless Networking", 0x273fe3db, 0x32a1eaee), // ZoomAir 4100 11Mb/s 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("Instant Wireless ",  " Network PC CARD",  "Version 01.02", 0x11d901af, 0x6e9bd926, 0x4b74baa0), // Linksys WPC11 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("Addtron",  "AWP-100 Wireless PCMCIA",  "Version 01.02", 0xe6ec52ce, 0x8649af2, 0x4b74baa0), // Addtron AWP-100 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("D",  "Link DWL-650 11Mbps WLAN Card",  "Version 01.02", 0x71b18589, 0xb6f1b0ab, 0x4b74baa0), // D-Link DWL-650 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("SMC",  "SMC2632W",  "Version 01.02", 0xc4f8b18b, 0x474a1f2a, 0x4b74baa0), // SMC 2632W 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID1234("Intersil",  "PRISM 2_5 PCMCIA ADAPTER",  "ISL37300P",  "Eval-RevA", 0x4b801a17, 0x6345a0bf, 0xc9049a39, 0xc23adc0e), // BroMax Freeport 11Mbps 802.11b WLAN Card (Prism 2.5)
+	PCMCIA_DEVICE_PROD_ID123("U.S. Robotics",  "IEEE 802.11b PC-CARD",  "Version 01.02", 0xc7b8df9d, 0x1700d087, 0x4b74baa0), // U.S. Robotics IEEE 802.11b PC-CARD
+	PCMCIA_DEVICE_PROD_ID12("Digital Data Communications",  "WPC-0100", 0xfdd73470, 0xe0b6f146), // Level-One WPC-0100
+	PCMCIA_DEVICE_MANF_CARD(0x0274, 0x1612), // Bromax OEM 11Mbps 802.11b WLAN Card (Prism 2.5)
+	PCMCIA_DEVICE_MANF_CARD(0x0274, 0x1613), // Bromax OEM 11Mbps 802.11b WLAN Card (Prism 3)
+	PCMCIA_DEVICE_PROD_ID12("corega K.K.",  "Wireless LAN PCC-11", 0x5261440f, 0xa6405584), // corega K.K. Wireless LAN PCC-11
+	PCMCIA_DEVICE_PROD_ID12("corega K.K.",  "Wireless LAN PCCA-11", 0x5261440f, 0xdf6115f9), // corega K.K. Wireless LAN PCCA-11
+	PCMCIA_DEVICE_MANF_CARD(0xc001, 0x0008), // CONTEC FLEXSCAN/FX-DDS110-PCC
+	PCMCIA_DEVICE_PROD_ID12("PLANEX",  "GeoWave/GW-NS110", 0x209f40ab, 0x46263178), // PLANEX GeoWave/GW-NS110
+	PCMCIA_DEVICE_PROD_ID123("OEM",  "PRISM2 IEEE 802.11 PC-Card",  "Version 01.02", 0xfea54c90, 0x48f2bdd6, 0x4b74baa0), // Ambicom WL1100 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("LeArtery",  "SYNCBYAIR 11Mbps Wireless LAN PC Card",  "Version 01.02", 0x7e3b326a, 0x49893e92, 0x4b74baa0), // LeArtery SYNCBYAIR 11Mbps 802.11b WLAN Card
+PCMCIA_DEVICE_MANF_CARD(0x01ff, 0x0008), // Intermec MobileLAN 11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("NETGEAR MA401 Wireless PC",  "Card",  "Version 01.00", 0xa37434e9, 0x9762e8f1, 0xa57adb8c), // NETGEAR MA401 11Mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_PROD_ID1234("Intersil",  "PRISM Freedom PCMCIA Adapter",  "ISL37100P",  "Eval-RevA", 0x4b801a17, 0xf222ec2d, 0x630d52b2, 0xc23adc0e), // Intersil PRISM Freedom 11mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_PROD_ID123("OTC",  "Wireless AirEZY 2411-PCC WLAN Card",  "Version 01.02", 0x4ac44287, 0x235a6bed, 0x4b74baa0), // OTC Wireless AirEZY 2411-PCC 11Mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_PROD_ID1234("802.11",  "11Mbps Wireless LAN Card",  "v08C1",  ""   , 0xb67a610e, 0x655aa7b7, 0x264b451a, 0x0), // Dynalink L11HDT 11Mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0xc250, 0x0002), // Dynalink L11HDT 11Mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_PROD_ID12("PROXIM",  "RangeLAN-DS/LAN PC CARD", 0xc6536a5e, 0x3f35797d), // PROXIM RangeLAN-DS/LAN PC CARD
+	PCMCIA_DEVICE_PROD_ID1234("ACTIONTEC",  "PRISM Wireless LAN PC Card",  "0381",  "RevA", 0x393089da, 0xa71e69d5, 0x90471fa9, 0x57a66194), // ACTIONTEC PRISM Wireless LAN PC Card
+	PCMCIA_DEVICE_MANF_CARD(0x1668, 0x0101), // ACTIONTEC PRISM Wireless LAN PC Card
+	PCMCIA_DEVICE_PROD_ID12("3Com",  "3CRWE737A AirConnect Wireless LAN PC Card", 0x41240e5b, 0x56010af3), // 3Com AirConnect 3CRWE737A
+	PCMCIA_DEVICE_PROD_ID12("3Com",  "3CRWE777A AirConnect Wireless LAN PCI Card"  , 0x41240e5b, 0xafc7c33e), // 3Com AirConnect 3CRWE777A
+	PCMCIA_DEVICE_PROD_ID12("ASUS",  "802_11b_PC_CARD_25", 0x78fc06ee, 0xdb9aa842), // ASUS WL-100 802.11b WLAN  PC Card
+	PCMCIA_DEVICE_PROD_ID12("ASUS",  "802_11B_CF_CARD_25", 0x78fc06ee, 0x45a50c1e), // ASUS WL-110 802.11b WLAN CF Card
+	PCMCIA_DEVICE_PROD_ID12("BUFFALO",  "WLI-CF-S11G", 0x2decece3, 0x82067c18), // BUFFALO WLI-CF-S11G 802.11b WLAN Card
+	PCMCIA_DEVICE_PROD_ID1234("The Linksys Group, Inc.", "Wireless Network CF Card", "ISL37300P", "RevA", 0xa5f472c2, 0x9c05598d, 0xc9049a39, 0x57a66194), // Linksys WCF11 11Mbps 802.11b WLAN Card (Prism 2.5)
+	PCMCIA_DEVICE_PROD_ID1234("Linksys",  "Wireless CompactFlash Card",  "",  "", 0x733cc81, 0xc52f395, 0x0, 0x0), // Linksys WCF12 11Mbps 802.11b WLAN Card (Prism 3)
+	PCMCIA_DEVICE_MANF_CARD(0x028a, 0x0673), // Linksys WCF12 11Mbps 802.11b WLAN Card (Prism 3)
+	PCMCIA_DEVICE_PROD_ID1234("NETGEAR MA401RA Wireless PC",  "Card",  "ISL37300P",  "Eval-RevA", 0x306467f, 0x9762e8f1, 0xc9049a39, 0xc23adc0e), // NETGEAR MA401RA 11Mbps 802.11 WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0xd601, 0x0005), // D-Link DCF-660W  11Mbps 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x02d2, 0x0001), // Microsoft Wireless Notebook Adapter MN-520
+	PCMCIA_DEVICE_MANF_CARD(0x0089, 0x0002), // AnyPoint(TM) Wireless II PC Card
+	PCMCIA_DEVICE_PROD_ID1234("D",  "Link DRC-650 11Mbps WLAN Card",  "Version 01.02",  "" , 0x71b18589, 0xf144e3ac, 0x4b74baa0, 0x0), // D-Link DRC-650 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x9005, 0x0021), // Adaptec AWN-8030
+	PCMCIA_DEVICE_MANF_CARD(0x000b, 0x7110), // D-Link DWL-650 rev P 802.11b WLAN card
+	// PCMCIA_DEVICE_PROD_ID1234("D-Link",  "DWL-650 Wireless PC Card RevP",  "ISL37101P-10",  "A3", 0x1a424a1c, 0x6ea57632, 0xdd97a26b, 0x56b21f52), // D-Link DWL-650 rev P 802.11b WLAN card
+	PCMCIA_DEVICE_PROD_ID123("INTERSIL",   "I-GATE 11M PC Card / PC Card plus",  "Version 01.02", 0x74c5e40d, 0x8304ff77, 0x4b74baa0), // I-Gate 11M PC Card
+	PCMCIA_DEVICE_PROD_ID1234("BENQ",  "AWL100 PCMCIA ADAPTER",  "ISL37300P",  "Eval-RevA", 0x35dadc74, 0x1f7fedb, 0xc9049a39, 0xc23adc0e), // benQ AWL100 802.11b WLAN Card
+	PCMCIA_DEVICE_MANF_CARD(0x000b, 0x7300), // benQ AWL100 802.11b WLAN Card
+	// PCMCIA_DEVICE_PROD_ID1("INTERSIL", 0x74c5e40d), // Intersil Prism 2 card
+	// PCMCIA_DEVICE_MANF_CARD(0x0156, 0x0002), // Intersil Prism 2 card
+
+	PCMCIA_DEVICE_NULL
+};
+
+MODULE_DEVICE_TABLE(pcmcia, prism2_cs_ids);
+#endif
+
+static struct pcmcia_driver prism2_cs_driver = {
+	.drv = { 
+		.name = "prism2_cs",
+	},
+	.owner = THIS_MODULE,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
+	.suspend = prism2_cs_suspend,
+	.resume = prism2_cs_resume,
+	.remove = prism2_cs_remove,
+	.probe = prism2_cs_probe,
+	.id_table = prism2_cs_ids,
+#else
+	.attach = prism2sta_attach,
+	.detach = prism2sta_detach,
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,12)
+	.id_table = prism2_cs_ids,
+	.event =  prism2sta_event,
+#endif // > 2.6.12
+#endif // <= 2.6.15
+};
+#endif /* kernel_version */
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
+#define CS_CHECK(fn, ret) \
+do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
+
+#define CFG_CHECK(fn, retf) \
+do { int ret = (retf); \
+if (ret != 0) { \
+        WLAN_LOG_DEBUG(1, "CardServices(" #fn ") returned %d\n", ret); \
+        cs_error(pdev, fn, ret); \
+        goto next_entry; \
+} \
+} while (0)
+
+void prism2_cs_remove(struct pcmcia_device *pdev)
+{
+	struct wlandevice  *wlandev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+        dev_link_t *link = dev_to_instance(pdev);
+#endif
+
+	DBFENTER;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	wlandev = pdev->priv;
+#else
+	wlandev = link->priv;
+#endif
+
+	if (wlandev) {
+		p80211netdev_hwremoved(wlandev);
+		unregister_wlandev(wlandev);
+		wlan_unsetup(wlandev);
+		if (wlandev->priv) {
+			hfa384x_t *hw = wlandev->priv;
+			wlandev->priv = NULL;
+			if (hw) {
+				hfa384x_destroy(hw);
+				kfree(hw);
+			}
+		}
+		kfree(wlandev);
+	}
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	pdev->priv = NULL;
+        pcmcia_disable_device(pdev);
+#else
+        if (link->state & DEV_CONFIG) {
+	        if (link->win)
+			pcmcia_release_window(link->win);
+		pcmcia_release_configuration(link->handle);
+		if (link->io.NumPorts1)
+			pcmcia_release_io(link->handle, &link->io);
+		if (link->irq.AssignedIRQ)
+			pcmcia_release_irq(link->handle, &link->irq);
+		
+		link->state &= ~DEV_CONFIG;
+	}
+
+	link->priv = NULL;
+	kfree(link);
+#endif
+
+	DBFEXIT;
+	return;
+}
+
+int prism2_cs_suspend(struct pcmcia_device *pdev)
+{
+	struct wlandevice  *wlandev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+        dev_link_t *link = dev_to_instance(pdev);
+#endif
+
+	DBFENTER;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	wlandev = pdev->priv;
+	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+#else
+	wlandev = link->priv;
+
+        link->state |= DEV_SUSPEND;
+        if (link->state & DEV_CONFIG) {	
+		prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+		pcmcia_release_configuration(link->handle);
+	}
+#endif
+
+	DBFEXIT;
+
+	return 0;
+}
+
+int prism2_cs_resume(struct pcmcia_device *pdev)
+{
+	struct wlandevice  *wlandev;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+        dev_link_t *link = dev_to_instance(pdev);
+#endif
+
+	DBFENTER;
+	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	wlandev = pdev->priv;
+	// XXX do something here?
+#else
+	wlandev = link->priv;
+        link->state &= ~DEV_SUSPEND;
+        if (link->state & DEV_CONFIG) {
+                pcmcia_request_configuration(link->handle, &link->conf);
+		// XXX do something here?
+	}
+#endif
+
+
+	DBFEXIT;
+
+	return 0;
+}
+
+int prism2_cs_probe(struct pcmcia_device *pdev)
+{
+	int rval = 0;
+	struct wlandevice *wlandev = NULL;
+	hfa384x_t *hw = NULL;
+
+        config_info_t socketconf;
+        cisparse_t *parse = NULL;
+	tuple_t tuple;
+	uint8_t	buf[64];
+        int last_fn, last_ret;
+        cistpl_cftable_entry_t dflt = { 0 };
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+	dev_link_t *link;
+#endif
+
+	DBFENTER;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	/* Set up interrupt type */
+        pdev->conf.IntType = INT_MEMORY_AND_IO;
+#else
+        link = kmalloc(sizeof(dev_link_t), GFP_KERNEL);
+        if (link == NULL)
+                return -ENOMEM;
+        memset(link, 0, sizeof(dev_link_t));
+	
+        link->conf.Vcc = 33;
+        link->conf.IntType = INT_MEMORY_AND_IO;
+
+        link->handle = pdev;
+        pdev->instance = link;
+        link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+
+#endif
+
+	// VCC crap?
+        parse = kmalloc(sizeof(cisparse_t), GFP_KERNEL);
+
+	wlandev = create_wlan();
+	if (!wlandev || !parse) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		rval = -EIO;
+		goto failed;
+	}
+	hw = wlandev->priv;
+
+	if ( wlan_setup(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: wlan_setup() failed.\n", dev_info);
+		rval = -EIO;
+		goto failed;
+	}
+
+	/* Initialize the hw struct for now */
+	hfa384x_create(hw, 0, 0, NULL);
+	hw->wlandev = wlandev;
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	hw->pdev = pdev;
+	pdev->priv = wlandev;
+#else
+	hw->link = link;
+	link->priv = wlandev;
+#endif
+
+        tuple.DesiredTuple = CISTPL_CONFIG;
+        tuple.Attributes = 0;
+        tuple.TupleData = buf;
+        tuple.TupleDataMax = sizeof(buf);
+        tuple.TupleOffset = 0;
+        CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(pdev, &tuple));
+        CS_CHECK(GetTupleData, pcmcia_get_tuple_data(pdev, &tuple));
+        CS_CHECK(ParseTuple, pcmcia_parse_tuple(pdev, &tuple, parse));
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+        pdev->conf.ConfigBase = parse->config.base;
+        pdev->conf.Present = parse->config.rmask[0];
+#else
+        link->conf.ConfigBase = parse->config.base;
+        link->conf.Present = parse->config.rmask[0];
+
+	link->conf.Vcc = socketconf.Vcc;
+#endif
+        CS_CHECK(GetConfigurationInfo,
+                 pcmcia_get_configuration_info(pdev, &socketconf));
+
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(pdev, &tuple));
+        for (;;) {
+		cistpl_cftable_entry_t *cfg = &(parse->cftable_entry);
+                CFG_CHECK(GetTupleData,
+                           pcmcia_get_tuple_data(pdev, &tuple));
+                CFG_CHECK(ParseTuple,
+                           pcmcia_parse_tuple(pdev, &tuple, parse));
+
+                if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+                        dflt = *cfg;
+                if (cfg->index == 0)
+                        goto next_entry;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+                pdev->conf.ConfigIndex = cfg->index;
+#else
+                link->conf.ConfigIndex = cfg->index;
+#endif
+
+                /* Does this card need audio output? */
+                if (cfg->flags & CISTPL_CFTABLE_AUDIO) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+                        pdev->conf.Attributes |= CONF_ENABLE_SPKR;
+                        pdev->conf.Status = CCSR_AUDIO_ENA;
+#else
+                        link->conf.Attributes |= CONF_ENABLE_SPKR;
+                        link->conf.Status = CCSR_AUDIO_ENA;
+#endif
+                }
+
+                /* Use power settings for Vcc and Vpp if present */
+                /*  Note that the CIS values need to be rescaled */
+                if (cfg->vcc.present & (1 << CISTPL_POWER_VNOM)) {
+                        if (socketconf.Vcc != cfg->vcc.param[CISTPL_POWER_VNOM] /
+                            10000 && !prism2_ignorevcc) {
+                                WLAN_LOG_DEBUG(1, "  Vcc mismatch - skipping"
+                                       " this entry\n");
+                                goto next_entry;
+                        }
+                } else if (dflt.vcc.present & (1 << CISTPL_POWER_VNOM)) {
+                        if (socketconf.Vcc != dflt.vcc.param[CISTPL_POWER_VNOM] /
+                            10000 && !prism2_ignorevcc) {
+                                WLAN_LOG_DEBUG(1, "  Vcc (default) mismatch "
+                                       "- skipping this entry\n");
+                                goto next_entry;
+                        }
+                }
+
+                if (cfg->vpp1.present & (1 << CISTPL_POWER_VNOM)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+                        pdev->conf.Vpp =
+                                cfg->vpp1.param[CISTPL_POWER_VNOM] / 10000;
+#else
+                        link->conf.Vpp1 = link->conf.Vpp2 =
+                                cfg->vpp1.param[CISTPL_POWER_VNOM] / 10000;
+#endif
+                } else if (dflt.vpp1.present & (1 << CISTPL_POWER_VNOM)) {
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+                        pdev->conf.Vpp =
+                                dflt.vpp1.param[CISTPL_POWER_VNOM] / 10000;
+#else
+                        link->conf.Vpp1 = link->conf.Vpp2 =
+                                dflt.vpp1.param[CISTPL_POWER_VNOM] / 10000;
+#endif
+		}
+
+		/* Do we need to allocate an interrupt? */
+		/* HACK: due to a bad CIS....we ALWAYS need an interrupt */
+		/* if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1) */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+		pdev->conf.Attributes |= CONF_ENABLE_IRQ;
+#else
+		link->conf.Attributes |= CONF_ENABLE_IRQ;
+#endif
+
+		/* IO window settings */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+		pdev->io.NumPorts1 = pdev->io.NumPorts2 = 0;
+		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
+			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
+			pdev->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io->flags & CISTPL_IO_8BIT))
+				pdev->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io->flags & CISTPL_IO_16BIT))
+				pdev->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			pdev->io.BasePort1 = io->win[0].base;
+			if  ( pdev->io.BasePort1 != 0 ) {
+				WLAN_LOG_WARNING(
+				"Brain damaged CIS: hard coded iobase="
+				"0x%x, try letting pcmcia_cs decide...\n",
+				pdev->io.BasePort1 );
+				pdev->io.BasePort1 = 0;
+			}
+			pdev->io.NumPorts1 = io->win[0].len;
+			if (io->nwin > 1) {
+				pdev->io.Attributes2 = pdev->io.Attributes1;
+				pdev->io.BasePort2 = io->win[1].base;
+				pdev->io.NumPorts2 = io->win[1].len;
+			}
+		}
+		/* This reserves IO space but doesn't actually enable it */
+		CFG_CHECK(RequestIO, pcmcia_request_io(pdev, &pdev->io));
+#else
+		link->io.NumPorts1 = link->io.NumPorts2 = 0;
+		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
+			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
+			link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io->flags & CISTPL_IO_8BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io->flags & CISTPL_IO_16BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			link->io.BasePort1 = io->win[0].base;
+			if  ( link->io.BasePort1 != 0 ) {
+				WLAN_LOG_WARNING(
+				"Brain damaged CIS: hard coded iobase="
+				"0x%x, try letting pcmcia_cs decide...\n",
+				link->io.BasePort1 );
+				link->io.BasePort1 = 0;
+			}
+			link->io.NumPorts1 = io->win[0].len;
+			if (io->nwin > 1) {
+				link->io.Attributes2 = link->io.Attributes1;
+				link->io.BasePort2 = io->win[1].base;
+				link->io.NumPorts2 = io->win[1].len;
+			}
+		}
+		/* This reserves IO space but doesn't actually enable it */
+		CFG_CHECK(RequestIO, pcmcia_request_io(pdev, &link->io));
+#endif
+		/* If we got this far, we're cool! */
+		break;
+		
+	next_entry:
+		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+			dflt = *cfg;
+		CS_CHECK(GetNextTuple, pcmcia_get_next_tuple(pdev, &tuple));
+
+	}
+
+	/* Let pcmcia know the device name */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	pdev->dev_node = &hw->node;
+#else
+	link->dev = &hw->node;
+#endif
+
+	/* Register the network device and get assigned a name */
+	SET_MODULE_OWNER(wlandev->netdev);
+	SET_NETDEV_DEV(wlandev->netdev,  &handle_to_dev(pdev));
+	if (register_wlandev(wlandev) != 0) {
+		WLAN_LOG_NOTICE("prism2sta_cs: register_wlandev() failed.\n");
+		goto failed;
+	}
+
+	strcpy(hw->node.dev_name, wlandev->name);
+
+	/* Allocate an interrupt line.  Note that this does not assign a */
+	/* handler to the interrupt, unless the 'Handler' member of the */
+	/* irq structure is initialized. */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	if (pdev->conf.Attributes & CONF_ENABLE_IRQ) {
+		pdev->irq.IRQInfo1 = IRQ_LEVEL_ID;
+		pdev->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+		pdev->irq.Handler = hfa384x_interrupt;
+		pdev->irq.Instance = wlandev;
+		CS_CHECK(RequestIRQ, pcmcia_request_irq(pdev, &pdev->irq));
+	}
+#else
+	if (link->conf.Attributes & CONF_ENABLE_IRQ) {
+		link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+		link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+		link->irq.Handler = hfa384x_interrupt;
+		link->irq.Instance = wlandev;
+		CS_CHECK(RequestIRQ, pcmcia_request_irq(pdev, &link->irq));
+	}
+#endif
+
+	/* This actually configures the PCMCIA socket -- setting up */
+	/* the I/O windows and the interrupt mapping, and putting the */
+	/* card and host interface into "Memory and IO" mode. */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(pdev, &pdev->conf));
+#else
+	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(pdev, &link->conf));
+#endif
+
+	/* Fill the netdevice with this info */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	wlandev->netdev->irq = pdev->irq.AssignedIRQ;
+	wlandev->netdev->base_addr = pdev->io.BasePort1;
+#else
+	wlandev->netdev->irq = link->irq.AssignedIRQ;
+	wlandev->netdev->base_addr = link->io.BasePort1;
+#endif
+
+	/* And the rest of the hw structure */
+	hw->irq = wlandev->netdev->irq;
+	hw->iobase = wlandev->netdev->base_addr;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
+	link->state |= DEV_CONFIG;
+	link->state &= ~DEV_CONFIG_PENDING;
+#endif
+
+	/* And now we're done! */
+	wlandev->msdstate = WLAN_MSD_HWPRESENT;
+
+	goto done;
+
+ cs_failed:
+        cs_error(pdev, last_fn, last_ret);
+	
+failed:
+	// wlandev, hw, etc etc..
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	pdev->priv = NULL;
+#else
+	pdev->instance = NULL;
+	if (link) {
+		link->priv = NULL;
+		kfree(link);
+	}
+#endif
+	if (wlandev) {
+		wlan_unsetup(wlandev);
+		if (wlandev->priv) {
+			hfa384x_t *hw = wlandev->priv;
+			wlandev->priv = NULL;
+			if (hw) {
+				hfa384x_destroy(hw);
+				kfree(hw);
+			}
+		}
+		kfree(wlandev);
+	}
+
+done:
+	if (parse) kfree(parse);
+	       
+	DBFEXIT;
+	return rval;
+}
+#else  // <= 2.6.15
+#define CS_CHECK(fn, ret) \
+do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
+
+#define CFG_CHECK(fn, retf) \
+do { int ret = (retf); \
+if (ret != 0) { \
+        WLAN_LOG_DEBUG(1, "CardServices(" #fn ") returned %d\n", ret); \
+        cs_error(link->handle, fn, ret); \
+        goto next_entry; \
+} \
+} while (0)
+
+/*----------------------------------------------------------------
+* prism2sta_attach
+*
+* Half of the attach/detach pair.  Creates and registers a device
+* instance with Card Services.  In this case, it also creates the
+* wlandev structure and device private structure.  These are 
+* linked to the device instance via its priv member.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	A valid ptr to dev_link_t on success, NULL otherwise
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process thread (insmod/init_module/register_pccard_driver)
+----------------------------------------------------------------*/
+dev_link_t *prism2sta_attach(void)
+{
+	client_reg_t		client_reg;
+	int			result;
+	dev_link_t		*link = NULL;
+	wlandevice_t		*wlandev = NULL;
+	hfa384x_t		*hw = NULL;
+
+	DBFENTER;
+
+	/* Alloc our structures */
+	link =		kmalloc(sizeof(struct dev_link_t), GFP_KERNEL);
+
+	if (!link || ((wlandev = create_wlan()) == NULL)) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}
+	hw = wlandev->priv;
+
+	/* Clear all the structs */
+	memset(link, 0, sizeof(struct dev_link_t));
+
+	if ( wlan_setup(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: wlan_setup() failed.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}
+
+	/* Initialize the hw struct for now */
+	hfa384x_create(hw, 0, 0, NULL);
+	hw->wlandev = wlandev;
+
+	/* Initialize the PC card device object. */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+	init_timer(&link->release);
+	link->release.function = &prism2sta_release;
+	link->release.data = (u_long)link;
+#endif
+	link->conf.IntType = INT_MEMORY_AND_IO;
+	link->priv = wlandev;
+#if (defined(CS_RELEASE_CODE) && (CS_RELEASE_CODE < 0x2911))
+	link->irq.Instance = wlandev;
+#endif
+
+	/* Link in to the list of devices managed by this driver */
+	link->next = dev_list;
+	dev_list = link;	
+
+	/* Register with Card Services */
+	client_reg.dev_info = &dev_info;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11) )
+	client_reg.Attributes = INFO_IO_CLIENT | INFO_CARD_SHARE;
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) )
+	client_reg.EventMask =
+		CS_EVENT_CARD_INSERTION | CS_EVENT_CARD_REMOVAL |
+		CS_EVENT_RESET_REQUEST |
+		CS_EVENT_RESET_PHYSICAL | CS_EVENT_CARD_RESET |
+		CS_EVENT_PM_SUSPEND | CS_EVENT_PM_RESUME;
+	client_reg.event_handler = &prism2sta_event;
+#endif
+
+	client_reg.Version = 0x0210;
+	client_reg.event_callback_args.client_data = link;
+
+	result = pcmcia_register_client(&link->handle, &client_reg);
+	if (result != 0) {
+		cs_error(link->handle, RegisterClient, result);
+		prism2sta_detach(link);
+		return NULL;
+	}
+
+	goto done;
+
+ failed:
+	if (link)	kfree(link);
+	if (wlandev)	kfree(wlandev);
+	if (hw)		kfree(hw);
+	link = NULL;
+
+ done:
+	DBFEXIT;
+	return link;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_detach
+*
+* Remove one of the device instances managed by this driver.
+*   Search the list for the given instance, 
+*   check our flags for a waiting timer'd release call
+*   call release
+*   Deregister the instance with Card Services
+*   (netdevice) unregister the network device.
+*   unlink the instance from the list
+*   free the link, priv, and priv->priv memory
+* Note: the dev_list variable is a driver scoped static used to
+*	maintain a list of device instances managed by this
+*	driver.
+*
+* Arguments:
+*	link	ptr to the instance to detach
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	the link structure is gone, the netdevice is gone
+*
+* Call context:
+*	Might be interrupt, don't block.
+----------------------------------------------------------------*/
+void prism2sta_detach(dev_link_t *link)
+{
+	dev_link_t		**linkp;
+	wlandevice_t		*wlandev;
+	hfa384x_t		*hw;
+
+	DBFENTER;
+
+	/* Locate prev device structure */
+	for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next) {
+		if (*linkp == link) break;
+	}
+
+	if (*linkp != NULL) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+		unsigned long	flags;
+		/* Get rid of any timer'd release call */
+		save_flags(flags);
+		cli();
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+		if (link->state & DEV_RELEASE_PENDING) {
+			del_timer_sync(&link->release);
+			link->state &= ~DEV_RELEASE_PENDING;
+		}
+#endif
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+		restore_flags(flags);
+#endif
+
+		/* If link says we're still config'd, call release */
+		if (link->state & DEV_CONFIG) {
+			prism2sta_release((u_long)link);
+			if (link->state & DEV_STALE_CONFIG) {
+				link->state |= DEV_STALE_LINK;
+				return;
+			}
+		}
+		
+		/* Tell Card Services we're not around any more */
+		if (link->handle) {
+			pcmcia_deregister_client(link->handle);
+		}	
+
+		/* Unlink device structure, free bits */
+		*linkp = link->next;
+		if ( link->priv != NULL ) {
+			wlandev = (wlandevice_t*)link->priv;
+			p80211netdev_hwremoved(wlandev);
+			if (link->dev != NULL) {
+				unregister_wlandev(wlandev);
+			}
+			wlan_unsetup(wlandev);
+			if (wlandev->priv) {
+				hw = wlandev->priv;
+				wlandev->priv = NULL;
+				if (hw) {
+					hfa384x_destroy(hw);
+					kfree(hw);
+				}
+			}
+			link->priv = NULL;
+			kfree(wlandev);
+		}
+		kfree(link);
+	}
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_config
+*
+* Half of the config/release pair.  Usually called in response to
+* a card insertion event.  At this point, we _know_ there's some
+* physical device present.  That means we can start poking around
+* at the CIS and at any device specific config data we want.
+*
+* Note the gotos and the macros.  I recoded this once without
+* them, and it got incredibly ugly.  It's actually simpler with
+* them.
+*
+* Arguments:
+*	link	the dev_link_t structure created in attach that 
+*		represents this device instance.
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	Resources (irq, io, mem) are allocated
+*	The pcmcia dev_link->node->name is set
+*	(For netcards) The device structure is finished and,
+*	  most importantly, registered.  This means that there
+*	  is now a _named_ device that can be configured from
+*	  userland.
+*
+* Call context:
+*	May be called from a timer.  Don't block!
+----------------------------------------------------------------*/
+#define CS_CHECK(fn, ret) \
+do { last_fn = (fn); if ((last_ret = (ret)) != 0) goto cs_failed; } while (0)
+
+#define CFG_CHECK(fn, retf) \
+do { int ret = (retf); \
+if (ret != 0) { \
+        WLAN_LOG_DEBUG(1, "CardServices(" #fn ") returned %d\n", ret); \
+        cs_error(link->handle, fn, ret); \
+        goto next_entry; \
+} \
+} while (0)
+
+void prism2sta_config(dev_link_t *link)
+{
+	client_handle_t		handle;
+	wlandevice_t		*wlandev;
+	hfa384x_t               *hw;
+	int			last_fn;
+	int			last_ret;
+	tuple_t			tuple;
+	cisparse_t		parse;
+	config_info_t		socketconf;
+	UINT8			buf[64];
+	int			minVcc = 0;
+	int			maxVcc = 0;
+	cistpl_cftable_entry_t	dflt = { 0 };
+
+	DBFENTER;
+
+	handle = link->handle;
+	wlandev = (wlandevice_t*)link->priv;
+	hw = wlandev->priv;
+
+	/* Collect the config register info */
+	tuple.DesiredTuple = CISTPL_CONFIG;
+	tuple.Attributes = 0;
+	tuple.TupleData = buf;
+	tuple.TupleDataMax = sizeof(buf);
+	tuple.TupleOffset = 0;
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+	CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+	CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+
+	link->conf.ConfigBase = parse.config.base;
+	link->conf.Present = parse.config.rmask[0];
+	
+	/* Configure card */
+	link->state |= DEV_CONFIG;
+
+	/* Acquire the current socket config (need Vcc setting) */
+	CS_CHECK(GetConfigurationInfo, pcmcia_get_configuration_info(handle, &socketconf));
+
+	/* Loop through the config table entries until we find one that works */
+	/* Assumes a complete and valid CIS */
+	tuple.DesiredTuple = CISTPL_CFTABLE_ENTRY;
+	CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+	while (1) {
+		cistpl_cftable_entry_t *cfg = &(parse.cftable_entry);
+		CFG_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
+		CFG_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+
+		if (cfg->index == 0) goto next_entry;
+		link->conf.ConfigIndex = cfg->index;
+
+		/* Lets print out the Vcc that the controller+pcmcia-cs set
+		 * for us, cause that's what we're going to use.
+		 */
+		WLAN_LOG_DEBUG(1,"Initial Vcc=%d/10v\n", socketconf.Vcc);
+		if (prism2_ignorevcc) {
+			link->conf.Vcc = socketconf.Vcc;
+			goto skipvcc;
+		}
+
+		/* Use power settings for Vcc and Vpp if present */
+		/* Note that the CIS values need to be rescaled */
+		if (cfg->vcc.present & (1<<CISTPL_POWER_VNOM)) {
+			WLAN_LOG_DEBUG(1, "Vcc obtained from curtupl.VNOM\n");
+			minVcc = maxVcc = 
+				cfg->vcc.param[CISTPL_POWER_VNOM]/10000;
+		} else if (dflt.vcc.present & (1<<CISTPL_POWER_VNOM)) {
+			WLAN_LOG_DEBUG(1, "Vcc set from dflt.VNOM\n");
+			minVcc = maxVcc = 
+				dflt.vcc.param[CISTPL_POWER_VNOM]/10000;
+		} else if ((cfg->vcc.present & (1<<CISTPL_POWER_VMAX)) &&
+			   (cfg->vcc.present & (1<<CISTPL_POWER_VMIN)) ) {
+			WLAN_LOG_DEBUG(1, "Vcc set from curtupl(VMIN,VMAX)\n");			minVcc = cfg->vcc.param[CISTPL_POWER_VMIN]/10000;
+			maxVcc = cfg->vcc.param[CISTPL_POWER_VMAX]/10000;
+		} else if ((dflt.vcc.present & (1<<CISTPL_POWER_VMAX)) &&
+			   (dflt.vcc.present & (1<<CISTPL_POWER_VMIN)) ) {
+			WLAN_LOG_DEBUG(1, "Vcc set from dflt(VMIN,VMAX)\n");
+			minVcc = dflt.vcc.param[CISTPL_POWER_VMIN]/10000;
+			maxVcc = dflt.vcc.param[CISTPL_POWER_VMAX]/10000;
+		}
+
+		if ( socketconf.Vcc >= minVcc && socketconf.Vcc <= maxVcc) {
+			link->conf.Vcc = socketconf.Vcc;
+		} else {
+			/* [MSM]: Note that I've given up trying to change 
+			 * the Vcc if a change is indicated.  It seems the
+			 * system&socketcontroller&card vendors can't seem
+			 * to get it right, so I'm tired of trying to hack
+			 * my way around it.  pcmcia-cs does its best using 
+			 * the voltage sense pins but sometimes the controller
+			 * lies.  Then, even if we have a good read on the VS 
+			 * pins, some system designs will silently ignore our
+			 * requests to set the voltage.  Additionally, some 
+			 * vendors have 3.3v indicated on their sense pins, 
+			 * but 5v specified in the CIS or vice-versa.  I've
+			 * had it.  My only recommendation is "let the buyer
+			 * beware".  Your system might supply 5v to a 3v card
+			 * (possibly causing damage) or a 3v capable system 
+			 * might supply 5v to a 3v capable card (wasting 
+			 * precious battery life).
+			 * My only recommendation (if you care) is to get 
+			 * yourself an extender card (I don't know where, I 
+			 * have only one myself) and a meter and test it for
+			 * yourself.
+			 */
+			goto next_entry;
+		}
+skipvcc:			
+		WLAN_LOG_DEBUG(1, "link->conf.Vcc=%d\n", link->conf.Vcc);
+
+		/* Do we need to allocate an interrupt? */
+		/* HACK: due to a bad CIS....we ALWAYS need an interrupt */
+		/* if (cfg->irq.IRQInfo1 || dflt.irq.IRQInfo1) */
+			link->conf.Attributes |= CONF_ENABLE_IRQ;
+
+		/* IO window settings */
+		link->io.NumPorts1 = link->io.NumPorts2 = 0;
+		if ((cfg->io.nwin > 0) || (dflt.io.nwin > 0)) {
+			cistpl_io_t *io = (cfg->io.nwin) ? &cfg->io : &dflt.io;
+			link->io.Attributes1 = IO_DATA_PATH_WIDTH_AUTO;
+			if (!(io->flags & CISTPL_IO_8BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_16;
+			if (!(io->flags & CISTPL_IO_16BIT))
+				link->io.Attributes1 = IO_DATA_PATH_WIDTH_8;
+			link->io.BasePort1 = io->win[0].base;
+			if  ( link->io.BasePort1 != 0 ) {
+				WLAN_LOG_WARNING(
+				"Brain damaged CIS: hard coded iobase="
+				"0x%x, try letting pcmcia_cs decide...\n",
+				link->io.BasePort1 );
+				link->io.BasePort1 = 0;
+			}
+			link->io.NumPorts1 = io->win[0].len;
+			if (io->nwin > 1) {
+				link->io.Attributes2 = link->io.Attributes1;
+				link->io.BasePort2 = io->win[1].base;
+				link->io.NumPorts2 = io->win[1].len;
+			}
+		}
+
+		/* This reserves IO space but doesn't actually enable it */
+		CFG_CHECK(RequestIO, pcmcia_request_io(link->handle, &link->io));
+
+		/* If we got this far, we're cool! */
+		break;
+
+next_entry:
+		if (cfg->flags & CISTPL_CFTABLE_DEFAULT)
+			dflt = *cfg;
+		CS_CHECK(GetNextTuple,
+                         pcmcia_get_next_tuple(handle, &tuple));
+	}
+
+	/* Allocate an interrupt line.  Note that this does not assign a */
+	/* handler to the interrupt, unless the 'Handler' member of the */
+	/* irq structure is initialized. */
+	if (link->conf.Attributes & CONF_ENABLE_IRQ)
+	{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11) )
+		int			i;
+		link->irq.IRQInfo1 = IRQ_INFO2_VALID | IRQ_LEVEL_ID;
+		if (irq_list[0] == -1)
+			link->irq.IRQInfo2 = irq_mask;
+		else
+			for (i=0; i<4; i++)
+				link->irq.IRQInfo2 |= 1 << irq_list[i];
+#else
+		link->irq.IRQInfo1 = IRQ_LEVEL_ID;
+#endif
+		link->irq.Attributes = IRQ_TYPE_EXCLUSIVE | IRQ_HANDLE_PRESENT;
+		link->irq.Handler = hfa384x_interrupt;
+		link->irq.Instance = wlandev;
+		CS_CHECK(RequestIRQ, pcmcia_request_irq(link->handle, &link->irq));
+	}
+
+	/* This actually configures the PCMCIA socket -- setting up */
+	/* the I/O windows and the interrupt mapping, and putting the */
+	/* card and host interface into "Memory and IO" mode. */
+	CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link->handle, &link->conf));
+
+	/* Fill the netdevice with this info */
+	wlandev->netdev->irq = link->irq.AssignedIRQ;
+	wlandev->netdev->base_addr = link->io.BasePort1;
+
+	/* Report what we've done */
+	WLAN_LOG_INFO("%s: index 0x%02x: Vcc %d.%d", 
+		dev_info, link->conf.ConfigIndex, 
+		link->conf.Vcc/10, link->conf.Vcc%10);
+	if (link->conf.Vpp1)
+		printk(", Vpp %d.%d", link->conf.Vpp1/10, link->conf.Vpp1%10);
+	if (link->conf.Attributes & CONF_ENABLE_IRQ)
+		printk(", irq %d", link->irq.AssignedIRQ);
+	if (link->io.NumPorts1)
+		printk(", io 0x%04x-0x%04x", link->io.BasePort1, link->io.BasePort1+link->io.NumPorts1-1);
+	if (link->io.NumPorts2)
+		printk(" & 0x%04x-0x%04x", link->io.BasePort2, link->io.BasePort2+link->io.NumPorts2-1);
+	printk("\n");
+
+	link->state &= ~DEV_CONFIG_PENDING;
+
+	/* Let pcmcia know the device name */
+	link->dev = &hw->node;
+
+	/* Register the network device and get assigned a name */
+	SET_MODULE_OWNER(wlandev->netdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11) )
+	SET_NETDEV_DEV(wlandev->netdev,  &handle_to_dev(link->handle));
+#endif
+	if (register_wlandev(wlandev) != 0) {
+		WLAN_LOG_NOTICE("prism2sta_cs: register_wlandev() failed.\n");
+		goto failed;
+	}
+
+	strcpy(hw->node.dev_name, wlandev->name);
+
+	/* Any device custom config/query stuff should be done here */
+	/* For a netdevice, we should at least grab the mac address */
+
+	return;
+cs_failed:
+	cs_error(link->handle, last_fn, last_ret);
+	WLAN_LOG_ERROR("NextTuple failure? It's probably a Vcc mismatch.\n");
+
+failed:
+	prism2sta_release((u_long)link);
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_release
+*
+* Half of the config/release pair.  Usually called in response to 
+* a card ejection event.  Checks to make sure no higher layers
+* are still (or think they are) using the card via the link->open
+* field.  
+*
+* NOTE: Don't forget to increment the link->open variable in the 
+*  device_open method, and decrement it in the device_close 
+*  method.
+*
+* Arguments:
+*	arg	a generic 32 bit variable.  It's the value that
+*		we assigned to link->release.data in sta_attach().
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*	All resources should be released after this function
+*	executes and finds the device !open.
+*
+* Call context:
+*	Possibly in a timer context.  Don't do anything that'll
+*	block.
+----------------------------------------------------------------*/
+void prism2sta_release(u_long arg)
+{
+        dev_link_t	*link = (dev_link_t *)arg;
+
+	DBFENTER;
+
+	/* First thing we should do is get the MSD back to the
+	 * HWPRESENT state.  I.e. everything quiescent.
+	 */
+	prism2sta_ifstate(link->priv, P80211ENUM_ifstate_disable);
+
+        if (link->open) {
+		/* TODO: I don't think we're even using this bit of code
+		 * and I don't think it's hurting us at the moment.
+		 */
+                WLAN_LOG_DEBUG(1, 
+			"prism2sta_cs: release postponed, '%s' still open\n",
+			link->dev->dev_name);
+                link->state |= DEV_STALE_CONFIG;
+                return;
+        }
+
+        pcmcia_release_configuration(link->handle);
+        pcmcia_release_io(link->handle, &link->io);
+        pcmcia_release_irq(link->handle, &link->irq);
+
+        link->state &= ~(DEV_CONFIG | DEV_RELEASE_PENDING);
+
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_event
+*
+* Handler for card services events.
+*
+* Arguments:
+*	event		The event code
+*	priority	hi/low - REMOVAL is the only hi
+*	args		ptr to card services struct containing info about
+*			pcmcia status
+*
+* Returns: 
+*	Zero on success, non-zero otherwise
+*
+* Side effects:
+*	
+*
+* Call context:
+*	Both interrupt and process thread, depends on the event.
+----------------------------------------------------------------*/
+static int 
+prism2sta_event (
+	event_t event, 
+	int priority, 
+	event_callback_args_t *args)
+{
+	int			result = 0;
+	dev_link_t		*link = (dev_link_t *) args->client_data;
+	wlandevice_t		*wlandev = (wlandevice_t*)link->priv;
+	hfa384x_t		*hw = NULL;
+
+	DBFENTER;
+
+	if (wlandev) hw = wlandev->priv;
+
+	switch (event)
+	{
+	case CS_EVENT_CARD_INSERTION:
+		WLAN_LOG_DEBUG(5,"event is INSERTION\n");
+		link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+		prism2sta_config(link);
+		if (!(link->state & DEV_CONFIG)) {
+			wlandev->netdev->irq = 0;
+			WLAN_LOG_ERROR(
+				"%s: Initialization failed!\n", dev_info);
+			wlandev->msdstate = WLAN_MSD_HWFAIL;
+			break;
+		}
+
+		/* Fill in the rest of the hw struct */
+		hw->irq = wlandev->netdev->irq;
+		hw->iobase = wlandev->netdev->base_addr;
+		hw->link = link;
+
+		if (prism2_doreset) {
+			result = hfa384x_corereset(hw, 
+					prism2_reset_holdtime, 
+					prism2_reset_settletime, 0);
+			if ( result ) {
+				WLAN_LOG_ERROR(
+					"corereset() failed, result=%d.\n", 
+					result);
+				wlandev->msdstate = WLAN_MSD_HWFAIL;
+				break;
+			}
+		}
+
+#if 0
+		/*
+		 * TODO: test_hostif() not implemented yet.
+		 */
+		result = hfa384x_test_hostif(hw);
+		if (result) {
+			WLAN_LOG_ERROR(
+			"test_hostif() failed, result=%d.\n", result);
+			wlandev->msdstate = WLAN_MSD_HWFAIL;
+			break;
+		}
+#endif
+		wlandev->msdstate = WLAN_MSD_HWPRESENT;
+		break;
+
+	case CS_EVENT_CARD_REMOVAL:
+		WLAN_LOG_DEBUG(5,"event is REMOVAL\n");
+		link->state &= ~DEV_PRESENT;
+
+		if (wlandev) {
+			p80211netdev_hwremoved(wlandev);
+		}
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0))
+		if (link->state & DEV_CONFIG)
+		{
+			link->release.expires = jiffies + (HZ/20);
+			add_timer(&link->release);
+		}
+#endif
+		break;
+	case CS_EVENT_RESET_REQUEST:
+		WLAN_LOG_DEBUG(5,"event is RESET_REQUEST\n");
+		WLAN_LOG_NOTICE(
+			"prism2 card reset not supported "
+			"due to post-reset user mode configuration "
+			"requirements.\n");
+		WLAN_LOG_NOTICE(
+			"  From user mode, use "
+			"'cardctl suspend;cardctl resume' "
+			"instead.\n");
+		break;
+	case CS_EVENT_RESET_PHYSICAL:
+	case CS_EVENT_CARD_RESET:
+		WLAN_LOG_WARNING("Rx'd CS_EVENT_RESET_xxx, should not "
+			"be possible since RESET_REQUEST was denied.\n");
+		break;
+
+	case CS_EVENT_PM_SUSPEND:
+		WLAN_LOG_DEBUG(5,"event is SUSPEND\n");
+		link->state |= DEV_SUSPEND;
+		if (link->state & DEV_CONFIG)
+		{
+			prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+			pcmcia_release_configuration(link->handle);
+		}
+		break;
+
+	case CS_EVENT_PM_RESUME:
+		WLAN_LOG_DEBUG(5,"event is RESUME\n");
+		link->state &= ~DEV_SUSPEND;
+		if (link->state & DEV_CONFIG) {
+			pcmcia_request_configuration(link->handle, &link->conf);
+		}
+		break;
+	}
+
+	DBFEXIT;
+	return 0;  /* noone else does anthing with the return value */
+}
+#endif // <= 2.6.15
+
+
+
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+{
+	int		result = 0;
+	conf_reg_t	reg;
+	UINT8		corsave;
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(3, "Doing reset via CardServices().\n");
+
+	/* Collect COR */
+	reg.Function = 0; 
+	reg.Action = CS_READ; 
+	reg.Offset = CISREG_COR;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	result = pcmcia_access_configuration_register(hw->pdev, &reg);
+#else
+	result = pcmcia_access_configuration_register(
+			hw->link->handle,
+			&reg);
+#endif
+	if (result != CS_SUCCESS ) {
+		WLAN_LOG_ERROR(
+			":0: AccessConfigurationRegister(CS_READ) failed,"
+			"result=%d.\n", result); 
+		result = -EIO;
+	}
+	corsave = reg.Value;
+
+	/* Write reset bit (BIT7) */
+	reg.Value |= BIT7;
+	reg.Action = CS_WRITE;
+	reg.Offset = CISREG_COR;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	result = pcmcia_access_configuration_register(hw->pdev, &reg);
+#else
+	result = pcmcia_access_configuration_register(
+			hw->link->handle,
+			&reg);
+#endif
+	if (result != CS_SUCCESS ) {
+		WLAN_LOG_ERROR(
+			":1: AccessConfigurationRegister(CS_WRITE) failed,"
+			"result=%d.\n", result); 
+		result = -EIO;
+	}
+
+	/* Hold for holdtime */
+	mdelay(holdtime);
+
+	if (genesis) {
+		reg.Value = genesis;
+		reg.Action = CS_WRITE;
+		reg.Offset = CISREG_CCSR;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+		result = pcmcia_access_configuration_register(hw->pdev, &reg);
+#else
+		result = pcmcia_access_configuration_register(
+				      hw->link->handle,
+				      &reg);
+#endif
+		if (result != CS_SUCCESS ) {
+			WLAN_LOG_ERROR(
+				":1: AccessConfigurationRegister(CS_WRITE) failed,"
+				"result=%d.\n", result); 
+			result = -EIO;
+		}
+	}
+
+	/* Hold for holdtime */
+	mdelay(holdtime);
+
+	/* Clear reset bit */
+	reg.Value &= ~BIT7;
+	reg.Action = CS_WRITE;
+	reg.Offset = CISREG_COR;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	result = pcmcia_access_configuration_register(hw->pdev, &reg);
+#else
+	result = pcmcia_access_configuration_register(
+				      hw->link->handle,
+				      &reg);
+#endif
+	if (result != CS_SUCCESS ) {
+		WLAN_LOG_ERROR(
+			":2: AccessConfigurationRegister(CS_WRITE) failed,"
+			"result=%d.\n", result); 
+		result = -EIO;
+		goto done;
+	}
+
+	/* Wait for settletime */
+	mdelay(settletime);
+
+	/* Set non-reset bits back what they were */
+	reg.Value = corsave;
+	reg.Action = CS_WRITE;
+	reg.Offset = CISREG_COR;
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,16)
+	result = pcmcia_access_configuration_register(hw->pdev, &reg);
+#else
+	result = pcmcia_access_configuration_register(
+				      hw->link->handle,
+				      &reg);
+#endif
+	if (result != CS_SUCCESS ) {
+		WLAN_LOG_ERROR(
+			":2: AccessConfigurationRegister(CS_WRITE) failed,"
+			"result=%d.\n", result); 
+		result = -EIO;
+		goto done;
+	}
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+#ifdef MODULE
+
+static int __init prism2cs_init(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,68))
+	servinfo_t	serv;
+#endif
+
+	DBFENTER;
+
+        WLAN_LOG_NOTICE("%s Loaded\n", version);
+        WLAN_LOG_NOTICE("dev_info is: %s\n", dev_info);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,68))
+	pcmcia_get_card_services_info(&serv);
+	if ( serv.Revision != CS_RELEASE_CODE )
+	{
+		printk(KERN_NOTICE"%s: CardServices release does not match!\n", dev_info);
+		return -1;
+	}
+
+	/* This call will result in a call to prism2sta_attach */
+	/*   and eventually prism2sta_detach */
+	register_pccard_driver( &dev_info, &prism2sta_attach, &prism2sta_detach);
+#else
+	pcmcia_register_driver(&prism2_cs_driver);
+#endif
+
+	DBFEXIT;
+	return 0;
+}
+
+static void __exit prism2cs_cleanup(void)
+{
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,68))
+        dev_link_t *link = dev_list;
+        dev_link_t *nlink;
+        DBFENTER;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10) )
+	for (link=dev_list; link != NULL; link = nlink) {
+		nlink = link->next;
+		if ( link->state & DEV_CONFIG ) {
+			prism2sta_release((u_long)link);
+		}
+		prism2sta_detach(link); /* remember detach() frees link */
+	}
+#endif
+
+	unregister_pccard_driver( &dev_info);
+#else
+	pcmcia_unregister_driver(&prism2_cs_driver);
+#endif
+
+        printk(KERN_NOTICE "%s Unloaded\n", version);
+
+        DBFEXIT;
+        return;
+}
+
+module_init(prism2cs_init);
+module_exit(prism2cs_cleanup);
+
+#endif // MODULE
+
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2mgmt.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2mgmt.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2mgmt.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2mgmt.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,2955 @@
+/* src/prism2/driver/prism2mgmt.c
+*
+* Management request handler functions.
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* The functions in this file handle management requests sent from
+* user mode.
+*
+* Most of these functions have two separate blocks of code that are
+* conditional on whether this is a station or an AP.  This is used
+* to separate out the STA and AP responses to these management primitives.
+* It's a choice (good, bad, indifferent?) to have the code in the same 
+* place so it's clear that the same primitive is implemented in both 
+* cases but has different behavior.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include <wlan/version.h>
+
+#include <linux/version.h>
+
+#include <linux/if_arp.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/wait.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+#include <linux/random.h>
+
+#if (WLAN_HOSTIF == WLAN_USB)
+#include <linux/usb.h>
+#endif
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+#endif
+
+#include <wlan/wlan_compat.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+#include <prism2/hfa384x.h>
+#include <prism2/prism2mgmt.h>
+
+/*================================================================*/
+/* Local Constants */
+
+
+/*================================================================*/
+/* Local Macros */
+
+/* Converts 802.11 format rate specifications to prism2 */
+#define p80211rate_to_p2bit(n)	((((n)&~BIT7) == 2) ? BIT0 : \
+				 (((n)&~BIT7) == 4) ? BIT1 : \
+				 (((n)&~BIT7) == 11) ? BIT2 : \
+				 (((n)&~BIT7) == 22) ? BIT3 : 0)
+
+/*================================================================*/
+/* Local Types */
+
+
+/*================================================================*/
+/* Local Static Definitions */
+
+
+/*================================================================*/
+/* Local Function Declarations */
+
+
+/*================================================================*/
+/* Function Definitions */
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_powermgmt
+*
+* Set the power management state of this station's MAC.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_powermgmt(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_powermgmt_t	*msg = msgp;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/*
+		 * Set CNFPMENABLED (on or off)
+		 * Set CNFMULTICASTRX (if PM on, otherwise clear)
+		 * Spout a notice stating that SleepDuration and
+		 * HoldoverDuration and PMEPS also have an impact.
+		 */
+		/* Powermgmt is currently unsupported for STA */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Powermgmt is never supported for AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_scan
+*
+* Initiate a scan for BSSs.
+*
+* This function corresponds to MLME-scan.request and part of 
+* MLME-scan.confirm.  As far as I can tell in the standard, there
+* are no restrictions on when a scan.request may be issued.  We have
+* to handle in whatever state the driver/MAC happen to be.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_scan(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_scan_t	*msg = msgp;
+        UINT16                  roamingmode, word;
+	int                     i, timeout;
+	int                     istmpenable = 0;
+
+        hfa384x_HostScanRequest_data_t  scanreq;
+
+	DBFENTER;
+
+        if (hw->ap) {
+                WLAN_LOG_ERROR("Prism2 in AP mode cannot perform scans.\n");
+                result = 1;
+                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+                goto exit;
+        }
+
+        /* gatekeeper check */
+        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+                                     hw->ident_sta_fw.minor,
+                                     hw->ident_sta_fw.variant) <
+            HFA384x_FIRMWARE_VERSION(1,3,2)) { 
+		WLAN_LOG_ERROR("HostScan not supported with current firmware (<1.3.2).\n");
+                result = 1;
+                msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto exit;
+	}
+
+        memset(&scanreq, 0, sizeof(scanreq));
+
+        /* save current roaming mode */
+        result = hfa384x_drvr_getconfig16(hw,
+                        HFA384x_RID_CNFROAMINGMODE, &roamingmode);
+        if ( result ) {
+                WLAN_LOG_ERROR("getconfig(ROAMMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* drop into mode 3 for the scan */
+        result = hfa384x_drvr_setconfig16(hw,
+                        HFA384x_RID_CNFROAMINGMODE,
+			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* active or passive? */
+        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+                                     hw->ident_sta_fw.minor,
+                                     hw->ident_sta_fw.variant) >
+            HFA384x_FIRMWARE_VERSION(1,5,0)) { 
+                if (msg->scantype.data != P80211ENUM_scantype_active) {
+                        word = host2hfa384x_16(msg->maxchanneltime.data);
+                } else {
+                        word = 0;
+                }
+                result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPASSIVESCANCTRL, word);
+                if ( result ) {
+                        WLAN_LOG_WARNING("Passive scan not supported with "
+					  "current firmware.  (<1.5.1)\n");
+                }
+        }
+
+	/* set up the txrate to be 2MBPS. Should be fastest basicrate... */
+	word = HFA384x_RATEBIT_2;
+	scanreq.txRate = host2hfa384x_16(word);
+
+        /* set up the channel list */
+        word = 0;
+        for (i = 0; i < msg->channellist.data.len; i++) {
+                UINT8 channel = msg->channellist.data.data[i];
+                if (channel > 14) continue;
+                /* channel 1 is BIT0 ... channel 14 is BIT13 */
+                word |= (1 << (channel-1));
+        }
+        scanreq.channelList = host2hfa384x_16(word);
+
+        /* set up the ssid, if present. */
+        scanreq.ssid.len = host2hfa384x_16(msg->ssid.data.len);
+        memcpy(scanreq.ssid.data, msg->ssid.data.data, msg->ssid.data.len);
+
+	/* Enable the MAC port if it's not already enabled  */
+	result = hfa384x_drvr_getconfig16(hw, HFA384x_RID_PORTSTATUS, &word);
+	if ( result ) {
+		WLAN_LOG_ERROR("getconfig(PORTSTATUS) failed. "
+				"result=%d\n", result);
+		msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+		goto exit;
+	}
+	if (word == HFA384x_PORTSTATUS_DISABLED) {
+		UINT16 wordbuf[17];
+
+		result = hfa384x_drvr_setconfig16(hw,
+			HFA384x_RID_CNFROAMINGMODE,
+			HFA384x_ROAMMODE_HOSTSCAN_HOSTROAM);
+		if ( result ) {
+			WLAN_LOG_ERROR("setconfig(ROAMINGMODE) failed. result=%d\n", result);
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* Construct a bogus SSID and assign it to OwnSSID and
+		 * DesiredSSID
+		 */
+		wordbuf[0] = host2hfa384x_16(WLAN_SSID_MAXLEN);
+		get_random_bytes(&wordbuf[1], WLAN_SSID_MAXLEN);
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				wordbuf, HFA384x_RID_CNFOWNSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set OwnSSID.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
+				wordbuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set DesiredSSID.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* bsstype */
+		result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CNFPORTTYPE,
+				HFA384x_PORTTYPE_IBSS);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CNFPORTTYPE.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		/* ibss options */
+		result = hfa384x_drvr_setconfig16(hw,
+				HFA384x_RID_CREATEIBSS,
+				HFA384x_CREATEIBSS_JOINCREATEIBSS);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CREATEIBSS.\n");
+			msg->resultcode.data =
+				P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("drvr_enable(0) failed. "
+					"result=%d\n", result);
+			msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+		istmpenable = 1;
+	}
+
+        /* Figure out our timeout first Kus, then HZ */
+        timeout = msg->channellist.data.len * msg->maxchanneltime.data;
+	timeout = (timeout * HZ)/1000;
+
+        /* Issue the scan request */
+        hw->scanflag = 0;
+
+	WLAN_HEX_DUMP(5,"hscanreq", &scanreq, sizeof(scanreq));
+
+        result = hfa384x_drvr_setconfig( hw,
+                        HFA384x_RID_HOSTSCAN, &scanreq,
+                        sizeof(hfa384x_HostScanRequest_data_t));
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(SCANREQUEST) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        /* sleep until info frame arrives */
+        wait_event_interruptible_timeout(hw->cmdq, hw->scanflag, timeout);
+
+	msg->numbss.status = P80211ENUM_msgitem_status_data_ok;
+	if (hw->scanflag == -1)
+		hw->scanflag = 0;
+
+	msg->numbss.data = hw->scanflag;
+
+        hw->scanflag = 0;
+
+	/* Disable port if we temporarily enabled it. */
+	if (istmpenable) {
+		result = hfa384x_drvr_disable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("drvr_disable(0) failed. "
+					"result=%d\n", result);
+			msg->resultcode.data =
+			P80211ENUM_resultcode_implementation_failure;
+			goto exit;
+		}
+	}
+
+	/* restore original roaming mode */
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE,
+					  roamingmode);
+        if ( result ) {
+                WLAN_LOG_ERROR("setconfig(ROAMMODE) failed. result=%d\n",
+                                result);
+                msg->resultcode.data =
+                        P80211ENUM_resultcode_implementation_failure;
+                goto exit;
+        }
+
+        result = 0;
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+ exit:
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_scan_results
+*
+* Retrieve the BSS description for one of the BSSs identified in
+* a scan.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_scan_results(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+        p80211msg_dot11req_scan_results_t       *req;
+	hfa384x_t		*hw = wlandev->priv;
+	hfa384x_HScanResultSub_t *item = NULL;
+
+	int count;
+
+	DBFENTER;
+
+        req = (p80211msg_dot11req_scan_results_t *) msgp;
+
+	req->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	if (hw->ap) {
+		result = 1;
+		req->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto exit;
+	}
+
+	if (! hw->scanresults) {
+		WLAN_LOG_ERROR("dot11req_scan_results can only be used after a successful dot11req_scan.\n");
+		result = 2;
+		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto exit;
+	}
+
+        count = (hw->scanresults->framelen - 3) / 32;
+	if (count > 32)  count = 32;
+
+	if (req->bssindex.data >= count) {
+		WLAN_LOG_DEBUG(0, "requested index (%d) out of range (%d)\n",
+				req->bssindex.data, count);
+		result = 2;
+		req->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto exit;
+	}
+
+	item = &(hw->scanresults->info.hscanresult.result[req->bssindex.data]);
+	/* signal and noise */
+	req->signal.status = P80211ENUM_msgitem_status_data_ok;
+	req->noise.status = P80211ENUM_msgitem_status_data_ok;
+	req->signal.data = hfa384x2host_16(item->sl);
+	req->noise.data = hfa384x2host_16(item->anl);
+
+	/* BSSID */
+	req->bssid.status = P80211ENUM_msgitem_status_data_ok;
+	req->bssid.data.len = WLAN_BSSID_LEN;
+	memcpy(req->bssid.data.data, item->bssid, WLAN_BSSID_LEN);
+
+	/* SSID */
+	req->ssid.status = P80211ENUM_msgitem_status_data_ok;
+	req->ssid.data.len = hfa384x2host_16(item->ssid.len);
+	memcpy(req->ssid.data.data, item->ssid.data, req->ssid.data.len);
+
+	/* supported rates */
+        for (count = 0; count < 10 ; count++)
+                if (item->supprates[count] == 0)
+                        break;
+
+#define REQBASICRATE(N) \
+	if ((count >= N) && DOT11_RATE5_ISBASIC_GET(item->supprates[(N)-1])) { \
+		req->basicrate ## N .data = item->supprates[(N)-1]; \
+		req->basicrate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+	}
+	
+	REQBASICRATE(1);
+	REQBASICRATE(2);
+	REQBASICRATE(3);
+	REQBASICRATE(4);
+	REQBASICRATE(5);
+	REQBASICRATE(6);
+	REQBASICRATE(7);
+	REQBASICRATE(8);
+
+#define REQSUPPRATE(N) \
+	if (count >= N) { \
+		req->supprate ## N .data = item->supprates[(N)-1]; \
+		req->supprate ## N .status = P80211ENUM_msgitem_status_data_ok; \
+	}
+	
+	REQSUPPRATE(1);
+	REQSUPPRATE(2);
+	REQSUPPRATE(3);
+	REQSUPPRATE(4);
+	REQSUPPRATE(5);
+	REQSUPPRATE(6);
+	REQSUPPRATE(7);
+	REQSUPPRATE(8);
+
+	/* beacon period */
+	req->beaconperiod.status = P80211ENUM_msgitem_status_data_ok;
+	req->beaconperiod.data = hfa384x2host_16(item->bcnint);
+
+	/* timestamps */
+	req->timestamp.status = P80211ENUM_msgitem_status_data_ok;
+	req->timestamp.data = jiffies;
+	req->localtime.status = P80211ENUM_msgitem_status_data_ok;
+	req->localtime.data = jiffies;
+
+	/* atim window */
+	req->ibssatimwindow.status = P80211ENUM_msgitem_status_data_ok;
+	req->ibssatimwindow.data = hfa384x2host_16(item->atim);
+
+	/* Channel */
+	req->dschannel.status = P80211ENUM_msgitem_status_data_ok;
+	req->dschannel.data = hfa384x2host_16(item->chid);
+
+	/* capinfo bits */
+	count = hfa384x2host_16(item->capinfo);
+
+	/* privacy flag */
+	req->privacy.status = P80211ENUM_msgitem_status_data_ok;
+	req->privacy.data = WLAN_GET_MGMT_CAP_INFO_PRIVACY(count);
+
+	/* cfpollable */
+	req->cfpollable.status = P80211ENUM_msgitem_status_data_ok;
+	req->cfpollable.data = WLAN_GET_MGMT_CAP_INFO_CFPOLLABLE(count);
+
+	/* cfpollreq */
+	req->cfpollreq.status = P80211ENUM_msgitem_status_data_ok;
+	req->cfpollreq.data = WLAN_GET_MGMT_CAP_INFO_CFPOLLREQ(count);
+
+	/* bsstype */
+	req->bsstype.status =  P80211ENUM_msgitem_status_data_ok;
+	req->bsstype.data = (WLAN_GET_MGMT_CAP_INFO_ESS(count)) ?
+		P80211ENUM_bsstype_infrastructure :
+		P80211ENUM_bsstype_independent;
+
+	// item->proberesp_rate
+/*
+	req->fhdwelltime
+	req->fhhopset
+	req->fhhoppattern
+	req->fhhopindex
+        req->cfpdurremaining
+*/
+
+	result = 0;
+	req->resultcode.data = P80211ENUM_resultcode_success;
+
+ exit:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_join
+*
+* Join a BSS whose BSS description was previously obtained with
+* a scan.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_join(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_join_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Implement after scan */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_p2_join
+*
+* Join a specific BSS
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_p2_join(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_join_t	*msg = msgp;
+	UINT16			reg;
+	p80211pstrd_t		*pstr;	
+	UINT8			bytebuf[256];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+        hfa384x_JoinRequest_data_t	joinreq;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		wlandev->macmode = WLAN_MACMODE_NONE;
+
+		/*** STATION ***/
+		/* Set the PortType */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+		/* ess port */
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set Port Type\n");
+			goto failed;
+		}
+
+		/* Set the auth type */
+		if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+			reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
+		} else {
+			reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set Authentication\n");
+			goto failed;
+		}
+
+		/* Turn off all roaming */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFROAMINGMODE, 3);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to Turn off Roaming\n");
+			goto failed;
+		}
+
+		/* Basic rates */
+                reg = 0;
+		if ( msg->basicrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg = p80211rate_to_p2bit(msg->basicrate1.data);
+		}
+		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate2.data);
+		}
+		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate3.data);
+		}
+		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate4.data);
+		}
+		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate5.data);
+		}
+		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate6.data);
+		}
+		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate7.data);
+		}
+		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->basicrate8.data);
+		}
+		if( reg == 0)
+			 reg = 0x03;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", reg);
+			goto failed;
+		}
+
+		/* Operational rates (supprates and txratecontrol) */
+		reg = 0;
+		if ( msg->operationalrate1.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg = p80211rate_to_p2bit(msg->operationalrate1.data);
+		}
+		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate2.data);
+		}
+		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate3.data);
+		}
+		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate4.data);
+		}
+		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate5.data);
+		}
+		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate6.data);
+		}
+		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate7.data);
+		}
+		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			reg |= p80211rate_to_p2bit(msg->operationalrate8.data);
+		}
+		if( reg == 0)
+			 reg = 0x0f;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", reg);
+			goto failed;
+		}
+
+ 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", reg);
+			goto failed;
+		}
+
+		/* Set the ssid */
+		memset(bytebuf, 0, 256);
+		pstr = (p80211pstrd_t*)&(msg->ssid.data);
+		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+		result = hfa384x_drvr_setconfig( 
+			hw, HFA384x_RID_CNFDESIREDSSID,
+			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set SSID\n");
+			goto failed;
+		}
+				        
+		/* Enable the Port */
+		result = hfa384x_cmd_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+			goto failed;
+		}
+
+		/* Fill in the join request */
+		joinreq.channel = msg->channel.data;
+		memcpy( joinreq.bssid, ((unsigned char *) &msg->bssid.data) + 1, WLAN_BSSID_LEN);
+		hw->joinreq = joinreq;
+		hw->join_ap = 1;
+
+		/* Send the join request */
+		result = hfa384x_drvr_setconfig( hw, 
+			HFA384x_RID_JOINREQUEST,
+			&joinreq, HFA384x_RID_JOINREQUEST_LEN);
+                if(result != 0) {
+			WLAN_LOG_ERROR("Join request failed, result=%d.\n", result);
+			goto failed;
+		}
+
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+        goto done;
+failed:
+	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+        result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_authenticate
+*
+* Station should be begin an authentication exchange.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_authenticate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_authenticate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Decide how we're going to handle this one w/ Prism2 */
+		/*       It could be entertaining since Prism2 doesn't have  */
+		/*       an explicit way to control this */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported by APs */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_deauthenticate
+*
+* Send a deauthenticate notification.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_deauthenticate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_deauthenticate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Decide how we're going to handle this one w/ Prism2 */
+		/*       It could be entertaining since Prism2 doesn't have  */
+		/*       an explicit way to control this */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_associate
+*
+* Associate with an ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_associate(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	int 			result = 0;
+	p80211msg_dot11req_associate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+#if 0
+		/* Set the TxRates */
+		reg = 0x000f;
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, reg);
+#endif
+
+		/* Set the PortType */
+		/* ess port */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 1);
+
+		/* Enable the Port */
+		hfa384x_drvr_enable(hw, 0);
+	
+		/* Set the resultcode */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_reassociate
+*
+* Renew association because of a BSS change.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_reassociate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_reassociate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Not supported yet...not sure how we're going to do it */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_disassociate
+*
+* Send a disassociation notification.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_disassociate(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_disassociate_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* TODO: Not supported yet...not sure how to do it */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	} else {
+
+		/*** ACCESS POINT ***/
+		hfa384x_drvr_handover(hw, msg->peerstaaddress.data.data);
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_reset
+*
+* Reset the MAC and MSD.  The p80211 layer has it's own handling
+* that should be done before and after this function.
+* Procedure:
+*   - disable system interrupts ??
+*   - disable MAC interrupts
+*   - restore system interrupts
+*   - issue the MAC initialize command 
+*   - clear any MSD level state (including timers, queued events,
+*     etc.).  Note that if we're removing timer'd/queue events, we may 
+*     need to have remained in the system interrupt disabled state.
+*     We should be left in the same state that we're in following
+*     driver initialization.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer, MAY BE NULL! for a driver local
+*			call.
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread, commonly wlanctl, but might be rmmod/pci_close.
+----------------------------------------------------------------*/
+int prism2mgmt_reset(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_reset_t	*msg = msgp;
+	DBFENTER;
+
+	/* 
+	 * This is supported on both AP and STA and it's not allowed 
+	 * to fail.
+	 */
+	if ( msgp ) {
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		WLAN_LOG_INFO("dot11req_reset: the macaddress and "
+			"setdefaultmib arguments are currently unsupported.\n");
+	}
+
+	/* 
+	 * If we got this far, the MSD must be in the MSDRUNNING state
+	 * therefore, we must stop and then restart the hw/MAC combo. 
+	 */
+	hfa384x_drvr_stop(hw);
+	result = hfa384x_drvr_start(hw);
+	if (result != 0) {
+		WLAN_LOG_ERROR("dot11req_reset: Initialize command failed,"
+				" bad things will happen from here.\n");
+		return 0;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_start
+*
+* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_start(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_dot11req_start_t	*msg = msgp;
+
+	p80211pstrd_t		*pstr;	
+	UINT8			bytebuf[80];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+	hfa384x_PCFInfo_data_t	*pcfinfo = (hfa384x_PCFInfo_data_t*)bytebuf;
+	UINT16			word;
+	DBFENTER;
+
+	wlandev->macmode = WLAN_MACMODE_NONE;
+
+	/* Set the SSID */
+	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
+
+	if (!hw->ap) {
+		/*** ADHOC IBSS ***/
+		/* see if current f/w is less than 8c3 */
+		if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+					     hw->ident_sta_fw.minor,
+					     hw->ident_sta_fw.variant) <
+		    HFA384x_FIRMWARE_VERSION(0,8,3)) {
+			/* Ad-Hoc not quite supported on Prism2 */
+			msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+			goto done;
+		}	
+		
+  		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	
+		/*** STATION ***/
+		/* Set the REQUIRED config items */
+		/* SSID */
+		pstr = (p80211pstrd_t*)&(msg->ssid.data);
+		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CnfOwnSSID\n");
+			goto failed;
+		}
+		result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFDESIREDSSID,
+				bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set CnfDesiredSSID\n");
+			goto failed;
+		}
+
+		/* bsstype - we use the default in the ap firmware */
+		/* IBSS port */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, 0);
+
+		/* beacon period */
+		word = msg->beaconperiod.data;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
+			goto failed;
+		}
+
+		/* dschannel */
+		word = msg->dschannel.data;
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
+			goto failed;
+		}
+		/* Basic rates */
+		word = p80211rate_to_p2bit(msg->basicrate1.data);
+		if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate2.data);
+		}
+		if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate3.data);
+		}
+		if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate4.data);
+		}
+		if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate5.data);
+		}
+		if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate6.data);
+		}
+		if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate7.data);
+		}
+		if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->basicrate8.data);
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
+			goto failed;
+		}
+
+		/* Operational rates (supprates and txratecontrol) */
+		word = p80211rate_to_p2bit(msg->operationalrate1.data);
+		if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate2.data);
+		}
+		if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate3.data);
+		}
+		if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate4.data);
+		}
+		if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate5.data);
+		}
+		if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate6.data);
+		}
+		if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate7.data);
+		}
+		if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+			word |= p80211rate_to_p2bit(msg->operationalrate8.data);
+		}
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
+			goto failed;
+		}
+
+ 		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, word);
+		if ( result ) {
+			WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
+			goto failed;
+		}
+
+		/* Set the macmode so the frame setup code knows what to do */
+		if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+			wlandev->macmode = WLAN_MACMODE_IBSS_STA;
+			/* lets extend the data length a bit */
+			hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
+		}
+
+		/* Enable the Port */
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+			goto failed;
+		}
+	
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* Validate the command, if BSStype=infra is the tertiary loaded? */
+	if ( msg->bsstype.data == P80211ENUM_bsstype_independent ) {
+		WLAN_LOG_ERROR("AP driver cannot create IBSS.\n");
+		goto failed;
+	} else if ( hw->cap_sup_sta.id != 5) {
+		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
+		goto failed;
+	}
+
+	/* Set the REQUIRED config items */
+	/* SSID */
+	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CNFOWNSSID,
+				bytebuf, HFA384x_RID_CNFOWNSSID_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set SSID, result=0x%04x\n", result);
+		goto failed;
+	}
+
+	/* bsstype - we use the default in the ap firmware */
+
+	/* beacon period */
+	word = msg->beaconperiod.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAPBCNINT, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set beacon period=%d.\n", word);
+		goto failed;
+	}
+
+	/* dschannel */
+	word = msg->dschannel.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNCHANNEL, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set channel=%d.\n", word);
+		goto failed;
+	}
+	/* Basic rates */
+	word = p80211rate_to_p2bit(msg->basicrate1.data);
+	if ( msg->basicrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate2.data);
+	}
+	if ( msg->basicrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate3.data);
+	}
+	if ( msg->basicrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate4.data);
+	}
+	if ( msg->basicrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate5.data);
+	}
+	if ( msg->basicrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate6.data);
+	}
+	if ( msg->basicrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate7.data);
+	}
+	if ( msg->basicrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->basicrate8.data);
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFBASICRATES, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set basicrates=%d.\n", word);
+		goto failed;
+	}
+
+	/* Operational rates (supprates and txratecontrol) */
+	word = p80211rate_to_p2bit(msg->operationalrate1.data);
+	if ( msg->operationalrate2.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate2.data);
+	}
+	if ( msg->operationalrate3.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate3.data);
+	}
+	if ( msg->operationalrate4.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate4.data);
+	}
+	if ( msg->operationalrate5.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate5.data);
+	}
+	if ( msg->operationalrate6.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate6.data);
+	}
+	if ( msg->operationalrate7.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate7.data);
+	}
+	if ( msg->operationalrate8.status == P80211ENUM_msgitem_status_data_ok ) {
+		word |= p80211rate_to_p2bit(msg->operationalrate8.data);
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set supprates=%d.\n", word);
+		goto failed;
+	}
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL0, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set txrates=%d.\n", word);
+		goto failed;
+	}
+
+	/* ibssatimwindow */
+	if (msg->ibssatimwindow.status == P80211ENUM_msgitem_status_data_ok) {
+		WLAN_LOG_INFO("prism2mgmt_start: atimwindow not used in "
+			       "Infrastructure mode, ignored.\n");
+	}
+
+	/* DTIM period */
+	word = msg->dtimperiod.data;
+	result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFOWNDTIMPER, word);
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to set dtim period=%d.\n", word);
+		goto failed;
+	}
+
+	/* probedelay */
+	if (msg->probedelay.status == P80211ENUM_msgitem_status_data_ok) {
+		WLAN_LOG_INFO("prism2mgmt_start: probedelay not "
+			       "supported in prism2, ignored.\n");
+	}
+
+	/* cfpollable, cfpollreq, cfpperiod, cfpmaxduration */
+	if (msg->cfpollable.data == P80211ENUM_truth_true && 
+	    msg->cfpollreq.data == P80211ENUM_truth_true ) {
+		WLAN_LOG_ERROR("cfpollable=cfpollreq=true is illegal.\n");
+		result = -1;
+		goto failed;
+	}
+
+	/* read the PCFInfo and update */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFAPPCFINFO, 
+					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
+	if ( result ) {
+		WLAN_LOG_INFO("prism2mgmt_start: read(pcfinfo) failed, "
+				"assume it's "
+				"not supported, pcf settings ignored.\n");
+		goto pcf_skip;
+	}
+	if ((msg->cfpollable.data == P80211ENUM_truth_false && 
+	     msg->cfpollreq.data == P80211ENUM_truth_false) ) {
+	    	pcfinfo->MediumOccupancyLimit = 0;
+		pcfinfo->CFPPeriod = 0;
+		pcfinfo->CFPMaxDuration = 0;
+		pcfinfo->CFPFlags &= host2hfa384x_16((UINT16)~BIT0);
+		
+		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok ||
+		     msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok ) {
+			WLAN_LOG_WARNING(
+				"Setting cfpperiod or cfpmaxduration when "
+				"cfpollable and cfreq are false is pointless.\n");
+		}
+	}
+	if ((msg->cfpollable.data == P80211ENUM_truth_true ||
+	     msg->cfpollreq.data == P80211ENUM_truth_true) ) {
+		if ( msg->cfpollable.data == P80211ENUM_truth_true) {
+			pcfinfo->CFPFlags |= host2hfa384x_16((UINT16)BIT0);
+		}
+
+		if ( msg->cfpperiod.status == P80211ENUM_msgitem_status_data_ok) {
+			pcfinfo->CFPPeriod = msg->cfpperiod.data;
+			pcfinfo->CFPPeriod = host2hfa384x_16(pcfinfo->CFPPeriod);
+		}
+
+		if ( msg->cfpmaxduration.status == P80211ENUM_msgitem_status_data_ok) {
+			pcfinfo->CFPMaxDuration = msg->cfpmaxduration.data;
+			pcfinfo->CFPMaxDuration = host2hfa384x_16(pcfinfo->CFPMaxDuration); 
+			pcfinfo->MediumOccupancyLimit = pcfinfo->CFPMaxDuration;
+		}
+	}
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFAPPCFINFO, 
+					pcfinfo, HFA384x_RID_CNFAPPCFINFO_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("write(pcfinfo) failed.\n");
+		goto failed;
+	}
+
+pcf_skip:
+	/* Set the macmode so the frame setup code knows what to do */
+	if ( msg->bsstype.data == P80211ENUM_bsstype_infrastructure ) {
+		wlandev->macmode = WLAN_MACMODE_ESS_AP;
+		/* lets extend the data length a bit */
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN, 2304);
+	}
+
+	/* Set the BSSID to the same as our MAC */
+	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
+
+	/* Enable the Port */
+	result = hfa384x_drvr_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		goto failed;
+	}
+	
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	goto done;
+failed:
+	WLAN_LOG_DEBUG(1, "Failed to set a config option, result=%d\n", result);
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+	result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_enable
+*
+* Start a BSS.  Any station can do this for IBSS, only AP for ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_enable(wlandevice_t *wlandev, void *msgp)
+{
+	int			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_enable_t	*msg = msgp;
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Ad-Hoc not quite supported on Prism2 */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* Is the tertiary loaded? */
+	if ( hw->cap_sup_sta.id != 5) {
+		WLAN_LOG_ERROR("AP driver failed to detect AP firmware.\n");
+		goto failed;
+	}
+
+	/* Set the macmode so the frame setup code knows what to do */
+	wlandev->macmode = WLAN_MACMODE_ESS_AP;
+
+	/* Set the BSSID to the same as our MAC */
+	memcpy( wlandev->bssid, wlandev->netdev->dev_addr, WLAN_BSSID_LEN);
+
+	/* Enable the Port */
+	result = hfa384x_drvr_enable(hw, 0);
+	if ( result ) {
+		WLAN_LOG_ERROR("Enable macport failed, result=%d.\n", result);
+		goto failed;
+	}
+	
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	goto done;
+failed:
+	msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+
+done:
+	result = 0;
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_readpda
+*
+* Collect the PDA data and put it in the message.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_readpda(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_readpda_t	*msg = msgp;
+	int				result;
+	DBFENTER;
+
+	/* We only support collecting the PDA when in the FWLOAD
+	 * state.
+	 */
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"PDA may only be read "
+			"in the fwload state.\n");
+		msg->resultcode.data = 
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	} else {
+		/*  Call drvr_readpda(), it handles the auxport enable
+		 *  and validating the returned PDA.
+		 */
+		result = hfa384x_drvr_readpda(
+			hw, 
+			msg->pda.data, 
+			HFA384x_PDA_LEN_MAX);
+		if (result) {
+			WLAN_LOG_ERROR(
+				"hfa384x_drvr_readpda() failed, "
+				"result=%d\n",
+				result);
+			
+			msg->resultcode.data = 
+				P80211ENUM_resultcode_implementation_failure;
+			msg->resultcode.status = 
+				P80211ENUM_msgitem_status_data_ok;
+			DBFEXIT;
+			return 0;
+		}
+		msg->pda.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_readcis
+*
+* Collect the CIS data and put it in the message.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_readcis(wlandevice_t *wlandev, void *msgp)
+{
+	int			result;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_readcis_t	*msg = msgp;
+
+	DBFENTER;
+
+        memset(msg->cis.data, 0, sizeof(msg->cis.data));
+
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CIS, 
+					msg->cis.data, HFA384x_RID_CIS_LEN);
+	if ( result ) {
+		WLAN_LOG_INFO("prism2mgmt_readcis: read(cis) failed.\n");
+		msg->cis.status = P80211ENUM_msgitem_status_no_value;
+		msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		
+		}
+	else {
+		msg->cis.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_state
+*
+* Enables/Disables the card's auxiliary port.  Should be called 
+* before and after a sequence of auxport_read()/auxport_write() 
+* calls.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_state(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_auxport_state_t	*msg = msgp;
+
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if (msg->enable.data == P80211ENUM_truth_true) {
+		if ( hfa384x_cmd_aux_enable(hw, 0) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_cmd_aux_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+#else /* !USB */
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+
+#endif /* WLAN_HOSTIF != WLAN_USB */
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_read
+*
+* Copies data from the card using the auxport.  The auxport must
+* have previously been enabled.  Note: this is not the way to 
+* do downloads, see the [ram|flash]dl functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_read(wlandevice_t *wlandev, void *msgp)
+{
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_auxport_read_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8*			buf;
+	UINT32			maxlen = sizeof(msg->data.data);
+	DBFENTER;
+
+	if ( hw->auxen ) {
+		addr = msg->addr.data;
+		len = msg->len.data;
+		buf = msg->data.data;
+		if ( len <= maxlen ) {  /* max read/write size */
+			hfa384x_copy_from_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		} else {
+			WLAN_LOG_DEBUG(1,"Attempt to read > maxlen from auxport.\n");
+			msg->resultcode.data = P80211ENUM_resultcode_refused;
+		}
+
+	} else {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+	}
+	msg->data.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+#else
+	DBFENTER;
+
+	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
+
+	DBFEXIT;
+	return 0;
+#endif
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_auxport_write
+*
+* Copies data to the card using the auxport.  The auxport must
+* have previously been enabled.  Note: this is not the way to 
+* do downloads, see the [ram|flash]dl functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_auxport_write(wlandevice_t *wlandev, void *msgp)
+{
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_auxport_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8*			buf;
+	UINT32			maxlen = sizeof(msg->data.data);
+	DBFENTER;
+
+	if ( hw->auxen ) {
+		addr = msg->addr.data;
+		len = msg->len.data;
+		buf = msg->data.data;
+		if ( len <= maxlen ) {  /* max read/write size */
+			hfa384x_copy_to_aux(hw, addr, HFA384x_AUX_CTL_EXTDS, buf, len);
+		} else {
+			WLAN_LOG_DEBUG(1,"Attempt to write > maxlen from auxport.\n");
+			msg->resultcode.data = P80211ENUM_resultcode_refused;
+		}
+
+	} else {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+	}
+	msg->data.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	DBFEXIT;
+	return 0;
+#else
+	DBFENTER;
+	WLAN_LOG_ERROR("prism2mgmt_auxport_read: Not supported on USB.\n");
+	DBFEXIT;
+	return 0;
+#endif
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_low_level
+*
+* Puts the card into the desired test mode.
+*
+* Arguments:
+*       wlandev         wlan device structure
+*       msgp            ptr to msg buffer
+*
+* Returns:
+*       0       success and done
+*       <0      success, but we're waiting for something to finish.
+*       >0      an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*       process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_low_level(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+        p80211msg_p2req_low_level_t     *msg = msgp;
+	hfa384x_metacmd_t cmd;
+        DBFENTER;
+
+        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+        /* call some routine to execute the test command */
+	cmd.cmd = (UINT16) msg->command.data;
+	cmd.parm0 = (UINT16) msg->param0.data;
+	cmd.parm1 = (UINT16) msg->param1.data;
+	cmd.parm2 = (UINT16) msg->param2.data;
+
+        hfa384x_drvr_low_level(hw,&cmd);
+
+        msg->resp0.data = (UINT32) cmd.result.resp0;
+        msg->resp1.data = (UINT32) cmd.result.resp1;
+        msg->resp2.data = (UINT32) cmd.result.resp2;
+
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+        DBFEXIT;
+        return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_test_command
+*
+* Puts the card into the desired test mode.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_test_command(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_test_command_t	*msg = msgp;
+	hfa384x_metacmd_t cmd;
+
+        DBFENTER;
+
+	cmd.cmd = ((UINT16) msg->testcode.data) << 8 | 0x38;
+	cmd.parm0 = (UINT16) msg->testparam.data;
+	cmd.parm1 = 0;
+	cmd.parm2 = 0;
+
+        /* call some routine to execute the test command */
+
+        hfa384x_drvr_low_level(hw,&cmd);
+
+        msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resultcode.data = P80211ENUM_resultcode_success;
+
+        msg->status.status = P80211ENUM_msgitem_status_data_ok;
+        msg->status.data = cmd.result.status;
+        msg->resp0.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp0.data = cmd.result.resp0;
+        msg->resp1.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp1.data = cmd.result.resp1;
+        msg->resp2.status = P80211ENUM_msgitem_status_data_ok;
+        msg->resp2.data = cmd.result.resp2;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_mmi_read
+*
+* Read from one of the MMI registers.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_mmi_read(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_mmi_read_t	*msg = msgp;
+	UINT32 resp = 0;
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* call some routine to execute the test command */
+
+	hfa384x_drvr_mmi_read(hw, msg->addr.data, &resp);
+
+	/* I'm not sure if this is "architecturally" correct, but it
+           is expedient. */
+
+	msg->value.status = P80211ENUM_msgitem_status_data_ok;
+	msg->value.data = resp;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_mmi_write
+*
+* Write a data value to one of the MMI registers.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_mmi_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_mmi_write_t	*msg = msgp;
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+
+	/* call some routine to execute the test command */
+
+	hfa384x_drvr_mmi_write(hw, msg->addr.data, msg->data.data);
+
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_ramdl_state
+*
+* Establishes the beginning/end of a card RAM download session.
+*
+* It is expected that the ramdl_write() function will be called 
+* one or more times between the 'enable' and 'disable' calls to
+* this function.
+*
+* Note: This function should not be called when a mac comm port 
+*       is active.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_ramdl_state(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_ramdl_state_t	*msg = msgp;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"ramdl_state(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data = 
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if  ( msg->enable.data == P80211ENUM_truth_true ) {
+		if ( hfa384x_drvr_ramdl_enable(hw, msg->exeaddr.data) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_drvr_ramdl_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_ramdl_write
+*
+* Writes a buffer to the card RAM using the download state.  This
+* is for writing code to card RAM.  To just read or write raw data
+* use the aux functions.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_ramdl_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_ramdl_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8			*buf;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"ramdl_write(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data = 
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	/* first validate the length */
+	if  ( msg->len.data > sizeof(msg->data.data) ) {
+		msg->resultcode.status = P80211ENUM_resultcode_invalid_parameters;
+		return 0;
+	}
+	/* call the hfa384x function to do the write */
+	addr = msg->addr.data;
+	len = msg->len.data;
+	buf = msg->data.data;
+	if ( hfa384x_drvr_ramdl_write(hw, addr, buf, len) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+		
+	}
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_flashdl_state
+*
+* Establishes the beginning/end of a card Flash download session.
+*
+* It is expected that the flashdl_write() function will be called 
+* one or more times between the 'enable' and 'disable' calls to
+* this function.
+*
+* Note: This function should not be called when a mac comm port 
+*       is active.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_flashdl_state(wlandevice_t *wlandev, void *msgp)
+{
+	int			result = 0;
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_flashdl_state_t	*msg = msgp;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"flashdl_state(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data = 
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	if  ( msg->enable.data == P80211ENUM_truth_true ) {
+		if ( hfa384x_drvr_flashdl_enable(hw) ) {
+			msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_success;
+		}
+	} else {
+		hfa384x_drvr_flashdl_disable(hw);
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		/* NOTE: At this point, the MAC is in the post-reset
+		 * state and the driver is in the fwload state.
+		 * We need to get the MAC back into the fwload
+		 * state.  To do this, we set the nsdstate to HWPRESENT
+		 * and then call the ifstate function to redo everything
+		 * that got us into the fwload state.
+		 */
+		wlandev->msdstate = WLAN_MSD_HWPRESENT;
+		result = prism2sta_ifstate(wlandev, P80211ENUM_ifstate_fwload);
+		if (result != P80211ENUM_resultcode_success) {
+			WLAN_LOG_ERROR("prism2sta_ifstate(fwload) failed,"
+				"P80211ENUM_resultcode=%d\n", result);
+			msg->resultcode.data = 
+				P80211ENUM_resultcode_implementation_failure;
+			result = -1;
+		}
+	}
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_flashdl_write
+*
+* 
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_flashdl_write(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	p80211msg_p2req_flashdl_write_t	*msg = msgp;
+	UINT32			addr;
+	UINT32			len;
+	UINT8			*buf;
+	DBFENTER;
+
+	if (wlandev->msdstate != WLAN_MSD_FWLOAD) {
+		WLAN_LOG_ERROR(
+			"flashdl_write(): may only be called "
+			"in the fwload state.\n");
+		msg->resultcode.data = 
+			P80211ENUM_resultcode_implementation_failure;
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		DBFEXIT;
+		return 0;
+	}
+
+	/*
+	** Note: Interrupts are locked out if this is an AP and are NOT
+	** locked out if this is a station.
+	*/
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	/* first validate the length */
+	if  ( msg->len.data > sizeof(msg->data.data) ) {
+		msg->resultcode.status = 
+			P80211ENUM_resultcode_invalid_parameters;
+		return 0;
+	}
+	/* call the hfa384x function to do the write */
+	addr = msg->addr.data;
+	len = msg->len.data;
+	buf = msg->data.data;
+	if ( hfa384x_drvr_flashdl_write(hw, addr, buf, len) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_refused;
+		
+	}
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_dump_state
+*
+* Dumps the driver's and hardware's current state via the kernel 
+* log at KERN_NOTICE level.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_dump_state(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_dump_state_t	*msg = msgp;
+	int				result = 0;
+
+#if (WLAN_HOSTIF != WLAN_USB)
+	hfa384x_t		*hw = wlandev->priv;
+	UINT16				auxbuf[15];
+	DBFENTER;
+
+	WLAN_LOG_NOTICE("prism2 driver and hardware state:\n");
+	if  ( (result = hfa384x_cmd_aux_enable(hw, 0)) ) {
+		WLAN_LOG_ERROR("aux_enable failed, result=%d\n", result);
+		goto failed;
+	}
+	hfa384x_copy_from_aux(hw, 
+		0x01e2, 
+		HFA384x_AUX_CTL_EXTDS, 
+		auxbuf, 
+		sizeof(auxbuf));
+	hfa384x_cmd_aux_disable(hw);
+	WLAN_LOG_NOTICE("  cmac: FreeBlocks=%d\n", auxbuf[5]);
+	WLAN_LOG_NOTICE("  cmac: IntEn=0x%02x EvStat=0x%02x\n", 
+		hfa384x_getreg(hw, HFA384x_INTEN),
+		hfa384x_getreg(hw, HFA384x_EVSTAT));
+
+	#ifdef USE_FID_STACK
+	WLAN_LOG_NOTICE("  drvr: txfid_top=%d stacksize=%d\n",
+		hw->txfid_top,HFA384x_DRVR_FIDSTACKLEN_MAX);
+	#else
+	WLAN_LOG_NOTICE("  drvr: txfid_head=%d txfid_tail=%d txfid_N=%d\n",
+		hw->txfid_head, hw->txfid_tail, hw->txfid_N);
+	#endif
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+#else /* (WLAN_HOSTIF == WLAN_USB) */
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+	goto failed;
+
+#endif /* (WLAN_HOSTIF != WLAN_USB) */
+
+failed:	
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_channel_info
+*
+* Issues a ChannelInfoRequest.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_channel_info(wlandevice_t *wlandev, void *msgp)
+{
+	p80211msg_p2req_channel_info_t	*msg=msgp;
+	hfa384x_t			*hw = wlandev->priv;
+	int				result, i, n=0;
+	UINT16				channel_mask=0;
+	hfa384x_ChannelInfoRequest_data_t	chinforeq;
+	// unsigned long 			now;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Not supported in STA f/w */
+		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+#define CHINFO_TIMEOUT 2
+
+	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
+
+	/* setting default value for channellist = all channels */
+	if (!msg->channellist.data) {
+		P80211_SET_INT(msg->channellist, 0x00007FFE);
+	}
+	/* setting default value for channeldwelltime = 100 ms */
+	if (!msg->channeldwelltime.data) {
+		P80211_SET_INT(msg->channeldwelltime, 100);
+	}
+	channel_mask = (UINT16) (msg->channellist.data >> 1);
+	for (i=0, n=0; i < 14; i++) {
+		if (channel_mask & (1<<i)) {
+			n++;
+		}
+	}
+	P80211_SET_INT(msg->numchinfo, n);
+	chinforeq.channelList = host2hfa384x_16(channel_mask);
+	chinforeq.channelDwellTime = host2hfa384x_16(msg->channeldwelltime.data);
+
+	atomic_set(&hw->channel_info.done, 1);
+
+	result = hfa384x_drvr_setconfig( hw, HFA384x_RID_CHANNELINFOREQUEST,
+					 &chinforeq, HFA384x_RID_CHANNELINFOREQUEST_LEN);
+	if ( result ) {
+		WLAN_LOG_ERROR("setconfig(CHANNELINFOREQUEST) failed. result=%d\n",
+				result);
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+	/*
+	now = jiffies;
+	while (atomic_read(&hw->channel_info.done) != 1) {
+		if ((jiffies - now) > CHINFO_TIMEOUT*HZ) {
+			WLAN_LOG_NOTICE("ChannelInfo results not received in %d seconds, aborting.\n", 
+					CHINFO_TIMEOUT);
+			msg->resultcode.data = P80211ENUM_resultcode_timeout;
+			goto done;
+		}
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(HZ/4);
+		current->state = TASK_RUNNING;
+	} 
+	*/
+
+done:
+
+	DBFEXIT;
+	return 0;
+}
+
+/*----------------------------------------------------------------
+* prism2mgmt_channel_info_results
+*
+* Returns required ChannelInfo result.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+----------------------------------------------------------------*/
+int prism2mgmt_channel_info_results(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t			*hw = wlandev->priv;
+
+	p80211msg_p2req_channel_info_results_t	*msg=msgp;
+	int				result=0;
+	int		channel;
+
+	DBFENTER;
+
+	if (!hw->ap) {
+
+		/*** STATION ***/
+
+		/* Not supported in STA f/w */
+		P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_not_supported);
+		goto done;
+	}
+
+	/*** ACCESS POINT ***/
+
+	switch (atomic_read(&hw->channel_info.done)) {
+	case 0: msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+		goto done;
+	case 1: msg->resultcode.status = P80211ENUM_msgitem_status_incomplete_itemdata;
+		goto done;
+	}
+
+	P80211_SET_INT(msg->resultcode, P80211ENUM_resultcode_success);
+	channel=msg->channel.data-1;
+	
+	if (channel < 0 || ! (hw->channel_info.results.scanchannels & 1<<channel) ) {
+		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		goto done;
+	}
+	WLAN_LOG_DEBUG(2, "chinfo_results: channel %d, avg/peak level=%d/%d dB, active=%d\n",
+			channel+1, 
+			hw->channel_info.results.result[channel].anl,
+			hw->channel_info.results.result[channel].pnl, 
+			hw->channel_info.results.result[channel].active
+		);
+	P80211_SET_INT(msg->avgnoiselevel, hw->channel_info.results.result[channel].anl);
+	P80211_SET_INT(msg->peaknoiselevel, hw->channel_info.results.result[channel].pnl);
+	P80211_SET_INT(msg->bssactive, hw->channel_info.results.result[channel].active & 
+		HFA384x_CHINFORESULT_BSSACTIVE 
+                ? P80211ENUM_truth_true
+                : P80211ENUM_truth_false) ;
+	P80211_SET_INT(msg->pcfactive, hw->channel_info.results.result[channel].active & 
+		HFA384x_CHINFORESULT_PCFACTIVE
+                ? P80211ENUM_truth_true
+                : P80211ENUM_truth_false) ;
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_autojoin
+*
+* Associate with an ESS.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_autojoin(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t			*hw = wlandev->priv;
+	int 			result = 0;
+	UINT16			reg;
+	UINT16			port_type;
+	p80211msg_lnxreq_autojoin_t	*msg = msgp;
+	p80211pstrd_t		*pstr;	
+	UINT8			bytebuf[256];
+	hfa384x_bytestr_t	*p2bytestr = (hfa384x_bytestr_t*)bytebuf;
+	DBFENTER;
+
+	wlandev->macmode = WLAN_MACMODE_NONE;
+
+	/* Set the SSID */
+	memcpy(&wlandev->ssid, &msg->ssid.data, sizeof(msg->ssid.data));
+
+	if (hw->ap) {
+
+		/*** ACCESS POINT ***/
+
+		/* Never supported on AP */
+		msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+
+	/* Disable the Port */
+	hfa384x_drvr_disable(hw, 0);
+
+	/*** STATION ***/
+	/* Set the TxRates */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_TXRATECNTL, 0x000f);
+
+	/* Set the auth type */
+	if ( msg->authtype.data == P80211ENUM_authalg_sharedkey ) {
+		reg = HFA384x_CNFAUTHENTICATION_SHAREDKEY;
+	} else {
+		reg = HFA384x_CNFAUTHENTICATION_OPENSYSTEM;
+	}
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFAUTHENTICATION, reg);
+
+	/* Set the ssid */
+	memset(bytebuf, 0, 256);
+	pstr = (p80211pstrd_t*)&(msg->ssid.data);
+	prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+        result = hfa384x_drvr_setconfig( 
+			hw, HFA384x_RID_CNFDESIREDSSID,
+			bytebuf, HFA384x_RID_CNFDESIREDSSID_LEN);
+#if 0
+	/* we can use the new-fangled auto-unknown mode if the firmware
+	   is 1.3.3 or newer */
+	if (HFA384x_FIRMARE_VERSION(hw->ident_sta_fw.major,
+				    hw->ident_sta_fw.minor,
+				    hw->ident_sta_fw.variant) >=
+	    HFA384x_FIRMWARE_VERSION(1,3,3)) {
+		/* Set up the IBSS options */
+		reg =  HFA384x_CREATEIBSS_JOINESS_JOINCREATEIBSS;
+		hfa384x_drvr_setconfig16(hw, HFA384x_RID_CREATEIBSS, reg); 
+	  
+		/* Set the PortType */
+		port_type = HFA384x_PORTTYPE_IBSS;
+	} else {
+		port_type = HFA384x_PORTTYPE_BSS;
+	}			
+#else        
+	port_type = HFA384x_PORTTYPE_BSS;
+#endif
+	/* Set the PortType */
+	hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFPORTTYPE, port_type);
+
+	/* Enable the Port */
+	hfa384x_drvr_enable(hw, 0);
+	
+	/* Set the resultcode */
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_wlansniff
+*
+* Start or stop sniffing.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+int prism2mgmt_wlansniff(wlandevice_t *wlandev, void *msgp)
+{
+	int 			result = 0;
+	p80211msg_lnxreq_wlansniff_t	*msg = msgp;
+
+	hfa384x_t			*hw = wlandev->priv;
+	UINT16			word;
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	switch (msg->enable.data)
+	{
+	case P80211ENUM_truth_false:
+		/* Confirm that we're in monitor mode */
+		if ( wlandev->netdev->type == ARPHRD_ETHER ) {
+			msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+			result = 0;
+			goto exit;
+		}
+		/* Disable monitor mode */
+		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_DISABLE);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				"failed to disable monitor mode, result=%d\n", 
+				result);
+			goto failed;
+		}
+		/* Disable port 0 */
+		result = hfa384x_drvr_disable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to disable port 0 after sniffing, result=%d\n", 
+			result);
+			goto failed;
+		}
+		/* Clear the driver state */
+		wlandev->netdev->type = ARPHRD_ETHER;
+
+		/* Restore the wepflags */
+		result = hfa384x_drvr_setconfig16(hw, 
+				HFA384x_RID_CNFWEPFLAGS, 
+				hw->presniff_wepflags);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to restore wepflags=0x%04x, result=%d\n", 
+			hw->presniff_wepflags,
+			result);
+			goto failed;
+		}
+
+		/* Set the port to its prior type and enable (if necessary) */
+		if (hw->presniff_port_type != 0 ) {
+			word = hw->presniff_port_type;
+			result = hfa384x_drvr_setconfig16(hw, 
+				HFA384x_RID_CNFPORTTYPE, word);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+				"failed to restore porttype, result=%d\n", 
+				result);
+				goto failed;
+			}
+
+			/* Enable the port */
+			result = hfa384x_drvr_enable(hw, 0);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1, "failed to enable port to presniff setting, result=%d\n", result);
+				goto failed;
+			}
+		} else {
+			result = hfa384x_drvr_disable(hw, 0);
+
+		}
+
+		WLAN_LOG_INFO("monitor mode disabled\n");
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		result = 0;
+		goto exit;
+		break;
+	case P80211ENUM_truth_true:
+		/* Disable the port (if enabled), only check Port 0 */
+		if ( hw->port_enabled[0]) {
+			if (wlandev->netdev->type == ARPHRD_ETHER) {
+				/* Save macport 0 state */
+				result = hfa384x_drvr_getconfig16(hw,
+								  HFA384x_RID_CNFPORTTYPE,
+								  &(hw->presniff_port_type));
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,"failed to read porttype, result=%d\n", result);
+					goto failed;
+				}
+				/* Save the wepflags state */
+				result = hfa384x_drvr_getconfig16(hw,
+								  HFA384x_RID_CNFWEPFLAGS,
+								  &(hw->presniff_wepflags));
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,"failed to read wepflags, result=%d\n", result);
+					goto failed;
+				}
+				hfa384x_drvr_stop(hw);
+				result = hfa384x_drvr_start(hw);
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,
+						       "failed to restart the card for sniffing, result=%d\n", 
+						       result);
+					goto failed;
+				}		
+			} else {
+				/* Disable the port */
+				result = hfa384x_drvr_disable(hw, 0);
+				if ( result ) {
+					WLAN_LOG_DEBUG(1,
+						       "failed to enable port for sniffing, result=%d\n", 
+						       result);
+					goto failed;
+				}
+			} 
+		} else {
+			hw->presniff_port_type = 0;
+		}
+
+		/* Set the channel we wish to sniff  */
+		word = msg->channel.data;
+		result = hfa384x_drvr_setconfig16(hw, 
+						  HFA384x_RID_CNFOWNCHANNEL, word);
+		hw->sniff_channel=word;
+		
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				       "failed to set channel %d, result=%d\n", 
+					       word,
+				       result);
+			goto failed;
+		}
+
+		/* Now if we're already sniffing, we can skip the rest */
+		if (wlandev->netdev->type != ARPHRD_ETHER) {		
+			/* Set the port type to pIbss */
+			word = HFA384x_PORTTYPE_PSUEDOIBSS;
+			result = hfa384x_drvr_setconfig16(hw, 
+							  HFA384x_RID_CNFPORTTYPE, word);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "failed to set porttype %d, result=%d\n", 
+					       word,
+					       result);
+				goto failed;
+			}
+			if ((msg->keepwepflags.status == P80211ENUM_msgitem_status_data_ok) && (msg->keepwepflags.data != P80211ENUM_truth_true)) {
+				/* Set the wepflags for no decryption */
+				word = HFA384x_WEPFLAGS_DISABLE_TXCRYPT | 
+					HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
+				result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFWEPFLAGS, word);
+			}
+			
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "failed to set wepflags=0x%04x, result=%d\n", 
+					       word,
+					       result);
+				goto failed;
+			}
+		}
+
+		/* Do we want to strip the FCS in monitor mode? */
+		if ((msg->stripfcs.status == P80211ENUM_msgitem_status_data_ok) && (msg->stripfcs.data == P80211ENUM_truth_true)) {
+			hw->sniff_fcs = 0;
+		} else {
+			hw->sniff_fcs = 1;
+		}
+
+		/* Do we want to truncate the packets? */
+		if (msg->packet_trunc.status == P80211ENUM_msgitem_status_data_ok) {
+			hw->sniff_truncate = msg->packet_trunc.data;
+		} else {
+			hw->sniff_truncate = 0;
+		}
+
+		/* Enable the port */
+		result = hfa384x_drvr_enable(hw, 0);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to enable port for sniffing, result=%d\n", 
+			result);
+			goto failed;
+		}
+		/* Enable monitor mode */
+		result = hfa384x_cmd_monitor(hw, HFA384x_MONITOR_ENABLE);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+			"failed to enable monitor mode, result=%d\n", 
+			result);
+			goto failed;
+		}
+
+		if (wlandev->netdev->type == ARPHRD_ETHER) {
+			WLAN_LOG_INFO("monitor mode enabled\n");
+		}
+
+		/* Set the driver state */
+		/* Do we want the prism2 header? */
+		if ((msg->prismheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->prismheader.data == P80211ENUM_truth_true)) {
+			hw->sniffhdr = 0;
+			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
+		} else if ((msg->wlanheader.status == P80211ENUM_msgitem_status_data_ok) && (msg->wlanheader.data == P80211ENUM_truth_true)) {
+			hw->sniffhdr = 1;
+			wlandev->netdev->type = ARPHRD_IEEE80211_PRISM;
+		} else {
+			wlandev->netdev->type = ARPHRD_IEEE80211;
+		}
+
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		result = 0;
+		goto exit;
+		break;
+	default:
+		msg->resultcode.data = P80211ENUM_resultcode_invalid_parameters;
+		result = 0;
+		goto exit;
+		break;
+	}
+
+failed:
+	msg->resultcode.data = P80211ENUM_resultcode_refused;
+	result = 0;
+exit:	
+
+	DBFEXIT;
+	return result;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2mib.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2mib.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2mib.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2mib.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,3798 @@
+/* src/prism2/driver/prism2mib.c
+*
+* Management request for mibset/mibget
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* The functions in this file handle the mibset/mibget management
+* functions.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include <wlan/version.h>
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+
+#include <wlan/wlan_compat.h>
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+#endif
+
+#if ((WLAN_HOSTIF == WLAN_PLX) || (WLAN_HOSTIF == WLAN_PCI))
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#endif
+
+#if (WLAN_HOSTIF == WLAN_USB)
+#include <linux/usb.h>
+#endif
+
+#include <wlan/wlan_compat.h>
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+#include <prism2/hfa384x.h>
+#include <prism2/prism2mgmt.h>
+
+/*================================================================*/
+/* Local Constants */
+
+#define MIB_TMP_MAXLEN    200    /* Max length of RID record (in bytes). */
+
+/*================================================================*/
+/* Local Types */
+
+#define  F_AP         0x1        /* MIB is supported on Access Points. */
+#define  F_STA        0x2        /* MIB is supported on stations. */
+#define  F_READ       0x4        /* MIB may be read. */
+#define  F_WRITE      0x8        /* MIB may be written. */
+
+typedef struct mibrec
+{
+    UINT32   did;
+    UINT16   flag;
+    UINT16   parm1;
+    UINT16   parm2;
+    UINT16   parm3;
+    int      (*func)(struct mibrec                *mib,
+                     int                          isget,
+                     wlandevice_t                 *wlandev,
+                     hfa384x_t                    *hw,
+                     p80211msg_dot11req_mibset_t  *msg,
+                     void                         *data);
+} mibrec_t;
+
+/*================================================================*/
+/* Local Function Declarations */
+
+static int prism2mib_bytestr2pstr(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_bytearea2pstr(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_uint32(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_uint32array(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_uint32offset(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_truth(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_preamble(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_flag(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_appcfinfoflag(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_regulatorydomains(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_wepdefaultkey(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_powermanagement(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_privacyinvoked(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_excludeunencrypted(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_fragmentationthreshold(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_operationalrateset(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_groupaddress(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_fwid(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_authalg(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_authalgenable(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static int prism2mib_priv(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data);
+
+static void prism2mib_priv_authlist(
+hfa384x_t      *hw,
+prism2sta_authlist_t  *list);
+
+static void prism2mib_priv_accessmode(
+hfa384x_t         *hw,
+UINT32            mode);
+
+static void prism2mib_priv_accessallow(
+hfa384x_t         *hw,
+p80211macarray_t  *macarray);
+
+static void prism2mib_priv_accessdeny(
+hfa384x_t         *hw,
+p80211macarray_t  *macarray);
+
+static void prism2mib_priv_deauthenticate(
+hfa384x_t         *hw,
+UINT8             *addr);
+
+/*================================================================*/
+/* Local Static Definitions */
+
+static mibrec_t mibtab[] = {
+
+    /* dot11smt MIB's */
+
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11StationID,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNMACADDR, HFA384x_RID_CNFOWNMACADDR_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11MediumOccupancyLimit,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 0,
+          prism2mib_uint32offset },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11CFPollable,
+          F_STA | F_READ,
+          HFA384x_RID_CFPOLLABLE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11CFPPeriod,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 1,
+          prism2mib_uint32offset },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11CFPMaxDuration,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 2,
+          prism2mib_uint32offset },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11AuthenticationResponseTimeOut,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFAUTHRSPTIMEOUT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11PrivacyOptionImplemented,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PRIVACYOPTIMP, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11PowerManagementMode,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPMENABLED, 0, 0,
+          prism2mib_powermanagement },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11DesiredSSID,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFDESIREDSSID, HFA384x_RID_CNFDESIREDSSID_LEN, 0,
+          prism2mib_bytestr2pstr },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11DesiredBSSType,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11OperationalRateSet,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL, 0, 0,
+          prism2mib_operationalrateset },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11OperationalRateSet,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL0, 0, 0,
+          prism2mib_operationalrateset },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11BeaconPeriod,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPBCNINT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11DTIMPeriod,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNDTIMPER, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11StationConfigTable_dot11AssociationResponseTimeOut,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PROTOCOLRSPTIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm1,
+          F_AP | F_STA | F_READ,
+          1, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm2,
+          F_AP | F_STA | F_READ,
+          2, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm3,
+          F_AP | F_STA | F_READ,
+          3, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm4,
+          F_AP | F_STA | F_READ,
+          4, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm5,
+          F_AP | F_STA | F_READ,
+          5, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithm6,
+          F_AP | F_STA | F_READ,
+          6, 0, 0,
+          prism2mib_authalg },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable1,
+          F_AP | F_STA | F_READ | F_WRITE,
+          1, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable2,
+          F_AP | F_STA | F_READ | F_WRITE,
+          2, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable3,
+          F_AP | F_STA | F_READ | F_WRITE,
+          3, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable4,
+          F_AP | F_STA | F_READ | F_WRITE,
+          4, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable5,
+          F_AP | F_STA | F_READ | F_WRITE,
+          5, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11AuthenticationAlgorithmsTable_dot11AuthenticationAlgorithmsEnable6,
+          F_AP | F_STA | F_READ | F_WRITE,
+          6, 0, 0,
+          prism2mib_authalgenable },
+    { DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY0, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY1, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY2, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY3, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWEPFLAGS, HFA384x_WEPFLAGS_PRIVINVOKED, 0,
+          prism2mib_privacyinvoked },
+    { DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEYID, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWEPFLAGS, HFA384x_WEPFLAGS_EXCLUDE, 0,
+          prism2mib_excludeunencrypted },
+    { DIDmib_dot11phy_dot11PhyOperationTable_dot11ShortPreambleEnabled,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFSHORTPREAMBLE, 0, 0,
+          prism2mib_preamble },
+
+    /* dot11mac MIB's */
+
+    { DIDmib_dot11mac_dot11OperationTable_dot11MACAddress,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNMACADDR, HFA384x_RID_CNFOWNMACADDR_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11OperationTable_dot11RTSThreshold,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH0, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_SHORTRETRYLIMIT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_LONGRETRYLIMIT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH0, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MAXTXLIFETIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11OperationTable_dot11MaxReceiveLifetime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MAXRXLIFETIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address1,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address2,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address3,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address4,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address5,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address6,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address7,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address8,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address9,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address10,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address11,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address12,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address13,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address14,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address15,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address16,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address17,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address18,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address19,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address20,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address21,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address22,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address23,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address24,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address25,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address26,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address27,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address28,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address29,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address30,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address31,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+    { DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address32,
+          F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_groupaddress },
+
+    /* dot11phy MIB's */
+
+    { DIDmib_dot11phy_dot11PhyOperationTable_dot11PHYType,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PHYTYPE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11phy_dot11PhyOperationTable_dot11TempType,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_TEMPTYPE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel,
+          F_STA | F_READ,
+          HFA384x_RID_CURRENTCHANNEL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentChannel,
+          F_AP | F_READ,
+          HFA384x_RID_CNFOWNCHANNEL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11phy_dot11PhyDSSSTable_dot11CurrentCCAMode,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CCAMODE, 0, 0,
+          prism2mib_uint32 },
+
+    /* p2Table MIB's */
+
+    { DIDmib_p2_p2Table_p2MMTx,
+          F_AP | F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2EarlyBeacon,
+          F_AP | F_READ | F_WRITE,
+          BIT7, 0, 0,
+          prism2mib_appcfinfoflag },
+    { DIDmib_p2_p2Table_p2ReceivedFrameStatistics,
+          F_AP | F_STA | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2CommunicationTallies,
+          F_AP | F_STA | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2Authenticated,
+          F_AP | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2Associated,
+          F_AP | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2PowerSaveUserCount,
+          F_AP | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2Comment,
+          F_AP | F_STA | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2AccessMode,
+          F_AP | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2AccessAllow,
+          F_AP | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2AccessDeny,
+          F_AP | F_READ | F_WRITE,
+          0, 0, 0,
+          prism2mib_priv },
+    { DIDmib_p2_p2Table_p2ChannelInfoResults,
+          F_AP | F_READ,
+          0, 0, 0,
+          prism2mib_priv },
+
+    /* p2Static MIB's */
+
+    { DIDmib_p2_p2Static_p2CnfPortType,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPORTTYPE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfOwnMACAddress,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNMACADDR, HFA384x_RID_CNFOWNMACADDR_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfDesiredSSID,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFDESIREDSSID, HFA384x_RID_CNFDESIREDSSID_LEN, 0,
+          prism2mib_bytestr2pstr },
+    { DIDmib_p2_p2Static_p2CnfOwnChannel,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNCHANNEL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfOwnSSID,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNSSID, HFA384x_RID_CNFOWNSSID_LEN, 0,
+          prism2mib_bytestr2pstr },
+    { DIDmib_p2_p2Static_p2CnfOwnATIMWindow,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNATIMWIN, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfSystemScale,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFSYSSCALE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfMaxDataLength,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFMAXDATALEN, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR, HFA384x_RID_CNFWDSADDR_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfPMEnabled,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPMENABLED, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfPMEPS,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPMEPS, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfMulticastReceive,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFMULTICASTRX, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfMaxSleepDuration,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFMAXSLEEPDUR, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfPMHoldoverDuration,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPMHOLDDUR, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfOwnName,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNNAME, HFA384x_RID_CNFOWNNAME_LEN, 0,
+          prism2mib_bytestr2pstr },
+    { DIDmib_p2_p2Static_p2CnfOwnDTIMPeriod,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFOWNDTIMPER, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress1,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR1, HFA384x_RID_CNFWDSADDR1_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress2,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR2, HFA384x_RID_CNFWDSADDR2_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress3,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR3, HFA384x_RID_CNFWDSADDR3_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress4,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR4, HFA384x_RID_CNFWDSADDR4_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress5,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR5, HFA384x_RID_CNFWDSADDR5_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfWDSAddress6,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFWDSADDR6, HFA384x_RID_CNFWDSADDR6_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2Static_p2CnfMulticastPMBuffering,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFMCASTPMBUFF, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfWEPDefaultKeyID,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEYID, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfWEPDefaultKey0,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY0, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_p2_p2Static_p2CnfWEPDefaultKey1,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY1, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_p2_p2Static_p2CnfWEPDefaultKey2,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY2, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_p2_p2Static_p2CnfWEPDefaultKey3,
+          F_AP | F_STA | F_WRITE,
+          HFA384x_RID_CNFWEPDEFAULTKEY3, 0, 0,
+          prism2mib_wepdefaultkey },
+    { DIDmib_p2_p2Static_p2CnfWEPFlags,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWEPFLAGS, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfAuthentication,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFAUTHENTICATION, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfMaxAssociatedStations,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFMAXASSOCSTATIONS, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfTxControl,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFTXCONTROL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfRoamingMode,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFROAMINGMODE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfHostAuthentication,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFHOSTAUTHASSOC, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfRcvCrcError,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFRCVCRCERROR, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfAltRetryCount,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFALTRETRYCNT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfBeaconInterval,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPBCNINT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfMediumOccupancyLimit,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 0,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2Static_p2CnfCFPPeriod,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 1,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2Static_p2CnfCFPMaxDuration,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 2,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2Static_p2CnfCFPFlags,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFAPPCFINFO, HFA384x_RID_CNFAPPCFINFO_LEN, 3,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2Static_p2CnfSTAPCFInfo,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFSTAPCFINFO, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfPriorityQUsage,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFPRIORITYQUSAGE, HFA384x_RID_CNFPRIOQUSAGE_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2Static_p2CnfTIMCtrl,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFTIMCTRL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfThirty2Tally,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFTHIRTY2TALLY, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfEnhSecurity,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFENHSECURITY, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfShortPreamble,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFSHORTPREAMBLE, 0, 0,
+          prism2mib_preamble },
+    { DIDmib_p2_p2Static_p2CnfExcludeLongPreamble,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_CNFEXCLONGPREAMBLE, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Static_p2CnfAuthenticationRspTO,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFAUTHRSPTIMEOUT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfBasicRates,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFBASICRATES, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Static_p2CnfSupportedRates,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFSUPPRATES, 0, 0,
+          prism2mib_uint32 },
+
+    /* p2Dynamic MIB's */
+
+    { DIDmib_p2_p2Dynamic_p2CreateIBSS,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CREATEIBSS, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2PromiscuousMode,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_PROMISCMODE, 0, 0,
+          prism2mib_truth },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold0,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH0, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold1,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH1, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold2,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH2, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold3,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH3, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold4,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH4, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold5,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH5, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2FragmentationThreshold6,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_FRAGTHRESH6, 0, 0,
+          prism2mib_fragmentationthreshold },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold0,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH0, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold1,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH1, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold2,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH2, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold3,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH3, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold4,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH4, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold5,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH5, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2RTSThreshold6,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_RTSTHRESH6, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl0,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL0, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl1,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL1, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl2,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL2, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl3,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL3, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl4,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL4, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl5,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL5, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Dynamic_p2TxRateControl6,
+          F_AP | F_READ | F_WRITE,
+          HFA384x_RID_TXRATECNTL6, 0, 0,
+          prism2mib_uint32 },
+
+    /* p2Behavior MIB's */
+
+    { DIDmib_p2_p2Behavior_p2TickTime,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_ITICKTIME, 0, 0,
+          prism2mib_uint32 },
+
+    /* p2NIC MIB's */
+
+    { DIDmib_p2_p2NIC_p2MaxLoadTime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MAXLOADTIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2NIC_p2DLBufferPage,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_DOWNLOADBUFFER, HFA384x_RID_DOWNLOADBUFFER_LEN, 0,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2NIC_p2DLBufferOffset,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_DOWNLOADBUFFER, HFA384x_RID_DOWNLOADBUFFER_LEN, 1,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2NIC_p2DLBufferLength,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_DOWNLOADBUFFER, HFA384x_RID_DOWNLOADBUFFER_LEN, 2,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2NIC_p2PRIIdentity,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PRIIDENTITY, HFA384x_RID_PRIIDENTITY_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2PRISupRange,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PRISUPRANGE, HFA384x_RID_PRISUPRANGE_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2CFIActRanges,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PRI_CFIACTRANGES, HFA384x_RID_CFIACTRANGES_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2BuildSequence,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_BUILDSEQ, HFA384x_RID_BUILDSEQ_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2PrimaryFWID,
+          F_AP | F_STA | F_READ,
+          0, 0, 0,
+          prism2mib_fwid },
+    { DIDmib_p2_p2NIC_p2SecondaryFWID,
+          F_AP | F_STA | F_READ,
+          0, 0, 0,
+          prism2mib_fwid },
+    { DIDmib_p2_p2NIC_p2TertiaryFWID,
+          F_AP | F_READ,
+          0, 0, 0,
+          prism2mib_fwid },
+    { DIDmib_p2_p2NIC_p2NICSerialNumber,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_NICSERIALNUMBER, HFA384x_RID_NICSERIALNUMBER_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2NIC_p2NICIdentity,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_NICIDENTITY, HFA384x_RID_NICIDENTITY_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2MFISupRange,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MFISUPRANGE, HFA384x_RID_MFISUPRANGE_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2CFISupRange,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CFISUPRANGE, HFA384x_RID_CFISUPRANGE_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2ChannelList,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CHANNELLIST, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2NIC_p2RegulatoryDomains,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_REGULATORYDOMAINS, HFA384x_RID_REGULATORYDOMAINS_LEN, 0,
+          prism2mib_regulatorydomains },
+    { DIDmib_p2_p2NIC_p2TempType,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_TEMPTYPE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2NIC_p2STAIdentity,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_STAIDENTITY, HFA384x_RID_STAIDENTITY_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2STASupRange,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_STASUPRANGE, HFA384x_RID_STASUPRANGE_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2MFIActRanges,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_STA_MFIACTRANGES, HFA384x_RID_MFIACTRANGES_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2NIC_p2STACFIActRanges,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_STA_CFIACTRANGES, HFA384x_RID_CFIACTRANGES2_LEN, 0,
+          prism2mib_uint32array },
+
+    /* p2MAC MIB's */
+
+    { DIDmib_p2_p2MAC_p2PortStatus,
+          F_STA | F_READ,
+          HFA384x_RID_PORTSTATUS, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentSSID,
+          F_STA | F_READ,
+          HFA384x_RID_CURRENTSSID, HFA384x_RID_CURRENTSSID_LEN, 0,
+          prism2mib_bytestr2pstr },
+    { DIDmib_p2_p2MAC_p2CurrentBSSID,
+          F_STA | F_READ,
+          HFA384x_RID_CURRENTBSSID, HFA384x_RID_CURRENTBSSID_LEN, 0,
+          prism2mib_bytearea2pstr },
+    { DIDmib_p2_p2MAC_p2CommsQuality,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2MAC_p2CommsQualityCQ,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 0,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2CommsQualityASL,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 1,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2CommsQualityANL,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 2,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2dbmCommsQuality,
+          F_STA | F_READ,
+          HFA384x_RID_DBMCOMMSQUALITY, HFA384x_RID_DBMCOMMSQUALITY_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2MAC_p2dbmCommsQualityCQ,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 0,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2dbmCommsQualityASL,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 1,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2dbmCommsQualityANL,
+          F_STA | F_READ,
+          HFA384x_RID_COMMSQUALITY, HFA384x_RID_COMMSQUALITY_LEN, 2,
+          prism2mib_uint32offset },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate,
+          F_STA | F_READ,
+          HFA384x_RID_CURRENTTXRATE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentBeaconInterval,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CURRENTBCNINT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2StaCurrentScaleThresholds,
+          F_STA | F_READ,
+          HFA384x_RID_CURRENTSCALETHRESH, HFA384x_RID_STACURSCALETHRESH_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2MAC_p2APCurrentScaleThresholds,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTSCALETHRESH, HFA384x_RID_APCURSCALETHRESH_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2MAC_p2ProtocolRspTime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PROTOCOLRSPTIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2ShortRetryLimit,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_SHORTRETRYLIMIT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2LongRetryLimit,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_LONGRETRYLIMIT, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2MaxTransmitLifetime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MAXTXLIFETIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2MaxReceiveLifetime,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_MAXRXLIFETIME, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CFPollable,
+          F_STA | F_READ,
+          HFA384x_RID_CFPOLLABLE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2AuthenticationAlgorithms,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_AUTHALGORITHMS, HFA384x_RID_AUTHALGORITHMS_LEN, 0,
+          prism2mib_uint32array },
+    { DIDmib_p2_p2MAC_p2PrivacyOptionImplemented,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PRIVACYOPTIMP, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate1,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE1, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate2,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE2, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate3,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE3, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate4,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE4, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate5,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE5, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2CurrentTxRate6,
+          F_AP | F_READ,
+          HFA384x_RID_CURRENTTXRATE6, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2MAC_p2OwnMACAddress,
+          F_AP | F_READ,
+          HFA384x_RID_OWNMACADDRESS, HFA384x_RID_OWNMACADDRESS_LEN, 0,
+          prism2mib_bytearea2pstr },
+
+    /* p2Modem MIB's */
+
+    { DIDmib_p2_p2Modem_p2PHYType,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_PHYTYPE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Modem_p2CurrentChannel,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CURRENTCHANNEL, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Modem_p2CurrentPowerState,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CURRENTPOWERSTATE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Modem_p2CCAMode,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_CCAMODE, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Modem_p2TxPowerMax,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_TXPOWERMAX, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel,
+          F_AP | F_STA | F_READ | F_WRITE,
+          HFA384x_RID_TXPOWERMAX, 0, 0,
+          prism2mib_uint32 },
+    { DIDmib_p2_p2Modem_p2SupportedDataRates,
+          F_AP | F_STA | F_READ,
+          HFA384x_RID_SUPPORTEDDATARATES, HFA384x_RID_SUPPORTEDDATARATES_LEN, 0,
+          prism2mib_bytestr2pstr },
+
+    /* And finally, lnx mibs */
+    { DIDmib_lnx_lnxConfigTable_lnxRSNAIE,
+          F_STA | F_READ | F_WRITE,
+          HFA384x_RID_CNFWPADATA, 0, 0,
+          prism2mib_priv },
+    { 0, 0, 0, 0, 0, NULL}};
+
+/*----------------------------------------------------------------
+These MIB's are not supported at this time:
+
+DIDmib_dot11phy_dot11PhyOperationTable_dot11ChannelAgilityPresent
+DIDmib_dot11phy_dot11PhyOperationTable_dot11ChannelAgilityEnabled
+DIDmib_dot11phy_dot11PhyDSSSTable_dot11PBCCOptionImplemented
+DIDmib_dot11phy_dot11RegDomainsSupportedTable_dot11RegDomainsSupportIndex
+DIDmib_dot11phy_dot11SupportedDataRatesTxTable_dot11SupportedDataRatesTxIndex
+DIDmib_dot11phy_dot11SupportedDataRatesTxTable_dot11SupportedDataRatesTxValue
+DIDmib_dot11phy_dot11SupportedDataRatesRxTable_dot11SupportedDataRatesRxIndex
+DIDmib_dot11phy_dot11SupportedDataRatesRxTable_dot11SupportedDataRatesRxValue
+
+DIDmib_dot11phy_dot11RegDomainsSupportedTable_dot11RegDomainsSupportValue
+TODO: need to investigate why wlan has this as enumerated and Prism2 has this
+      as btye str.
+
+DIDmib_dot11phy_dot11PhyDSSSTable_dot11ShortPreambleOptionImplemented
+TODO: Find out the firmware version number(s) for identifying 
+      whether the firmware is capable of short preamble. TRUE or FALSE
+      will be returned based on the version of the firmware.
+
+WEP Key mappings aren't supported in the f/w.
+DIDmib_dot11smt_dot11WEPKeyMappingsTable_dot11WEPKeyMappingIndex
+DIDmib_dot11smt_dot11WEPKeyMappingsTable_dot11WEPKeyMappingAddress
+DIDmib_dot11smt_dot11WEPKeyMappingsTable_dot11WEPKeyMappingWEPOn
+DIDmib_dot11smt_dot11WEPKeyMappingsTable_dot11WEPKeyMappingValue
+DIDmib_dot11smt_dot11PrivacyTable_dot11WEPKeyMappingLength
+
+TODO: implement counters.
+DIDmib_dot11smt_dot11PrivacyTable_dot11WEPICVErrorCount
+DIDmib_dot11smt_dot11PrivacyTable_dot11WEPExcludedCount
+DIDmib_dot11mac_dot11CountersTable_dot11TransmittedFragmentCount
+DIDmib_dot11mac_dot11CountersTable_dot11MulticastTransmittedFrameCount
+DIDmib_dot11mac_dot11CountersTable_dot11FailedCount
+DIDmib_dot11mac_dot11CountersTable_dot11RetryCount
+DIDmib_dot11mac_dot11CountersTable_dot11MultipleRetryCount
+DIDmib_dot11mac_dot11CountersTable_dot11FrameDuplicateCount
+DIDmib_dot11mac_dot11CountersTable_dot11RTSSuccessCount
+DIDmib_dot11mac_dot11CountersTable_dot11RTSFailureCount
+DIDmib_dot11mac_dot11CountersTable_dot11ACKFailureCount
+DIDmib_dot11mac_dot11CountersTable_dot11ReceivedFragmentCount
+DIDmib_dot11mac_dot11CountersTable_dot11MulticastReceivedFrameCount
+DIDmib_dot11mac_dot11CountersTable_dot11FCSErrorCount
+DIDmib_dot11mac_dot11CountersTable_dot11TransmittedFrameCount
+DIDmib_dot11mac_dot11CountersTable_dot11WEPUndecryptableCount
+
+TODO: implement sane values for these.
+DIDmib_dot11mac_dot11OperationTable_dot11ManufacturerID
+DIDmib_dot11mac_dot11OperationTable_dot11ProductID
+
+Not too worried about these at the moment.
+DIDmib_dot11phy_dot11PhyAntennaTable_dot11CurrentTxAntenna
+DIDmib_dot11phy_dot11PhyAntennaTable_dot11DiversitySupport
+DIDmib_dot11phy_dot11PhyAntennaTable_dot11CurrentRxAntenna
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11NumberSupportedPowerLevels
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel1
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel2
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel3
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel4
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel5
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel6
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel7
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel8
+DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel
+
+Ummm, FH and IR don't apply
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11HopTime
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11CurrentChannelNumber
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11MaxDwellTime
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11CurrentDwellTime
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11CurrentSet
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11CurrentPattern
+DIDmib_dot11phy_dot11PhyFHSSTable_dot11CurrentIndex
+DIDmib_dot11phy_dot11PhyDSSSTable_dot11CCAModeSupported
+DIDmib_dot11phy_dot11PhyDSSSTable_dot11EDThreshold
+DIDmib_dot11phy_dot11PhyIRTable_dot11CCAWatchdogTimerMax
+DIDmib_dot11phy_dot11PhyIRTable_dot11CCAWatchdogCountMax
+DIDmib_dot11phy_dot11PhyIRTable_dot11CCAWatchdogTimerMin
+DIDmib_dot11phy_dot11PhyIRTable_dot11CCAWatchdogCountMin
+
+We just don't have enough antennas right now to worry about this.
+DIDmib_dot11phy_dot11AntennasListTable_dot11AntennaListIndex
+DIDmib_dot11phy_dot11AntennasListTable_dot11SupportedTxAntenna
+DIDmib_dot11phy_dot11AntennasListTable_dot11SupportedRxAntenna
+DIDmib_dot11phy_dot11AntennasListTable_dot11DiversitySelectionRx
+
+------------------------------------------------------------------*/
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* prism2mgmt_mibset_mibget
+*
+* Set the value of a mib item.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+*	0	success and done
+*	<0	success, but we're waiting for something to finish.
+*	>0	an error occurred while handling the message.
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+
+int prism2mgmt_mibset_mibget(wlandevice_t *wlandev, void *msgp)
+{
+	hfa384x_t		*hw = wlandev->priv;
+	int			result, isget;
+	mibrec_t		*mib;
+	UINT16			which;
+
+	p80211msg_dot11req_mibset_t	*msg = msgp;
+	p80211itemd_t			*mibitem;
+
+	DBFENTER;
+
+	msg->resultcode.status = P80211ENUM_msgitem_status_data_ok;
+	msg->resultcode.data = P80211ENUM_resultcode_success;
+
+	/*
+	** Determine if this is an Access Point or a station.
+	*/
+	
+	which = hw->ap ? F_AP : F_STA;
+
+	/*
+	** Find the MIB in the MIB table.  Note that a MIB may be in the
+	** table twice...once for an AP and once for a station.  Make sure
+	** to get the correct one.  Note that DID=0 marks the end of the
+	** MIB table.
+	*/
+
+	mibitem = (p80211itemd_t *) msg->mibattribute.data;
+
+	for (mib = mibtab; mib->did != 0; mib++)
+		if (mib->did == mibitem->did && (mib->flag & which))
+			break;
+
+	if (mib->did == 0) {
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		goto done;
+	}
+
+	/*
+	** Determine if this is a "mibget" or a "mibset".  If this is a
+	** "mibget", then make sure that the MIB may be read.  Otherwise,
+	** this is a "mibset" so make make sure that the MIB may be written.
+	*/
+
+	isget = (msg->msgcode == DIDmsg_dot11req_mibget);
+
+	if (isget) {
+		if (!(mib->flag & F_READ)) {
+			msg->resultcode.data =
+				P80211ENUM_resultcode_cant_get_writeonly_mib;
+			goto done;
+		}
+	} else {
+		if (!(mib->flag & F_WRITE)) {
+			msg->resultcode.data =
+				P80211ENUM_resultcode_cant_set_readonly_mib;
+			goto done;
+		}
+	}
+
+	/*
+	** Execute the MIB function.  If things worked okay, then make
+	** sure that the MIB function also worked okay.  If so, and this
+	** is a "mibget", then the status value must be set for both the
+	** "mibattribute" parameter and the mib item within the data
+	** portion of the "mibattribute".
+	*/
+
+	result = mib->func(mib, isget, wlandev, hw, msg,
+			   (void *) mibitem->data);
+
+	if (msg->resultcode.data == P80211ENUM_resultcode_success) {
+		if (result != 0) {
+			WLAN_LOG_DEBUG(1, "get/set failure, result=%d\n",
+					result);
+			msg->resultcode.data =
+				 P80211ENUM_resultcode_implementation_failure;
+		} else {
+			if (isget) {
+				msg->mibattribute.status =
+					P80211ENUM_msgitem_status_data_ok;
+				mibitem->status =
+					P80211ENUM_msgitem_status_data_ok;
+			}
+		}
+	}
+
+done:
+	DBFEXIT;
+
+	return(0);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_bytestr2pstr
+*
+* Get/set pstr data to/from a byte string.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_bytestr2pstr(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int                result;
+	p80211pstrd_t      *pstr = (p80211pstrd_t*) data;
+	UINT8              bytebuf[MIB_TMP_MAXLEN];
+	hfa384x_bytestr_t  *p2bytestr = (hfa384x_bytestr_t*) bytebuf;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig(hw, mib->parm1, bytebuf, mib->parm2);
+		prism2mgmt_bytestr2pstr(p2bytestr, pstr);
+	} else {
+		memset(bytebuf, 0, mib->parm2);
+		prism2mgmt_pstr2bytestr(p2bytestr, pstr);
+		result = hfa384x_drvr_setconfig(hw, mib->parm1, bytebuf, mib->parm2);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_bytearea2pstr
+*
+* Get/set pstr data to/from a byte area.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_bytearea2pstr(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int            result;
+	p80211pstrd_t  *pstr = (p80211pstrd_t*) data;
+	UINT8          bytebuf[MIB_TMP_MAXLEN];
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig(hw, mib->parm1, bytebuf, mib->parm2);
+		prism2mgmt_bytearea2pstr(bytebuf, pstr,	mib->parm2);
+	} else {
+		memset(bytebuf, 0, mib->parm2);
+		prism2mgmt_pstr2bytearea(bytebuf, pstr);
+		result = hfa384x_drvr_setconfig(hw, mib->parm1, bytebuf, mib->parm2);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_uint32
+*
+* Get/set uint32 data.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_uint32(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);
+		*uint32 = *wordbuf;
+		/* [MSM] Removed, getconfig16 returns the value in host order.
+		 * prism2mgmt_prism2int2p80211int(wordbuf, uint32);
+		 */
+	} else {
+		/* [MSM] Removed, setconfig16 expects host order.
+		 * prism2mgmt_p80211int2prism2int(wordbuf, uint32);
+		 */
+		*wordbuf = *uint32;
+		result = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_uint32array
+*
+* Get/set an array of uint32 data.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_uint32array(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32 *) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+	int     i, cnt;
+
+	DBFENTER;
+
+	cnt = mib->parm2 / sizeof(UINT16);
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig(hw, mib->parm1, wordbuf, mib->parm2);
+		for (i = 0; i < cnt; i++)
+			prism2mgmt_prism2int2p80211int(wordbuf+i, uint32+i);
+	} else {
+		for (i = 0; i < cnt; i++)
+			prism2mgmt_p80211int2prism2int(wordbuf+i, uint32+i);
+		result = hfa384x_drvr_setconfig(hw, mib->parm1, wordbuf, mib->parm2);
+		}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_uint32offset
+*
+* Get/set a single element in an array of uint32 data.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Element index.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_uint32offset(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+	UINT16  cnt;
+
+	DBFENTER;
+
+	cnt = mib->parm2 / sizeof(UINT16);
+
+	result = hfa384x_drvr_getconfig(hw, mib->parm1, wordbuf, mib->parm2);
+	if (result == 0) {
+		if (isget) {
+			if (mib->parm3 < cnt)
+				prism2mgmt_prism2int2p80211int(wordbuf+mib->parm3, uint32);
+			else
+				*uint32 = 0;
+		} else {
+			if (mib->parm3 < cnt) {
+				prism2mgmt_p80211int2prism2int(wordbuf+mib->parm3, uint32);
+				result = hfa384x_drvr_setconfig(hw, mib->parm1, wordbuf, mib->parm2);
+			}
+		}
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_truth
+*
+* Get/set truth data.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_truth(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);
+		*uint32 = (*wordbuf) ?
+				P80211ENUM_truth_true : P80211ENUM_truth_false;
+	} else {
+		*wordbuf = ((*uint32) == P80211ENUM_truth_true) ? 1 : 0;
+		result = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_flag
+*
+* Get/set a flag.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Bit to get/set.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_flag(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+	UINT32  flags;
+
+	DBFENTER;
+
+	result = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);
+	if (result == 0) {
+		/* [MSM] Removed, getconfig16 returns the value in host order.
+		 * prism2mgmt_prism2int2p80211int(wordbuf, &flags);
+		 */
+		flags = *wordbuf;
+		if (isget) {
+			*uint32 = (flags & mib->parm2) ?
+				P80211ENUM_truth_true : P80211ENUM_truth_false;
+		} else {
+			if ((*uint32) == P80211ENUM_truth_true)
+				flags |= mib->parm2;
+			else
+				flags &= ~mib->parm2;
+			/* [MSM] Removed, setconfig16 expects host order.
+			 * prism2mgmt_p80211int2prism2int(wordbuf, &flags);
+			 */
+			*wordbuf = flags;
+			result = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);
+		}
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_appcfinfoflag
+*
+* Get/set a single flag in the APPCFINFO record.
+*
+* MIB record parameters:
+*       parm1    Bit to get/set.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_appcfinfoflag(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+	UINT16  word;
+
+	DBFENTER;
+
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFAPPCFINFO,
+					bytebuf, HFA384x_RID_CNFAPPCFINFO_LEN);
+	if (result == 0) {
+		if (isget) {
+			*uint32 = (hfa384x2host_16(wordbuf[3]) & mib->parm1) ?
+				P80211ENUM_truth_true : P80211ENUM_truth_false;
+		} else {
+			word = hfa384x2host_16(wordbuf[3]);
+			word = ((*uint32) == P80211ENUM_truth_true) ?
+				(word | mib->parm1) : (word & ~mib->parm1);
+			wordbuf[3] = host2hfa384x_16(word);
+			result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFAPPCFINFO,
+					bytebuf, HFA384x_RID_CNFAPPCFINFO_LEN);
+		}
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_regulatorydomains
+*
+* Get regulatory domain data.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_regulatorydomains(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int            result;
+	UINT32         cnt;
+	p80211pstrd_t  *pstr = (p80211pstrd_t*) data;
+	UINT8          bytebuf[MIB_TMP_MAXLEN];
+	UINT16         *wordbuf = (UINT16*) bytebuf;
+
+	DBFENTER;
+
+	result = 0;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig(hw, mib->parm1, wordbuf, mib->parm2);
+		prism2mgmt_prism2int2p80211int(wordbuf, &cnt);
+		pstr->len = (UINT8) cnt;
+		memcpy(pstr->data, &wordbuf[1], pstr->len);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_wepdefaultkey
+*
+* Get/set WEP default keys.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Number of bytes of RID data.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_wepdefaultkey(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int            result;
+	p80211pstrd_t  *pstr = (p80211pstrd_t*) data;
+	UINT8          bytebuf[MIB_TMP_MAXLEN];
+	UINT16         len;
+
+	DBFENTER;
+
+	if (isget) {
+		result = 0;    /* Should never happen. */
+	} else {
+		len = (pstr->len > 5) ? HFA384x_RID_CNFWEP128DEFAULTKEY_LEN :
+					HFA384x_RID_CNFWEPDEFAULTKEY_LEN;
+		memset(bytebuf, 0, len);
+		prism2mgmt_pstr2bytearea(bytebuf, pstr);
+		result = hfa384x_drvr_setconfig(hw, mib->parm1, bytebuf, len);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_powermanagement
+*
+* Get/set 802.11 power management value.  Note that this is defined differently
+* by 802.11 and Prism2:
+*
+*       Meaning     802.11       Prism2
+*        active       1           false
+*      powersave      2           true
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_powermanagement(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT32  value;
+
+	DBFENTER;
+
+	if (isget) {
+		result = prism2mib_uint32(mib, isget, wlandev, hw, msg, &value);
+		*uint32 = (value == 0) ? 1 : 2;
+	} else {
+		value = ((*uint32) == 1) ? 0 : 1;
+		result = prism2mib_uint32(mib, isget, wlandev, hw, msg, &value);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_preamble
+*
+* Get/set Prism2 short preamble
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns:
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_preamble(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+	UINT8   bytebuf[MIB_TMP_MAXLEN];
+	UINT16  *wordbuf = (UINT16*) bytebuf;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);
+		*uint32 = *wordbuf;
+	} else {
+		*wordbuf = *uint32;
+		result = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_privacyinvoked
+*
+* Get/set the dot11PrivacyInvoked value.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Bit value for PrivacyInvoked flag.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_privacyinvoked(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+
+	DBFENTER;
+
+	if (wlandev->hostwep & HOSTWEP_DECRYPT) {
+		if (wlandev->hostwep & HOSTWEP_DECRYPT) 
+			mib->parm2 |= HFA384x_WEPFLAGS_DISABLE_RXCRYPT;
+		if (wlandev->hostwep & HOSTWEP_ENCRYPT)
+			mib->parm2 |= HFA384x_WEPFLAGS_DISABLE_TXCRYPT;
+	}
+
+	result = prism2mib_flag(mib, isget, wlandev, hw, msg, data);
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_excludeunencrypted
+*
+* Get/set the dot11ExcludeUnencrypted value.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Bit value for ExcludeUnencrypted flag.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_excludeunencrypted(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+
+	DBFENTER;
+
+	result = prism2mib_flag(mib, isget, wlandev, hw, msg, data);
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_fragmentationthreshold
+*
+* Get/set the fragmentation threshold.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_fragmentationthreshold(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+
+	DBFENTER;
+
+	if (!isget)
+		if ((*uint32) % 2) {
+			WLAN_LOG_WARNING("Attempt to set odd number "
+					  "FragmentationThreshold\n"); 
+			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+			return(0);
+		}
+
+	result = prism2mib_uint32(mib, isget, wlandev, hw, msg, data);
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_operationalrateset
+*
+* Get/set the operational rate set.
+*
+* MIB record parameters:
+*       parm1    Prism2 RID value.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_operationalrateset(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int            result;
+	p80211pstrd_t  *pstr = (p80211pstrd_t *) data;
+	UINT8          bytebuf[MIB_TMP_MAXLEN];
+	UINT16         *wordbuf = (UINT16*) bytebuf;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig16(hw, mib->parm1, wordbuf);
+		prism2mgmt_get_oprateset(wordbuf, pstr);
+	} else {
+		prism2mgmt_set_oprateset(wordbuf, pstr);
+		result = hfa384x_drvr_setconfig16(hw, mib->parm1, *wordbuf);
+		result = hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFSUPPRATES, *wordbuf);
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_groupaddress
+*
+* Get/set the dot11GroupAddressesTable.
+*
+* MIB record parameters:
+*       parm1    Not used.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_groupaddress(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int            result;
+	p80211pstrd_t  *pstr = (p80211pstrd_t *) data;
+	UINT8          bytebuf[MIB_TMP_MAXLEN];
+	UINT16         len;
+
+	DBFENTER;
+
+	/* TODO: fix this.  f/w doesn't support mcast filters */
+
+	if (isget) {
+		prism2mgmt_get_grpaddr(mib->did, pstr, hw);
+		return(0);
+	}
+
+	result = prism2mgmt_set_grpaddr(mib->did, bytebuf, pstr, hw);
+	if (result != 0) {
+		msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		return(result);
+	}
+
+	if (hw->dot11_grpcnt <= MAX_PRISM2_GRP_ADDR) {
+		len = hw->dot11_grpcnt * WLAN_ADDR_LEN;
+		memcpy(bytebuf, hw->dot11_grp_addr[0], len);
+		result = hfa384x_drvr_setconfig(hw, HFA384x_RID_GROUPADDR, bytebuf, len);
+
+		/*
+		** Turn off promiscuous mode if count is equal to MAX.  We may
+		** have been at a higher count in promiscuous mode and need to
+		** turn it off.
+		*/
+		
+		/* but only if we're not already in promisc mode. :) */
+		if ((hw->dot11_grpcnt == MAX_PRISM2_GRP_ADDR) &&
+		    !( wlandev->netdev->flags & IFF_PROMISC)) {
+			result = hfa384x_drvr_setconfig16(hw,
+					     HFA384x_RID_PROMISCMODE, 0);
+		}
+	} else {
+
+		/*
+		** Clear group addresses in card and set to promiscuous mode.
+		*/
+
+		memset(bytebuf, 0, sizeof(bytebuf));
+		result = hfa384x_drvr_setconfig(hw, HFA384x_RID_GROUPADDR,
+						bytebuf, 0);
+		if (result == 0) {
+			result = hfa384x_drvr_setconfig16(hw,
+					HFA384x_RID_PROMISCMODE, 1);
+		}
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_fwid
+*
+* Get the firmware ID.
+*
+* MIB record parameters:
+*       parm1    Not used.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_fwid(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int             result;
+	p80211pstrd_t   *pstr = (p80211pstrd_t *) data;
+	hfa384x_FWID_t  fwid;
+
+	DBFENTER;
+
+	if (isget) {
+		result = hfa384x_drvr_getconfig(hw, HFA384x_RID_FWID,
+						&fwid, HFA384x_RID_FWID_LEN);
+		if (mib->did == DIDmib_p2_p2NIC_p2PrimaryFWID) {
+			fwid.primary[HFA384x_FWID_LEN - 1] = '\0';
+			pstr->len = strlen(fwid.primary);
+			memcpy(pstr->data, fwid.primary, pstr->len);
+		} else {
+			fwid.secondary[HFA384x_FWID_LEN - 1] = '\0';
+			pstr->len = strlen(fwid.secondary);
+			memcpy(pstr->data, fwid.secondary, pstr->len);
+		}
+	} else
+		result = 0;     /* Should never happen. */
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_authalg
+*
+* Get values from the AuhtenticationAlgorithmsTable.
+*
+* MIB record parameters:
+*       parm1    Table index (1-6).
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_authalg(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	UINT32  *uint32 = (UINT32*) data;
+
+	DBFENTER;
+
+	/* MSM: pkx supplied code that  code queries RID FD4D....but the f/w's
+         *  results are bogus. Therefore, we have to simulate the appropriate 
+         *  results here in the driver based on our knowledge of existing MAC 
+         *  features.  That's the whole point behind this ugly function. 
+         */
+
+	if (isget) {
+		msg->resultcode.data = P80211ENUM_resultcode_success;
+		switch (mib->parm1) {
+			case 1: /* Open System */
+				*uint32 = P80211ENUM_authalg_opensystem;
+				break;
+			case 2: /* SharedKey */
+				*uint32 = P80211ENUM_authalg_sharedkey;
+				break;
+			default:
+				*uint32 = 0;
+				msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+				break;
+		}
+	}
+
+	DBFEXIT;
+	return(0);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_authalgenable
+*
+* Get/set the enable values from the AuhtenticationAlgorithmsTable.
+*
+* MIB record parameters:
+*       parm1    Table index (1-6).
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_authalgenable(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	int     result;
+	UINT32  *uint32 = (UINT32*) data;
+
+	int     index;
+	UINT16  cnf_auth;
+	UINT16	mask;
+
+	DBFENTER;
+
+	index = mib->parm1 - 1;
+
+	result = hfa384x_drvr_getconfig16( hw, 
+			HFA384x_RID_CNFAUTHENTICATION, &cnf_auth);
+	WLAN_LOG_DEBUG(2,"cnfAuthentication0=%d, index=%d\n", cnf_auth, index);
+
+	if (isget) {
+		if ( index == 0 || index == 1 ) {
+			*uint32 = (cnf_auth & (1<<index)) ? 
+				P80211ENUM_truth_true: P80211ENUM_truth_false;
+		} else {
+			*uint32 = P80211ENUM_truth_false;
+			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		}
+	} else {
+		if ( index == 0 || index == 1 ) {
+			mask = 1 << index;
+			if (*uint32==P80211ENUM_truth_true ) {
+				cnf_auth |= mask;
+			} else {
+				cnf_auth &= ~mask;
+			}
+			result = hfa384x_drvr_setconfig16( hw, 
+					HFA384x_RID_CNFAUTHENTICATION, cnf_auth);
+			WLAN_LOG_DEBUG(2,"cnfAuthentication:=%d\n", cnf_auth);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,"Unable to set p2cnfAuthentication to %d\n", cnf_auth);
+				msg->resultcode.data = P80211ENUM_resultcode_implementation_failure;
+			}
+		} else {
+			msg->resultcode.data = P80211ENUM_resultcode_not_supported;
+		}
+	}
+
+	DBFEXIT;
+	return(result);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv
+*
+* Get/set values in the "priv" data structure.
+*
+* MIB record parameters:
+*       parm1    Not used.
+*       parm2    Not used.
+*       parm3    Not used.
+*
+* Arguments:
+*       mib      MIB record.
+*       isget    MIBGET/MIBSET flag.
+*       wlandev  wlan device structure.
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       msg      Message structure.
+*       data     Data buffer.
+*
+* Returns: 
+*       0   - Success.
+*       ~0  - Error.
+*
+----------------------------------------------------------------*/
+
+static int prism2mib_priv(
+mibrec_t                     *mib,
+int                          isget,
+wlandevice_t                 *wlandev,
+hfa384x_t                    *hw,
+p80211msg_dot11req_mibset_t  *msg,
+void                         *data)
+{
+	UINT32            *uint32 = (UINT32*) data;
+	p80211pstrd_t     *pstr = (p80211pstrd_t*) data;
+	p80211macarray_t  *macarray = (p80211macarray_t *) data;
+
+	int  i, cnt, result, done;
+
+	prism2sta_authlist_t  old;
+
+	/*
+	** "test" is a lot longer than necessary but who cares?  ...as long as
+	** it is long enough!
+	*/
+
+	UINT8  test[sizeof(wlandev->rx) + sizeof(hw->tallies)];
+
+	DBFENTER;
+
+	switch (mib->did) {
+	case DIDmib_p2_p2Table_p2ReceivedFrameStatistics:
+
+		/*
+		** Note: The values in this record are changed by the
+		** interrupt handler and therefore cannot be guaranteed
+		** to be stable while they are being copied.  However,
+		** the interrupt handler will take priority over this
+		** code.  Hence, if the same values are copied twice,
+		** then we are ensured that the values have not been
+		** changed.  If they have, then just try again.  Don't
+		** try more than 10 times...if we still haven't got it,
+		** then the values we do have are probably good enough.
+		** This scheme for copying values is used in order to
+		** prevent having to block the interrupt handler while
+		** we copy the values.
+		*/
+		
+		if (isget)
+			for (i = 0; i < 10; i++) {
+				memcpy(data, &wlandev->rx, sizeof(wlandev->rx));
+				memcpy(test, &wlandev->rx, sizeof(wlandev->rx));
+				if (memcmp(data, test, sizeof(wlandev->rx)) == 0) break;
+			}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2CommunicationTallies:
+		
+		/*
+		** Note: The values in this record are changed by the
+		** interrupt handler and therefore cannot be guaranteed
+		** to be stable while they are being copied.  See the
+		** note above about copying values.
+		*/
+		
+		if (isget) {
+			result = hfa384x_drvr_commtallies(hw);
+			
+			/* ?????? We need to wait a bit here for the */
+			/*   tallies to get updated. ?????? */
+			/* MSM: TODO: The right way to do this is to 
+			 *      add a "commtallie" wait queue to the
+			 *      priv structure that gets run every time
+			 *      we receive a commtally info frame.
+			 *      This process would sleep on that
+			 *      queue and get awakened when the 
+			 *      the requested info frame arrives.
+			 *      Don't have time to do and test this
+			 *      right now.
+			 */
+			
+			/* Ugh, this is nasty. */
+			for (i = 0; i < 10; i++) {
+				memcpy(data, 
+				       &hw->tallies, 
+				       sizeof(hw->tallies));
+				memcpy(test, 
+				       &hw->tallies, 
+				       sizeof(hw->tallies));
+				if ( memcmp(data, 
+					    test, 
+					    sizeof(hw->tallies)) == 0) 
+					break;
+			}
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2Authenticated:
+		
+		if (isget) {
+			prism2mib_priv_authlist(hw, &old);
+			
+			macarray->cnt = 0;
+			for (i = 0; i < old.cnt; i++) {
+				if (!old.assoc[i]) {
+					memcpy(macarray->data[macarray->cnt], old.addr[i], WLAN_ADDR_LEN);
+					macarray->cnt++;
+				}
+			}
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2Associated:
+		
+		if (isget) {
+			prism2mib_priv_authlist(hw, &old);
+			
+			macarray->cnt = 0;
+			for (i = 0; i < old.cnt; i++) {
+				if (old.assoc[i]) {
+					memcpy(macarray->data[macarray->cnt], old.addr[i], WLAN_ADDR_LEN);
+					macarray->cnt++;
+				}
+			}
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2PowerSaveUserCount:
+		
+		if (isget)
+			*uint32 = hw->psusercount;
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2Comment:
+		
+		if (isget) {
+			pstr->len = strlen(hw->comment);
+			memcpy(pstr->data, hw->comment, pstr->len);
+		} else {
+			cnt = pstr->len;
+			if (cnt < 0) cnt = 0;
+			if (cnt >= sizeof(hw->comment))
+				cnt = sizeof(hw->comment)-1;
+			memcpy(hw->comment, pstr->data, cnt);
+			pstr->data[cnt] = '\0';
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2AccessMode:
+		
+		if (isget)
+			*uint32 = hw->accessmode;
+		else
+			prism2mib_priv_accessmode(hw, *uint32);
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2AccessAllow:
+		
+		if (isget) {
+			macarray->cnt = hw->allow.cnt;
+			memcpy(macarray->data, hw->allow.addr,
+			       macarray->cnt*WLAN_ADDR_LEN);
+		} else {
+			prism2mib_priv_accessallow(hw, macarray);
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2AccessDeny:
+		
+		if (isget) {
+			macarray->cnt = hw->deny.cnt;
+			memcpy(macarray->data, hw->deny.addr,
+			       macarray->cnt*WLAN_ADDR_LEN);
+		} else {
+			prism2mib_priv_accessdeny(hw, macarray);
+		}
+		
+		break;
+		
+	case DIDmib_p2_p2Table_p2ChannelInfoResults:
+		
+		if (isget) {
+			done = atomic_read(&hw->channel_info.done);
+			if (done == 0) {
+				msg->resultcode.status = P80211ENUM_msgitem_status_no_value;
+				break;
+			}
+			if (done == 1) {
+				msg->resultcode.status = P80211ENUM_msgitem_status_incomplete_itemdata;
+				break;
+			}
+			
+			for (i = 0; i < 14; i++, uint32 += 5) {
+				uint32[0] = i+1;
+				uint32[1] = hw->channel_info.results.result[i].anl;
+				uint32[2] = hw->channel_info.results.result[i].pnl;
+				uint32[3] = (hw->channel_info.results.result[i].active & HFA384x_CHINFORESULT_BSSACTIVE) ? 1 : 0;
+				uint32[4] = (hw->channel_info.results.result[i].active & HFA384x_CHINFORESULT_PCFACTIVE) ? 1 : 0;
+			}
+		}
+		
+		break;
+		
+	case DIDmib_dot11smt_dot11StationConfigTable_dot11DesiredBSSType:
+		
+		if (isget)
+			*uint32 = hw->dot11_desired_bss_type;
+		else
+			hw->dot11_desired_bss_type = *uint32;
+		
+		break;
+		
+	case DIDmib_lnx_lnxConfigTable_lnxRSNAIE: {
+		hfa384x_WPAData_t wpa;
+		if (isget) {
+			hfa384x_drvr_getconfig( hw, HFA384x_RID_CNFWPADATA,
+						(UINT8 *) &wpa, sizeof(wpa));
+			pstr->len = hfa384x2host_16(wpa.datalen);
+			memcpy(pstr->data, wpa.data, pstr->len);
+		} else {
+			wpa.datalen = host2hfa384x_16(pstr->len);
+			memcpy(wpa.data, pstr->data, pstr->len);
+
+			result = hfa384x_drvr_setconfig(hw, HFA384x_RID_CNFWPADATA,
+				(UINT8 *) &wpa, sizeof(wpa));
+		}
+		break;
+	}
+	default:
+		WLAN_LOG_ERROR("Unhandled DID 0x%08x\n", mib->did);
+	}
+
+	DBFEXIT;
+	return(0);
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv_authlist
+*
+* Get a copy of the list of authenticated stations.
+*
+* Arguments:
+*       priv     "priv" structure.
+*       list     List of authenticated stations.
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+static void prism2mib_priv_authlist(
+hfa384x_t             *hw,
+prism2sta_authlist_t  *list)
+{
+	prism2sta_authlist_t  test;
+	int                   i;
+
+	DBFENTER;
+
+	/*
+	** Note: The values in this record are changed by the interrupt
+	** handler and therefore cannot be guaranteed to be stable while
+	** they are being copied.  However, the interrupt handler will
+	** take priority over this code.  Hence, if the same values are
+	** copied twice, then we are ensured that the values have not
+	** been changed.  If they have, then just try again.  Don't try
+	** more than 10 times...the list of authenticated stations is
+	** unlikely to be changing frequently enough that we can't get
+	** a snapshot in 10 tries.  Don't try more than this so that we
+	** don't risk locking-up for long periods of time.  If we still
+	** haven't got the snapshot, then generate an error message and
+	** return an empty list (since this is the only valid list that
+	** we can guarentee).  This scheme for copying values is used in
+	** order to prevent having to block the interrupt handler while
+	** we copy the values.
+	*/
+
+	for (i = 0; i < 10; i++) {
+		memcpy(list, &hw->authlist, sizeof(prism2sta_authlist_t));
+		memcpy(&test, &hw->authlist, sizeof(prism2sta_authlist_t));
+		if (memcmp(list, &test, sizeof(prism2sta_authlist_t)) == 0)
+			break;
+	}
+
+	if (i >= 10) {
+		list->cnt = 0;
+		WLAN_LOG_ERROR("Could not obtain snapshot of authenticated stations.\n");
+		}
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv_accessmode
+*
+* Set the Access Mode.
+*
+* Arguments:
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       mode     New access mode.
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+static void prism2mib_priv_accessmode(
+hfa384x_t         *hw,
+UINT32            mode)
+{
+	prism2sta_authlist_t  old;
+	int                   i, j, deauth;
+	UINT8                 *addr;
+
+	DBFENTER;
+
+	/*
+	** If the mode is not changing or it is changing to "All", then it's
+	** okay to go ahead without a lot of messing around.  Otherwise, the
+	** access mode is changing in a way that may leave some stations
+	** authenticated which should not be authenticated.  It will be
+	** necessary to de-authenticate these stations.
+	*/
+
+	if (mode == WLAN_ACCESS_ALL || mode == hw->accessmode) {
+		hw->accessmode = mode;
+		return;
+	}
+
+	/*
+	** Switch to the new access mode.  Once this is done, then the interrupt
+	** handler (which uses this value) will be prevented from authenticating
+	** ADDITIONAL stations which should not be authenticated.  Then get a
+	** copy of the current list of authenticated stations.
+	*/
+
+	hw->accessmode = mode;
+
+	prism2mib_priv_authlist(hw, &old);
+
+	/*
+	** Now go through the list of previously authenticated stations (some
+	** of which might de-authenticate themselves while we are processing it
+	** but that is okay).  Any station which no longer matches the access
+	** mode, must be de-authenticated.
+	*/
+
+	for (i = 0; i < old.cnt; i++) {
+		addr = old.addr[i];
+
+		if (mode == WLAN_ACCESS_NONE)
+			deauth = 1;
+		else {
+			if (mode == WLAN_ACCESS_ALLOW) {
+				for (j = 0; j < hw->allow.cnt; j++)
+					if (memcmp(addr, hw->allow.addr[j],
+							WLAN_ADDR_LEN) == 0)
+						break;
+				deauth = (j >= hw->allow.cnt);
+			} else {
+				for (j = 0; j < hw->deny.cnt; j++)
+					if (memcmp(addr, hw->deny.addr[j],
+							WLAN_ADDR_LEN) == 0)
+						break;
+				deauth = (j < hw->deny.cnt);
+			}
+		}
+
+		if (deauth) prism2mib_priv_deauthenticate(hw, addr);
+	}
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv_accessallow
+*
+* Change the list of allowed MAC addresses.
+*
+* Arguments:
+*       priv      "priv" structure.
+*       hw        "hw" structure.
+*       macarray  New array of MAC addresses.
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+static void prism2mib_priv_accessallow(
+hfa384x_t         *hw,
+p80211macarray_t  *macarray)
+{
+	prism2sta_authlist_t  old;
+	int                   i, j;
+
+	DBFENTER;
+
+	/*
+	** Change the access list.  Note that the interrupt handler may be in
+	** the middle of using the access list!!!  Since the interrupt handler
+	** will	always have priority over this process and this is the only
+	** process that will modify the list, this problem can be handled as
+	** follows:
+	**
+	**    1. Set the "modify" flag.
+	**    2. Change the first copy of the list.
+	**    3. Clear the "modify" flag.
+	**    4. Change the backup copy of the list.
+	**
+	** The interrupt handler will check the "modify" flag.  If NOT set, then
+	** the first copy of the list is valid and may be used.  Otherwise, the
+	** first copy is being changed but the backup copy is valid and may be
+	** used.  Doing things this way prevents having to have the interrupt
+	** handler block while the list is being updated.
+	*/
+
+	hw->allow.modify = 1;
+
+	hw->allow.cnt = macarray->cnt;
+	memcpy(hw->allow.addr, macarray->data, macarray->cnt*WLAN_ADDR_LEN);
+
+	hw->allow.modify = 0;
+
+	hw->allow.cnt1 = macarray->cnt;
+	memcpy(hw->allow.addr1, macarray->data, macarray->cnt*WLAN_ADDR_LEN);
+
+	/*
+	** If the current access mode is "Allow", then changing the access
+	** list may leave some stations authenticated which should not be
+	** authenticated.  It will be necessary to de-authenticate these
+	** stations.  Otherwise, the list can be changed without a lot of fuss.
+	*/
+
+	if (hw->accessmode == WLAN_ACCESS_ALLOW) {
+
+		/*
+		** Go through the list of authenticated stations (some of
+		** which might de-authenticate themselves while we are
+		** processing it but that is okay).  Any station which is
+		** no longer in the list of allowed stations, must be
+		** de-authenticated.
+		*/
+
+		prism2mib_priv_authlist(hw, &old);
+
+		for (i = 0; i < old.cnt; i++) {
+			for (j = 0; j < hw->allow.cnt; j++)
+				if (memcmp(old.addr[i], hw->allow.addr[j],
+							WLAN_ADDR_LEN) == 0)
+					break;
+			if (j >= hw->allow.cnt)
+				prism2mib_priv_deauthenticate(hw, old.addr[i]);
+		}
+	}
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv_accessdeny
+*
+* Change the list of denied MAC addresses.
+*
+* Arguments:
+*       priv      "priv" structure.
+*       hw        "hw" structure.
+*       macarray  New array of MAC addresses.
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+static void prism2mib_priv_accessdeny(
+hfa384x_t         *hw,
+p80211macarray_t  *macarray)
+{
+	prism2sta_authlist_t  old;
+	int                   i, j;
+
+	DBFENTER;
+
+	/*
+	** Change the access list.  Note that the interrupt handler may be in
+	** the middle of using the access list!!!  Since the interrupt handler
+	** will always have priority over this process and this is the only
+	** process that will modify the list, this problem can be handled as
+	** follows:
+	**
+	**    1. Set the "modify" flag.
+	**    2. Change the first copy of the list.
+	**    3. Clear the "modify" flag.
+	**    4. Change the backup copy of the list.
+	**
+	** The interrupt handler will check the "modify" flag.  If NOT set, then
+	** the first copy of the list is valid and may be used.  Otherwise, the
+	** first copy is being changed but the backup copy is valid and may be
+	** used.  Doing things this way prevents having to have the interrupt
+	** handler block while the list is being updated.
+	*/
+
+	hw->deny.modify = 1;
+
+	hw->deny.cnt = macarray->cnt;
+	memcpy(hw->deny.addr, macarray->data, macarray->cnt*WLAN_ADDR_LEN);
+
+	hw->deny.modify = 0;
+
+	hw->deny.cnt1 = macarray->cnt;
+	memcpy(hw->deny.addr1, macarray->data, macarray->cnt*WLAN_ADDR_LEN);
+
+	/*
+	** If the current access mode is "Deny", then changing the access
+	** list may leave some stations authenticated which should not be
+	** authenticated.  It will be necessary to de-authenticate these
+	** stations.  Otherwise, the list can be changed without a lot of fuss.
+	*/
+
+	if (hw->accessmode == WLAN_ACCESS_DENY) {
+
+		/*
+		** Go through the list of authenticated stations (some of
+		** which might de-authenticate themselves while we are
+		** processing it but that is okay).  Any station which is
+		** now in the list of denied stations, must be de-authenticated.
+		*/
+
+		prism2mib_priv_authlist(hw, &old);
+
+		for (i = 0; i < old.cnt; i++)
+			for (j = 0; j < hw->deny.cnt; j++)
+				if (memcmp(old.addr[i], hw->deny.addr[j],
+							 WLAN_ADDR_LEN) == 0) {
+					prism2mib_priv_deauthenticate(hw, old.addr[i]);
+					break;
+				}
+	}
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2mib_priv_deauthenticate
+*
+* De-authenticate a station.  This is done by sending a HandoverAddress
+* information frame to the firmware.  This should work, according to
+* Intersil.
+*
+* Arguments:
+*       priv     "priv" structure.
+*       hw       "hw" structure.
+*       addr     MAC address of station to be de-authenticated.
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+static void prism2mib_priv_deauthenticate(
+hfa384x_t         *hw,
+UINT8             *addr)
+{
+	DBFENTER;
+	hfa384x_drvr_handover(hw, addr);
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_pstr2bytestr
+*
+* Convert the pstr data in the WLAN message structure into an hfa384x
+* byte string format.
+*
+* Arguments:
+*	bytestr		hfa384x byte string data type
+*	pstr		wlan message data
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_pstr2bytestr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr)
+{
+	DBFENTER;
+
+	bytestr->len = host2hfa384x_16((UINT16)(pstr->len));
+	memcpy(bytestr->data, pstr->data, pstr->len);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_pstr2bytearea
+*
+* Convert the pstr data in the WLAN message structure into an hfa384x
+* byte area format.
+*
+* Arguments:
+*	bytearea	hfa384x byte area data type
+*	pstr		wlan message data
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_pstr2bytearea(UINT8 *bytearea, p80211pstrd_t *pstr)
+{
+	DBFENTER;
+
+	memcpy(bytearea, pstr->data, pstr->len);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_bytestr2pstr
+*
+* Convert the data in an hfa384x byte string format into a
+* pstr in the WLAN message.
+*
+* Arguments:
+*	bytestr		hfa384x byte string data type
+*	msg		wlan message
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_bytestr2pstr(hfa384x_bytestr_t *bytestr, p80211pstrd_t *pstr)
+{
+	DBFENTER;
+
+	pstr->len = (UINT8)(hfa384x2host_16((UINT16)(bytestr->len)));
+	memcpy(pstr->data, bytestr->data, pstr->len);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_bytearea2pstr
+*
+* Convert the data in an hfa384x byte area format into a pstr
+* in the WLAN message.
+*
+* Arguments:
+*	bytearea	hfa384x byte area data type
+*	msg		wlan message
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_bytearea2pstr(UINT8 *bytearea, p80211pstrd_t *pstr, int len)
+{
+	DBFENTER;
+
+	pstr->len = (UINT8)len;
+	memcpy(pstr->data, bytearea, len);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_prism2int2p80211int
+*
+* Convert an hfa384x integer into a wlan integer
+*
+* Arguments:
+*	prism2enum	pointer to hfa384x integer
+*	wlanenum	pointer to p80211 integer
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_prism2int2p80211int(UINT16 *prism2int, UINT32 *wlanint)
+{
+	DBFENTER;
+
+	*wlanint = (UINT32)hfa384x2host_16(*prism2int);
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_p80211int2prism2int
+*
+* Convert a wlan integer into an hfa384x integer
+*
+* Arguments:
+*	prism2enum	pointer to hfa384x integer
+*	wlanenum	pointer to p80211 integer
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+
+void prism2mgmt_p80211int2prism2int(UINT16 *prism2int, UINT32 *wlanint)
+{
+	DBFENTER;
+
+	*prism2int = host2hfa384x_16((UINT16)(*wlanint));
+	DBFEXIT;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_prism2enum2p80211enum
+*
+* Convert the hfa384x enumerated int into a p80211 enumerated int
+*
+* Arguments:
+*	prism2enum	pointer to hfa384x integer
+*	wlanenum	pointer to p80211 integer
+*	rid		hfa384x record id
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+void prism2mgmt_prism2enum2p80211enum(UINT16 *prism2enum, UINT32 *wlanenum, UINT16 rid)
+{
+	DBFENTER;
+
+	/* At the moment, the need for this functionality hasn't
+	presented itself. All the wlan enumerated values are
+	a 1-to-1 match against the Prism2 enumerated values*/
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_p80211enum2prism2enum
+*
+* Convert the p80211 enumerated int into an hfa384x enumerated int
+*
+* Arguments:
+*	prism2enum	pointer to hfa384x integer
+*	wlanenum	pointer to p80211 integer
+*	rid		hfa384x record id
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+void prism2mgmt_p80211enum2prism2enum(UINT16 *prism2enum, UINT32 *wlanenum, UINT16 rid)
+{
+	DBFENTER;
+
+	/* At the moment, the need for this functionality hasn't
+	presented itself. All the wlan enumerated values are
+	a 1-to-1 match against the Prism2 enumerated values*/
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_get_oprateset
+*
+* Convert the hfa384x bit area into a wlan octet string.
+*
+* Arguments:
+*	rate		Prism2 bit area
+*	pstr		wlan octet string
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+void prism2mgmt_get_oprateset(UINT16 *rate, p80211pstrd_t *pstr)
+{
+	UINT8	len;
+	UINT8	*datarate;
+
+	DBFENTER;
+
+	len = 0;
+	datarate = pstr->data;
+
+ 	/* 1 Mbps */
+	if ( BIT0 & (*rate) ) {
+		len += (UINT8)1;
+		*datarate = (UINT8)2;
+		datarate++;
+	}
+
+ 	/* 2 Mbps */
+	if ( BIT1 & (*rate) ) {
+		len += (UINT8)1;
+		*datarate = (UINT8)4;
+		datarate++;
+	}
+
+ 	/* 5.5 Mbps */
+	if ( BIT2 & (*rate) ) {
+		len += (UINT8)1;
+		*datarate = (UINT8)11;
+		datarate++;
+	}
+
+ 	/* 11 Mbps */
+	if ( BIT3 & (*rate) ) {
+		len += (UINT8)1;
+		*datarate = (UINT8)22;
+		datarate++;
+	}
+
+	pstr->len = len;
+
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_set_oprateset
+*
+* Convert the wlan octet string into an hfa384x bit area.
+*
+* Arguments:
+*	rate		Prism2 bit area
+*	pstr		wlan octet string
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+void prism2mgmt_set_oprateset(UINT16 *rate, p80211pstrd_t *pstr)
+{
+	UINT8	*datarate;
+	int	i;
+
+	DBFENTER;
+
+	*rate = 0;
+
+	datarate = pstr->data;
+
+	for ( i=0; i < pstr->len; i++, datarate++ ) {
+		switch (*datarate) {
+		case 2: /* 1 Mbps */
+			*rate |= BIT0;
+			break;
+		case 4: /* 2 Mbps */
+			*rate |= BIT1;
+			break;
+		case 11: /* 5.5 Mbps */
+			*rate |= BIT2;
+			break;
+		case 22: /* 11 Mbps */
+			*rate |= BIT3;
+			break;
+		default:
+			WLAN_LOG_DEBUG(1, "Unrecoginzed Rate of %d\n",
+				*datarate);
+			break;
+		}
+	}
+
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_get_grpaddr
+*
+* Retrieves a particular group address from the list of
+* group addresses.
+*
+* Arguments:
+*	did		mibitem did
+*	pstr		wlan octet string
+*	priv		prism2 driver private data structure
+*
+* Returns: 
+*	Nothing
+*
+----------------------------------------------------------------*/
+void prism2mgmt_get_grpaddr(UINT32 did, p80211pstrd_t *pstr,
+	hfa384x_t *hw )
+{
+	int	index;
+			
+	DBFENTER;
+
+	index = prism2mgmt_get_grpaddr_index(did);
+
+	if ( index >= 0 ) {
+		pstr->len = WLAN_ADDR_LEN;
+		memcpy(pstr->data, hw->dot11_grp_addr[index],
+			WLAN_ADDR_LEN);
+	}
+
+	DBFEXIT;
+	return;
+}
+
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_set_grpaddr
+*
+* Convert the wlan octet string into an hfa384x bit area.
+*
+* Arguments:
+*	did		mibitem did
+*	buf		
+*	groups
+*
+* Returns: 
+*	0	Success
+*	!0	Error
+*
+----------------------------------------------------------------*/
+int prism2mgmt_set_grpaddr(UINT32 did, UINT8 *prism2buf,
+	p80211pstrd_t *pstr, hfa384x_t *hw )
+{
+	UINT8	no_addr[WLAN_ADDR_LEN];
+	int	index;
+
+	DBFENTER;
+
+	memset(no_addr, 0, WLAN_ADDR_LEN);
+	if (memcmp(no_addr, pstr->data, WLAN_ADDR_LEN) != 0) {
+
+		/*
+		** The address is NOT 0 so we are "adding" an address to the
+		** group address list.  Check to make sure we aren't trying
+		** to add more than the maximum allowed number of group
+		** addresses in the list.  The new address is added to the
+		** end of the list regardless of the DID used to add the
+		** address.
+		*/
+
+		if (hw->dot11_grpcnt >= MAX_GRP_ADDR) return(-1);
+
+		memcpy(hw->dot11_grp_addr[hw->dot11_grpcnt], pstr->data,
+								 WLAN_ADDR_LEN);
+		hw->dot11_grpcnt += 1;
+	} else {
+
+		/*
+		** The address is 0.  Interpret this as "deleting" an address
+		** from the group address list.  Get the address index from
+		** the DID.  If this is within the range of used addresses,
+		** then delete the specified address by shifting all following
+		** addresses down.  Then clear the last address (which should
+		** now be unused).  If the address index is NOT within the
+		** range of used addresses, then just ignore the address.
+		*/
+
+		index = prism2mgmt_get_grpaddr_index(did);
+		if (index >= 0 && index < hw->dot11_grpcnt) {
+			hw->dot11_grpcnt -= 1;
+			memmove(hw->dot11_grp_addr[index],
+				hw->dot11_grp_addr[index + 1],
+				((hw->dot11_grpcnt)-index) * WLAN_ADDR_LEN);
+			memset(hw->dot11_grp_addr[hw->dot11_grpcnt], 0,
+								 WLAN_ADDR_LEN);
+		}
+	}
+
+	DBFEXIT;
+	return(0);
+}
+
+
+/*----------------------------------------------------------------
+* prism2mgmt_get_grpaddr_index
+*
+* Gets the index in the group address list based on the did.
+*
+* Arguments:
+*	did		mibitem did
+*
+* Returns: 
+*	>= 0	If valid did
+*	< 0	If not valid did
+*
+----------------------------------------------------------------*/
+int prism2mgmt_get_grpaddr_index( UINT32 did )
+{
+	int	index;
+
+	DBFENTER;
+
+	index = -1;
+
+	switch (did) {
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address1:
+		index = 0;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address2:
+		index = 1;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address3:
+		index = 2;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address4:
+		index = 3;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address5:
+		index = 4;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address6:
+		index = 5;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address7:
+		index = 6;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address8:
+		index = 7;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address9:
+		index = 8;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address10:
+		index = 9;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address11:
+		index = 10;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address12:
+		index = 11;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address13:
+		index = 12;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address14:
+		index = 13;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address15:
+		index = 14;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address16:
+		index = 15;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address17:
+		index = 16;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address18:
+		index = 17;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address19:
+		index = 18;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address20:
+		index = 19;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address21:
+		index = 20;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address22:
+		index = 21;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address23:
+		index = 22;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address24:
+		index = 23;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address25:
+		index = 24;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address26:
+		index = 25;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address27:
+		index = 26;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address28:
+		index = 27;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address29:
+		index = 28;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address30:
+		index = 29;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address31:
+		index = 30;
+		break;
+	case DIDmib_dot11mac_dot11GroupAddressesTable_dot11Address32:
+		index = 31;
+		break;
+	}
+
+	DBFEXIT;
+	return index;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_pci.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_pci.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_pci.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_pci.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,332 @@
+#define WLAN_HOSTIF WLAN_PCI
+#include "hfa384x.c"
+#include "prism2mgmt.c"
+#include "prism2mib.c"
+#include "prism2sta.c"
+
+#define PCI_SIZE		0x1000		/* Memory size - 4K bytes */
+
+/* ISL3874A 11Mb/s WLAN controller */
+#define PCIVENDOR_INTERSIL	0x1260UL
+#define PCIDEVICE_ISL3874	0x3873UL /* [MSM] yeah I know...the ID says 
+					    3873. Trust me, it's a 3874. */
+
+/* Samsung SWL-2210P 11Mb/s WLAN controller (uses ISL3874A) */
+#define PCIVENDOR_SAMSUNG      0x167dUL
+#define PCIDEVICE_SWL_2210P    0xa000UL
+
+#define PCIVENDOR_NETGEAR      0x1385UL /* for MA311 */
+
+/* PCI Class & Sub-Class code, Network-'Other controller' */
+#define PCI_CLASS_NETWORK_OTHERS 0x280
+
+
+/*----------------------------------------------------------------
+* prism2sta_probe_pci
+*
+* Probe routine called when a PCI device w/ matching ID is found. 
+* The ISL3874 implementation uses the following map:
+*   BAR0: Prism2.x registers memory mapped, size=4k
+* Here's the sequence:
+*   - Allocate the PCI resources.  
+*   - Read the PCMCIA attribute memory to make sure we have a WLAN card
+*   - Reset the MAC 
+*   - Initialize the netdev and wlan data
+*   - Initialize the MAC
+*
+* Arguments:
+*	pdev		ptr to pci device structure containing info about 
+*			pci configuration.
+*	id		ptr to the device id entry that matched this device.
+*
+* Returns: 
+*	zero		- success
+*	negative	- failed
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process thread
+*	
+----------------------------------------------------------------*/
+static int __devinit
+prism2sta_probe_pci(
+	struct pci_dev *pdev, 
+	const struct pci_device_id *id)
+{
+	int		result;
+	phys_t		phymem = 0;
+	void		*mem = NULL;
+        wlandevice_t    *wlandev = NULL;
+	hfa384x_t	*hw = NULL;
+
+	DBFENTER;
+
+	/* Enable the pci device */
+	if (pci_enable_device(pdev)) {
+		WLAN_LOG_ERROR("%s: pci_enable_device() failed.\n", dev_info);
+		result = -EIO;
+		goto fail;
+	}
+
+	/* Figure out our resources */
+	phymem = pci_resource_start(pdev, 0);
+
+        if (!request_mem_region(phymem, pci_resource_len(pdev, 0), "Prism2")) {
+		printk(KERN_ERR "prism2: Cannot reserve PCI memory region\n");
+		result = -EIO;
+		goto fail;
+        }
+
+	mem = ioremap(phymem, PCI_SIZE);
+	if ( mem == 0 ) {
+		WLAN_LOG_ERROR("%s: ioremap() failed.\n", dev_info);
+		result = -EIO;
+		goto fail;
+	}
+
+	/* Log the device */
+        WLAN_LOG_INFO("A Prism2.5 PCI device found, "
+		"phymem:0x%llx, irq:%d, mem:0x%p\n", 
+		(unsigned long long)phymem, pdev->irq, mem);
+	
+	if ((wlandev = create_wlan()) == NULL) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		result = -EIO;
+		goto fail;
+	}
+	hw = wlandev->priv;
+	
+	if ( wlan_setup(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: wlan_setup() failed.\n", dev_info);
+		result = -EIO;
+		goto fail;
+	}
+
+	/* Setup netdevice's ability to report resources 
+	 * Note: the netdevice was allocated by wlan_setup()
+	 */
+        wlandev->netdev->irq = pdev->irq;
+        wlandev->netdev->mem_start = (unsigned long) mem;
+        wlandev->netdev->mem_end = wlandev->netdev->mem_start + 
+		pci_resource_len(pdev, 0);
+
+	/* Initialize the hw data */
+        hfa384x_create(hw, wlandev->netdev->irq, 0, mem);
+	hw->wlandev = wlandev;
+
+	/* Register the wlandev, this gets us a name and registers the
+	 * linux netdevice.
+	 */
+	SET_MODULE_OWNER(wlandev->netdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+       SET_NETDEV_DEV(wlandev->netdev, &(pdev->dev));
+#endif
+        if ( register_wlandev(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: register_wlandev() failed.\n", dev_info);
+		result = -EIO;
+		goto fail;
+        }
+
+#if 0
+	/* TODO: Move this and an irq test into an hfa384x_testif() routine.
+	 */
+	outw(PRISM2STA_MAGIC, HFA384x_SWSUPPORT(wlandev->netdev->base_addr));
+	reg=inw( HFA384x_SWSUPPORT(wlandev->netdev->base_addr));
+	if ( reg != PRISM2STA_MAGIC ) {
+		WLAN_LOG_ERROR("MAC register access test failed!\n");
+		result = -EIO;
+		goto fail;
+	}		
+#endif
+
+	/* Do a chip-level reset on the MAC */
+	if (prism2_doreset) {
+		result = hfa384x_corereset(hw, 
+				prism2_reset_holdtime, 
+				prism2_reset_settletime, 0);
+		if (result != 0) {
+			WLAN_LOG_ERROR(
+				"%s: hfa384x_corereset() failed.\n", 
+				dev_info);
+			unregister_wlandev(wlandev);
+			hfa384x_destroy(hw);
+			result = -EIO;
+			goto fail;
+		}
+	}
+
+        pci_set_drvdata(pdev, wlandev);
+
+	/* Shouldn't actually hook up the IRQ until we 
+	 * _know_ things are alright.  A test routine would help.
+	 */
+       	request_irq(wlandev->netdev->irq, hfa384x_interrupt, 
+		IRQF_SHARED, wlandev->name, wlandev);
+
+	wlandev->msdstate = WLAN_MSD_HWPRESENT;
+
+	result = 0;
+	goto done;
+
+ fail:
+	pci_set_drvdata(pdev, NULL);
+	if (wlandev)	kfree(wlandev);
+	if (hw)		kfree(hw);
+        if (mem)        iounmap((void *) mem);
+	pci_release_regions(pdev);
+        pci_disable_device(pdev);
+
+ done:
+	DBFEXIT;
+	return result;
+}
+
+static void __devexit prism2sta_remove_pci(struct pci_dev *pdev)
+{
+       	wlandevice_t		*wlandev;
+	hfa384x_t	*hw;
+
+	wlandev = (wlandevice_t *) pci_get_drvdata(pdev);
+	hw = wlandev->priv;
+
+	p80211netdev_hwremoved(wlandev);
+
+	/* reset hardware */
+	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+
+        if (pdev->irq)
+		free_irq(pdev->irq, wlandev);
+
+	unregister_wlandev(wlandev);
+
+	/* free local stuff */
+	if (hw) {
+		hfa384x_destroy(hw);
+		kfree(hw);
+	}
+
+	iounmap((void*) wlandev->netdev->mem_start);
+	wlan_unsetup(wlandev);
+
+	pci_release_regions(pdev);
+        pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(wlandev);
+}
+
+
+static struct pci_device_id pci_id_tbl[] = {
+	{
+		PCIVENDOR_INTERSIL, PCIDEVICE_ISL3874,	
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"Intersil Prism2.5 ISL3874 11Mb/s WLAN Controller"
+	},
+	{
+		PCIVENDOR_INTERSIL, 0x3872,	
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"Intersil Prism2.5 ISL3872 11Mb/s WLAN Controller"
+	},
+        { 
+               PCIVENDOR_SAMSUNG, PCIDEVICE_SWL_2210P,
+               PCI_ANY_ID, PCI_ANY_ID,
+               0, 0,
+               /* Driver data, we just put the name here */
+               (unsigned long)"Samsung MagicLAN SWL-2210P 11Mb/s WLAN Controller"
+	},
+	{ /* for NetGear MA311 */
+		PCIVENDOR_NETGEAR, 0x3872,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		/* Driver data, we just put the name here */
+		(unsigned long)"Netgear MA311 WLAN Controller"
+	},
+	{
+		0, 0, 0, 0, 0, 0, 0
+	}
+};
+
+MODULE_DEVICE_TABLE(pci, pci_id_tbl);
+
+/* Function declared here because of ptr reference below */
+static int  __devinit prism2sta_probe_pci(struct pci_dev *pdev, 
+				const struct pci_device_id *id);
+static void  __devexit prism2sta_remove_pci(struct pci_dev *pdev);
+
+struct pci_driver prism2_pci_drv_id = {
+        .name = "prism2_pci",
+        .id_table = pci_id_tbl,
+        .probe = prism2sta_probe_pci,
+        .remove = prism2sta_remove_pci,
+#ifdef CONFIG_PM
+        .suspend = prism2sta_suspend_pci,
+        .resume = prism2sta_resume_pci,
+#endif
+};
+
+#ifdef MODULE
+
+static int __init prism2pci_init(void)
+{
+        WLAN_LOG_NOTICE("%s Loaded\n", version);
+	return pci_module_init(&prism2_pci_drv_id);
+};
+
+static void __exit prism2pci_cleanup(void)
+{
+	pci_unregister_driver(&prism2_pci_drv_id);
+};
+
+module_init(prism2pci_init);
+module_exit(prism2pci_cleanup);
+
+#endif
+
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+{
+	int		result = 0;
+	unsigned long	timeout;
+	UINT16	reg;
+	DBFENTER;
+
+	/* Assert reset and wait awhile 
+	 * (note: these delays are _really_ long, but they appear to be
+	 *        necessary.)
+	 */
+	hfa384x_setreg(hw, 0xc5, HFA384x_PCICOR);
+	timeout = jiffies + HZ/4;
+	while(time_before(jiffies, timeout)) udelay(5);
+
+	if (genesis) {
+		hfa384x_setreg(hw, genesis, HFA384x_PCIHCR);
+		timeout = jiffies + HZ/4;
+		while(time_before(jiffies, timeout)) udelay(5);
+	}
+
+	/* Clear the reset and wait some more 
+	 */
+	hfa384x_setreg(hw, 0x45, HFA384x_PCICOR);
+	timeout = jiffies + HZ/2;
+	while(time_before(jiffies, timeout)) udelay(5);	
+
+	/* Wait for f/w to complete initialization (CMD:BUSY == 0) 
+	 */
+	timeout = jiffies + 2*HZ;
+	reg = hfa384x_getreg(hw, HFA384x_CMD);
+	while ( HFA384x_CMD_ISBUSY(reg) && time_before( jiffies, timeout) ) {
+		reg = hfa384x_getreg(hw, HFA384x_CMD);
+		udelay(10);
+	}
+	if (HFA384x_CMD_ISBUSY(reg)) {
+		WLAN_LOG_WARNING("corereset: Timed out waiting for cmd register.\n");
+		result=1;
+	}
+	DBFEXIT;
+	return result;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_plx.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_plx.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_plx.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_plx.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,471 @@
+#define WLAN_HOSTIF WLAN_PLX
+#include "hfa384x.c"
+#include "prism2mgmt.c"
+#include "prism2mib.c"
+#include "prism2sta.c"
+
+#define PLX_ATTR_SIZE	0x1000	/* Attribute memory size - 4K bytes */
+#define COR_OFFSET	0x3e0	/* COR attribute offset of Prism2 PC card */
+#define COR_VALUE	0x41	/* Enable PC card with irq in level trigger */
+#define PLX_INTCSR	0x4c	/* Interrupt Control and Status Register */
+#define PLX_INTCSR_INTEN (1<<6) /* Interrupt Enable bit */
+#define PLX_MIN_ATTR_LEN 512    /* at least 2 x 256 is needed for CIS */
+
+/* 3Com 3CRW777A (PLX) board ID */
+#define PCIVENDOR_3COM       0x10B7
+#define PCIDEVICE_AIRCONNECT 0x7770
+
+/* Eumitcom PCI WL11000 PCI Adapter (PLX) board device+vendor ID */
+#define PCIVENDOR_EUMITCOM	0x1638UL
+#define PCIDEVICE_WL11000	0x1100UL
+
+/* Global Sun Tech GL24110P PCI Adapter (PLX) board device+vendor ID */
+#define PCIVENDOR_GLOBALSUN	0x16abUL
+#define PCIDEVICE_GL24110P	0x1101UL
+#define PCIDEVICE_GL24110P_ALT	0x1102UL
+
+/* Netgear MA301 PCI Adapter (PLX) board device+vendor ID */
+#define PCIVENDOR_NETGEAR	0x1385UL
+#define PCIDEVICE_MA301		0x4100UL
+
+/* US Robotics USR2410 PCI Adapter (PLX) board device+vendor ID */
+#define	PCIVENDOR_USROBOTICS    0x16ecUL
+#define PCIDEVICE_USR2410       0x3685UL
+
+/* Linksys WPC11 card with the WDT11 adapter (PLX) board device+vendor ID */
+#define	PCIVENDOR_Linksys       0x16abUL
+#define PCIDEVICE_Wpc11Wdt11    0x1102UL
+
+/* National Datacomm Corp SOHOware Netblaster II PCI */
+#define PCIVENDOR_NDC	        0x15e8UL
+#define PCIDEVICE_NCP130_PLX 	0x0130UL
+#define PCIDEVICE_NCP130_ASIC	0x0131UL
+
+/* NDC NCP130_PLX is also sold by Corega. Their name is CGWLPCIA11 */
+#define PCIVENDOR_COREGA       PCIVENDOR_NDC
+#define PCIDEVICE_CGWLPCIA11   PCIDEVICE_NCP130_PLX
+
+/* PCI Class & Sub-Class code, Network-'Other controller' */
+#define PCI_CLASS_NETWORK_OTHERS 0x280
+
+/*----------------------------------------------------------------
+* prism2sta_probe_plx
+*
+* Probe routine called when a PCI device w/ matching ID is found. 
+* This PLX implementation uses the following map:
+*   BAR0: Unused
+*   BAR1: ????
+*   BAR2: PCMCIA attribute memory
+*   BAR3: PCMCIA i/o space 
+* Here's the sequence:
+*   - Allocate the PCI resources.  
+*   - Read the PCMCIA attribute memory to make sure we have a WLAN card
+*   - Reset the MAC using the PCMCIA COR
+*   - Initialize the netdev and wlan data
+*   - Initialize the MAC
+*
+* Arguments:
+*	pdev		ptr to pci device structure containing info about 
+*			pci configuration.
+*	id		ptr to the device id entry that matched this device.
+*
+* Returns: 
+*	zero		- success
+*	negative	- failed
+*
+* Side effects:
+*	
+*
+* Call context:
+*	process thread
+*	
+----------------------------------------------------------------*/
+static int __devinit
+prism2sta_probe_plx(
+	struct pci_dev			*pdev, 
+	const struct pci_device_id	*id)
+{
+	int		result;
+        phys_t	pccard_ioaddr;
+	phys_t  pccard_attr_mem;
+        unsigned int    pccard_attr_len;
+	UINT8 *attr_mem = NULL;
+	UINT32		plx_addr; 
+        wlandevice_t    *wlandev = NULL;
+	hfa384x_t	*hw = NULL;
+	int		reg;
+        u32		regic;
+
+	if (pci_enable_device(pdev))
+		return -EIO;
+
+	/* TMC7160 boards are special */
+	if ((pdev->vendor == PCIVENDOR_NDC) && 
+	    (pdev->device == PCIDEVICE_NCP130_ASIC)) {
+		unsigned long delay;
+
+		pccard_attr_mem = 0;
+		pccard_ioaddr = pci_resource_start(pdev, 1);
+
+		outb(0x45, pccard_ioaddr);
+		delay = jiffies + 1*HZ;
+		while (time_before(jiffies, delay));
+
+		if (inb(pccard_ioaddr) != 0x45) {
+			WLAN_LOG_ERROR("Initialize the TMC7160 failed. (0x%x)\n", inb(pccard_ioaddr));
+			return -EIO;
+		}
+		
+		pccard_ioaddr = pci_resource_start(pdev, 2);
+		prism2_doreset = 0;
+
+		WLAN_LOG_INFO("NDC NCP130 with TMC716(ASIC) PCI interface device found at io:0x%x, irq:%d\n", pccard_ioaddr, pdev->irq);
+		goto init;
+	}
+
+	/* Collect the resource requirements */
+	pccard_attr_mem = pci_resource_start(pdev, 2);
+	pccard_attr_len = pci_resource_len(pdev, 2);
+        if (pccard_attr_len < PLX_MIN_ATTR_LEN)
+		return -EIO;
+
+	pccard_ioaddr = pci_resource_start(pdev, 3);
+
+	/* bjoern: We need to tell the card to enable interrupts, in
+	 * case the serial eprom didn't do this already. See the
+	 * PLX9052 data book, p8-1 and 8-24 for reference.
+	 * [MSM]: This bit of code came from the orinoco_cs driver.
+	 */
+	plx_addr = pci_resource_start(pdev, 1);
+
+	regic = 0;
+	regic = inl(plx_addr+PLX_INTCSR);
+	if(regic & PLX_INTCSR_INTEN) {
+		WLAN_LOG_DEBUG(1,
+			"%s: Local Interrupt already enabled\n", dev_info);
+	} else {
+		regic |= PLX_INTCSR_INTEN;
+		outl(regic, plx_addr+PLX_INTCSR);
+		regic = inl(plx_addr+PLX_INTCSR);
+		if(!(regic & PLX_INTCSR_INTEN)) {
+			WLAN_LOG_ERROR(
+				"%s: Couldn't enable Local Interrupts\n",
+				dev_info);
+			return -EIO;
+		}
+	}
+
+	/* These assignments are here in case of future mappings for
+	 * io space and irq that might be similar to ioremap 
+	 */
+        if (!request_mem_region(pccard_attr_mem, pci_resource_len(pdev, 2), "Prism2")) {
+		WLAN_LOG_ERROR("%s: Couldn't reserve PCI memory region\n", dev_info);
+		return -EIO;
+        }
+
+	attr_mem = ioremap(pccard_attr_mem, pccard_attr_len);
+
+	WLAN_LOG_INFO("A PLX PCI/PCMCIA interface device found, "
+		"phymem:0x%llx, phyio=0x%x, irq:%d, "
+		"mem: 0x%lx\n", 
+		(unsigned long long)pccard_attr_mem, pccard_ioaddr, pdev->irq,
+		(long)attr_mem);
+
+	/* Verify whether PC card is present. 
+	 * [MSM] This needs improvement, the right thing to do is
+	 * probably to walk the CIS looking for the vendor and product
+	 * IDs.  It would be nice if this could be tied in with the
+	 * etc/pcmcia/wlan-ng.conf file.  Any volunteers?  ;-)
+	 */
+	if (
+	attr_mem[0] != 0x01 || attr_mem[2] != 0x03 ||
+	attr_mem[4] != 0x00 || attr_mem[6] != 0x00 ||
+	attr_mem[8] != 0xFF || attr_mem[10] != 0x17 ||
+	attr_mem[12] != 0x04 || attr_mem[14] != 0x67) {
+		WLAN_LOG_ERROR("Prism2 PC card CIS is invalid.\n");
+		return -EIO;
+        }
+        WLAN_LOG_INFO("A PCMCIA WLAN adapter was found.\n");
+
+        /* Write COR to enable PC card */
+	attr_mem[COR_OFFSET] = COR_VALUE; reg = attr_mem[COR_OFFSET];
+	
+ init:
+
+	/*
+	 * Now do everything the same as a PCI device
+	 * [MSM] TODO: We could probably factor this out of pcmcia/pci/plx
+	 * and perhaps usb.  Perhaps a task for another day.......
+	 */
+
+	if ((wlandev = create_wlan()) == NULL) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}
+
+	hw = wlandev->priv;
+
+	if ( wlan_setup(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: wlan_setup() failed.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}
+
+	/* Setup netdevice's ability to report resources 
+	 * Note: the netdevice was allocated by wlan_setup()
+	 */
+        wlandev->netdev->irq = pdev->irq;
+        wlandev->netdev->base_addr = pccard_ioaddr;
+        wlandev->netdev->mem_start = (unsigned long)attr_mem;
+        wlandev->netdev->mem_end = (unsigned long)attr_mem + pci_resource_len(pdev, 0);
+
+	/* Initialize the hw data */
+        hfa384x_create(hw, wlandev->netdev->irq, pccard_ioaddr, attr_mem);
+	hw->wlandev = wlandev;
+
+	/* Register the wlandev, this gets us a name and registers the
+	 * linux netdevice.
+	 */
+	SET_MODULE_OWNER(wlandev->netdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+       SET_NETDEV_DEV(wlandev->netdev, &(pdev->dev));
+#endif
+        if ( register_wlandev(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: register_wlandev() failed.\n", dev_info);
+		result = -EIO;
+		goto failed;
+        }
+
+#if 0
+	/* TODO: Move this and an irq test into an hfa384x_testif() routine.
+	 */
+	outw(PRISM2STA_MAGIC, HFA384x_SWSUPPORT(wlandev->netdev->base_addr));
+	reg=inw( HFA384x_SWSUPPORT(wlandev->netdev->base_addr));
+	if ( reg != PRISM2STA_MAGIC ) {
+		WLAN_LOG_ERROR("MAC register access test failed!\n");
+ 		result = -EIO;
+		goto failed;
+	}		
+#endif
+
+	/* Do a chip-level reset on the MAC */
+	if (prism2_doreset) {
+		result = hfa384x_corereset(hw, 
+				prism2_reset_holdtime, 
+				prism2_reset_settletime, 0);
+		if (result != 0) {
+			unregister_wlandev(wlandev);
+			hfa384x_destroy(hw);
+			WLAN_LOG_ERROR(
+				"%s: hfa384x_corereset() failed.\n", 
+				dev_info);
+			result = -EIO;
+			goto failed;
+		}
+	}
+
+	pci_set_drvdata(pdev, wlandev);
+
+	/* Shouldn't actually hook up the IRQ until we 
+	 * _know_ things are alright.  A test routine would help.
+	 */
+       	request_irq(wlandev->netdev->irq, hfa384x_interrupt, 
+		IRQF_SHARED, wlandev->name, wlandev);
+
+	wlandev->msdstate = WLAN_MSD_HWPRESENT;
+
+	result = 0;
+
+	goto done;
+	
+ failed:
+
+	pci_set_drvdata(pdev, NULL);
+	if (wlandev)	kfree(wlandev);
+	if (hw)		kfree(hw);
+        if (attr_mem)        iounmap((void *) attr_mem);
+	pci_release_regions(pdev);
+        pci_disable_device(pdev);
+
+ done:
+	DBFEXIT;
+        return result;
+}
+
+static void __devexit prism2sta_remove_plx(struct pci_dev *pdev)
+{
+       	wlandevice_t		*wlandev;
+	hfa384x_t               *hw;
+
+	wlandev = (wlandevice_t *) pci_get_drvdata(pdev);
+	hw = wlandev->priv;
+
+	p80211netdev_hwremoved(wlandev);
+
+	/* reset hardware */
+	prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+
+        if (pdev->irq)
+		free_irq(pdev->irq, wlandev);
+
+	unregister_wlandev(wlandev);
+
+	/* free local stuff */
+	if (hw) {
+		hfa384x_destroy(hw);
+		kfree(hw);
+	}
+
+	iounmap((void*)wlandev->netdev->mem_start);
+	wlan_unsetup(wlandev);
+
+	pci_release_regions(pdev);
+        pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
+
+	kfree(wlandev);
+}
+
+static struct pci_device_id plx_id_tbl[] = {
+	{
+		PCIVENDOR_EUMITCOM, PCIDEVICE_WL11000,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		/* Driver data, we just put the name here */
+		(unsigned long)"Eumitcom WL11000 PCI(PLX) card"	
+	},
+	{
+		PCIVENDOR_GLOBALSUN, PCIDEVICE_GL24110P,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"Global Sun Tech GL24110P PCI(PLX) card"
+	},
+	{
+		PCIVENDOR_GLOBALSUN, PCIDEVICE_GL24110P_ALT,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"Global Sun Tech GL24110P PCI(PLX) card"
+	},
+	{
+		PCIVENDOR_NETGEAR, PCIDEVICE_MA301,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"Global Sun Tech GL24110P PCI(PLX) card"
+	},
+	{
+		PCIVENDOR_USROBOTICS, PCIDEVICE_USR2410,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		/* Driver data, we just put the name here */
+		(unsigned long)"US Robotics USR2410 PCI(PLX) card"	
+	},
+	{
+		PCIVENDOR_Linksys, PCIDEVICE_Wpc11Wdt11,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0,
+		/* Driver data, we just put the name here */
+		(unsigned long)"Linksys WPC11 with WDT11 PCI(PLX) adapter"	
+	},
+	{
+	        PCIVENDOR_NDC, PCIDEVICE_NCP130_PLX,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"NDC Netblaster II PCI(PLX)"
+	},
+	{
+	        PCIVENDOR_NDC, PCIDEVICE_NCP130_ASIC,
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"NDC Netblaster II PCI(TMC7160)"
+	},
+	{
+		PCIVENDOR_3COM, PCIDEVICE_AIRCONNECT,	
+		PCI_ANY_ID, PCI_ANY_ID,
+		0, 0, 
+		/* Driver data, we just put the name here */
+		(unsigned long)"3Com AirConnect PCI 802.11b 11Mb/s WLAN Controller"
+	},
+	{
+		0, 0, 0, 0, 0, 0, 0
+	}
+};
+
+MODULE_DEVICE_TABLE(pci, plx_id_tbl);
+
+/* Function declared here because of ptr reference below */
+static int __devinit prism2sta_probe_plx(struct pci_dev *pdev, 
+					 const struct pci_device_id *);
+static void __devexit prism2sta_remove_plx(struct pci_dev *pdev);
+
+struct pci_driver prism2_plx_drv_id = {
+        .name = "prism2_plx",
+        .id_table = plx_id_tbl,
+        .probe = prism2sta_probe_plx,
+        .remove = prism2sta_remove_plx,
+#ifdef CONFIG_PM
+        .suspend = prism2sta_suspend_pci,
+        .resume = prism2sta_resume_pci,
+#endif
+};
+
+#ifdef MODULE
+
+static int __init prism2plx_init(void)
+{
+        WLAN_LOG_NOTICE("%s Loaded\n", version);
+	return pci_module_init(&prism2_plx_drv_id);
+};
+
+static void __exit prism2plx_cleanup(void)
+{
+	pci_unregister_driver(&prism2_plx_drv_id);
+};
+
+module_init(prism2plx_init);
+module_exit(prism2plx_cleanup);
+
+#endif // MODULE
+
+
+int hfa384x_corereset(hfa384x_t *hw, int holdtime, int settletime, int genesis)
+{
+	int		result = 0;
+
+#define COR_OFFSET	0x3e0	/* COR attribute offset of Prism2 PC card */
+#define COR_VALUE	0x41	/* Enable PC card with irq in level trigger */
+
+#define HCR_OFFSET	0x3e2	/* HCR attribute offset of Prism2 PC card */
+
+	UINT8		corsave;
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(3, "Doing reset via direct COR access.\n");
+
+	/* Collect COR */
+	corsave = ((UINT8*)hw->membase)[COR_OFFSET];
+	/* Write reset bit (BIT7) */
+	((UINT8*)hw->membase)[COR_OFFSET] = corsave | BIT7;
+	/* Hold for holdtime */
+	mdelay(holdtime);
+
+	if (genesis) {
+		((UINT8*)hw->membase)[HCR_OFFSET] = genesis; 
+		/* Hold for holdtime */
+		mdelay(holdtime);
+	}
+
+	/* Clear reset bit */
+	((UINT8*)hw->membase)[COR_OFFSET] = corsave & ~BIT7;
+	/* Wait for settletime */
+	mdelay(settletime);
+	/* Set non-reset bits back what they were */
+	((UINT8*)hw->membase)[COR_OFFSET] = corsave;
+	DBFEXIT;
+	return result;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2sta.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2sta.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2sta.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2sta.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,2494 @@
+/* src/prism2/driver/prism2sta.c
+*
+* Implements the station functionality for prism2
+*
+* Copyright (C) 1999 AbsoluteValue Systems, Inc.  All Rights Reserved.
+* --------------------------------------------------------------------
+*
+* linux-wlan
+*
+*   The contents of this file are subject to the Mozilla Public
+*   License Version 1.1 (the "License"); you may not use this file
+*   except in compliance with the License. You may obtain a copy of
+*   the License at http://www.mozilla.org/MPL/
+*
+*   Software distributed under the License is distributed on an "AS
+*   IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
+*   implied. See the License for the specific language governing
+*   rights and limitations under the License.
+*
+*   Alternatively, the contents of this file may be used under the
+*   terms of the GNU Public License version 2 (the "GPL"), in which
+*   case the provisions of the GPL are applicable instead of the
+*   above.  If you wish to allow the use of your version of this file
+*   only under the terms of the GPL and not to allow others to use
+*   your version of this file under the MPL, indicate your decision
+*   by deleting the provisions above and replace them with the notice
+*   and other provisions required by the GPL.  If you do not delete
+*   the provisions above, a recipient may use your version of this
+*   file under either the MPL or the GPL.
+*
+* --------------------------------------------------------------------
+*
+* Inquiries regarding the linux-wlan Open Source project can be
+* made directly to:
+*
+* AbsoluteValue Systems Inc.
+* info@linux-wlan.com
+* http://www.linux-wlan.com
+*
+* --------------------------------------------------------------------
+*
+* Portions of the development of this software were funded by 
+* Intersil Corporation as part of PRISM(R) chipset product development.
+*
+* --------------------------------------------------------------------
+*
+* This file implements the module and linux pcmcia routines for the
+* prism2 driver.
+*
+* --------------------------------------------------------------------
+*/
+
+/*================================================================*/
+/* System Includes */
+#define WLAN_DBVAR	prism2_debug
+
+#include <wlan/version.h>
+
+#include <linux/version.h>
+
+#include <linux/module.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,25))
+#include <linux/moduleparam.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/wireless.h>
+#include <linux/netdevice.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+#include <linux/tqueue.h>
+#else
+#include <linux/workqueue.h>
+#endif
+
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <asm/byteorder.h>
+#include <linux/if_arp.h>
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/cs.h>
+#include <pcmcia/cistpl.h>
+#include <pcmcia/ds.h>
+#include <pcmcia/cisreg.h>
+#endif
+
+#include <wlan/wlan_compat.h>
+
+#if ((WLAN_HOSTIF == WLAN_PLX) || (WLAN_HOSTIF == WLAN_PCI))
+#include <linux/ioport.h>
+#include <linux/pci.h>
+#endif
+
+/*================================================================*/
+/* Project Includes */
+
+#include <wlan/p80211types.h>
+#include <wlan/p80211hdr.h>
+#include <wlan/p80211mgmt.h>
+#include <wlan/p80211conv.h>
+#include <wlan/p80211msg.h>
+#include <wlan/p80211netdev.h>
+#include <wlan/p80211req.h>
+#include <wlan/p80211metadef.h>
+#include <wlan/p80211metastruct.h>
+#include <prism2/hfa384x.h>
+#include <prism2/prism2mgmt.h>
+
+/*================================================================*/
+/* Local Constants */
+
+/*================================================================*/
+/* Local Macros */
+
+/*================================================================*/
+/* Local Types */
+
+/*================================================================*/
+/* Local Static Definitions */
+
+#if (WLAN_HOSTIF == WLAN_PCMCIA)
+#define DRIVER_SUFFIX	"_cs"
+#elif (WLAN_HOSTIF == WLAN_PLX)
+#define DRIVER_SUFFIX	"_plx"
+typedef char* dev_info_t;
+#elif (WLAN_HOSTIF == WLAN_PCI)
+#define DRIVER_SUFFIX	"_pci"
+typedef char* dev_info_t;
+#elif (WLAN_HOSTIF == WLAN_USB)
+#define DRIVER_SUFFIX	"_usb"
+typedef char* dev_info_t;
+#else
+#error "HOSTIF unsupported or undefined!"
+#endif
+
+static char		*version = "prism2" DRIVER_SUFFIX ".o: " WLAN_RELEASE;
+static dev_info_t	dev_info = "prism2" DRIVER_SUFFIX;
+
+#if (WLAN_HOSTIF == WLAN_PLX || WLAN_HOSTIF == WLAN_PCI)
+#ifdef CONFIG_PM
+static int prism2sta_suspend_pci(struct pci_dev *pdev, pm_message_t state);
+static int prism2sta_resume_pci(struct pci_dev *pdev);
+#endif
+#endif
+
+#if (WLAN_HOSTIF == WLAN_PCI)
+
+#endif /* WLAN_PCI */
+
+static wlandevice_t *create_wlan(void);
+
+/*----------------------------------------------------------------*/
+/* --Module Parameters */
+
+int      prism2_reset_holdtime=30;	/* Reset hold time in ms */
+int	 prism2_reset_settletime=100;	/* Reset settle time in ms */
+
+#if (WLAN_HOSTIF == WLAN_USB)
+static int	prism2_doreset=0;		/* Do a reset at init? */
+#else
+static int      prism2_doreset=1;		/* Do a reset at init? */
+int             prism2_bap_timeout=1000;        /* BAP timeout */
+int		prism2_irq_evread_max=20;	/* Maximum number of 
+						 * ev_reads (loops)
+						 * in irq handler 
+						 */
+#endif
+
+#ifdef WLAN_INCLUDE_DEBUG
+int prism2_debug=0;
+module_param( prism2_debug, int, 0644);
+MODULE_PARM_DESC(prism2_debug, "prism2 debugging");	
+#endif
+
+module_param( prism2_doreset, int, 0644);
+MODULE_PARM_DESC(prism2_doreset, "Issue a reset on initialization");
+
+module_param( prism2_reset_holdtime, int, 0644);
+MODULE_PARM_DESC( prism2_reset_holdtime, "reset hold time in ms");
+module_param( prism2_reset_settletime, int, 0644);
+MODULE_PARM_DESC( prism2_reset_settletime, "reset settle time in ms");
+
+#if (WLAN_HOSTIF != WLAN_USB)
+module_param( prism2_bap_timeout, int, 0644);
+MODULE_PARM_DESC(prism2_bap_timeout, "BufferAccessPath Timeout in 10*n us");
+module_param( prism2_irq_evread_max, int, 0644);
+MODULE_PARM_DESC( prism2_irq_evread_max, "Maximim number of event reads in interrupt handler");
+#endif
+
+MODULE_LICENSE("Dual MPL/GPL");
+
+/*================================================================*/
+/* Local Function Declarations */
+
+static int	prism2sta_open(wlandevice_t *wlandev);
+static int	prism2sta_close(wlandevice_t *wlandev);
+static void	prism2sta_reset(wlandevice_t *wlandev );
+static int      prism2sta_txframe(wlandevice_t *wlandev, struct sk_buff *skb, p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep);
+static int	prism2sta_mlmerequest(wlandevice_t *wlandev, p80211msg_t *msg);
+static int	prism2sta_getcardinfo(wlandevice_t *wlandev);
+static int	prism2sta_globalsetup(wlandevice_t *wlandev);
+static int      prism2sta_setmulticast(wlandevice_t *wlandev, 
+				       netdevice_t *dev);
+
+static void	prism2sta_inf_handover(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_tallies(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void     prism2sta_inf_hostscanresults(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_scanresults(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_chinforesults(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_linkstatus(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_assocstatus(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_authreq(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_authreq_defer(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+static void	prism2sta_inf_psusercnt(
+			wlandevice_t *wlandev, hfa384x_InfFrame_t *inf);
+
+#ifdef CONFIG_PROC_FS
+static int
+prism2sta_proc_read(
+	char	*page, 
+	char	**start, 
+	off_t	offset, 
+	int	count,
+	int	*eof,
+	void	*data);
+#endif
+
+/*================================================================*/
+/* Function Definitions */
+
+/*----------------------------------------------------------------
+* dmpmem
+*
+* Debug utility function to dump memory to the kernel debug log.
+*
+* Arguments:
+*	buf	ptr data we want dumped
+*	len	length of data
+*
+* Returns: 
+*	nothing
+* Side effects:
+*
+* Call context:
+*	process thread
+*	interrupt
+----------------------------------------------------------------*/
+inline void dmpmem(void *buf, int n)
+{
+	int c;
+	for ( c= 0; c < n; c++) {
+		if ( (c % 16) == 0 ) printk(KERN_DEBUG"dmp[%d]: ", c);
+		printk("%02x ", ((UINT8*)buf)[c]);
+		if ( (c % 16) == 15 ) printk("\n");
+	}
+	if ( (c % 16) != 0 ) printk("\n");
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_open
+*
+* WLAN device open method.  Called from p80211netdev when kernel 
+* device open (start) method is called in response to the 
+* SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP 
+* from clear to set.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	0	success
+*	>0	f/w reported error
+*	<0	driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int prism2sta_open(wlandevice_t *wlandev)
+{
+	DBFENTER;
+
+#ifdef ANCIENT_MODULE_CODE
+	MOD_INC_USE_COUNT;
+#endif
+
+	/* We don't currently have to do anything else. 
+	 * The setup of the MAC should be subsequently completed via
+	 * the mlme commands.
+	 * Higher layers know we're ready from dev->start==1 and 
+	 * dev->tbusy==0.  Our rx path knows to pass up received/
+	 * frames because of dev->flags&IFF_UP is true. 
+	 */
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_close
+*
+* WLAN device close method.  Called from p80211netdev when kernel 
+* device close method is called in response to the 
+* SIOCSIIFFLAGS ioctl changing the flags bit IFF_UP 
+* from set to clear.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	0	success
+*	>0	f/w reported error
+*	<0	driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int prism2sta_close(wlandevice_t *wlandev)
+{
+	DBFENTER;
+
+#ifdef ANCIENT_MODULE_CODE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	/* We don't currently have to do anything else.
+	 * Higher layers know we're not ready from dev->start==0 and
+	 * dev->tbusy==1.  Our rx path knows to not pass up received
+	 * frames because of dev->flags&IFF_UP is false.
+	 */
+
+	DBFEXIT;
+	return 0;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_reset
+*
+* Not currently implented.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	none
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+void prism2sta_reset(wlandevice_t *wlandev )
+{
+	DBFENTER;
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_txframe
+*
+* Takes a frame from p80211 and queues it for transmission.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	pb		packet buffer struct.  Contains an 802.11
+*			data frame.
+*       p80211_hdr      points to the 802.11 header for the packet.
+* Returns: 
+*	0		Success and more buffs available
+*	1		Success but no more buffs
+*	2		Allocation failure
+*	4		Buffer full or queue busy
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int prism2sta_txframe(wlandevice_t *wlandev, struct sk_buff *skb,
+		      p80211_hdr_t *p80211_hdr, p80211_metawep_t *p80211_wep)
+{
+	hfa384x_t		*hw = (hfa384x_t *)wlandev->priv;
+	int			result;
+	DBFENTER;
+
+	/* If necessary, set the 802.11 WEP bit */
+	if ((wlandev->hostwep & (HOSTWEP_PRIVACYINVOKED | HOSTWEP_ENCRYPT)) == HOSTWEP_PRIVACYINVOKED) {
+		p80211_hdr->a3.fc |= host2ieee16(WLAN_SET_FC_ISWEP(1));
+	}
+
+	result = hfa384x_drvr_txframe(hw, skb, p80211_hdr, p80211_wep);
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_mlmerequest
+*
+* wlan command message handler.  All we do here is pass the message
+* over to the prism2sta_mgmt_handler.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msg		wlan command message
+* Returns: 
+*	0		success
+*	<0		successful acceptance of message, but we're
+*			waiting for an async process to finish before
+*			we're done with the msg.  When the asynch
+*			process is done, we'll call the p80211 
+*			function p80211req_confirm() .
+*	>0		An error occurred while we were handling
+*			the message.
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int prism2sta_mlmerequest(wlandevice_t *wlandev, p80211msg_t *msg)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+
+	int result = 0;
+	DBFENTER;
+
+	switch( msg->msgcode )
+	{
+	case DIDmsg_dot11req_mibget :
+		WLAN_LOG_DEBUG(2,"Received mibget request\n");
+		result = prism2mgmt_mibset_mibget(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_mibset :
+		WLAN_LOG_DEBUG(2,"Received mibset request\n");
+		result = prism2mgmt_mibset_mibget(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_powermgmt :
+		WLAN_LOG_DEBUG(2,"Received powermgmt request\n");
+		result = prism2mgmt_powermgmt(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_scan :
+		WLAN_LOG_DEBUG(2,"Received scan request\n");
+		result = prism2mgmt_scan(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_scan_results :
+		WLAN_LOG_DEBUG(2,"Received scan_results request\n");
+		result = prism2mgmt_scan_results(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_join :
+		WLAN_LOG_DEBUG(2,"Received join request\n");
+		result = prism2mgmt_join(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_authenticate :
+		WLAN_LOG_DEBUG(2,"Received authenticate request\n");
+		result = prism2mgmt_authenticate(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_deauthenticate :
+		WLAN_LOG_DEBUG(2,"Received mlme deauthenticate request\n");
+		result = prism2mgmt_deauthenticate(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_associate :
+		WLAN_LOG_DEBUG(2,"Received mlme associate request\n");
+		result = prism2mgmt_associate(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_reassociate :
+		WLAN_LOG_DEBUG(2,"Received mlme reassociate request\n");
+		result = prism2mgmt_reassociate(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_disassociate :
+		WLAN_LOG_DEBUG(2,"Received mlme disassociate request\n");
+		result = prism2mgmt_disassociate(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_reset :
+		WLAN_LOG_DEBUG(2,"Received mlme reset request\n");
+		result = prism2mgmt_reset(wlandev, msg);
+		break;
+	case DIDmsg_dot11req_start :
+		WLAN_LOG_DEBUG(2,"Received mlme start request\n");
+		result = prism2mgmt_start(wlandev, msg);
+		break;
+	/*
+	 * Prism2 specific messages
+	 */
+	case DIDmsg_p2req_join :
+		WLAN_LOG_DEBUG(2,"Received p2 join request\n");
+		result = prism2mgmt_p2_join(wlandev, msg);
+		break;
+       	case DIDmsg_p2req_readpda :
+		WLAN_LOG_DEBUG(2,"Received mlme readpda request\n");
+		result = prism2mgmt_readpda(wlandev, msg);
+		break;
+	case DIDmsg_p2req_readcis :
+		WLAN_LOG_DEBUG(2,"Received mlme readcis request\n");
+		result = prism2mgmt_readcis(wlandev, msg);
+		break;
+	case DIDmsg_p2req_auxport_state :
+		WLAN_LOG_DEBUG(2,"Received mlme auxport_state request\n");
+		result = prism2mgmt_auxport_state(wlandev, msg);
+		break;
+	case DIDmsg_p2req_auxport_read :
+		WLAN_LOG_DEBUG(2,"Received mlme auxport_read request\n");
+		result = prism2mgmt_auxport_read(wlandev, msg);
+		break;
+	case DIDmsg_p2req_auxport_write :
+		WLAN_LOG_DEBUG(2,"Received mlme auxport_write request\n");
+		result = prism2mgmt_auxport_write(wlandev, msg);
+		break;
+	case DIDmsg_p2req_low_level :
+		WLAN_LOG_DEBUG(2,"Received mlme low_level request\n");
+		result = prism2mgmt_low_level(wlandev, msg);
+		break;
+        case DIDmsg_p2req_test_command :
+                WLAN_LOG_DEBUG(2,"Received mlme test_command request\n");
+                result = prism2mgmt_test_command(wlandev, msg);
+                break;
+        case DIDmsg_p2req_mmi_read :
+                WLAN_LOG_DEBUG(2,"Received mlme mmi_read request\n");
+                result = prism2mgmt_mmi_read(wlandev, msg);
+                break;
+        case DIDmsg_p2req_mmi_write :
+                WLAN_LOG_DEBUG(2,"Received mlme mmi_write request\n");
+                result = prism2mgmt_mmi_write(wlandev, msg);
+                break;
+	case DIDmsg_p2req_ramdl_state :
+		WLAN_LOG_DEBUG(2,"Received mlme ramdl_state request\n");
+		result = prism2mgmt_ramdl_state(wlandev, msg);
+		break;
+	case DIDmsg_p2req_ramdl_write :
+		WLAN_LOG_DEBUG(2,"Received mlme ramdl_write request\n");
+		result = prism2mgmt_ramdl_write(wlandev, msg);
+		break;
+	case DIDmsg_p2req_flashdl_state :
+		WLAN_LOG_DEBUG(2,"Received mlme flashdl_state request\n");
+		result = prism2mgmt_flashdl_state(wlandev, msg);
+		break;
+	case DIDmsg_p2req_flashdl_write :
+		WLAN_LOG_DEBUG(2,"Received mlme flashdl_write request\n");
+		result = prism2mgmt_flashdl_write(wlandev, msg);
+		break;
+	case DIDmsg_p2req_dump_state :
+		WLAN_LOG_DEBUG(2,"Received mlme dump_state request\n");
+		result = prism2mgmt_dump_state(wlandev, msg);
+		break;
+	case DIDmsg_p2req_channel_info :
+		WLAN_LOG_DEBUG(2,"Received mlme channel_info request\n");
+		result = prism2mgmt_channel_info(wlandev, msg);
+		break;
+	case DIDmsg_p2req_channel_info_results :
+		WLAN_LOG_DEBUG(2,"Received mlme channel_info_results request\n");
+		result = prism2mgmt_channel_info_results(wlandev, msg);
+		break;
+	/*
+	 * Linux specific messages
+	 */
+	case DIDmsg_lnxreq_hostwep : 
+		break;   // ignore me.
+        case DIDmsg_lnxreq_ifstate :
+		{
+		p80211msg_lnxreq_ifstate_t	*ifstatemsg;
+                WLAN_LOG_DEBUG(2,"Received mlme ifstate request\n");
+		ifstatemsg = (p80211msg_lnxreq_ifstate_t*)msg;
+                result = prism2sta_ifstate(wlandev, ifstatemsg->ifstate.data);
+		ifstatemsg->resultcode.status = 
+			P80211ENUM_msgitem_status_data_ok;
+		ifstatemsg->resultcode.data = result;
+		result = 0;
+		}
+                break;
+        case DIDmsg_lnxreq_wlansniff :
+                WLAN_LOG_DEBUG(2,"Received mlme wlansniff request\n");
+                result = prism2mgmt_wlansniff(wlandev, msg);
+                break;
+	case DIDmsg_lnxreq_autojoin :
+		WLAN_LOG_DEBUG(2,"Received mlme autojoin request\n");
+		result = prism2mgmt_autojoin(wlandev, msg);
+		break;
+	case DIDmsg_p2req_enable :
+		WLAN_LOG_DEBUG(2,"Received mlme enable request\n");
+		result = prism2mgmt_enable(wlandev, msg);
+		break;
+	case DIDmsg_lnxreq_commsquality: {
+		p80211msg_lnxreq_commsquality_t *qualmsg;
+
+		WLAN_LOG_DEBUG(2,"Received commsquality request\n");
+
+		if (hw->ap)
+			break;
+
+		qualmsg = (p80211msg_lnxreq_commsquality_t*) msg;
+
+		qualmsg->link.status = P80211ENUM_msgitem_status_data_ok;
+		qualmsg->level.status = P80211ENUM_msgitem_status_data_ok;
+		qualmsg->noise.status = P80211ENUM_msgitem_status_data_ok;
+
+
+		qualmsg->link.data = hfa384x2host_16(hw->qual.CQ_currBSS);
+		qualmsg->level.data = hfa384x2host_16(hw->qual.ASL_currBSS);
+		qualmsg->noise.data = hfa384x2host_16(hw->qual.ANL_currFC);
+
+		break;
+	}
+	default:
+		WLAN_LOG_WARNING("Unknown mgmt request message 0x%08x", msg->msgcode);
+		break;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ifstate
+*
+* Interface state.  This is the primary WLAN interface enable/disable
+* handler.  Following the driver/load/deviceprobe sequence, this
+* function must be called with a state of "enable" before any other
+* commands will be accepted.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	msgp		ptr to msg buffer
+*
+* Returns: 
+* 	A p80211 message resultcode value.
+*
+* Side effects:
+*
+* Call context:
+*	process thread  (usually)
+*	interrupt
+----------------------------------------------------------------*/
+UINT32 prism2sta_ifstate(wlandevice_t *wlandev, UINT32 ifstate)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	UINT32 			result;
+	DBFENTER;
+
+	result = P80211ENUM_resultcode_implementation_failure;
+
+	WLAN_LOG_DEBUG(2, "Current MSD state(%d), requesting(%d)\n",
+	                  wlandev->msdstate, ifstate);
+	switch (ifstate)
+	{
+	case P80211ENUM_ifstate_fwload:
+		switch (wlandev->msdstate) {
+		case WLAN_MSD_HWPRESENT:
+			wlandev->msdstate = WLAN_MSD_FWLOAD_PENDING;
+			/*
+			 * Initialize the device+driver sufficiently
+			 * for firmware loading.
+			 */
+#if (WLAN_HOSTIF != WLAN_USB)
+			result=hfa384x_cmd_initialize(hw);
+#else
+			if ((result=hfa384x_drvr_start(hw))) {
+				WLAN_LOG_ERROR(
+					"hfa384x_drvr_start() failed,"
+					"result=%d\n", (int)result);
+				result = 
+				P80211ENUM_resultcode_implementation_failure;
+				wlandev->msdstate = WLAN_MSD_HWPRESENT;
+				break;
+			}
+#endif
+			wlandev->msdstate = WLAN_MSD_FWLOAD;
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_FWLOAD:
+			hfa384x_cmd_initialize(hw);
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_RUNNING:
+			WLAN_LOG_WARNING(
+				"Cannot enter fwload state from enable state,"
+				"you must disable first.\n");
+			result = P80211ENUM_resultcode_invalid_parameters;
+			break;
+		case WLAN_MSD_HWFAIL:
+		default:
+			/* probe() had a problem or the msdstate contains
+			 * an unrecognized value, there's nothing we can do.
+			 */
+			result = P80211ENUM_resultcode_implementation_failure;
+			break;
+		}
+		break;
+	case P80211ENUM_ifstate_enable:
+		switch (wlandev->msdstate) {
+		case WLAN_MSD_HWPRESENT:
+		case WLAN_MSD_FWLOAD:
+			wlandev->msdstate = WLAN_MSD_RUNNING_PENDING;
+			/* Initialize the device+driver for full
+			 * operation. Note that this might me an FWLOAD to
+			 * to RUNNING transition so we must not do a chip
+			 * or board level reset.  Note that on failure,
+			 * the MSD state is set to HWPRESENT because we 
+			 * can't make any assumptions about the state 
+			 * of the hardware or a previous firmware load.
+			 */
+			if ((result=hfa384x_drvr_start(hw))) {
+				WLAN_LOG_ERROR(
+					"hfa384x_drvr_start() failed,"
+					"result=%d\n", (int)result);
+				result = 
+				P80211ENUM_resultcode_implementation_failure;
+				wlandev->msdstate = WLAN_MSD_HWPRESENT;
+				break;
+			}
+
+			if ((result=prism2sta_getcardinfo(wlandev))) {
+				WLAN_LOG_ERROR(
+					"prism2sta_getcardinfo() failed,"
+					"result=%d\n", (int)result);
+				result = 
+				P80211ENUM_resultcode_implementation_failure;
+				hfa384x_drvr_stop(hw);
+				wlandev->msdstate = WLAN_MSD_HWPRESENT;
+				break;
+			}
+			if ((result=prism2sta_globalsetup(wlandev))) {
+				WLAN_LOG_ERROR(
+					"prism2sta_globalsetup() failed,"
+					"result=%d\n", (int)result);
+				result = 
+				P80211ENUM_resultcode_implementation_failure;
+				hfa384x_drvr_stop(hw);
+				wlandev->msdstate = WLAN_MSD_HWPRESENT;
+				break;
+			}
+			wlandev->msdstate = WLAN_MSD_RUNNING;
+			hw->join_ap = 0;
+			hw->join_retries = 60;
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_RUNNING:
+			/* Do nothing, we're already in this state.*/
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_HWFAIL:
+		default:
+			/* probe() had a problem or the msdstate contains
+			 * an unrecognized value, there's nothing we can do.
+			 */
+			result = P80211ENUM_resultcode_implementation_failure;
+			break;
+		}
+		break;
+	case P80211ENUM_ifstate_disable:
+		switch (wlandev->msdstate) {
+		case WLAN_MSD_HWPRESENT:
+			/* Do nothing, we're already in this state.*/
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_FWLOAD:
+		case WLAN_MSD_RUNNING:
+			wlandev->msdstate = WLAN_MSD_HWPRESENT_PENDING;
+			/*
+			 * TODO: Shut down the MAC completely. Here a chip
+			 * or board level reset is probably called for.
+			 * After a "disable" _all_ results are lost, even
+			 * those from a fwload. 
+			 */
+			if (!wlandev->hwremoved)
+				netif_carrier_off(wlandev->netdev);
+
+			hfa384x_drvr_stop(hw);
+
+			wlandev->macmode = WLAN_MACMODE_NONE;
+			wlandev->msdstate = WLAN_MSD_HWPRESENT;
+			result = P80211ENUM_resultcode_success;
+			break;
+		case WLAN_MSD_HWFAIL:
+		default:
+			/* probe() had a problem or the msdstate contains
+			 * an unrecognized value, there's nothing we can do.
+			 */
+			result = P80211ENUM_resultcode_implementation_failure;
+			break;
+		}
+		break;
+	default:
+		result = P80211ENUM_resultcode_invalid_parameters;
+		break;
+	}
+
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_getcardinfo
+*
+* Collect the NICID, firmware version and any other identifiers
+* we'd like to have in host-side data structures.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	0	success
+*	>0	f/w reported error
+*	<0	driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	Either.
+----------------------------------------------------------------*/
+int prism2sta_getcardinfo(wlandevice_t *wlandev)
+{
+	int 			result = 0;
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	UINT16                  temp;
+	UINT8			snum[HFA384x_RID_NICSERIALNUMBER_LEN];
+	char			pstr[(HFA384x_RID_NICSERIALNUMBER_LEN * 4) + 1];
+
+	DBFENTER;
+
+	/* Collect version and compatibility info */
+	/*  Some are critical, some are not */
+	/* NIC identity */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_NICIDENTITY,
+			&hw->ident_nic, sizeof(hfa384x_compident_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve NICIDENTITY\n");
+		goto failed;
+	}
+
+	/* get all the nic id fields in host byte order */
+	hw->ident_nic.id = hfa384x2host_16(hw->ident_nic.id);
+	hw->ident_nic.variant = hfa384x2host_16(hw->ident_nic.variant);
+	hw->ident_nic.major = hfa384x2host_16(hw->ident_nic.major);
+	hw->ident_nic.minor = hfa384x2host_16(hw->ident_nic.minor);
+
+	WLAN_LOG_INFO( "ident: nic h/w: id=0x%02x %d.%d.%d\n",
+			hw->ident_nic.id, hw->ident_nic.major,
+			hw->ident_nic.minor, hw->ident_nic.variant);
+
+	/* Primary f/w identity */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRIIDENTITY,
+			&hw->ident_pri_fw, sizeof(hfa384x_compident_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve PRIIDENTITY\n");
+		goto failed;
+	}
+
+	/* get all the private fw id fields in host byte order */
+	hw->ident_pri_fw.id = hfa384x2host_16(hw->ident_pri_fw.id);
+	hw->ident_pri_fw.variant = hfa384x2host_16(hw->ident_pri_fw.variant);
+	hw->ident_pri_fw.major = hfa384x2host_16(hw->ident_pri_fw.major);
+	hw->ident_pri_fw.minor = hfa384x2host_16(hw->ident_pri_fw.minor);
+
+	WLAN_LOG_INFO( "ident: pri f/w: id=0x%02x %d.%d.%d\n",
+			hw->ident_pri_fw.id, hw->ident_pri_fw.major,
+			hw->ident_pri_fw.minor, hw->ident_pri_fw.variant);
+
+	/* Station (Secondary?) f/w identity */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_STAIDENTITY,
+			&hw->ident_sta_fw, sizeof(hfa384x_compident_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve STAIDENTITY\n");
+		goto failed;
+	}
+
+	if (hw->ident_nic.id < 0x8000) {
+		WLAN_LOG_ERROR("FATAL: Card is not an Intersil Prism2/2.5/3\n");
+		result = -1;
+		goto failed;
+	}
+
+	/* get all the station fw id fields in host byte order */
+	hw->ident_sta_fw.id = hfa384x2host_16(hw->ident_sta_fw.id);
+	hw->ident_sta_fw.variant = hfa384x2host_16(hw->ident_sta_fw.variant);
+	hw->ident_sta_fw.major = hfa384x2host_16(hw->ident_sta_fw.major);
+	hw->ident_sta_fw.minor = hfa384x2host_16(hw->ident_sta_fw.minor);
+
+	/* strip out the 'special' variant bits */
+	hw->mm_mods = hw->ident_sta_fw.variant & (BIT14 | BIT15);
+	hw->ident_sta_fw.variant &= ~((UINT16)(BIT14 | BIT15));
+
+	if  ( hw->ident_sta_fw.id == 0x1f ) {
+		hw->ap = 0;
+		WLAN_LOG_INFO( 
+			"ident: sta f/w: id=0x%02x %d.%d.%d\n",
+			hw->ident_sta_fw.id, hw->ident_sta_fw.major,
+			hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);
+	} else {
+		hw->ap = 1;
+		WLAN_LOG_INFO(
+			"ident:  ap f/w: id=0x%02x %d.%d.%d\n",
+			hw->ident_sta_fw.id, hw->ident_sta_fw.major,
+			hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);
+	}
+
+	/* Compatibility range, Modem supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_MFISUPRANGE,
+			&hw->cap_sup_mfi, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve MFISUPRANGE\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, modem interface supplier
+	fields in byte order */
+	hw->cap_sup_mfi.role = hfa384x2host_16(hw->cap_sup_mfi.role);
+	hw->cap_sup_mfi.id = hfa384x2host_16(hw->cap_sup_mfi.id);
+	hw->cap_sup_mfi.variant = hfa384x2host_16(hw->cap_sup_mfi.variant);
+	hw->cap_sup_mfi.bottom = hfa384x2host_16(hw->cap_sup_mfi.bottom);
+	hw->cap_sup_mfi.top = hfa384x2host_16(hw->cap_sup_mfi.top);
+
+	WLAN_LOG_INFO(
+		"MFI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_sup_mfi.role, hw->cap_sup_mfi.id,
+		hw->cap_sup_mfi.variant, hw->cap_sup_mfi.bottom,
+		hw->cap_sup_mfi.top);
+
+	/* Compatibility range, Controller supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CFISUPRANGE,
+			&hw->cap_sup_cfi, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve CFISUPRANGE\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, controller interface supplier
+	fields in byte order */
+	hw->cap_sup_cfi.role = hfa384x2host_16(hw->cap_sup_cfi.role);
+	hw->cap_sup_cfi.id = hfa384x2host_16(hw->cap_sup_cfi.id);
+	hw->cap_sup_cfi.variant = hfa384x2host_16(hw->cap_sup_cfi.variant);
+	hw->cap_sup_cfi.bottom = hfa384x2host_16(hw->cap_sup_cfi.bottom);
+	hw->cap_sup_cfi.top = hfa384x2host_16(hw->cap_sup_cfi.top);
+
+	WLAN_LOG_INFO( 
+		"CFI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_sup_cfi.role, hw->cap_sup_cfi.id,
+		hw->cap_sup_cfi.variant, hw->cap_sup_cfi.bottom,
+		hw->cap_sup_cfi.top);
+
+	/* Compatibility range, Primary f/w supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRISUPRANGE,
+			&hw->cap_sup_pri, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve PRISUPRANGE\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, primary firmware supplier
+	fields in byte order */
+	hw->cap_sup_pri.role = hfa384x2host_16(hw->cap_sup_pri.role);
+	hw->cap_sup_pri.id = hfa384x2host_16(hw->cap_sup_pri.id);
+	hw->cap_sup_pri.variant = hfa384x2host_16(hw->cap_sup_pri.variant);
+	hw->cap_sup_pri.bottom = hfa384x2host_16(hw->cap_sup_pri.bottom);
+	hw->cap_sup_pri.top = hfa384x2host_16(hw->cap_sup_pri.top);
+
+	WLAN_LOG_INFO(
+		"PRI:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_sup_pri.role, hw->cap_sup_pri.id,
+		hw->cap_sup_pri.variant, hw->cap_sup_pri.bottom,
+		hw->cap_sup_pri.top);
+	
+	/* Compatibility range, Station f/w supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_STASUPRANGE,
+			&hw->cap_sup_sta, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve STASUPRANGE\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, station firmware supplier
+	fields in byte order */
+	hw->cap_sup_sta.role = hfa384x2host_16(hw->cap_sup_sta.role);
+	hw->cap_sup_sta.id = hfa384x2host_16(hw->cap_sup_sta.id);
+	hw->cap_sup_sta.variant = hfa384x2host_16(hw->cap_sup_sta.variant);
+	hw->cap_sup_sta.bottom = hfa384x2host_16(hw->cap_sup_sta.bottom);
+	hw->cap_sup_sta.top = hfa384x2host_16(hw->cap_sup_sta.top);
+
+	if ( hw->cap_sup_sta.id == 0x04 ) {
+		WLAN_LOG_INFO(
+		"STA:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_sup_sta.role, hw->cap_sup_sta.id,
+		hw->cap_sup_sta.variant, hw->cap_sup_sta.bottom,
+		hw->cap_sup_sta.top);
+	} else {
+		WLAN_LOG_INFO(
+		"AP:SUP:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_sup_sta.role, hw->cap_sup_sta.id,
+		hw->cap_sup_sta.variant, hw->cap_sup_sta.bottom,
+		hw->cap_sup_sta.top);
+	}
+
+	/* Compatibility range, primary f/w actor, CFI supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_PRI_CFIACTRANGES,
+			&hw->cap_act_pri_cfi, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve PRI_CFIACTRANGES\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, primary f/w actor, CFI supplier
+	fields in byte order */
+	hw->cap_act_pri_cfi.role = hfa384x2host_16(hw->cap_act_pri_cfi.role);
+	hw->cap_act_pri_cfi.id = hfa384x2host_16(hw->cap_act_pri_cfi.id);
+	hw->cap_act_pri_cfi.variant = hfa384x2host_16(hw->cap_act_pri_cfi.variant);
+	hw->cap_act_pri_cfi.bottom = hfa384x2host_16(hw->cap_act_pri_cfi.bottom);
+	hw->cap_act_pri_cfi.top = hfa384x2host_16(hw->cap_act_pri_cfi.top);
+
+	WLAN_LOG_INFO(
+		"PRI-CFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_act_pri_cfi.role, hw->cap_act_pri_cfi.id,
+		hw->cap_act_pri_cfi.variant, hw->cap_act_pri_cfi.bottom,
+		hw->cap_act_pri_cfi.top);
+	
+	/* Compatibility range, sta f/w actor, CFI supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_STA_CFIACTRANGES,
+			&hw->cap_act_sta_cfi, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve STA_CFIACTRANGES\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, station f/w actor, CFI supplier
+	fields in byte order */
+	hw->cap_act_sta_cfi.role = hfa384x2host_16(hw->cap_act_sta_cfi.role);
+	hw->cap_act_sta_cfi.id = hfa384x2host_16(hw->cap_act_sta_cfi.id);
+	hw->cap_act_sta_cfi.variant = hfa384x2host_16(hw->cap_act_sta_cfi.variant);
+	hw->cap_act_sta_cfi.bottom = hfa384x2host_16(hw->cap_act_sta_cfi.bottom);
+	hw->cap_act_sta_cfi.top = hfa384x2host_16(hw->cap_act_sta_cfi.top);
+
+	WLAN_LOG_INFO(
+		"STA-CFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_act_sta_cfi.role, hw->cap_act_sta_cfi.id,
+		hw->cap_act_sta_cfi.variant, hw->cap_act_sta_cfi.bottom,
+		hw->cap_act_sta_cfi.top);
+
+	/* Compatibility range, sta f/w actor, MFI supplier */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_STA_MFIACTRANGES,
+			&hw->cap_act_sta_mfi, sizeof(hfa384x_caplevel_t));
+	if ( result ) {
+		WLAN_LOG_ERROR("Failed to retrieve STA_MFIACTRANGES\n");
+		goto failed;
+	}
+
+	/* get all the Compatibility range, station f/w actor, MFI supplier
+	fields in byte order */
+	hw->cap_act_sta_mfi.role = hfa384x2host_16(hw->cap_act_sta_mfi.role);
+	hw->cap_act_sta_mfi.id = hfa384x2host_16(hw->cap_act_sta_mfi.id);
+	hw->cap_act_sta_mfi.variant = hfa384x2host_16(hw->cap_act_sta_mfi.variant);
+	hw->cap_act_sta_mfi.bottom = hfa384x2host_16(hw->cap_act_sta_mfi.bottom);
+	hw->cap_act_sta_mfi.top = hfa384x2host_16(hw->cap_act_sta_mfi.top);
+
+	WLAN_LOG_INFO(
+		"STA-MFI:ACT:role=0x%02x:id=0x%02x:var=0x%02x:b/t=%d/%d\n",
+		hw->cap_act_sta_mfi.role, hw->cap_act_sta_mfi.id,
+		hw->cap_act_sta_mfi.variant, hw->cap_act_sta_mfi.bottom,
+		hw->cap_act_sta_mfi.top);
+
+	/* Serial Number */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_NICSERIALNUMBER,
+			snum, HFA384x_RID_NICSERIALNUMBER_LEN);
+	if ( !result ) {
+		wlan_mkprintstr(snum, HFA384x_RID_NICSERIALNUMBER_LEN,
+				pstr, sizeof(pstr));
+		WLAN_LOG_INFO("Prism2 card SN: %s\n", pstr);
+	} else {
+		WLAN_LOG_ERROR("Failed to retrieve Prism2 Card SN\n");
+		goto failed;
+	}
+
+	/* Collect the MAC address */
+	result = hfa384x_drvr_getconfig(hw, HFA384x_RID_CNFOWNMACADDR, 
+		wlandev->netdev->dev_addr, WLAN_ADDR_LEN);
+	if ( result != 0 ) {
+		WLAN_LOG_ERROR("Failed to retrieve mac address\n");
+		goto failed;
+	}
+
+	/* short preamble is always implemented */
+	wlandev->nsdcaps |= P80211_NSDCAP_SHORT_PREAMBLE;
+
+	/* find out if hardware wep is implemented */
+	hfa384x_drvr_getconfig16(hw, HFA384x_RID_PRIVACYOPTIMP, &temp);
+	if (temp)
+		wlandev->nsdcaps |= P80211_NSDCAP_HARDWAREWEP;
+
+	/* get the dBm Scaling constant */
+	hfa384x_drvr_getconfig16(hw, HFA384x_RID_CNFDBMADJUST, &temp); 
+	hw->dbmadjust = temp;
+
+	/* Only enable scan by default on newer firmware */
+        if (HFA384x_FIRMWARE_VERSION(hw->ident_sta_fw.major,
+                                     hw->ident_sta_fw.minor,
+                                     hw->ident_sta_fw.variant) <
+	    HFA384x_FIRMWARE_VERSION(1,5,5)) {
+		wlandev->nsdcaps |= P80211_NSDCAP_NOSCAN;
+	}
+
+	/* TODO: Set any internally managed config items */
+
+	goto done;
+failed:
+	WLAN_LOG_ERROR("Failed, result=%d\n", result);
+done:
+	DBFEXIT;
+	return result;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_globalsetup
+*
+* Set any global RIDs that we want to set at device activation.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	0	success
+*	>0	f/w reported error
+*	<0	driver reported error
+*
+* Side effects:
+*
+* Call context:
+*	process thread
+----------------------------------------------------------------*/
+int prism2sta_globalsetup(wlandevice_t *wlandev)
+{
+	hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+
+	/* Set the maximum frame size */
+	return hfa384x_drvr_setconfig16(hw, HFA384x_RID_CNFMAXDATALEN,
+	                                    WLAN_DATA_MAXLEN);
+}
+
+int prism2sta_setmulticast(wlandevice_t *wlandev, netdevice_t *dev)
+{
+	int result = 0;
+	hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+
+	UINT16  promisc;
+
+	DBFENTER;
+
+	/* If we're not ready, what's the point? */
+	if ( hw->state != HFA384x_STATE_RUNNING )
+		goto exit;
+
+	/* If we're an AP, do nothing here */
+	if (hw->ap)
+		goto exit;
+
+	if ( (dev->flags & (IFF_PROMISC | IFF_ALLMULTI)) != 0 )
+		promisc = P80211ENUM_truth_true;
+	else
+		promisc = P80211ENUM_truth_false;
+
+	result = hfa384x_drvr_setconfig16_async(hw, HFA384x_RID_PROMISCMODE, promisc);
+	
+	/* XXX TODO: configure the multicast list */
+	// CLEAR_HW_MULTICAST_LIST
+	// struct dev_mc_list element = dev->mc_list;
+	// while (element != null) {
+	//  HW_ADD_MULTICAST_ADDR(element->dmi_addr, dmi_addrlen)
+	//  element = element->next;
+	// }
+
+ exit:
+	DBFEXIT;
+	return result;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_handover
+*
+* Handles the receipt of a Handover info frame. Should only be present
+* in APs only.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_handover(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+	DBFENTER;
+	WLAN_LOG_DEBUG(2,"received infoframe:HANDOVER (unhandled)\n");
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_inf_tallies
+*
+* Handles the receipt of a CommTallies info frame. 
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_tallies(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	UINT16			*src16;
+	UINT32			*dst;
+	UINT32			*src32;
+	int			i;
+	int			cnt;
+
+	DBFENTER;
+
+	/*
+	** Determine if these are 16-bit or 32-bit tallies, based on the
+	** record length of the info record.
+	*/
+
+	cnt = sizeof(hfa384x_CommTallies32_t) / sizeof(UINT32);
+	if (inf->framelen > 22) {
+		dst   = (UINT32 *) &hw->tallies;
+		src32 = (UINT32 *) &inf->info.commtallies32;
+		for (i = 0; i < cnt; i++, dst++, src32++)
+			*dst += hfa384x2host_32(*src32);
+	} else {
+		dst   = (UINT32 *) &hw->tallies;
+		src16 = (UINT16 *) &inf->info.commtallies16;
+		for (i = 0; i < cnt; i++, dst++, src16++)
+			*dst += hfa384x2host_16(*src16);
+	}
+
+	DBFEXIT;
+
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_scanresults
+*
+* Handles the receipt of a Scan Results info frame.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_scanresults(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	int			nbss;
+	hfa384x_ScanResult_t	*sr = &(inf->info.scanresult);
+	int			i;
+	hfa384x_JoinRequest_data_t	joinreq;
+	int			result;
+	DBFENTER;
+
+	/* Get the number of results, first in bytes, then in results */
+	nbss = (inf->framelen * sizeof(UINT16)) - 
+		sizeof(inf->infotype) -
+		sizeof(inf->info.scanresult.scanreason);
+	nbss /= sizeof(hfa384x_ScanResultSub_t);
+
+	/* Print em */
+	WLAN_LOG_DEBUG(1,"rx scanresults, reason=%d, nbss=%d:\n",
+		inf->info.scanresult.scanreason, nbss);
+	for ( i = 0; i < nbss; i++) {
+		WLAN_LOG_DEBUG(1, "chid=%d anl=%d sl=%d bcnint=%d\n",
+			sr->result[i].chid,
+			sr->result[i].anl,
+			sr->result[i].sl,
+			sr->result[i].bcnint);
+		WLAN_LOG_DEBUG(1, "  capinfo=0x%04x proberesp_rate=%d\n",
+			sr->result[i].capinfo,
+			sr->result[i].proberesp_rate);
+	}
+	/* issue a join request */
+	joinreq.channel = sr->result[0].chid;
+	memcpy( joinreq.bssid, sr->result[0].bssid, WLAN_BSSID_LEN);
+	result = hfa384x_drvr_setconfig( hw, 
+			HFA384x_RID_JOINREQUEST,
+			&joinreq, HFA384x_RID_JOINREQUEST_LEN);
+	if (result) {
+		WLAN_LOG_ERROR("setconfig(joinreq) failed, result=%d\n", result);
+	}
+	
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_hostscanresults
+*
+* Handles the receipt of a Scan Results info frame.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_hostscanresults(wlandevice_t *wlandev, 
+				   hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	int			nbss;
+	DBFENTER;
+
+	nbss = (inf->framelen - 3) / 32;
+	WLAN_LOG_DEBUG(1, "Received %d hostscan results\n", nbss);
+
+	if (nbss > 32) 
+		nbss = 32;
+
+	if (hw->scanresults)
+		kfree(hw->scanresults);
+
+	hw->scanresults = kmalloc(sizeof(hfa384x_InfFrame_t), GFP_ATOMIC);
+	memcpy(hw->scanresults, inf, sizeof(hfa384x_InfFrame_t));
+
+	if (nbss == 0)
+		nbss = -1;
+
+        /* Notify/wake the sleeping caller. */
+        hw->scanflag = nbss;
+        wake_up_interruptible(&hw->cmdq);
+
+	DBFEXIT;
+};
+
+/*----------------------------------------------------------------
+* prism2sta_inf_chinforesults
+*
+* Handles the receipt of a Channel Info Results info frame.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_chinforesults(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	unsigned int		i, n;
+
+	DBFENTER;
+	hw->channel_info.results.scanchannels = 
+		hfa384x2host_16(inf->info.chinforesult.scanchannels);
+#if 0
+	memcpy(&inf->info.chinforesult, &hw->channel_info.results, sizeof(hfa384x_ChInfoResult_t));
+#endif
+
+	for (i=0, n=0; i<HFA384x_CHINFORESULT_MAX; i++) {
+		if (hw->channel_info.results.scanchannels & (1<<i)) {
+			int 	channel=hfa384x2host_16(inf->info.chinforesult.result[n].chid)-1;
+			hfa384x_ChInfoResultSub_t *chinforesult=&hw->channel_info.results.result[channel];
+			chinforesult->chid   = channel;
+			chinforesult->anl    = hfa384x2host_16(inf->info.chinforesult.result[n].anl);
+			chinforesult->pnl    = hfa384x2host_16(inf->info.chinforesult.result[n].pnl);
+			chinforesult->active = hfa384x2host_16(inf->info.chinforesult.result[n].active);
+			WLAN_LOG_DEBUG(2, "chinfo: channel %d, %s level (avg/peak)=%d/%d dB, pcf %d\n",
+					channel+1, 
+					chinforesult->active & 
+					HFA384x_CHINFORESULT_BSSACTIVE ? "signal" : "noise", 
+					chinforesult->anl, chinforesult->pnl, 
+					chinforesult->active & HFA384x_CHINFORESULT_PCFACTIVE ? 1 : 0
+			);
+			n++;
+		}
+	}
+	atomic_set(&hw->channel_info.done, 2);
+
+	hw->channel_info.count = n;
+	DBFEXIT;
+	return;
+}
+
+void prism2sta_processing_defer(struct work_struct *ws)
+{
+	hfa384x_t		*hw = container_of(ws, hfa384x_t, link_bh);
+	wlandevice_t            *wlandev = hw->wlandev;
+	hfa384x_bytestr32_t ssid;
+	int			result;
+
+	DBFENTER;
+	/* First let's process the auth frames */
+	{
+		struct sk_buff          *skb;
+		hfa384x_InfFrame_t *inf;
+		
+		while ( (skb = skb_dequeue(&hw->authq)) ) {
+			inf = (hfa384x_InfFrame_t *) skb->data;
+			prism2sta_inf_authreq_defer(wlandev, inf);
+		}
+
+	}
+
+	/* Now let's handle the linkstatus stuff */
+	if (hw->link_status == hw->link_status_new)
+		goto failed;
+
+	hw->link_status = hw->link_status_new;
+
+	switch(hw->link_status) {
+	case HFA384x_LINK_NOTCONNECTED:
+		/* I'm currently assuming that this is the initial link 
+		 * state.  It should only be possible immediately
+		 * following an Enable command.
+		 * Response:
+		 * Block Transmits, Ignore receives of data frames
+		 */
+		netif_carrier_off(wlandev->netdev);
+
+		WLAN_LOG_INFO("linkstatus=NOTCONNECTED (unhandled)\n");
+		break;
+
+	case HFA384x_LINK_CONNECTED:
+		/* This one indicates a successful scan/join/auth/assoc.
+		 * When we have the full MLME complement, this event will
+		 * signify successful completion of both mlme_authenticate
+		 * and mlme_associate.  State management will get a little
+		 * ugly here.
+		 * Response:
+		 * Indicate authentication and/or association
+		 * Enable Transmits, Receives and pass up data frames
+		 */
+
+		netif_carrier_on(wlandev->netdev);
+
+		/* If we are joining a specific AP, set our state and reset retries */
+		if(hw->join_ap == 1)
+			hw->join_ap = 2;
+		hw->join_retries = 60;
+
+		/* Don't call this in monitor mode */
+		if ( wlandev->netdev->type == ARPHRD_ETHER ) {
+			UINT16			portstatus;
+
+			WLAN_LOG_INFO("linkstatus=CONNECTED\n");
+						
+			/* For non-usb devices, we can use the sync versions */
+			/* Collect the BSSID, and set state to allow tx */
+			
+			result = hfa384x_drvr_getconfig(hw, 
+							HFA384x_RID_CURRENTBSSID,
+							wlandev->bssid, WLAN_BSSID_LEN);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "getconfig(0x%02x) failed, result = %d\n",
+					       HFA384x_RID_CURRENTBSSID, result);
+				goto failed;
+			}
+			
+			result = hfa384x_drvr_getconfig(hw, 
+							HFA384x_RID_CURRENTSSID,
+							&ssid, sizeof(ssid));
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "getconfig(0x%02x) failed, result = %d\n",
+					       HFA384x_RID_CURRENTSSID, result);
+				goto failed;
+			}
+			prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid, 
+						(p80211pstrd_t *) &wlandev->ssid);
+			
+			/* Collect the port status */
+			result = hfa384x_drvr_getconfig16(hw, 
+							  HFA384x_RID_PORTSTATUS, &portstatus);
+			if ( result ) {
+				WLAN_LOG_DEBUG(1,
+					       "getconfig(0x%02x) failed, result = %d\n",
+					       HFA384x_RID_PORTSTATUS, result);
+				goto failed;
+			}
+			wlandev->macmode = 
+				(portstatus == HFA384x_PSTATUS_CONN_IBSS) ?
+				WLAN_MACMODE_IBSS_STA : WLAN_MACMODE_ESS_STA;
+
+			/* Get the ball rolling on the comms quality stuff */
+			prism2sta_commsqual_defer(&hw->commsqual_bh);
+		}
+		break;
+
+	case HFA384x_LINK_DISCONNECTED:
+		/* This one indicates that our association is gone.  We've
+		 * lost connection with the AP and/or been disassociated.  
+		 * This indicates that the MAC has completely cleared it's
+		 * associated state.  We * should send a deauth indication 
+		 * (implying disassoc) up * to the MLME.
+		 * Response:
+		 * Indicate Deauthentication
+		 * Block Transmits, Ignore receives of data frames
+		 */
+		if(hw->join_ap == 2)
+		{
+			hfa384x_JoinRequest_data_t      joinreq;
+			joinreq = hw->joinreq;
+			/* Send the join request */
+			hfa384x_drvr_setconfig( hw, 
+				HFA384x_RID_JOINREQUEST,
+				&joinreq, HFA384x_RID_JOINREQUEST_LEN);
+			WLAN_LOG_INFO("linkstatus=DISCONNECTED (re-submitting join)\n");
+		} else {
+			if (wlandev->netdev->type == ARPHRD_ETHER)
+				WLAN_LOG_INFO("linkstatus=DISCONNECTED (unhandled)\n");
+		}
+		wlandev->macmode = WLAN_MACMODE_NONE;
+
+		netif_carrier_off(wlandev->netdev);
+
+		break;
+
+	case HFA384x_LINK_AP_CHANGE:
+		/* This one indicates that the MAC has decided to and 
+		 * successfully completed a change to another AP.  We
+		 * should probably implement a reassociation indication 
+		 * in response to this one.  I'm thinking that the the 
+		 * p80211 layer needs to be notified in case of 
+		 * buffering/queueing issues.  User mode also needs to be
+		 * notified so that any BSS dependent elements can be 
+		 * updated.
+		 * associated state.  We * should send a deauth indication 
+		 * (implying disassoc) up * to the MLME.
+		 * Response:
+		 * Indicate Reassociation
+		 * Enable Transmits, Receives and pass up data frames
+		 */
+		WLAN_LOG_INFO("linkstatus=AP_CHANGE\n");
+
+		result = hfa384x_drvr_getconfig(hw, 
+						HFA384x_RID_CURRENTBSSID,
+						wlandev->bssid, WLAN_BSSID_LEN);
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				       "getconfig(0x%02x) failed, result = %d\n",
+				       HFA384x_RID_CURRENTBSSID, result);
+			goto failed;
+		}
+
+		result = hfa384x_drvr_getconfig(hw, 
+						HFA384x_RID_CURRENTSSID,
+						&ssid, sizeof(ssid));
+		if ( result ) {
+			WLAN_LOG_DEBUG(1,
+				       "getconfig(0x%02x) failed, result = %d\n",
+				       HFA384x_RID_CURRENTSSID, result);
+			goto failed;
+		}
+		prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid, 
+					(p80211pstrd_t *) &wlandev->ssid);
+
+		
+		hw->link_status = HFA384x_LINK_CONNECTED;
+		netif_carrier_on(wlandev->netdev);
+
+		break;
+
+	case HFA384x_LINK_AP_OUTOFRANGE:
+		/* This one indicates that the MAC has decided that the
+		 * AP is out of range, but hasn't found a better candidate
+		 * so the MAC maintains its "associated" state in case
+		 * we get back in range.  We should block transmits and 
+		 * receives in this state.  Do we need an indication here?
+		 * Probably not since a polling user-mode element would 
+		 * get this status from from p2PortStatus(FD40). What about
+		 * p80211?
+		 * Response:
+		 * Block Transmits, Ignore receives of data frames
+		 */
+		WLAN_LOG_INFO("linkstatus=AP_OUTOFRANGE (unhandled)\n");
+
+		netif_carrier_off(wlandev->netdev);
+
+		break;
+
+	case HFA384x_LINK_AP_INRANGE:
+		/* This one indicates that the MAC has decided that the
+		 * AP is back in range.  We continue working with our 
+		 * existing association.
+		 * Response:
+		 * Enable Transmits, Receives and pass up data frames
+		 */
+		WLAN_LOG_INFO("linkstatus=AP_INRANGE\n");
+
+		hw->link_status = HFA384x_LINK_CONNECTED;
+		netif_carrier_on(wlandev->netdev);
+
+		break;
+
+	case HFA384x_LINK_ASSOCFAIL:
+		/* This one is actually a peer to CONNECTED.  We've 
+		 * requested a join for a given SSID and optionally BSSID.
+		 * We can use this one to indicate authentication and 
+		 * association failures.  The trick is going to be 
+		 * 1) identifying the failure, and 2) state management.
+		 * Response:
+		 * Disable Transmits, Ignore receives of data frames
+		 */
+		if(hw->join_ap && --hw->join_retries > 0)
+		{
+			hfa384x_JoinRequest_data_t      joinreq;
+			joinreq = hw->joinreq;
+			/* Send the join request */
+			hfa384x_drvr_setconfig( hw, 
+				HFA384x_RID_JOINREQUEST,
+				&joinreq, HFA384x_RID_JOINREQUEST_LEN);
+			WLAN_LOG_INFO("linkstatus=ASSOCFAIL (re-submitting join)\n");
+		} else {
+			WLAN_LOG_INFO("linkstatus=ASSOCFAIL (unhandled)\n");
+		}
+
+		netif_carrier_off(wlandev->netdev);
+
+		break;
+
+	default:
+		/* This is bad, IO port problems? */
+		WLAN_LOG_WARNING( 
+			"unknown linkstatus=0x%02x\n", hw->link_status);
+		goto failed;
+		break;
+	}
+
+	wlandev->linkstatus = (hw->link_status == HFA384x_LINK_CONNECTED);
+#ifdef WIRELESS_EXT
+	p80211wext_event_associated(wlandev, wlandev->linkstatus);
+#endif
+
+ failed:
+	DBFEXIT;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_linkstatus
+*
+* Handles the receipt of a Link Status info frame.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_linkstatus(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+
+	DBFENTER;
+
+	hw->link_status_new = hfa384x2host_16(inf->info.linkstatus.linkstatus);
+
+	schedule_work(&hw->link_bh);
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_assocstatus
+*
+* Handles the receipt of an Association Status info frame. Should 
+* be present in APs only.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_assocstatus(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	hfa384x_AssocStatus_t	rec;
+	int			i;
+
+	DBFENTER;
+
+	memcpy(&rec, &inf->info.assocstatus, sizeof(rec));
+	rec.assocstatus = hfa384x2host_16(rec.assocstatus);
+	rec.reason      = hfa384x2host_16(rec.reason);
+
+	/*
+	** Find the address in the list of authenticated stations.  If it wasn't
+	** found, then this address has not been previously authenticated and
+	** something weird has happened if this is anything other than an
+	** "authentication failed" message.  If the address was found, then
+	** set the "associated" flag for that station, based on whether the
+	** station is associating or losing its association.  Something weird
+	** has also happened if we find the address in the list of authenticated
+	** stations but we are getting an "authentication failed" message.
+	*/
+
+	for (i = 0; i < hw->authlist.cnt; i++)
+		if (memcmp(rec.sta_addr, hw->authlist.addr[i], WLAN_ADDR_LEN) == 0)
+			break;
+
+	if (i >= hw->authlist.cnt) {
+		if (rec.assocstatus != HFA384x_ASSOCSTATUS_AUTHFAIL)
+			WLAN_LOG_WARNING("assocstatus info frame received for non-authenticated station.\n");
+	} else {
+		hw->authlist.assoc[i] =
+			(rec.assocstatus == HFA384x_ASSOCSTATUS_STAASSOC ||
+			 rec.assocstatus == HFA384x_ASSOCSTATUS_REASSOC);
+
+		if (rec.assocstatus == HFA384x_ASSOCSTATUS_AUTHFAIL)
+			WLAN_LOG_WARNING("authfail assocstatus info frame received for authenticated station.\n");
+	}
+
+	DBFEXIT;
+
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_inf_authreq
+*
+* Handles the receipt of an Authentication Request info frame. Should 
+* be present in APs only.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+*
+----------------------------------------------------------------*/
+void prism2sta_inf_authreq( wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	struct sk_buff *skb;
+	
+	DBFENTER;
+
+	skb = dev_alloc_skb(sizeof(*inf));
+	if (skb) {
+		skb_put(skb, sizeof(*inf));
+		memcpy(skb->data, inf, sizeof(*inf));
+		skb_queue_tail(&hw->authq, skb);
+		schedule_work(&hw->link_bh);
+	}		
+
+	DBFEXIT;
+}
+
+void prism2sta_inf_authreq_defer(wlandevice_t *wlandev, 
+				 hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+	hfa384x_authenticateStation_data_t  rec;
+
+	int    i, added, result, cnt;
+	UINT8  *addr;
+
+	DBFENTER;
+
+	/*
+	** Build the AuthenticateStation record.  Initialize it for denying
+	** authentication.
+	*/
+
+	memcpy(rec.address, inf->info.authreq.sta_addr, WLAN_ADDR_LEN);
+	rec.status = P80211ENUM_status_unspec_failure;
+
+	/*
+	** Authenticate based on the access mode.
+	*/
+
+	switch (hw->accessmode) {
+		case WLAN_ACCESS_NONE:
+
+			/*
+			** Deny all new authentications.  However, if a station
+			** is ALREADY authenticated, then accept it.
+			*/
+
+			for (i = 0; i < hw->authlist.cnt; i++)
+				if (memcmp(rec.address, hw->authlist.addr[i],
+						WLAN_ADDR_LEN) == 0) {
+					rec.status = P80211ENUM_status_successful;
+					break;
+				}
+
+			break;
+
+		case WLAN_ACCESS_ALL:
+
+			/*
+			** Allow all authentications.
+			*/
+
+			rec.status = P80211ENUM_status_successful;
+			break;
+
+		case WLAN_ACCESS_ALLOW:
+
+			/*
+			** Only allow the authentication if the MAC address
+			** is in the list of allowed addresses.
+			**
+			** Since this is the interrupt handler, we may be here
+			** while the access list is in the middle of being
+			** updated.  Choose the list which is currently okay.
+			** See "prism2mib_priv_accessallow()" for details.
+			*/
+
+			if (hw->allow.modify == 0) {
+				cnt  = hw->allow.cnt;
+				addr = hw->allow.addr[0];
+			} else {
+				cnt  = hw->allow.cnt1;
+				addr = hw->allow.addr1[0];
+			}
+
+			for (i = 0; i < cnt; i++, addr += WLAN_ADDR_LEN)
+				if (memcmp(rec.address, addr, WLAN_ADDR_LEN) == 0) {
+					rec.status = P80211ENUM_status_successful;
+					break;
+				}
+
+			break;
+
+		case WLAN_ACCESS_DENY:
+
+			/*
+			** Allow the authentication UNLESS the MAC address is
+			** in the list of denied addresses.
+			**
+			** Since this is the interrupt handler, we may be here
+			** while the access list is in the middle of being
+			** updated.  Choose the list which is currently okay.
+			** See "prism2mib_priv_accessdeny()" for details.
+			*/
+
+			if (hw->deny.modify == 0) {
+				cnt  = hw->deny.cnt;
+				addr = hw->deny.addr[0];
+			} else {
+				cnt  = hw->deny.cnt1;
+				addr = hw->deny.addr1[0];
+			}
+
+			rec.status = P80211ENUM_status_successful;
+
+			for (i = 0; i < cnt; i++, addr += WLAN_ADDR_LEN)
+				if (memcmp(rec.address, addr, WLAN_ADDR_LEN) == 0) {
+					rec.status = P80211ENUM_status_unspec_failure;
+					break;
+				}
+
+			break;
+	}
+
+	/*
+	** If the authentication is okay, then add the MAC address to the list
+	** of authenticated stations.  Don't add the address if it is already in
+	** the list.  (802.11b does not seem to disallow a station from issuing
+	** an authentication request when the station is already authenticated.
+	** Does this sort of thing ever happen?  We might as well do the check
+	** just in case.)
+	*/
+
+	added = 0;
+
+	if (rec.status == P80211ENUM_status_successful) {
+		for (i = 0; i < hw->authlist.cnt; i++)
+			if (memcmp(rec.address, hw->authlist.addr[i], WLAN_ADDR_LEN) == 0)
+				break;
+
+		if (i >= hw->authlist.cnt) {
+			if (hw->authlist.cnt >= WLAN_AUTH_MAX) {
+				rec.status = P80211ENUM_status_ap_full;
+			} else {
+				memcpy(hw->authlist.addr[hw->authlist.cnt],
+					rec.address, WLAN_ADDR_LEN);
+				hw->authlist.cnt++;
+				added = 1;
+			}
+		}
+	}
+
+	/*
+	** Send back the results of the authentication.  If this doesn't work,
+	** then make sure to remove the address from the authenticated list if
+	** it was added.
+	*/
+
+	rec.status = host2hfa384x_16(rec.status);
+	rec.algorithm = inf->info.authreq.algorithm;
+
+	result = hfa384x_drvr_setconfig(hw, HFA384x_RID_AUTHENTICATESTA,
+							&rec, sizeof(rec));
+	if (result) {
+		if (added) hw->authlist.cnt--;
+		WLAN_LOG_ERROR("setconfig(authenticatestation) failed, result=%d\n", result);
+	}
+
+	DBFEXIT;
+
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_inf_psusercnt
+*
+* Handles the receipt of a PowerSaveUserCount info frame. Should 
+* be present in APs only.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to info frame (contents in hfa384x order)
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_inf_psusercnt( wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+
+	DBFENTER;
+
+	hw->psusercount = hfa384x2host_16(inf->info.psusercnt.usercnt);
+
+	DBFEXIT;
+
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_ev_dtim
+*
+* Handles the DTIM early warning event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_dtim(wlandevice_t *wlandev)
+{
+#if 0
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+#endif
+	DBFENTER;
+	WLAN_LOG_DEBUG(3, "DTIM event, currently unhandled.\n");
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ev_infdrop
+*
+* Handles the InfDrop event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_infdrop(wlandevice_t *wlandev)
+{
+#if 0
+        hfa384x_t               *hw = (hfa384x_t *)wlandev->priv;
+#endif
+	DBFENTER;
+	WLAN_LOG_DEBUG(3, "Info frame dropped due to card mem low.\n");
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ev_info
+*
+* Handles the Info event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	inf		ptr to a generic info frame
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_info(wlandevice_t *wlandev, hfa384x_InfFrame_t *inf)
+{
+	DBFENTER;
+	inf->infotype = hfa384x2host_16(inf->infotype);
+	/* Dispatch */
+	switch ( inf->infotype ) {
+		case HFA384x_IT_HANDOVERADDR:
+			prism2sta_inf_handover(wlandev, inf);
+			break;
+		case HFA384x_IT_COMMTALLIES:
+			prism2sta_inf_tallies(wlandev, inf);
+			break;
+               case HFA384x_IT_HOSTSCANRESULTS:
+                        prism2sta_inf_hostscanresults(wlandev, inf);
+                        break;
+		case HFA384x_IT_SCANRESULTS:
+			prism2sta_inf_scanresults(wlandev, inf);
+			break;
+		case HFA384x_IT_CHINFORESULTS:
+			prism2sta_inf_chinforesults(wlandev, inf);
+			break;
+		case HFA384x_IT_LINKSTATUS:
+			prism2sta_inf_linkstatus(wlandev, inf);
+			break;
+		case HFA384x_IT_ASSOCSTATUS:
+			prism2sta_inf_assocstatus(wlandev, inf);
+			break;
+		case HFA384x_IT_AUTHREQ:
+			prism2sta_inf_authreq(wlandev, inf);
+			break;
+		case HFA384x_IT_PSUSERCNT:
+			prism2sta_inf_psusercnt(wlandev, inf);
+			break;
+	        case HFA384x_IT_KEYIDCHANGED:
+			WLAN_LOG_WARNING("Unhandled IT_KEYIDCHANGED\n");
+			break;
+	        case HFA384x_IT_ASSOCREQ:
+			WLAN_LOG_WARNING("Unhandled IT_ASSOCREQ\n");
+			break;
+	        case HFA384x_IT_MICFAILURE:
+			WLAN_LOG_WARNING("Unhandled IT_MICFAILURE\n");
+			break;
+		default:
+			WLAN_LOG_WARNING(
+				"Unknown info type=0x%02x\n", inf->infotype);
+			break;
+	}
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ev_txexc
+*
+* Handles the TxExc event.  A Transmit Exception event indicates
+* that the MAC's TX process was unsuccessful - so the packet did
+* not get transmitted.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	status		tx frame status word
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_txexc(wlandevice_t *wlandev, UINT16 status)
+{
+	DBFENTER;
+
+	WLAN_LOG_DEBUG(3, "TxExc status=0x%x.\n", status);
+
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ev_tx
+*
+* Handles the Tx event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*	status		tx frame status word
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_tx(wlandevice_t *wlandev, UINT16 status)
+{
+	DBFENTER;
+	WLAN_LOG_DEBUG(4, "Tx Complete, status=0x%04x\n", status);
+	/* update linux network stats */
+	wlandev->linux_stats.tx_packets++;
+	DBFEXIT;
+	return;
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_ev_rx
+*
+* Handles the Rx event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_rx(wlandevice_t *wlandev, struct sk_buff *skb)
+{
+	DBFENTER;
+
+	p80211netdev_rx(wlandev, skb);
+
+	DBFEXIT;
+	return;
+}
+
+/*----------------------------------------------------------------
+* prism2sta_ev_alloc
+*
+* Handles the Alloc event.
+*
+* Arguments:
+*	wlandev		wlan device structure
+*
+* Returns: 
+*	nothing
+*
+* Side effects:
+*
+* Call context:
+*	interrupt
+----------------------------------------------------------------*/
+void prism2sta_ev_alloc(wlandevice_t *wlandev)
+{
+	DBFENTER;
+
+	p80211netdev_wake_queue(wlandev);
+
+	DBFEXIT;
+	return;
+}
+
+#if (WLAN_HOSTIF == WLAN_PLX || WLAN_HOSTIF == WLAN_PCI)
+#ifdef CONFIG_PM
+static int prism2sta_suspend_pci(struct pci_dev *pdev, pm_message_t state)
+{
+       	wlandevice_t		*wlandev;
+
+	wlandev = (wlandevice_t *) pci_get_drvdata(pdev);
+
+	/* reset hardware */
+	if (wlandev) {
+		prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+		p80211_suspend(wlandev);
+	}
+
+	// call a netif_device_detach(wlandev->netdev) ?
+
+	return 0;
+}
+
+static int prism2sta_resume_pci (struct pci_dev *pdev)
+{
+       	wlandevice_t		*wlandev;
+
+	wlandev = (wlandevice_t *) pci_get_drvdata(pdev);
+
+	if (wlandev) {
+		prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+		p80211_resume(wlandev);
+	}
+		
+        return 0;
+}
+#endif
+#endif
+
+/*----------------------------------------------------------------
+* create_wlan
+*
+* Called at module init time.  This creates the wlandevice_t structure
+* and initializes it with relevant bits.
+*
+* Arguments:
+*	none
+*
+* Returns: 
+*	the created wlandevice_t structure.
+*
+* Side effects:
+* 	also allocates the priv/hw structures.
+*
+* Call context:
+*	process thread
+*
+----------------------------------------------------------------*/
+static wlandevice_t *create_wlan(void)
+{
+        wlandevice_t    *wlandev = NULL;
+	hfa384x_t	*hw = NULL;
+
+      	/* Alloc our structures */
+	wlandev =	kmalloc(sizeof(wlandevice_t), GFP_KERNEL);
+	hw =		kmalloc(sizeof(hfa384x_t), GFP_KERNEL);
+
+	if (!wlandev || !hw) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		if (wlandev)	kfree(wlandev);
+		if (hw)		kfree(hw);
+		return NULL;
+	}
+
+	/* Clear all the structs */
+	memset(wlandev, 0, sizeof(wlandevice_t));
+	memset(hw, 0, sizeof(hfa384x_t));
+
+	/* Initialize the network device object. */
+	wlandev->nsdname = dev_info;
+	wlandev->msdstate = WLAN_MSD_HWPRESENT_PENDING;
+	wlandev->priv = hw;
+	wlandev->open = prism2sta_open;
+	wlandev->close = prism2sta_close;
+	wlandev->reset = prism2sta_reset;
+#ifdef CONFIG_PROC_FS
+	wlandev->nsd_proc_read = prism2sta_proc_read;
+#endif
+	wlandev->txframe = prism2sta_txframe;
+	wlandev->mlmerequest = prism2sta_mlmerequest;
+	wlandev->set_multicast_list = prism2sta_setmulticast;
+	wlandev->tx_timeout = hfa384x_tx_timeout;
+
+	wlandev->nsdcaps = P80211_NSDCAP_HWFRAGMENT | 
+	                   P80211_NSDCAP_AUTOJOIN;
+
+	/* Initialize the device private data stucture. */
+        hw->dot11_desired_bss_type = 1;
+
+	return wlandev;
+}
+
+#ifdef CONFIG_PROC_FS
+static int
+prism2sta_proc_read(
+	char	*page, 
+	char	**start, 
+	off_t	offset, 
+	int	count,
+	int	*eof,
+	void	*data)
+{
+	char	 *p = page;
+	wlandevice_t *wlandev = (wlandevice_t *) data;
+	hfa384x_t *hw = (hfa384x_t *) wlandev->priv;
+
+	UINT16 hwtype = 0;
+
+	DBFENTER;
+	if (offset != 0) {
+		*eof = 1;
+		goto exit;
+	} 
+
+	// XXX 0x0001 for prism2.5/3, 0x0000 for prism2.
+	hwtype = BIT0;
+
+#if (WLAN_HOSTIF != WLAN_USB)
+	if (hw->isram16)
+		hwtype |= BIT1;
+#endif
+
+#if (WLAN_HOSTIF == WLAN_PCI)
+	hwtype |= BIT2;
+#endif
+
+#define PRISM2_CVS_ID "$Id: prism2sta.c 1767 2006-01-19 21:25:50Z solomon $"
+
+	p += sprintf(p, "# %s version %s (%s) '%s'\n\n", 
+		     dev_info,
+		     WLAN_RELEASE, WLAN_BUILD_DATE, PRISM2_CVS_ID);
+
+	p += sprintf(p, "# nic h/w: id=0x%02x %d.%d.%d\n",
+		     hw->ident_nic.id, hw->ident_nic.major,
+		     hw->ident_nic.minor, hw->ident_nic.variant);
+
+	p += sprintf(p, "# pri f/w: id=0x%02x %d.%d.%d\n",
+		     hw->ident_pri_fw.id, hw->ident_pri_fw.major,
+		     hw->ident_pri_fw.minor, hw->ident_pri_fw.variant);
+
+	if (hw->ident_sta_fw.id == 0x1f) {
+		p += sprintf(p, "# sta f/w: id=0x%02x %d.%d.%d\n",
+			     hw->ident_sta_fw.id, hw->ident_sta_fw.major,
+			     hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);
+	} else {
+		p += sprintf(p, "# ap f/w: id=0x%02x %d.%d.%d\n",
+			     hw->ident_sta_fw.id, hw->ident_sta_fw.major,
+			     hw->ident_sta_fw.minor, hw->ident_sta_fw.variant);
+	}
+	
+#if (WLAN_HOSTIF != WLAN_USB)
+	p += sprintf(p, "# initial nic hw type, needed for SSF ramdl\n");
+	p += sprintf(p, "initnichw=%04x\n", hwtype);
+#endif
+
+ exit:
+	DBFEXIT;
+	return (p - page);
+}
+#endif
+
+void prism2sta_commsqual_defer(struct work_struct *ws)
+{
+        hfa384x_t               *hw = container_of(ws, hfa384x_t, commsqual_bh);
+        wlandevice_t            *wlandev = hw->wlandev;
+	hfa384x_bytestr32_t ssid;
+	int result = 0;
+
+	DBFENTER;
+
+	if (hw->wlandev->hwremoved)
+		goto done;
+
+	/* we don't care if we're in AP mode */	
+	if ((wlandev->macmode == WLAN_MACMODE_NONE) ||
+	    (wlandev->macmode == WLAN_MACMODE_ESS_AP)) {
+		goto done;
+	}
+
+	/* It only makes sense to poll these in non-IBSS */
+	if (wlandev->macmode != WLAN_MACMODE_IBSS_STA) {
+		result = hfa384x_drvr_getconfig(hw, HFA384x_RID_DBMCOMMSQUALITY, 
+						&hw->qual, 
+						HFA384x_RID_DBMCOMMSQUALITY_LEN);
+		
+		if (result) {
+			WLAN_LOG_ERROR("error fetching commsqual\n");
+			goto done;
+		}
+
+		// qual.CQ_currBSS; // link
+		// ASL_currBSS;  // level
+		// qual.ANL_currFC; // noise
+		
+		WLAN_LOG_DEBUG(3, "commsqual %d %d %d\n", 
+			       hfa384x2host_16(hw->qual.CQ_currBSS),
+			       hfa384x2host_16(hw->qual.ASL_currBSS),
+			       hfa384x2host_16(hw->qual.ANL_currFC));
+	}
+
+	/* Lastly, we need to make sure the BSSID didn't change on us */
+	result = hfa384x_drvr_getconfig(hw, 
+					HFA384x_RID_CURRENTBSSID,
+					wlandev->bssid, WLAN_BSSID_LEN);
+	if ( result ) {
+		WLAN_LOG_DEBUG(1,
+			       "getconfig(0x%02x) failed, result = %d\n",
+			       HFA384x_RID_CURRENTBSSID, result);
+		goto done;
+	}
+	
+	result = hfa384x_drvr_getconfig(hw, 
+					HFA384x_RID_CURRENTSSID,
+					&ssid, sizeof(ssid));
+	if ( result ) {
+		WLAN_LOG_DEBUG(1,
+			       "getconfig(0x%02x) failed, result = %d\n",
+			       HFA384x_RID_CURRENTSSID, result);
+		goto done;
+	}
+	prism2mgmt_bytestr2pstr((hfa384x_bytestr_t *)&ssid, 
+				(p80211pstrd_t *) &wlandev->ssid);
+	
+
+	/* Reschedule timer */
+	mod_timer(&hw->commsqual_timer, jiffies + HZ);
+
+ done:
+	DBFEXIT;
+}
+
+void prism2sta_commsqual_timer(unsigned long data)
+{
+        hfa384x_t               *hw = (hfa384x_t *) data;
+
+	DBFENTER;
+
+	schedule_work(&hw->commsqual_bh);
+	
+	DBFEXIT;
+}
diff -Nurp linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_usb.c linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_usb.c
--- linux-2.6.20-sabayon-r2.orig/drivers/net/wireless/prism2/prism2_usb.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.20-sabayon-r2/drivers/net/wireless/prism2/prism2_usb.c	2007-01-10 15:57:03.000000000 +0100
@@ -0,0 +1,362 @@
+#define WLAN_HOSTIF WLAN_USB
+#include "hfa384x_usb.c"
+#include "prism2mgmt.c"
+#include "prism2mib.c"
+#include "prism2sta.c"
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0))
+#error "prism2_usb requires at least a 2.4.x kernel!"
+#endif
+
+#define PRISM_USB_DEVICE(vid, pid, name) \
+           USB_DEVICE(vid, pid),  \
+           .driver_info = (unsigned long) name
+
+static struct usb_device_id usb_prism_tbl[] = {
+	{PRISM_USB_DEVICE(0x04bb, 0x0922, "IOData AirPort WN-B11/USBS")},
+	{PRISM_USB_DEVICE(0x07aa, 0x0012, "Corega Wireless LAN USB Stick-11")},
+	{PRISM_USB_DEVICE(0x09aa, 0x3642, "Prism2.x 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x1668, 0x0408, "Actiontec Prism2.5 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x1668, 0x0421, "Actiontec Prism2.5 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x1915, 0x2236, "Linksys WUSB11v3.0 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x066b, 0x2212, "Linksys WUSB11v2.5 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x066b, 0x2213, "Linksys WUSB12v1.1 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x067c, 0x1022, "Siemens SpeedStream 1022 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x049f, 0x0033, "Compaq/Intel W100 PRO/Wireless 11Mbps multiport WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x0411, 0x0016, "Melco WLI-USB-S11 11Mbps WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x08de, 0x7a01, "PRISM25 IEEE 802.11 Mini USB Adapter")},
+	{PRISM_USB_DEVICE(0x8086, 0x1111, "Intel PRO/Wireless 2011B LAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x0d8e, 0x7a01, "PRISM25 IEEE 802.11 Mini USB Adapter")},
+	{PRISM_USB_DEVICE(0x045e, 0x006e, "Microsoft MN510 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x0967, 0x0204, "Acer Warplink USB Adapter")},
+	{PRISM_USB_DEVICE(0x0cde, 0x0002, "Z-Com 725/726 Prism2.5 USB/USB Integrated")},
+	{PRISM_USB_DEVICE(0x0cde, 0x0005, "Z-Com Xl735 Wireless 802.11b USB Adapter")},
+	{PRISM_USB_DEVICE(0x413c, 0x8100, "Dell TrueMobile 1180 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x0b3b, 0x1601, "ALLNET 0193 11Mbps WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x0b3b, 0x1602, "ZyXEL ZyAIR B200 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x0baf, 0x00eb, "USRobotics USR1120 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x0411, 0x0027, "Melco WLI-USB-KS11G 11Mbps WLAN Adapter")},
+        {PRISM_USB_DEVICE(0x04f1, 0x3009, "JVC MP-XP7250 Builtin USB WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x0846, 0x4110, "NetGear MA111")},
+        {PRISM_USB_DEVICE(0x03f3, 0x0020, "Adaptec AWN-8020 USB WLAN Adapter")},
+//	{PRISM_USB_DEVICE(0x0ace, 0x1201, "ZyDAS ZD1201 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x2821, 0x3300, "ASUS-WL140 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x2001, 0x3700, "DWL-122 Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x2001, 0x3702, "DWL-120 Rev F Wireless USB Adapter")},
+	{PRISM_USB_DEVICE(0x50c2, 0x4013, "Averatec USB WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x2c02, 0x14ea, "Planex GW-US11H WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x124a, 0x168b, "Airvast PRISM3 WLAN USB Adapter")},
+	{PRISM_USB_DEVICE(0x083a, 0x3503, "T-Sinus 111 USB WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x2821, 0x3300, "Hawking HighDB USB Adapter")},
+	{PRISM_USB_DEVICE(0x0411, 0x0044, "Melco WLI-USB-KB11 11Mbps WLAN Adapter")},
+	{PRISM_USB_DEVICE(0x1668, 0x6106, "ROPEX FreeLan 802.11b USB Adapter")},
+	{PRISM_USB_DEVICE(0x124a, 0x4017, "Pheenet WL-503IA 802.11b USB Adapter")},
+	{PRISM_USB_DEVICE(0x0bb2, 0x0302, "Ambit Microsystems Corp.")},
+	{PRISM_USB_DEVICE(0x9016, 0x182d, "Sitecom WL-022 802.11b USB Adapter")},
+	{PRISM_USB_DEVICE(0x0543, 0x0f01, "ViewSonic Airsync USB Adapter 11Mbps (Prism2.5)")},
+	{ /* terminator */ }
+};
+
+MODULE_DEVICE_TABLE(usb, usb_prism_tbl);
+
+/*----------------------------------------------------------------
+* prism2sta_probe_usb
+*
+* Probe routine called by the USB subsystem.
+*
+* Arguments:
+*	dev		ptr to the usb_device struct
+*	ifnum		interface number being offered
+*
+* Returns: 
+*	NULL		- we're not claiming the device+interface
+*	non-NULL	- we are claiming the device+interface and
+*			  this is a ptr to the data we want back
+*			  when disconnect is called.
+*
+* Side effects:
+*	
+* Call context:
+*	I'm not sure, assume it's interrupt.
+*	
+----------------------------------------------------------------*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void __devinit *prism2sta_probe_usb(
+	struct usb_device *dev, 
+	unsigned int ifnum,
+	const struct usb_device_id *id)
+#else
+int prism2sta_probe_usb(
+	struct usb_interface *interface,
+	const struct usb_device_id *id)
+#endif
+{
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	struct usb_interface *interface;
+#else
+	struct usb_device *dev;
+#endif
+
+	wlandevice_t	*wlandev = NULL;
+	hfa384x_t	*hw = NULL;
+	int              result = 0;
+
+	DBFENTER;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	interface = &dev->actconfig->interface[ifnum];
+#else
+	dev = interface_to_usbdev(interface);
+#endif
+	
+
+	if ((wlandev = create_wlan()) == NULL) {
+		WLAN_LOG_ERROR("%s: Memory allocation failure.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}
+	hw = wlandev->priv;
+
+	if ( wlan_setup(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: wlan_setup() failed.\n", dev_info);
+		result = -EIO;
+		goto failed;
+	}	
+
+	/* Initialize the hw data */
+	hfa384x_create(hw, dev);
+	hw->wlandev = wlandev;
+
+	/* Register the wlandev, this gets us a name and registers the
+	 * linux netdevice.
+	 */
+	SET_MODULE_OWNER(wlandev->netdev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0))
+	SET_NETDEV_DEV(wlandev->netdev, &(interface->dev));
+#endif
+        if ( register_wlandev(wlandev) != 0 ) {
+		WLAN_LOG_ERROR("%s: register_wlandev() failed.\n", dev_info);
+		result = -EIO;
+		goto failed;
+        }
+
+	/* Do a chip-level reset on the MAC */
+	if (prism2_doreset) {
+		result = hfa384x_corereset(hw, 
+				prism2_reset_holdtime, 
+				prism2_reset_settletime, 0);
+		if (result != 0) {
+			unregister_wlandev(wlandev);
+			hfa384x_destroy(hw);
+			result = -EIO;
+			WLAN_LOG_ERROR(
+				"%s: hfa384x_corereset() failed.\n", 
+				dev_info);
+			goto failed;
+		}
+	}
+
+#ifndef NEW_MODULE_CODE
+	usb_inc_dev_use(dev);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15))
+	usb_get_dev(dev);
+#endif
+
+	wlandev->msdstate = WLAN_MSD_HWPRESENT;
+
+	goto done;
+
+ failed:
+	if (wlandev)	kfree(wlandev);
+	if (hw)		kfree(hw);
+	wlandev = NULL;
+
+ done:
+	DBFEXIT;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+	return wlandev;
+#else
+	usb_set_intfdata(interface, wlandev);
+	return result;
+#endif
+}
+
+
+/*----------------------------------------------------------------
+* prism2sta_disconnect_usb
+*
+* Called when a device previously claimed by probe is removed 
+* from the USB. 
+*
+* Arguments:
+*	dev		ptr to the usb_device struct
+*	ptr		ptr returned by probe() when the device
+*                       was claimed.
+*
+* Returns: 
+*	Nothing
+*
+* Side effects:
+*	
+* Call context:
+*	process
+----------------------------------------------------------------*/
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0))
+void __devexit
+prism2sta_disconnect_usb(struct usb_device *dev, void *ptr)
+#else
+void
+prism2sta_disconnect_usb(struct usb_interface *interface)
+#endif
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+	wlandevice_t		*wlandev;
+#else
+	wlandevice_t		*wlandev = (wlandevice_t*)ptr;
+#endif
+
+        DBFENTER;
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+	wlandev = (wlandevice_t *) usb_get_intfdata(interface);
+#endif
+
+	if ( wlandev != NULL ) {
+		LIST_HEAD(cleanlist);
+		struct list_head	*entry;
+		struct list_head	*temp;
+		unsigned long		flags;
+
+		hfa384x_t		*hw = wlandev->priv;
+
+		if (!hw)
+			goto exit;
+
+		spin_lock_irqsave(&hw->ctlxq.lock, flags);
+
+		p80211netdev_hwremoved(wlandev);
+		list_splice_init(&hw->ctlxq.reapable, &cleanlist);
+		list_splice_init(&hw->ctlxq.completing, &cleanlist);
+		list_splice_init(&hw->ctlxq.pending, &cleanlist);
+		list_splice_init(&hw->ctlxq.active, &cleanlist);
+
+		spin_unlock_irqrestore(&hw->ctlxq.lock, flags);
+
+		/* There's no hardware to shutdown, but the driver
+		 * might have some tasks or tasklets that must be
+		 * stopped before we can tear everything down.
+		 */
+		prism2sta_ifstate(wlandev, P80211ENUM_ifstate_disable);
+
+		del_singleshot_timer_sync(&hw->throttle);
+		del_singleshot_timer_sync(&hw->reqtimer);
+		del_singleshot_timer_sync(&hw->resptimer);
+
+		/* Unlink all the URBs. This "removes the wheels"
+		 * from the entire CTLX handling mechanism.
+		 */
+		usb_kill_urb(&hw->rx_urb);
+		usb_kill_urb(&hw->tx_urb);
+		usb_kill_urb(&hw->ctlx_urb);
+
+		tasklet_kill(&hw->completion_bh);
+		tasklet_kill(&hw->reaper_bh);
+
+		flush_scheduled_work();
+
+		/* Now we complete any outstanding commands
+		 * and tell everyone who is waiting for their
+		 * responses that we have shut down.
+		 */
+		list_for_each(entry, &cleanlist) {
+			hfa384x_usbctlx_t	*ctlx;
+
+			ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+			complete(&ctlx->done);
+		}
+
+		/* Give any outstanding synchronous commands
+		 * a chance to complete. All they need to do
+		 * is "wake up", so that's easy.
+		 * (I'd like a better way to do this, really.)
+		 */
+		msleep(100);
+
+		/* Now delete the CTLXs, because no-one else can now. */
+		list_for_each_safe(entry, temp, &cleanlist) {
+			hfa384x_usbctlx_t *ctlx;
+
+			ctlx = list_entry(entry, hfa384x_usbctlx_t, list);
+			kfree(ctlx);
+		}
+
+		/* Unhook the wlandev */
+		unregister_wlandev(wlandev);
+		wlan_unsetup(wlandev);
+
+#ifndef NEW_MODULE_CODE
+		usb_dec_dev_use(hw->usb);
+#endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15))
+		usb_put_dev(hw->usb);
+#endif
+
+		hfa384x_destroy(hw);
+		kfree(hw);
+
+		kfree(wlandev);
+	}
+
+ exit:
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0))
+	usb_set_intfdata(interface, NULL);
+#endif
+	DBFEXIT;
+}
+
+
+struct usb_driver prism2_usb_driver = {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,4,19)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,16)) 
+	.owner = THIS_MODULE,
+#endif
+	.name = "prism2_usb",
+	.probe = prism2sta_probe_usb,
+	.disconnect = prism2sta_disconnect_usb,
+	.id_table = usb_prism_tbl,
+	/* fops, minor? */
+};
+
+#ifdef MODULE
+
+static int __init prism2usb_init(void)
+{
+        DBFENTER;
+
+        WLAN_LOG_NOTICE("%s Loaded\n", version);
+        WLAN_LOG_NOTICE("dev_info is: %s\n", dev_info);
+
+	/* This call will result in calls to prism2sta_probe_usb. */
+	return usb_register(&prism2_usb_driver);
+
+	DBFEXIT;
+};
+
+static void __exit prism2usb_cleanup(void)
+{
+        DBFENTER;
+
+	usb_deregister(&prism2_usb_driver);
+
+        printk(KERN_NOTICE "%s Unloaded\n", version);
+
+	DBFEXIT;
+};
+
+module_init(prism2usb_init);
+module_exit(prism2usb_cleanup);
+
+#endif // module
