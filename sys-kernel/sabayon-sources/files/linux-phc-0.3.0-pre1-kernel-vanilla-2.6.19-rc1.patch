Index: linux/arch/i386/kernel/cpu/cpufreq/Kconfig
===================================================================
--- linux.orig/arch/i386/kernel/cpu/cpufreq/Kconfig
+++ linux/arch/i386/kernel/cpu/cpufreq/Kconfig
@@ -2,6 +2,9 @@
 # CPU Frequency scaling
 #
 
+# This file has been patched with Linux PHC: https://www.dedigentoo.org/trac/linux-phc
+# Patch version: linux-phc-0.3.0-pre1-kernel-vanilla-2.6.19-rc1.patch
+
 menu "CPU Frequency scaling"
 
 source "drivers/cpufreq/Kconfig"
@@ -106,16 +109,52 @@ config X86_GX_SUSPMOD
 
 	 If in doubt, say N.
 
+config X86_PHC_EST
+	tristate "Linux PHC Enhanced Speedstep (Experimental)"
+	depends on SYSFS
+	select CPU_FREQ_TABLE
+	help
+	  This adds the CPUFreq driver from the Linux-PHC project for 
+	  Enhanced SpeedStep enabled mobile processors.  
+	  This means Intel Pentium M (Centrino) and Intel Core processors.
+
+	  For details, take a look at https://www.dedigentoo.org/trac/linux-phc.
+
+	  If in doubt, say N.
+
 config X86_SPEEDSTEP_CENTRINO
 	tristate "Intel Enhanced SpeedStep"
 	select CPU_FREQ_TABLE
-	select X86_SPEEDSTEP_CENTRINO_TABLE if (!X86_SPEEDSTEP_CENTRINO_ACPI)
+	select X86_SPEEDSTEP_CENTRINO_ACPI if (!X86_SPEEDSTEP_CENTRINO_BUILTIN || (!X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS && !X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN && !X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA ))
 	help
 	  This adds the CPUFreq driver for Enhanced SpeedStep enabled
 	  mobile CPUs.  This means Intel Pentium M (Centrino) CPUs. However,
-	  you also need to say Y to "Use ACPI tables to decode..." below
-	  [which might imply enabling ACPI] if you want to use this driver
-	  on non-Banias CPUs.
+	  you also need to say Y below to at least one of the following options:
+	   - "Use ACPI tables to decode..." [which might imply enabling ACPI]
+	   - "Built-in Tables for ... CPUs"
+
+	  You can also say yes to all of these options. In this configuration the
+	  driver will first try to use ACPI. Then if it fails it will try to use
+	  a built-in table if there is one matching the CPU.
+
+	  For details, take a look at <file:Documentation/cpu-freq/>.
+
+	  If in doubt, say N.
+
+config X86_SPEEDSTEP_CENTRINO_SYSFS
+	bool "Userspace control of CPU frequency/voltage table"
+	depends on X86_SPEEDSTEP_CENTRINO
+	depends on SYSFS
+	depends on (X86_SPEEDSTEP_CENTRINO_BUILTIN && (X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS || X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN || X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA )) || X86_SPEEDSTEP_CENTRINO_ACPI || X86_SPEEDSTEP_CENTRINO_DEFAULT
+	default y
+	help
+	  Add support for user space control of the CPU frequency/voltage 
+	  operating points table through a sysfs interface.
+
+	  If you say Y here files will be created in 
+	  /sys/devices/system/cpu/cpu*/cpufreq/op_points_table
+	  allowing reading and writing of the current table values as well as 
+	  adding or removing operating points.
 
 	  For details, take a look at <file:Documentation/cpu-freq/>.
 
@@ -130,20 +169,66 @@ config X86_SPEEDSTEP_CENTRINO_ACPI
 	  acpi_cpufreq (X86_ACPI_CPUFREQ). Use that driver instead of
 	  speedstep_centrino.
 	  Use primarily the information provided in the BIOS ACPI tables
-	  to determine valid CPU frequency and voltage pairings. It is
-	  required for the driver to work on non-Banias CPUs.
+          to determine valid CPU frequency and voltage pairings.
+          It is required for the driver to work on CPUs with no built-in
+          table available
 
 	  If in doubt, say Y.
-
-config X86_SPEEDSTEP_CENTRINO_TABLE
-	bool "Built-in tables for Banias CPUs"
+config X86_SPEEDSTEP_CENTRINO_BUILTIN
+        bool "Built-in tables"
 	depends on X86_SPEEDSTEP_CENTRINO
 	default y
 	help
-	  Use built-in tables for Banias CPUs if ACPI encoding
 	  is not available.
 
-	  If in doubt, say N.
+          If you say Y here you must select at least one of the CPU below.
+
+          If you are not sure of your exact CPU model you can select several CPU
+          models or all of them. The driver will only use the table that match
+          the exact CPU name and family/model/stepping numbers.
+          Selecting all the built-in tables will only add a small size overhead
+          to the kernel and an insignificant extra time to intialize the driver.
+ 
+          If both ACPI and built-in tables support are enabled then built-in
+          tables will be used only if ACPI table decoding fails.
+        
+          If you want to force usage of built-in tables over ACPI you need to say
+          Y here and N to X86_SPEEDSTEP_CENTRINO_ACPI.
+ 
+          If in doubt, say Y.
+
+config X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS
+        bool "Built-in tables for Banias CPUs"
+        depends on X86_SPEEDSTEP_CENTRINO_BUILTIN
+        default y
+        help
+          Use built-in tables for Banias CPUs if ACPI encoding is not available.
+          Banias CPUs are the first generation of Pentium-M, with a 1 MB L2 cache
+          and 400 MHz FSB manufactured on 0.13 micron process.
+ 
+          If in doubt, say Y.
+ 
+config X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN
+        bool "Built-in tables for Dothan CPUs"
+        depends on X86_SPEEDSTEP_CENTRINO_BUILTIN
+        default y
+        help
+          Use built-in tables for Dothan CPUs if ACPI encoding is not available.
+          Dothan CPUs are the second generation of Pentium-M, with a 2 MB L2
+          cache and 400 MHz FSB manufactured on 90 nm process.
+ 
+          If in doubt, say Y.
+ 
+config X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA
+        bool "Built-in tables for Sonoma CPUs"
+        depends on X86_SPEEDSTEP_CENTRINO_BUILTIN
+        default y
+        help
+          Use built-in tables for Sonoma CPUs if ACPI encoding is not available.
+          Sonoma CPUs are the third generation of Pentium-M, with a 2 MB L2 cache
+          and 533 MHz FSB manufactured on 90 nm process.
+ 
+          If in doubt, say Y.
 
 config X86_SPEEDSTEP_ICH
 	tristate "Intel Speedstep on ICH-M chipsets (ioport interface)"
Index: linux/arch/i386/kernel/cpu/cpufreq/Makefile
===================================================================
--- linux.orig/arch/i386/kernel/cpu/cpufreq/Makefile
+++ linux/arch/i386/kernel/cpu/cpufreq/Makefile
@@ -14,3 +14,4 @@ obj-$(CONFIG_X86_ACPI_CPUFREQ)		+= acpi-
 obj-$(CONFIG_X86_SPEEDSTEP_CENTRINO)	+= speedstep-centrino.o
 obj-$(CONFIG_X86_P4_CLOCKMOD)		+= p4-clockmod.o
 obj-$(CONFIG_X86_CPUFREQ_NFORCE2)	+= cpufreq-nforce2.o
+obj-$(CONFIG_X86_PHC_EST)               += phc-est.o
Index: linux/arch/i386/kernel/cpu/cpufreq/phc-est.c
===================================================================
--- /dev/null
+++ linux/arch/i386/kernel/cpu/cpufreq/phc-est.c
@@ -0,0 +1,1241 @@
+/*
+ * cpufreq driver for Enhanced SpeedStep, as found in Intel Pentium
+ * M and Intel Core processors.
+ *
+ * derived from the speedstep-centrino driver
+ *
+ * Copyright (C) 2006 Fabrice Bellamy <b12_1971@yahoo.fr>
+ */
+
+/*
+ * This driver is part of Linux PHC: https://www.dedigentoo.org/trac/linux-phc
+ * Linux-PHC version: linux-phc-0.3.0-pre1-kernel-vanilla-2.6.19-rc1.patch
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/cpufreq.h>
+#include <linux/sched.h>	/* current */
+#include <linux/delay.h>
+#include <linux/compiler.h>
+
+#ifdef CONFIG_X86_PHC_EST_ACPI
+#include <linux/acpi.h>
+#include <acpi/processor.h>
+#endif
+
+#include <asm/msr.h>
+#include <asm/processor.h>
+#include <asm/cpufeature.h>
+
+#define PFX		"phc-est: "
+#define MAINTAINER	"b12_1971@yahoo.fr"
+
+#define debug_printk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_DRIVER, "phc-est", msg)
+#define error_printk(msg...) phc_error_printk("phc-est", msg)
+
+/* TODO Add a vendor field */
+struct cpu_id
+{
+	__u8	x86;            /* CPU family */
+	__u8    x86_vendor;     /* CPU vendor */
+	__u8	x86_model;	/* model */
+	__u8	x86_mask;	/* stepping */
+};
+
+
+/* TODO Add VIA CPU types */
+enum {
+	CPU_BANIAS,
+	CPU_DOTHAN_A1,
+	CPU_DOTHAN_A2,
+	CPU_DOTHAN_B0,
+	CPU_DOTHAN_C0,
+	CPU_CORE,
+	CPU_CORE2,
+	CPU_MP4HT_D0,
+	CPU_MP4HT_E0,
+};
+
+/* TODO Add VIA CPU types */
+static const struct cpu_id cpu_ids[] = {
+	[CPU_BANIAS]	= { 6, X86_VENDOR_INTEL,  9, 5 },
+	[CPU_DOTHAN_A1]	= { 6, X86_VENDOR_INTEL, 13, 1 },
+	[CPU_DOTHAN_A2]	= { 6, X86_VENDOR_INTEL, 13, 2 },
+	[CPU_DOTHAN_B0]	= { 6, X86_VENDOR_INTEL, 13, 6 },
+	[CPU_DOTHAN_C0]	= { 6, X86_VENDOR_INTEL, 13, 8 },
+	[CPU_CORE]	= { 6, X86_VENDOR_INTEL, 14, 8 },
+	[CPU_CORE2]	= { 6, X86_VENDOR_INTEL, 15, 6 },
+	[CPU_MP4HT_D0]	= {15, X86_VENDOR_INTEL,  3, 4 },
+	[CPU_MP4HT_E0]	= {15, X86_VENDOR_INTEL,  4, 1 },
+};
+#define N_IDS	ARRAY_SIZE(cpu_ids)
+
+struct cpu_model
+{
+	const struct cpu_id *cpu_id;
+	const char	*model_name;
+	unsigned	max_freq; /* max clock in kHz */
+	struct cpufreq_frequency_table *op_points; /* clock/voltage pairs */
+	unsigned	bus_clock_x3; /* base frequency used to convert between core frequency and FID */
+};
+static int est_verify_cpu_id(const struct cpuinfo_x86 *c, const struct cpu_id *x);
+
+/* Operating points for current CPU */
+static struct cpu_model *est_model[NR_CPUS];
+static const struct cpu_id *est_cpu[NR_CPUS];
+
+static struct cpufreq_driver est_driver;
+
+
+
+/* CPU models, their operating frequency range, and freq/voltage
+   operating points */
+static struct cpu_model models[] =
+{
+	/* NULL model_name is a wildcard to catch known CPU IDs for which
+	 * we don't have any builtin table */
+	{ &cpu_ids[CPU_BANIAS], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_A1], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_A2], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_B0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_C0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_CORE], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_CORE2], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL, 0 },
+
+	/* End of the table */
+	{ NULL, }
+};
+
+
+void phc_error_printk(const char *prefix, const char *fmt, ...)
+{
+        char s[256];
+        va_list args;
+        unsigned int len;
+
+        if ((prefix != NULL) && (fmt != NULL))
+	{
+                len = snprintf(s, 256, KERN_INFO "%s: ", prefix);
+
+                va_start(args, fmt);
+                len += vsnprintf(&s[len], (256 - len), fmt, args);
+                va_end(args);
+
+                printk(s);
+        }
+}
+
+
+static int est_cpu_init_table(struct cpufreq_policy *policy)
+{
+	unsigned cpu = policy->cpu;
+	struct cpuinfo_x86 *cpuinfo = &cpu_data[cpu];
+	struct cpu_model *model;
+
+	unsigned i;
+	unsigned msr_l;
+	unsigned msr_h;
+	unsigned vid_lfm;
+	unsigned vid_hfm;
+	unsigned fid_lfm;
+	unsigned fid_hfm;
+	unsigned bus_clock;
+	unsigned bus_clock_x3;
+	unsigned op_point_count;
+	cpumask_t saved_mask;
+
+	/* Get LFM and HFM FID/VID from the PERF_STATUS MSR register */
+
+	// Ensure we are running on the correct CPU
+	saved_mask = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	if (smp_processor_id() != cpu)
+	{
+		error_printk("Error: set_cpus_allowed() failed\n");
+		return -ENOENT;
+	}
+
+	// Read the PERF_STATUS register value
+	rdmsr(MSR_IA32_PERF_STATUS, msr_l, msr_h);
+
+	// Now that we have read the register we can run on any CPUs
+	set_cpus_allowed(current, saved_mask);
+
+
+	// Decode the PERF_STATUS register value
+	debug_printk("PERF_STATUS = 0x%0lX%0lX\n",msr_h,msr_l);
+	vid_hfm = msr_h & 0xFF;
+	msr_h >>= 8;
+	fid_hfm = msr_h & 0xFF;
+	msr_h >>= 8;
+	vid_lfm = msr_h & 0xFF;
+	msr_h >>= 8;
+	fid_lfm = msr_h & 0xFF;
+	debug_printk("LFM_FID=%u, LFM_VID=%u, HFM_FID=%u, HFM_VID=%u\n", 
+		fid_lfm, vid_lfm, fid_hfm, vid_hfm);
+
+	// Make some sanity checks on the FID/VID we have decoded
+	if (fid_hfm < fid_lfm)
+	{
+		error_printk("Error: fid_hfm < fid_lfm (%u<%u)\n",fid_hfm,fid_lfm);
+		return -ENOENT;
+	}
+	if (vid_hfm < vid_lfm)
+	{
+		error_printk("Error: vid_hfm < vid_lfm (%u<%u)\n",vid_hfm,vid_lfm);
+		return -ENOENT;
+	}
+	if (fid_lfm<4)
+	{
+		// Maybe we should make an error only if FID == 0 ?.
+		error_printk("Error: fid_lfm < 4 (%u)\n",fid_lfm);
+		return -ENOENT;
+	}
+	if (vid_lfm>0x3F)
+	{
+		// We are not sure how to handle VID > 63 yet.
+		error_printk("Error: vid_lfm > 63 (%u)\n",vid_lfm);
+		return -ENOENT;
+	}
+	if (vid_hfm>0x3F)
+	{
+		// We are not sure how to handle VID > 63 yet.
+		error_printk("Error: vid_hfm > 63 (%u)\n",vid_hfm);
+		return -ENOENT;
+	}
+	if (fid_hfm > 0x20)
+	{
+		// Maybe we should allow greater FIDs ?
+		error_printk("Error: fid_hfm > 32 (%u)\n",fid_hfm);
+		return -ENOENT;
+	}
+
+	// TODO Add checks of current FID/VID
+
+	// Guess the bus clock frequency
+
+	/* TODO guess the bus clock*/
+	bus_clock = 133333;
+	bus_clock_x3 = 400000;
+	debug_printk("Bus clock estimation: %u kHz\n", bus_clock);
+
+	// Build the operating points table
+	model = kzalloc(sizeof(struct cpu_model), GFP_KERNEL);
+	if (!model) 
+	{
+		return -ENOMEM;
+	}
+
+	/* TODO set model_name*/
+	model->model_name="Unknown";
+	model->max_freq = (bus_clock_x3 * fid_hfm) / 3;
+	model->bus_clock_x3 = bus_clock_x3;
+	op_point_count = fid_hfm - fid_lfm +1;
+	model->op_points =  kmalloc(sizeof(struct cpufreq_frequency_table) *
+					     (op_point_count+1), GFP_KERNEL);
+        if (!model->op_points) 
+	{
+                kfree(model);
+		return -ENOMEM;
+        }
+
+	/* TODO set operating points in the table*/
+	for (i=0; i<op_point_count; i++)
+	{
+		unsigned fid = fid_lfm + i;
+		unsigned freq = (bus_clock_x3 * fid) / 3;
+		/* TODO round the vid to the nearest greater vid, not to the nearest lower */
+		unsigned vid = vid_lfm + ((vid_hfm - vid_lfm) * i) / (fid_hfm - fid_lfm);
+		model->op_points[i].index = (fid << 8) | vid;
+		model->op_points[i].frequency = freq;
+		debug_printk("State %u: f=%u kHz, fid=%u, vid=%u\n", i, freq, fid, vid);
+	}
+
+	model->op_points[op_point_count].frequency = CPUFREQ_TABLE_END;
+
+
+	/* TODO store table in est_model[policy->cpu] instead of freeing it*/
+        kfree(model->op_points);
+        kfree(model);
+	/*
+	est_model[policy->cpu] = model;
+
+	debug_printk("found \"%s\": max frequency: %dkHz\n",
+	       model->model_name, model->max_freq);
+	*/
+
+	/* TODO Remove this debug test*/
+	error_printk("Debug test of error_printk %u\n",(unsigned)37);
+
+	/* TODO change this to return 0 when we will have finished to implement this function*/
+	error_printk("Error: Not completely implemented yet!\n");
+	return -ENOENT;
+	//return 0;
+}
+
+
+static int est_verify_cpu_id(const struct cpuinfo_x86 *c, const struct cpu_id *x)
+{
+	if ((c->x86 == x->x86) &&
+	    (c->x86_model == x->x86_model) &&
+	    (c->x86_mask == x->x86_mask))
+		return 1;
+	return 0;
+}
+
+/* To be called only after est_model is initialized */
+static unsigned extract_clock(unsigned msr, unsigned int cpu, int failsafe)
+{
+	int i;
+
+	if ((est_model[cpu]) && (est_model[cpu]->bus_clock_x3 != 0))
+	{
+		msr = (msr >> 8) & 0xff;
+		return (msr * est_model[cpu]->bus_clock_x3) / 3;
+	}
+
+	if ((!est_model[cpu]) || (!est_model[cpu]->op_points))
+	{
+		return 0;
+	}
+
+	msr &= 0xffff;
+	for (i=0;est_model[cpu]->op_points[i].frequency != CPUFREQ_TABLE_END; i++)
+	{
+		if (msr == est_model[cpu]->op_points[i].index)
+		{
+			return est_model[cpu]->op_points[i].frequency;
+		}
+	}
+
+	if (failsafe)
+	{
+		return est_model[cpu]->op_points[i-1].frequency;
+	}
+	else
+	{
+		return 0;
+	}
+}
+
+/* Return the current CPU frequency in kHz */
+static unsigned int get_cur_freq(unsigned int cpu)
+{
+	unsigned l, h;
+	unsigned clock_freq;
+	cpumask_t saved_mask;
+
+	saved_mask = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(cpu));
+	if (smp_processor_id() != cpu)
+	{
+		return 0;
+	}
+
+	rdmsr(MSR_IA32_PERF_STATUS, l, h);
+	clock_freq = extract_clock(l, cpu, 0);
+
+	if (unlikely(clock_freq == 0)) 
+	{
+		/*
+		 * On some CPUs, we can see transient MSR values (which are
+		 * not present in _PSS), while CPU is doing some automatic
+		 * P-state transition (like TM2). Get the last freq set 
+		 * in PERF_CTL.
+		 */
+		rdmsr(MSR_IA32_PERF_CTL, l, h);
+		clock_freq = extract_clock(l, cpu, 1);
+	}
+
+	set_cpus_allowed(current, saved_mask);
+	return clock_freq;
+}
+
+
+#ifdef CONFIG_X86_PHC_EST_ACPI
+
+static struct acpi_processor_performance *acpi_perf_data[NR_CPUS];
+
+/*
+ * est_cpu_early_init_acpi - Do the preregistering with ACPI P-States
+ * library
+ *
+ * Before doing the actual init, we need to do _PSD related setup whenever
+ * supported by the BIOS. These are handled by this early_init routine.
+ */
+static int est_cpu_early_init_acpi(void)
+{
+	unsigned int	i, j;
+	struct acpi_processor_performance	*data;
+
+	for_each_possible_cpu(i) {
+		data = kzalloc(sizeof(struct acpi_processor_performance), 
+				GFP_KERNEL);
+		if (!data) {
+			for_each_possible_cpu(j) {
+				kfree(acpi_perf_data[j]);
+				acpi_perf_data[j] = NULL;
+			}
+			return (-ENOMEM);
+		}
+		acpi_perf_data[i] = data;
+	}
+
+	acpi_processor_preregister_performance(acpi_perf_data);
+	return 0;
+}
+
+/*
+ * est_cpu_init_acpi - register with ACPI P-States library
+ *
+ * Register with the ACPI P-States library (part of drivers/acpi/processor.c)
+ * in order to determine correct frequency and voltage pairings by reading
+ * the _PSS of the ACPI DSDT or SSDT tables.
+ */
+static int est_cpu_init_acpi(struct cpufreq_policy *policy)
+{
+	unsigned long			cur_freq;
+	int				result = 0, i;
+	unsigned int			cpu = policy->cpu;
+	struct acpi_processor_performance	*p;
+
+	p = acpi_perf_data[cpu];
+
+	/* register with ACPI core */
+	if (acpi_processor_register_performance(p, cpu)) {
+		error_printk("ACPI: Obtaining ACPI data failed\n");
+		return -EIO;
+	}
+	policy->shared_type = p->shared_type;
+	/*
+	 * Will let policy->cpus know about dependency only when software 
+	 * coordination is required.
+	 */
+	if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL ||
+	    policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
+		policy->cpus = p->shared_cpu_map;
+
+	/* verify the acpi_data */
+	if (p->state_count <= 1) {
+		error_printk("ACPI: No P-States\n");
+		result = -ENODEV;
+		goto err_unreg;
+	}
+
+	if ((p->control_register.space_id != ACPI_ADR_SPACE_FIXED_HARDWARE) ||
+	    (p->status_register.space_id != ACPI_ADR_SPACE_FIXED_HARDWARE)) {
+		error_printk("ACPI: Invalid control/status registers (%x - %x)\n",
+			p->control_register.space_id, p->status_register.space_id);
+		result = -EIO;
+		goto err_unreg;
+	}
+
+	for (i=0; i<p->state_count; i++) {
+		if (p->states[i].control != p->states[i].status) {
+			error_printk("ACPI: Different control (%llu) and status values (%llu)\n",
+				p->states[i].control, p->states[i].status);
+			result = -EINVAL;
+			goto err_unreg;
+		}
+
+		if (!p->states[i].core_frequency) {
+			error_printk("ACPI: Zero core frequency for state %u\n", i);
+			result = -EINVAL;
+			goto err_unreg;
+		}
+
+		if (p->states[i].core_frequency > p->states[0].core_frequency) {
+			debug_printk("ACPI: P%u has larger frequency (%llu) than P0 (%llu), skipping\n", i,
+				p->states[i].core_frequency, p->states[0].core_frequency);
+			p->states[i].core_frequency = 0;
+			continue;
+		}
+	}
+
+	est_model[cpu] = kzalloc(sizeof(struct cpu_model), GFP_KERNEL);
+	if (!est_model[cpu]) {
+		result = -ENOMEM;
+		goto err_unreg;
+	}
+
+	est_model[cpu]->model_name=NULL;
+	est_model[cpu]->max_freq = p->states[0].core_frequency * 1000;
+	est_model[cpu]->op_points =  kmalloc(sizeof(struct cpufreq_frequency_table) *
+					     (p->state_count + 1), GFP_KERNEL);
+        if (!est_model[cpu]->op_points) {
+                result = -ENOMEM;
+                goto err_kfree;
+        }
+
+        for (i=0; i<p->state_count; i++) {
+		est_model[cpu]->op_points[i].index = p->states[i].control;
+		est_model[cpu]->op_points[i].frequency = p->states[i].core_frequency * 1000;
+		debug_printk("ACPI: Adding state %i with frequency %u and control value %04x\n", 
+			i, est_model[cpu]->op_points[i].frequency, est_model[cpu]->op_points[i].index);
+	}
+	est_model[cpu]->op_points[p->state_count].frequency = CPUFREQ_TABLE_END;
+
+	cur_freq = get_cur_freq(cpu);
+	est_model[cpu]->bus_clock_x3 = 0;
+
+	for (i=0; i<p->state_count; i++) {
+		if (!p->states[i].core_frequency) {
+			debug_printk("ACPI: Skipping state %u\n", i);
+			est_model[cpu]->op_points[i].frequency = CPUFREQ_ENTRY_INVALID;
+			continue;
+		}
+		
+		if (extract_clock(est_model[cpu]->op_points[i].index, cpu, 0) !=
+		    (est_model[cpu]->op_points[i].frequency)) {
+			debug_printk("ACPI: Invalid encoded frequency (%u vs. %u)\n",
+			extract_clock(est_model[cpu]->op_points[i].index, cpu, 0),
+			est_model[cpu]->op_points[i].frequency);
+			result = -EINVAL;
+			goto err_kfree_all;
+		}
+
+		if (cur_freq == est_model[cpu]->op_points[i].frequency)
+			p->state = i;
+	}
+
+	/* notify BIOS that we exist */
+	acpi_processor_notify_smm(THIS_MODULE);
+
+	return 0;
+
+ err_kfree_all:
+	kfree(est_model[cpu]->op_points);
+ err_kfree:
+	kfree(est_model[cpu]);
+ err_unreg:
+	acpi_processor_unregister_performance(p, cpu);
+	error_printk("ACPI: invalid ACPI data\n");
+	return (result);
+}
+#else
+static inline int est_cpu_init_acpi(struct cpufreq_policy *policy) { return -ENODEV; }
+static inline int est_cpu_early_init_acpi(void) { return 0; }
+#endif
+
+static int est_target (struct cpufreq_policy *policy,
+			    unsigned int target_freq,
+			    unsigned int relation);
+
+
+/************************** sysfs interface for user defined voltage table ************************/
+
+static struct cpufreq_frequency_table **original_table = NULL;
+
+static void check_origial_table (unsigned int cpu)
+{
+	int           i;
+
+	if (!original_table) 
+	{
+		original_table = kmalloc(sizeof(struct cpufreq_frequency_table *)*NR_CPUS, GFP_KERNEL);
+		for (i=0; i < NR_CPUS; i++)
+		{
+			original_table[i] = NULL;
+		}
+	}
+
+	if (!original_table[cpu]) 
+	{
+		/* Count number of frequencies and allocate memory for a copy */
+		for (i=0; est_model[cpu]->op_points[i].frequency != CPUFREQ_TABLE_END; i++);
+		/* Allocate memory to store the copy */
+		original_table[cpu] = (struct cpufreq_frequency_table*) kmalloc(sizeof(struct cpufreq_frequency_table)*(i+1), GFP_KERNEL);
+		/* Make copy of frequency/voltage pairs */
+		for (i=0; est_model[cpu]->op_points[i].frequency != CPUFREQ_TABLE_END; i++) 
+		{
+			original_table[cpu][i].frequency = est_model[cpu]->op_points[i].frequency;
+			original_table[cpu][i].index = est_model[cpu]->op_points[i].index;
+		}
+		original_table[cpu][i].frequency = CPUFREQ_TABLE_END;
+	}
+}
+
+
+static ssize_t show_user_op_points (struct cpufreq_policy *policy, char *buf)
+{
+	/* TODO update this function according to new sysfs interface with FIDs and VIDs */
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu          = policy->cpu;
+	unsigned int  op_index     = 0;
+	unsigned int  op_count     = 0;
+	unsigned int  voltage      = 0;
+	unsigned int  frequency    = 0;
+
+	//debug_printk("showing user voltage table in sysfs\n");
+
+	while ( (est_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+	       && (bytes_written<PAGE_SIZE-16) )
+	{
+		//debug_printk("getting state %i \n", i);
+		frequency = est_model[cpu]->op_points[op_index].frequency;
+		if (frequency != CPUFREQ_ENTRY_INVALID)
+		{
+			op_count++;
+			if (op_count>1)
+				bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, ",");
+			voltage = est_model[cpu]->op_points[op_index].index;
+			voltage = 700 + ((voltage & 0xFF) << 4); 
+			//debug_printk("writing voltage %i: %u mV \n", i, voltage);
+			bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-2, "%u:%u",frequency,voltage);
+		}
+		else
+		{
+			// This operating point of the table is invalid, ignoring it.
+			debug_printk("Ignoring invalid operating point %i \n", op_index);
+		}
+		op_index++;
+	}
+	bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, "\n");	
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static ssize_t 
+store_user_op_points (struct cpufreq_policy *policy, const char *buf, size_t count) 
+{
+	/* TODO update this function according to new sysfs interface with FIDs and VIDs */
+	unsigned int  cpu;
+	const char   *curr_buf;
+	unsigned int  curr_freq;
+	unsigned int  op_index;
+	unsigned int  op_count;
+	int           isok;
+	char         *next_buf;
+	unsigned int  op_point;
+	ssize_t       retval;
+	unsigned int  voltage;
+	unsigned int  frequency;
+	int           found;
+
+	if (!policy)
+	    return -ENODEV;
+	cpu = policy->cpu;
+	if (!est_model[cpu] || !est_model[cpu]->op_points)
+	    return -ENODEV;
+
+	check_origial_table(cpu);
+
+	op_count = 0;
+	curr_buf = buf;
+	next_buf = NULL;
+	isok     = 1;
+	
+	while ( (isok) && (curr_buf != NULL) )
+	{
+		op_count++;
+		// Parse frequency
+		frequency = simple_strtoul(curr_buf, &next_buf, 10);
+		if ((next_buf != curr_buf) && (next_buf != NULL))
+		{
+			// Parse separator between frequency and voltage 
+			curr_buf = next_buf;
+			next_buf = NULL;
+			if (*curr_buf==':')
+			{
+				curr_buf++;
+				// Parse voltage
+				voltage = simple_strtoul(curr_buf, &next_buf, 10);
+				if ((next_buf != curr_buf) && (next_buf != NULL))
+				{
+					if ((voltage >= 700) && (voltage<=1600))
+					{
+						voltage = ((voltage - 700) >> 4) & 0xFF;
+						op_index = 0;
+						found = 0;
+						while (est_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+						{
+							if ((est_model[cpu]->op_points[op_index].frequency == frequency)
+							    && (est_model[cpu]->op_points[op_index].frequency != CPUFREQ_ENTRY_INVALID))
+							{
+								found = 1;
+								op_point = (original_table[cpu])[op_index].index;
+								if (voltage <= (op_point & 0xFF))
+								{
+									//debug_printk("setting control value %i to %04x\n", op_index, op_point);
+									op_point = (op_point & 0xFFFFFF00) | voltage;
+									est_model[cpu]->op_points[op_index].index = op_point;
+								}
+								else
+								{
+									op_point = (op_point & 0xFFFFFF00) | voltage;
+									debug_printk("not setting control value %i to %04x because requested voltage is not lower than the default value (%u MHz)\n", op_index, op_point, frequency);
+								}
+							}
+							op_index++;
+						}
+						if (found == 0)
+						{
+							debug_printk("operating point # %u not found: %u MHz\n", op_count, frequency);
+							isok = 0;
+						}
+					}
+					else
+					{
+						debug_printk("operating point # %u voltage value is out of bounds: %u mV\n", op_count, voltage);
+						isok = 0;
+					}
+					// Parse seprator before next operating point, if any
+					curr_buf = next_buf;
+					next_buf = NULL;
+					if (*curr_buf==',')
+						curr_buf++;
+					else
+						curr_buf = NULL;
+				}
+				else
+				{
+					debug_printk("failed to parse operating point # %u voltage\n", op_count);
+					isok = 0;
+				}
+			}
+			else
+			{
+				debug_printk("failed to parse operating point # %u\n", op_count);
+				isok = 0;
+			}
+		}
+		else
+		{
+			debug_printk("failed to parse operating point # %u frequency\n", op_count);
+			isok = 0;
+		}
+	}
+
+	if (isok)
+	{
+		retval = count;
+		curr_freq = cpufreq_get(policy->cpu);
+		est_target(policy, curr_freq, CPUFREQ_RELATION_L);
+	}
+	else
+	{
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static struct freq_attr est_freq_attr_operating_points = 
+{
+	.attr = { .name = "operating_points", .mode = 0644, .owner = THIS_MODULE },
+	.show = show_user_op_points,
+	.store = store_user_op_points,
+};
+
+unsigned long rounded_div(unsigned long x, unsigned long y)
+{
+  return (((x*2) / y)+1)/2;
+}
+
+static ssize_t show_bus_clock (struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu           = policy->cpu;
+	unsigned int  frequency;
+
+	frequency = est_model[cpu]->bus_clock_x3 / 3;
+	if (frequency!=0)
+	{
+		bytes_written += snprintf (buf, PAGE_SIZE-2, "%u kHz\n",frequency);
+	}
+
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static ssize_t 
+store_bus_clock (struct cpufreq_policy *policy, const char *buf, size_t count) 
+{
+	unsigned int  cpu;
+	const char   *curr_buf;
+	unsigned int  curr_freq;
+	unsigned int  bus_clock;
+	unsigned int  bus_clock_x3;
+	unsigned int  index;
+	char         *next_buf;
+	unsigned int  op_index			= 0;
+	ssize_t       retval;
+
+	if (!policy)
+		return -ENODEV;
+	cpu = policy->cpu;
+	if (!est_model[cpu] || !est_model[cpu]->op_points)
+		return -ENODEV;
+
+	curr_buf = buf;
+	next_buf = NULL;
+	bus_clock = simple_strtoul(curr_buf, &next_buf, 10);
+	if ((next_buf != curr_buf) && (next_buf != NULL))
+	{
+		bus_clock_x3 = bus_clock * 3;
+		if ((bus_clock % 10) == 3)
+			bus_clock_x3 += 1;
+		else if ((bus_clock % 10) == 6)
+			bus_clock_x3 += 2;
+		if (est_model[cpu]->bus_clock_x3 != bus_clock_x3)
+		{
+			check_origial_table(cpu);
+			est_model[cpu]->bus_clock_x3 = bus_clock_x3;
+			while (est_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+			{
+				if (bus_clock>0)
+				{
+					index = original_table[cpu][op_index].index;
+					index = (index >> 8) & 0xFF;
+					if (index > 0)
+					{
+						est_model[cpu]->op_points[op_index].frequency = (bus_clock_x3 * index) / 3;
+					}
+				}
+				else
+				{
+					est_model[cpu]->op_points[op_index].frequency = original_table[cpu][op_index].frequency;
+				}
+				op_index++;
+			}
+		}
+
+		retval = count;
+		curr_freq = cpufreq_get(policy->cpu);
+		est_target(policy, curr_freq, CPUFREQ_RELATION_L);
+	}
+	else
+	{
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static struct freq_attr est_freq_attr_bus_clock = 
+{
+	.attr = { .name = "bus_clock", .mode = 0644, .owner = THIS_MODULE },
+	.show = show_bus_clock,
+	.store = store_bus_clock,
+};
+
+
+static ssize_t show_phc_debug (struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu           = policy->cpu;
+	unsigned int  frequency     = 0;
+	unsigned int  op_index      = 0;
+	unsigned int  op_count      = 0;
+	unsigned int  op_value      = 0;
+	unsigned int  vid           = 0;
+	unsigned int  fid           = 0;
+
+	bytes_written += snprintf (&buf[bytes_written], 
+		PAGE_SIZE-bytes_written-2, "Active table:\n");
+	while ( (est_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+	       && (bytes_written<PAGE_SIZE-16) )
+	{
+		frequency = est_model[cpu]->op_points[op_index].frequency;
+		if (frequency != CPUFREQ_ENTRY_INVALID)
+		{
+			op_count++;
+			if (op_count>1)
+				bytes_written += snprintf (&buf[bytes_written], 
+					PAGE_SIZE-bytes_written-1, ",");
+			op_value = est_model[cpu]->op_points[op_index].index;
+			vid = op_value & 0xFF;
+			fid = (op_value >> 8) & 0xFF;
+			bytes_written += snprintf (&buf[bytes_written], 
+				PAGE_SIZE-bytes_written-2, 
+				"%u:%u:%u",frequency,fid,vid);
+		}
+		else
+		{
+			// This operating point of the table is invalid, ignoring it.
+			debug_printk("Ignoring invalid operating point %i \n", op_index);
+		}
+		op_index++;
+	}
+	bytes_written += snprintf (&buf[bytes_written], PAGE_SIZE-bytes_written-1, "\n");	
+	bytes_written += snprintf (&buf[bytes_written], PAGE_SIZE-bytes_written-1, 
+		"Table interpolated from PERF_STATUS:\n");
+	/* TODO display the original table */
+
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static struct freq_attr est_freq_attr_phc_debug = 
+{
+	.attr = { .name = "phc_debug", .mode = 0444, .owner = THIS_MODULE },
+	.show = show_phc_debug,
+	.store = 0,
+};
+
+
+
+static int est_cpu_init(struct cpufreq_policy *policy)
+{
+	struct cpuinfo_x86 *cpu = &cpu_data[policy->cpu];
+	unsigned freq;
+	unsigned l, h;
+	int ret;
+	int i;
+
+	// TODO Some VIA processors have enhanced speedstep? (CentaurHauls) 
+	if (cpu->x86_vendor != X86_VENDOR_INTEL || !cpu_has(cpu, X86_FEATURE_EST))
+		return -ENODEV;
+
+	if (cpu_has(cpu, X86_FEATURE_CONSTANT_TSC))
+		est_driver.flags |= CPUFREQ_CONST_LOOPS;
+
+	/* TODO Add code to only allow known processors */
+
+	/*
+	if (est_cpu_init_acpi(policy)) 
+	{
+		if (policy->cpu != 0)
+			return -ENODEV;
+
+		for (i = 0; i < N_IDS; i++)
+			if (est_verify_cpu_id(cpu, &cpu_ids[i]))
+				break;
+
+		if (i != N_IDS)
+			est_cpu[policy->cpu] = &cpu_ids[i];
+
+		if (!est_cpu[policy->cpu]) {
+			debug_printk("found unsupported CPU with "
+			"Enhanced SpeedStep: send /proc/cpuinfo to "
+			MAINTAINER "\n");
+			return -ENODEV;
+		}
+
+		if (0 != est_cpu_init_table(policy)) {
+			return -ENODEV;
+		}
+	}
+	*/
+
+	if (0 != est_cpu_init_table(policy)) 
+	{
+		return -ENODEV;
+	}
+
+	/* Check to see if Enhanced SpeedStep is enabled, and try to
+	   enable it if not. */
+	rdmsr(MSR_IA32_MISC_ENABLE, l, h);
+
+	if (!(l & (1<<16))) 
+	{
+		l |= (1<<16);
+		debug_printk("trying to enable Enhanced SpeedStep (%x)\n", l);
+		wrmsr(MSR_IA32_MISC_ENABLE, l, h);
+
+		/* check to see if it stuck */
+		rdmsr(MSR_IA32_MISC_ENABLE, l, h);
+		if (!(l & (1<<16))) 
+		{
+			error_printk("couldn't enable Enhanced SpeedStep\n");
+			return -ENODEV;
+		}
+	}
+
+	freq = get_cur_freq(policy->cpu);
+
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
+	policy->cpuinfo.transition_latency = 10000; /* 10uS transition latency */
+	policy->cur = freq;
+
+	debug_printk("est_cpu_init: cur=%dkHz\n", policy->cur);
+
+	ret = cpufreq_frequency_table_cpuinfo(policy, est_model[policy->cpu]->op_points);
+	if (ret)
+		return (ret);
+
+	cpufreq_frequency_table_get_attr(est_model[policy->cpu]->op_points, policy->cpu);
+
+	return 0;
+}
+
+static int est_cpu_exit(struct cpufreq_policy *policy)
+{
+	unsigned int cpu = policy->cpu;
+
+	if (!est_model[cpu])
+		return -ENODEV;
+
+	cpufreq_frequency_table_put_attr(cpu);
+
+#ifdef CONFIG_X86_PHC_EST_ACPI
+	if (!est_model[cpu]->model_name) 
+	{
+		static struct acpi_processor_performance *p;
+
+		if (acpi_perf_data[cpu]) 
+		{
+			p = acpi_perf_data[cpu];
+			debug_printk("ACPI: Unregistering and freeing ACPI data\n");
+			acpi_processor_unregister_performance(p, cpu);
+			kfree(est_model[cpu]->op_points);
+			kfree(est_model[cpu]);
+		}
+	}
+#endif
+
+	/* TODO free original table */
+
+	est_model[cpu] = NULL;
+
+	return 0;
+}
+
+/**
+ * est_verify - verifies a new CPUFreq policy
+ * @policy: new policy
+ *
+ * Limit must be within this model's frequency range at least one
+ * border included.
+ */
+static int est_verify (struct cpufreq_policy *policy)
+{
+	return cpufreq_frequency_table_verify(policy, est_model[policy->cpu]->op_points);
+}
+
+/**
+ * est_target - set a new CPUFreq policy
+ * @policy: new policy
+ * @target_freq: the target frequency
+ * @relation: how that frequency relates to achieved frequency (CPUFREQ_RELATION_L or CPUFREQ_RELATION_H)
+ *
+ * Sets a new CPUFreq policy.
+ */
+static int est_target (struct cpufreq_policy *policy,
+			    unsigned int target_freq,
+			    unsigned int relation)
+{
+	unsigned int	cpu = policy->cpu;
+	unsigned int	first_cpu;
+	unsigned int	h = 0;
+	unsigned int	j;
+	unsigned int	k;
+	unsigned int	msr;
+	unsigned int    newstate = 0;
+	unsigned int	oldmsr = 0;
+	int		retval = 0;
+	unsigned int	tmp;
+
+	cpumask_t	online_policy_cpus;
+	cpumask_t	saved_mask;
+	cpumask_t	set_mask;
+	cpumask_t	covered_cpus;
+
+	struct cpufreq_freqs	freqs;
+
+	if (unlikely(est_model[cpu] == NULL))
+	{
+		return -ENODEV;
+	}
+
+	if (unlikely(cpufreq_frequency_table_target(policy,
+			est_model[cpu]->op_points, target_freq,
+			relation, &newstate)))
+	{
+		return -EINVAL;
+	}
+
+#ifdef CONFIG_HOTPLUG_CPU
+	/* cpufreq holds the hotplug lock, so we are safe from here on */
+	cpus_and(online_policy_cpus, cpu_online_map, policy->cpus);
+#else
+	online_policy_cpus = policy->cpus;
+#endif
+
+	saved_mask = current->cpus_allowed;
+	first_cpu = 1;
+	cpus_clear(covered_cpus);
+	for_each_cpu_mask(j, online_policy_cpus) 
+	{
+		/*
+		 * Support for SMP systems.
+		 * Make sure we are running on CPU that wants to change freq
+		 */
+		cpus_clear(set_mask);
+		if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
+			cpus_or(set_mask, set_mask, online_policy_cpus);
+		else
+			cpu_set(j, set_mask);
+
+		set_cpus_allowed(current, set_mask);
+		if (unlikely(!cpu_isset(smp_processor_id(), set_mask))) 
+		{
+			debug_printk("couldn't limit to CPUs in this domain\n");
+			retval = -EAGAIN;
+			if (first_cpu) 
+			{
+				/* We haven't started the transition yet. */
+				goto migrate_end;
+			}
+			break;
+		}
+
+		msr = est_model[cpu]->op_points[newstate].index;
+
+		if (first_cpu) 
+		{
+			rdmsr(MSR_IA32_PERF_CTL, oldmsr, h);
+			if (msr == (oldmsr & 0xffff)) 
+			{
+				debug_printk("no change needed - msr was and needs "
+					"to be %x\n", oldmsr);
+				retval = 0;
+				goto migrate_end;
+			}
+
+			freqs.old = extract_clock(oldmsr, cpu, 0);
+			freqs.new = extract_clock(msr, cpu, 0);
+
+			debug_printk("target=%dkHz old=%d new=%d msr=%04x\n",
+				target_freq, freqs.old, freqs.new, msr);
+
+			for_each_cpu_mask(k, online_policy_cpus) 
+			{
+				freqs.cpu = k;
+				cpufreq_notify_transition(&freqs,
+					CPUFREQ_PRECHANGE);
+			}
+
+			first_cpu = 0;
+			/* all but 16 LSB are reserved, treat them with care */
+			oldmsr &= ~0xffff;
+			msr &= 0xffff;
+			oldmsr |= msr;
+		}
+
+		wrmsr(MSR_IA32_PERF_CTL, oldmsr, h);
+		if (policy->shared_type == CPUFREQ_SHARED_TYPE_ANY)
+			break;
+
+		cpu_set(j, covered_cpus);
+	}
+
+	for_each_cpu_mask(k, online_policy_cpus) 
+	{
+		freqs.cpu = k;
+		cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+	}
+
+	if (unlikely(retval)) 
+	{
+		/*
+		 * We have failed halfway through the frequency change.
+		 * We have sent callbacks to policy->cpus and
+		 * MSRs have already been written on covered_cpus.
+		 * Best effort undo..
+		 */
+
+		if (!cpus_empty(covered_cpus)) 
+		{
+			for_each_cpu_mask(j, covered_cpus) 
+			{
+				set_cpus_allowed(current, cpumask_of_cpu(j));
+				wrmsr(MSR_IA32_PERF_CTL, oldmsr, h);
+			}
+		}
+
+		tmp = freqs.new;
+		freqs.new = freqs.old;
+		freqs.old = tmp;
+		for_each_cpu_mask(j, online_policy_cpus) 
+		{
+			freqs.cpu = j;
+			cpufreq_notify_transition(&freqs, CPUFREQ_PRECHANGE);
+			cpufreq_notify_transition(&freqs, CPUFREQ_POSTCHANGE);
+		}
+	}
+
+migrate_end:
+	set_cpus_allowed(current, saved_mask);
+	return 0;
+}
+
+static struct freq_attr* est_attr[] = 
+{
+	&cpufreq_freq_attr_scaling_available_freqs,
+	&est_freq_attr_operating_points,
+	&est_freq_attr_bus_clock,
+	&est_freq_attr_phc_debug,
+	NULL,
+};
+
+static struct cpufreq_driver est_driver = 
+{
+	.name		= "phc-est",
+	.init		= est_cpu_init,
+	.exit		= est_cpu_exit,
+	.verify		= est_verify,
+	.target		= est_target,
+	.get		= get_cur_freq,
+	.attr           = est_attr,
+	.owner		= THIS_MODULE,
+};
+
+
+/**
+ * est_init - initializes the Enhanced SpeedStep CPUFreq driver
+ *
+ * Initializes the Enhanced SpeedStep support. Returns -ENODEV on
+ * unsupported devices, -ENOENT if there's no voltage table for this
+ * particular CPU model, -EINVAL on problems during initiatization,
+ * and zero on success.
+ *
+ * This is quite picky.  Not only does the CPU have to advertise the
+ * "est" flag in the cpuid capability flags, we look for a specific
+ * CPU model and stepping, and we need to have the exact model name in
+ * our voltage tables.  That is, be paranoid about not releasing
+ * someone's valuable magic smoke.
+ */
+static int __init est_init(void)
+{
+	struct cpuinfo_x86 *cpu = cpu_data;
+
+	if (!cpu_has(cpu, X86_FEATURE_EST))
+	{
+		error_printk("Processor does not support Enhance Speedstep\n");
+		return -ENODEV;
+	}
+
+	est_cpu_early_init_acpi();
+
+	return cpufreq_register_driver(&est_driver);
+}
+
+static void __exit est_exit(void)
+{
+#ifdef CONFIG_X86_PHC_EST_ACPI
+	unsigned int j;
+#endif
+	
+	cpufreq_unregister_driver(&est_driver);
+
+#ifdef CONFIG_X86_PHC_EST_ACPI
+	for_each_possible_cpu(j) 
+	{
+		kfree(acpi_perf_data[j]);
+		acpi_perf_data[j] = NULL;
+	}
+#endif
+}
+
+MODULE_AUTHOR ("Fabrice Bellamy <b12_1971@yahoo.fr>");
+MODULE_DESCRIPTION ("Enhanced SpeedStep driver.");
+MODULE_LICENSE ("GPL");
+
+late_initcall(est_init);
+module_exit(est_exit);
+ 
Index: linux/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
===================================================================
--- linux.orig/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
+++ linux/arch/i386/kernel/cpu/cpufreq/speedstep-centrino.c
@@ -13,6 +13,11 @@
  * Copyright (C) 2003 Jeremy Fitzhardinge <jeremy@goop.org>
  */
 
+/*
+ * This file has been patched with Linux PHC: https://www.dedigentoo.org/trac/linux-phc
+ * Patch version: linux-phc-0.3.0-pre1-kernel-vanilla-2.6.19-rc1.patch
+ */
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/init.h>
@@ -50,6 +55,7 @@ enum {
 	CPU_DOTHAN_A1,
 	CPU_DOTHAN_A2,
 	CPU_DOTHAN_B0,
+	CPU_DOTHAN_C0,
 	CPU_MP4HT_D0,
 	CPU_MP4HT_E0,
 };
@@ -59,6 +65,7 @@ static const struct cpu_id cpu_ids[] = {
 	[CPU_DOTHAN_A1]	= { 6, 13, 1 },
 	[CPU_DOTHAN_A2]	= { 6, 13, 2 },
 	[CPU_DOTHAN_B0]	= { 6, 13, 6 },
+	[CPU_DOTHAN_C0]	= { 6, 13, 8 },
 	[CPU_MP4HT_D0]	= {15,  3, 4 },
 	[CPU_MP4HT_E0]	= {15,  4, 1 },
 };
@@ -69,8 +76,8 @@ struct cpu_model
 	const struct cpu_id *cpu_id;
 	const char	*model_name;
 	unsigned	max_freq; /* max clock in kHz */
-
 	struct cpufreq_frequency_table *op_points; /* clock/voltage pairs */
+	unsigned	base_freq; /* base frequency used to convert between clock rates and MSR: FSB/4 in kHz */
 };
 static int centrino_verify_cpu_id(const struct cpuinfo_x86 *c, const struct cpu_id *x);
 
@@ -80,7 +87,9 @@ static const struct cpu_id *centrino_cpu
 
 static struct cpufreq_driver centrino_driver;
 
-#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_TABLE
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS
 
 /* Computes the correct form for IA32_PERF_CTL MSR for a particular
    frequency/voltage operating point; frequency in MHz, volts in mV.
@@ -128,7 +137,6 @@ static struct cpufreq_frequency_table ba
 	{ .frequency = CPUFREQ_TABLE_END }
 };
 
-
 /* Low Voltage Intel Pentium M processor 1.20GHz (Banias) */
 static struct cpufreq_frequency_table banias_1200[] =
 {
@@ -205,13 +213,243 @@ static struct cpufreq_frequency_table ba
 	.model_name	= "Intel(R) Pentium(R) M processor " name "MHz", \
 	.max_freq	= (max)*1000,	\
 	.op_points	= banias_##max,	\
+	.base_freq = 100000,		\
 }
 #define BANIAS(max)	_BANIAS(&cpu_ids[CPU_BANIAS], max, #max)
 
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS */
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN
+/* Dothan processor datasheet 30218903.pdf defines 4 voltages for each
+   frequency (VID#A through VID#D) - this macro allows us to define all
+   of these but we only use the VID#A voltages at compile time - this may
+   need some work if we want to select the voltage profile at runtime. */
+
+#define OP(mhz, mva, mvb, mvc, mvd)					\
+	{								\
+		.frequency = (mhz) * 1000,				\
+		.index = (((mhz)/100) << 8) | ((mva - 700) / 16)       	\
+	}
+
+/* Intel Pentium M processor 733 / 1.10GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1100[] =
+{
+ 	OP( 600, 700, 700, 700, 700),
+ 	OP( 800, 748, 748, 748, 748),
+ 	OP( 900, 764, 764, 764, 764),
+ 	OP(1000, 812, 812, 812, 812),
+ 	OP(1100, 844, 844, 844, 844),
+ 	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 710 / 1.40GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1400[] =
+{
+
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1068, 1068, 1068, 1052),
+	OP(1000, 1148, 1148, 1132, 1116),
+	OP(1200, 1228, 1212, 1212, 1180),
+	OP(1400, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 715 / 1.50GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1500[] =
+{
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1068, 1068, 1068, 1052),
+	OP(1000, 1148, 1148, 1132, 1116),
+	OP(1200, 1228, 1212, 1212, 1180),
+	OP(1500, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 725 / 1.60GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1600[] =
+{
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1068, 1068, 1052, 1052),
+	OP(1000, 1132, 1132, 1116, 1116),
+	OP(1200, 1212, 1196, 1180, 1164),
+	OP(1400, 1276, 1260, 1244, 1228),
+	OP(1600, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 735 / 1.70GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1700[] =
+{
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1052, 1052, 1052, 1052),
+	OP(1000, 1116, 1116, 1116, 1100),
+	OP(1200, 1180, 1180, 1164, 1148),
+	OP(1400, 1244, 1244, 1228, 1212),
+	OP(1700, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 745 / 1.80GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_1800[] =
+{
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1052, 1052, 1052, 1036),
+	OP(1000, 1116, 1100, 1100, 1084),
+	OP(1200, 1164, 1164, 1148, 1132),
+	OP(1400, 1228, 1212, 1212, 1180),
+	OP(1600, 1292, 1276, 1260, 1228),
+	OP(1800, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 755 / 2.00GHz (Dothan) */
+static struct cpufreq_frequency_table dothan_2000[] =
+{
+	OP( 600,  988,  988,  988,  988),
+	OP( 800, 1052, 1036, 1036, 1036),
+	OP(1000, 1100, 1084, 1084, 1084),
+	OP(1200, 1148, 1132, 1132, 1116),
+	OP(1400, 1196, 1180, 1180, 1164),
+	OP(1600, 1244, 1228, 1228, 1196),
+	OP(1800, 1292, 1276, 1276, 1244),
+	OP(2000, 1340, 1324, 1308, 1276),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+#undef OP
+
+#define DOTHAN(cpuid, max, name)	\
+{	.cpu_id		= cpuid,	\
+	.model_name	= "Intel(R) Pentium(R) M processor " name "GHz", \
+	.max_freq	= (max)*1000,	\
+	.op_points	= dothan_##max,	\
+	.base_freq = 100000,		\
+}
+
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN */
+
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA
+
+/* Intel datasheets 30526202.pdf define voltages only for highest and 
+   lowest frequency modes (HFM and LFM). 
+   For LFM the datasheet gives one typical voltage: LFMVccTyp.
+   For HFM the datasheet gives a min and a max voltage: HFMVccMin and HFMVccMax.
+   The tables below are using HFMVccMax for the highest frequency to be on
+   the safe side. The voltages of the intermediate frequencies are linearly 
+   interpolated from LFMVccTyp and HFMVccMax as it is what I have observed
+   to be used by the ACPI tables of my laptop and of some other's one.
+
+   LFMVccTyp is 988 mv for all models
+   HFMVccMin is 1260 mv for all models
+   HFMVccMax is 1356 mv for models 730, 740, 750 and 760.
+   HFMVccMax is 1372 mv for model 770.
+   HFMVccMax is 1404 mv for model 780.
+
+   As only the first voltage of each row of the tables are used I have put 
+   there the values interpolated  from HFMVccMax rounded to the next higher 16 mV step
+   For reference I have put in the other 3 columns:
+   values interpolated from HFMVccMax rounded to the nearest 1 mv
+   values interpolated from HFMVccMin rounded to the next higher 16 mv step
+   values interpolated from HFMVccMin rounded to the nearest 1 mv
+*/
+
+#define OPEX(mhz, base, mva, mvb, mvc, mvd)			\
+{								\
+	.frequency = (mhz) * 1000,				\
+	.index = (((mhz)/(base)) << 8) | ((mva - 700) / 16)	\
+}
+
+/* Intel Pentium M processor 730 / 1.60 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_1596[] =
+{
+	OPEX( 798, 133,  988,  988,  988,  988),
+	OPEX(1064, 133, 1116, 1111, 1084, 1079),
+	OPEX(1330, 133, 1244, 1233, 1180, 1169),
+	OPEX(1596, 133, 1356, 1356, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 740 / 1.73 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_1729[] =
+{
+	OPEX( 798, 133,  988,  988,  988,  988),
+	OPEX(1064, 133, 1100, 1093, 1068, 1066),
+	OPEX(1330, 133, 1212, 1198, 1148, 1143),
+	OPEX(1729, 133, 1356, 1356, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 750 / 1.86 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_1862[] =
+{
+	OPEX( 798, 133,  988,  988,  988,  988),
+	OPEX(1064, 133, 1084, 1080, 1068, 1056),
+	OPEX(1330, 133, 1180, 1172, 1132, 1124),
+	OPEX(1596, 133, 1276, 1264, 1196, 1192),
+	OPEX(1862, 133, 1356, 1356, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 760 / 2.00 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_1995[] =
+{
+	OPEX( 798, 133, 988, 988, 988, 988),
+	OPEX(1064, 133, 1084, 1070, 1052, 1048),
+	OPEX(1330, 133, 1164, 1152, 1116, 1109),
+	OPEX(1596, 133, 1244, 1233, 1180, 1169),
+	OPEX(1995, 133, 1356, 1356, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 770 / 2.13 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_2128[] =
+{
+	OPEX( 798, 133, 988, 988, 988, 988),
+	OPEX(1064, 133, 1068, 1065, 1052, 1042),
+	OPEX(1330, 133, 1148, 1142, 1100, 1097),
+	OPEX(1596, 133, 1228, 1218, 1164, 1151),
+	OPEX(1862, 133, 1308, 1295, 1212, 1206),
+	OPEX(2128, 133, 1372, 1372, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+/* Intel Pentium M processor 780 / 2.26 GHz (Sonoma) */
+static struct cpufreq_frequency_table sonoma_2261[] =
+{
+	OPEX( 798, 133, 988, 988, 988, 988),
+	OPEX(1064, 133, 1068, 1064, 1052, 1037),
+	OPEX(1330, 133, 1148, 1139, 1100, 1087),
+	OPEX(1596, 133, 1228, 1215, 1148, 1136),
+	OPEX(1862, 133, 1292, 1291, 1196, 1186),
+	OPEX(2261, 133, 1404, 1404, 1260, 1260),
+	{ .frequency = CPUFREQ_TABLE_END }
+};
+
+#undef OPEX
+
+#define SONOMA(cpuid, max, base, name)	\
+{	.cpu_id		= cpuid,	\
+	.model_name	= "Intel(R) Pentium(R) M processor " name "GHz", \
+	.max_freq	= (max)*1000,	\
+	.op_points	= sonoma_##max,	\
+	.base_freq	= (base)*1000,	\
+}
+
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA */
+
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_YONAH
+// To Do
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_YONAH */
+
+
 /* CPU models, their operating frequency range, and freq/voltage
    operating points */
 static struct cpu_model models[] =
 {
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS
+	/* Builtin tables for Banias CPUs */
 	_BANIAS(&cpu_ids[CPU_BANIAS], 900, " 900"),
 	BANIAS(1000),
 	BANIAS(1100),
@@ -221,18 +459,51 @@ static struct cpu_model models[] =
 	BANIAS(1500),
 	BANIAS(1600),
 	BANIAS(1700),
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_BANIAS */
 
-	/* NULL model_name is a wildcard */
-	{ &cpu_ids[CPU_DOTHAN_A1], NULL, 0, NULL },
-	{ &cpu_ids[CPU_DOTHAN_A2], NULL, 0, NULL },
-	{ &cpu_ids[CPU_DOTHAN_B0], NULL, 0, NULL },
-	{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL },
-	{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL },
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN
+	/* Builtin tables for Dothan B0 CPUs */
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1100, "1.10"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1400, "1.40"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1500, "1.50"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1600, "1.60"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1700, "1.70"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 1800, "1.80"),
+	DOTHAN(&cpu_ids[CPU_DOTHAN_B0], 2000, "2.00"),
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_DOTHAN */
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA
+	/* Builtin tables for Dothan C0 CPUs, a.k.a Sonoma */
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 1596, 133, "1.60"),
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 1729, 133, "1.73"),
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 1862, 133, "1.86"),
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 1995, 133, "2.00"),
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 2128, 133, "2.13"),
+	SONOMA(&cpu_ids[CPU_DOTHAN_C0], 2261, 133, "2.26"),
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_SONOMA */
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_YONAH
+	/* Builtin tables for Yonah CPUs */
+	// To Do
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN_YONAH */
+
+	/* NULL model_name is a wildcard to catch known CPU IDs for which
+	 * we don't have any builtin table */
+	{ &cpu_ids[CPU_BANIAS], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_A1], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_A2], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_B0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_DOTHAN_C0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_MP4HT_D0], NULL, 0, NULL, 0 },
+	{ &cpu_ids[CPU_MP4HT_E0], NULL, 0, NULL, 0 },
 
+	/* End of the table */
 	{ NULL, }
 };
 #undef _BANIAS
 #undef BANIAS
+#undef DOTHAN
+#undef SONOMA
 
 static int centrino_cpu_init_table(struct cpufreq_policy *policy)
 {
@@ -273,7 +544,7 @@ static int centrino_cpu_init_table(struc
 
 #else
 static inline int centrino_cpu_init_table(struct cpufreq_policy *policy) { return -ENODEV; }
-#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_TABLE */
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_BUILTIN */
 
 static int centrino_verify_cpu_id(const struct cpuinfo_x86 *c, const struct cpu_id *x)
 {
@@ -294,6 +565,13 @@ static unsigned extract_clock(unsigned m
 	 * for centrino, as some DSDTs are buggy.
 	 * Ideally, this can be done using the acpi_data structure.
 	 */
+
+	if ((centrino_model[cpu]) && (centrino_model[cpu]->base_freq != 0))
+	{
+		msr = (msr >> 8) & 0xff;
+		return msr * centrino_model[cpu]->base_freq;
+	}
+
 	if ((centrino_cpu[cpu] == &cpu_ids[CPU_BANIAS]) ||
 	    (centrino_cpu[cpu] == &cpu_ids[CPU_DOTHAN_A1]) ||
 	    (centrino_cpu[cpu] == &cpu_ids[CPU_DOTHAN_B0])) {
@@ -510,6 +788,7 @@ static int centrino_cpu_init_acpi(struct
 	centrino_model[cpu]->op_points[p->state_count].frequency = CPUFREQ_TABLE_END;
 
 	cur_freq = get_cur_freq(cpu);
+	centrino_model[cpu]->base_freq = 0;
 
 	for (i=0; i<p->state_count; i++) {
 		if (!p->states[i].core_frequency) {
@@ -521,8 +800,8 @@ static int centrino_cpu_init_acpi(struct
 		if (extract_clock(centrino_model[cpu]->op_points[i].index, cpu, 0) !=
 		    (centrino_model[cpu]->op_points[i].frequency)) {
 			dprintk("Invalid encoded frequency (%u vs. %u)\n",
-				extract_clock(centrino_model[cpu]->op_points[i].index, cpu, 0),
-				centrino_model[cpu]->op_points[i].frequency);
+			extract_clock(centrino_model[cpu]->op_points[i].index, cpu, 0),
+			centrino_model[cpu]->op_points[i].frequency);
 			result = -EINVAL;
 			goto err_kfree_all;
 		}
@@ -553,6 +832,459 @@ static inline int centrino_cpu_init_acpi
 static inline int centrino_cpu_early_init_acpi(void) { return 0; }
 #endif
 
+static int centrino_target (struct cpufreq_policy *policy,
+			    unsigned int target_freq,
+			    unsigned int relation);
+
+
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_SYSFS
+/************************** sysfs interface for user defined voltage table ************************/
+
+static struct cpufreq_frequency_table **original_table = NULL;
+
+static void check_origial_table (unsigned int cpu)
+{
+	int           i;
+
+	if (!original_table) 
+	{
+		original_table = kmalloc(sizeof(struct cpufreq_frequency_table *)*NR_CPUS, GFP_KERNEL);
+		for (i=0; i < NR_CPUS; i++)
+		{
+			original_table[i] = NULL;
+		}
+	}
+
+	if (!original_table[cpu]) 
+	{
+		/* Count number of frequencies and allocate memory for a copy */
+		for (i=0; centrino_model[cpu]->op_points[i].frequency != CPUFREQ_TABLE_END; i++);
+		/* Allocate memory to store the copy */
+		original_table[cpu] = (struct cpufreq_frequency_table*) kmalloc(sizeof(struct cpufreq_frequency_table)*(i+1), GFP_KERNEL);
+		/* Make copy of frequency/voltage pairs */
+		for (i=0; centrino_model[cpu]->op_points[i].frequency != CPUFREQ_TABLE_END; i++) 
+		{
+			original_table[cpu][i].frequency = centrino_model[cpu]->op_points[i].frequency;
+			original_table[cpu][i].index = centrino_model[cpu]->op_points[i].index;
+		}
+		original_table[cpu][i].frequency = CPUFREQ_TABLE_END;
+	}
+}
+
+
+static ssize_t show_user_voltage (struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu          = policy->cpu;
+	unsigned int  op_index     = 0;
+	unsigned int  op_count     = 0;
+	unsigned int  voltage      = 0;
+	unsigned int  frequency    = 0;
+
+	//dprintk("showing user voltage table in sysfs\n");
+
+	while ( (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+	       && (bytes_written<PAGE_SIZE-16) )
+	{
+		//dprintk("getting state %i \n", op_index);
+		frequency = centrino_model[cpu]->op_points[op_index].frequency;
+		if (frequency != CPUFREQ_ENTRY_INVALID)
+		{
+			op_count++;
+			if (op_count>1)
+				bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, ",");
+			voltage = centrino_model[cpu]->op_points[op_index].index;
+			voltage = 700 + ((voltage & 0xFF) << 4); 
+			//dprintk("writing voltage %i: %u mV \n", op_index, voltage);
+			bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, "%u",voltage);
+		}
+		else
+		{
+			// This operating point of the table is invalid, ignoring it.
+			dprintk("Ignoring invalid operating point %i \n", op_index);
+		}
+		op_index++;
+	}
+	bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, "\n");	
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static ssize_t 
+store_user_voltage (struct cpufreq_policy *policy, const char *buf, size_t count) 
+{
+	unsigned int  cpu;
+	const char   *curr_buf;
+	unsigned int  curr_freq;
+	unsigned int  op_index;
+	int           isok;
+	char         *next_buf;
+	unsigned int  op_point;
+	ssize_t       retval;
+	unsigned int  voltage;
+
+	if (!policy)
+	    return -ENODEV;
+	cpu = policy->cpu;
+	if (!centrino_model[cpu] || !centrino_model[cpu]->op_points)
+	    return -ENODEV;
+
+	check_origial_table(cpu);
+
+	op_index = 0;
+	curr_buf = buf;
+	next_buf = NULL;
+	isok     = 1;
+	
+	while ((centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END) 
+		&& (isok))
+	{
+		if (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_ENTRY_INVALID)
+		{
+			voltage = simple_strtoul(curr_buf, &next_buf, 10);
+			if ((next_buf != curr_buf) && (next_buf != NULL))
+			{
+				if ((voltage >= 700) && (voltage<=1600))
+				{
+					voltage = ((voltage - 700) >> 4) & 0xFF;
+					op_point = (original_table[cpu])[op_index].index;
+					if (voltage <= (op_point & 0xFF))
+					{
+						//dprintk("setting control value %i to %04x\n", op_index, op_point);
+						op_point = (op_point & 0xFFFFFF00) | voltage;
+						centrino_model[cpu]->op_points[op_index].index = op_point;
+					}
+					else
+					{
+						op_point = (op_point & 0xFFFFFF00) | voltage;
+						dprintk("not setting control value %i to %04x because requested voltage is not lower than the default value\n", op_index, op_point);
+						//isok = 0;
+					}
+				}
+				else
+				{
+					dprintk("voltage value %i is out of bounds: %u mV\n", op_index, voltage);
+					isok = 0;
+				}
+				curr_buf = next_buf;
+				if (*curr_buf==',')
+					curr_buf++;
+				next_buf = NULL;
+			}
+			else
+			{
+				dprintk("failed to parse voltage value %i\n", op_index);
+				isok = 0;
+			}
+		}
+		else
+		{
+			// This operating point of the table is invalid, ignoring it.
+			dprintk("Ignoring invalid operating point %i \n", op_index);
+		}
+		op_index++;
+	}
+
+	if (isok)
+	{
+		retval = count;
+		curr_freq = cpufreq_get(policy->cpu);
+		centrino_target(policy, curr_freq, CPUFREQ_RELATION_L);
+	}
+	else
+	{
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static struct freq_attr centrino_freq_attr_voltage_table = 
+{
+	.attr = { .name = "voltage_table", .mode = 0644, .owner = THIS_MODULE },
+	.show = show_user_voltage,
+	.store = store_user_voltage,
+};
+
+
+static ssize_t show_user_op_points (struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu          = policy->cpu;
+	unsigned int  op_index     = 0;
+	unsigned int  op_count     = 0;
+	unsigned int  voltage      = 0;
+	unsigned int  frequency    = 0;
+
+	//dprintk("showing user voltage table in sysfs\n");
+
+	while ( (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+	       && (bytes_written<PAGE_SIZE-16) )
+	{
+		//dprintk("getting state %i \n", i);
+		frequency = centrino_model[cpu]->op_points[op_index].frequency;
+		if (frequency != CPUFREQ_ENTRY_INVALID)
+		{
+			op_count++;
+			if (op_count>1)
+				bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, ",");
+			voltage = centrino_model[cpu]->op_points[op_index].index;
+			voltage = 700 + ((voltage & 0xFF) << 4); 
+			//dprintk("writing voltage %i: %u mV \n", i, voltage);
+			bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-2, "%u:%u",frequency,voltage);
+		}
+		else
+		{
+			// This operating point of the table is invalid, ignoring it.
+			dprintk("Ignoring invalid operating point %i \n", op_index);
+		}
+		op_index++;
+	}
+	bytes_written += snprintf (&buf[bytes_written],PAGE_SIZE-bytes_written-1, "\n");	
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static ssize_t 
+store_user_op_points (struct cpufreq_policy *policy, const char *buf, size_t count) 
+{
+	unsigned int  cpu;
+	const char   *curr_buf;
+	unsigned int  curr_freq;
+	unsigned int  op_index;
+	unsigned int  op_count;
+	int           isok;
+	char         *next_buf;
+	unsigned int  op_point;
+	ssize_t       retval;
+	unsigned int  voltage;
+	unsigned int  frequency;
+	int           found;
+
+	if (!policy)
+	    return -ENODEV;
+	cpu = policy->cpu;
+	if (!centrino_model[cpu] || !centrino_model[cpu]->op_points)
+	    return -ENODEV;
+
+	check_origial_table(cpu);
+
+	op_count = 0;
+	curr_buf = buf;
+	next_buf = NULL;
+	isok     = 1;
+	
+	while ( (isok) && (curr_buf != NULL) )
+	{
+		op_count++;
+		// Parse frequency
+		frequency = simple_strtoul(curr_buf, &next_buf, 10);
+		if ((next_buf != curr_buf) && (next_buf != NULL))
+		{
+			// Parse separator between frequency and voltage 
+			curr_buf = next_buf;
+			next_buf = NULL;
+			if (*curr_buf==':')
+			{
+				curr_buf++;
+				// Parse voltage
+				voltage = simple_strtoul(curr_buf, &next_buf, 10);
+				if ((next_buf != curr_buf) && (next_buf != NULL))
+				{
+					if ((voltage >= 700) && (voltage<=1600))
+					{
+						voltage = ((voltage - 700) >> 4) & 0xFF;
+						op_index = 0;
+						found = 0;
+						while (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+						{
+							if ((centrino_model[cpu]->op_points[op_index].frequency == frequency)
+							    && (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_ENTRY_INVALID))
+							{
+								found = 1;
+								op_point = (original_table[cpu])[op_index].index;
+								if (voltage <= (op_point & 0xFF))
+								{
+									//dprintk("setting control value %i to %04x\n", op_index, op_point);
+									op_point = (op_point & 0xFFFFFF00) | voltage;
+									centrino_model[cpu]->op_points[op_index].index = op_point;
+								}
+								else
+								{
+									op_point = (op_point & 0xFFFFFF00) | voltage;
+									dprintk("not setting control value %i to %04x because requested voltage is not lower than the default value (%u MHz)\n", op_index, op_point, frequency);
+								}
+							}
+							op_index++;
+						}
+						if (found == 0)
+						{
+							dprintk("operating point # %u not found: %u MHz\n", op_count, frequency);
+							isok = 0;
+						}
+					}
+					else
+					{
+						dprintk("operating point # %u voltage value is out of bounds: %u mV\n", op_count, voltage);
+						isok = 0;
+					}
+					// Parse seprator before next operating point, if any
+					curr_buf = next_buf;
+					next_buf = NULL;
+					if (*curr_buf==',')
+						curr_buf++;
+					else
+						curr_buf = NULL;
+				}
+				else
+				{
+					dprintk("failed to parse operating point # %u voltage\n", op_count);
+					isok = 0;
+				}
+			}
+			else
+			{
+				dprintk("failed to parse operating point # %u\n", op_count);
+				isok = 0;
+			}
+		}
+		else
+		{
+			dprintk("failed to parse operating point # %u frequency\n", op_count);
+			isok = 0;
+		}
+	}
+
+	if (isok)
+	{
+		retval = count;
+		curr_freq = cpufreq_get(policy->cpu);
+		centrino_target(policy, curr_freq, CPUFREQ_RELATION_L);
+	}
+	else
+	{
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static struct freq_attr centrino_freq_attr_op_points_table = 
+{
+	.attr = { .name = "op_points_table", .mode = 0644, .owner = THIS_MODULE },
+	.show = show_user_op_points,
+	.store = store_user_op_points,
+};
+
+unsigned long rounded_div(unsigned long x, unsigned long y)
+{
+  return (((x*2) / y)+1)/2;
+}
+
+static ssize_t show_FSB_base_freq (struct cpufreq_policy *policy, char *buf)
+{
+	ssize_t       bytes_written = 0;
+	unsigned int  cpu           = policy->cpu;
+	unsigned int  frequency;
+	unsigned int  index;
+	unsigned int  op_index			= 0;
+
+	frequency = centrino_model[cpu]->base_freq;
+	if (frequency!=0)
+	{
+		bytes_written += snprintf (buf, PAGE_SIZE-2, "User defined base FSB frequency:\n%u kHz\n",frequency);
+	}
+
+	bytes_written += snprintf (buf+bytes_written, PAGE_SIZE-bytes_written-2, 
+	                           "Base FSB frequency computed from operating points table:\n");
+
+	check_origial_table(cpu);
+	while ((original_table[cpu][op_index].frequency != CPUFREQ_TABLE_END)
+	       && (bytes_written < PAGE_SIZE-3))
+	{
+		index = original_table[cpu][op_index].index;
+		index = (index >> 8) & 0xFF;
+		if (index > 0)
+		{
+			frequency = rounded_div((original_table[cpu][op_index].frequency), index);
+			bytes_written += snprintf (buf+bytes_written, PAGE_SIZE-bytes_written-2, "%u kHz (%u / %u)\n",
+			                           frequency, original_table[cpu][op_index].frequency, index);
+		}
+		op_index++;
+	}
+
+	buf[PAGE_SIZE-1] = 0;
+	return bytes_written;
+}
+
+static ssize_t 
+store_FSB_base_freq (struct cpufreq_policy *policy, const char *buf, size_t count) 
+{
+	unsigned int  cpu;
+	const char   *curr_buf;
+	unsigned int  curr_freq;
+	unsigned int  frequency;
+	unsigned int  index;
+	char         *next_buf;
+	unsigned int  op_index			= 0;
+	ssize_t       retval;
+
+	if (!policy)
+		return -ENODEV;
+	cpu = policy->cpu;
+	if (!centrino_model[cpu] || !centrino_model[cpu]->op_points)
+		return -ENODEV;
+
+	curr_buf = buf;
+	next_buf = NULL;
+	frequency = simple_strtoul(curr_buf, &next_buf, 10);
+	if ((next_buf != curr_buf) && (next_buf != NULL))
+	{
+		if (centrino_model[cpu]->base_freq != frequency)
+		{
+			centrino_model[cpu]->base_freq = frequency;
+
+			check_origial_table(cpu);
+			while (centrino_model[cpu]->op_points[op_index].frequency != CPUFREQ_TABLE_END)
+			{
+				if (frequency>0)
+				{
+					index = original_table[cpu][op_index].index;
+					index = (index >> 8) & 0xFF;
+					if (index > 0)
+					{
+						centrino_model[cpu]->op_points[op_index].frequency = frequency * index;
+					}
+				}
+				else
+				{
+					centrino_model[cpu]->op_points[op_index].frequency = original_table[cpu][op_index].frequency;
+				}
+				op_index++;
+			}
+		}
+
+		retval = count;
+		curr_freq = cpufreq_get(policy->cpu);
+		centrino_target(policy, curr_freq, CPUFREQ_RELATION_L);
+	}
+	else
+	{
+		retval = -EINVAL;
+	}
+
+	return retval;
+}
+
+static struct freq_attr centrino_freq_attr_FSB_Base_Freq = 
+{
+	.attr = { .name = "FSB_base_frequency", .mode = 0644, .owner = THIS_MODULE },
+	.show = show_FSB_base_freq,
+	.store = store_FSB_base_freq,
+};
+
+#endif /* CONFIG_X86_SPEEDSTEP_CENTRINO_SYSFS */
+
 static int centrino_cpu_init(struct cpufreq_policy *policy)
 {
 	struct cpuinfo_x86 *cpu = &cpu_data[policy->cpu];
@@ -804,6 +1536,11 @@ migrate_end:
 
 static struct freq_attr* centrino_attr[] = {
 	&cpufreq_freq_attr_scaling_available_freqs,
+#ifdef CONFIG_X86_SPEEDSTEP_CENTRINO_SYSFS
+	&centrino_freq_attr_voltage_table,
+	&centrino_freq_attr_op_points_table,
+	&centrino_freq_attr_FSB_Base_Freq,
+#endif
 	NULL,
 };
 
@@ -868,3 +1605,4 @@ MODULE_LICENSE ("GPL");
 
 late_initcall(centrino_init);
 module_exit(centrino_exit);
+ 
