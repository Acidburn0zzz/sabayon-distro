Fix AppleSMC registers on non-pro Macbooks.

From: Martin Szulecki <mactel@sukimashita.com>


---

 drivers/hwmon/applesmc.c |   14 +++++++++-----
 1 files changed, 9 insertions(+), 5 deletions(-)

diff --git a/drivers/hwmon/applesmc.c b/drivers/hwmon/applesmc.c
index eb81a64..232cbad 100644
--- a/drivers/hwmon/applesmc.c
+++ b/drivers/hwmon/applesmc.c
@@ -79,11 +79,15 @@
 
 /*
  * Temperature sensors keys (sp78 - 2 bytes).
- * First set for Macbook(Pro), second for Macmini.
  */
 static const char* temperature_sensors_sets[][13] = {
+/* Set 0: Macbook Pro */
 	{ "TA0P", "TB0T", "TC0D", "TC0P", "TG0H", "TG0P", "TG0T", "Th0H",
 	  "Th1H", "Tm0P", "Ts0P", "Ts1P", NULL },
+/* Set 1: Macbook set */
+	{ "TB0T", "TC0D", "TC0P", "TM0P", "TN0P", "TN1P", "Th0H", "Th0S",
+	  "Th1H", "Ts0P", NULL },
+/* Set 2: Macmini set */
 	{ "TC0D", "TC0P", NULL }
 };
 
@@ -1129,10 +1133,10 @@ static void applesmc_release_accelerometer(void)
 static __initdata struct dmi_match_data applesmc_dmi_data[] = {
 /* MacBook Pro: accelerometer, backlight and temperature set 0 */
 	{ .accelerometer = 1, .light = 1, .temperature_set = 0 },
-/* MacBook: accelerometer and temperature set 0 */
-	{ .accelerometer = 1, .light = 0, .temperature_set = 0 },
-/* MacBook: temperature set 1 */
-	{ .accelerometer = 0, .light = 0, .temperature_set = 1 }
+/* MacBook: accelerometer and temperature set 1 */
+	{ .accelerometer = 1, .light = 0, .temperature_set = 1 },
+/* MacMini: temperature set 2 */
+	{ .accelerometer = 0, .light = 0, .temperature_set = 2 }
 };
 
 /* Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
Interrupt support for the accelerometer.

From: Nicolas Boichat <nicolas@boichat.ch>


---

 drivers/hwmon/applesmc.c |  321 +++++++++++++++++++++++++++++++++++++++++++---
 1 files changed, 298 insertions(+), 23 deletions(-)

diff --git a/drivers/hwmon/applesmc.c b/drivers/hwmon/applesmc.c
index 232cbad..933a72d 100644
--- a/drivers/hwmon/applesmc.c
+++ b/drivers/hwmon/applesmc.c
@@ -39,14 +39,20 @@
 #include <linux/leds.h>
 #include <linux/hwmon.h>
 #include <linux/workqueue.h>
+#include <linux/interrupt.h>
 
 /* data port used by Apple SMC */
 #define APPLESMC_DATA_PORT	0x300
 /* command/status port used by Apple SMC */
 #define APPLESMC_CMD_PORT	0x304
+/* status port used by Apple SMC to get which interrupt type just happened */
+#define APPLESMC_INT_PORT	0x31f
 
 #define APPLESMC_NR_PORTS	32 /* 0x300-0x31f */
 
+/* Defined in ACPI DSDT table, should we read it from there? */
+#define APPLESMC_IRQ		6
+
 #define APPLESMC_MAX_DATA_LENGTH 32
 
 #define APPLESMC_STATUS_MASK	0x0f
@@ -57,6 +63,8 @@
 
 #define KEY_COUNT_KEY		"#KEY" /* r-o ui32 */
 
+#define INTERRUPT_OK_KEY	"NTOK" /* w-o ui8 */
+
 #define LIGHT_SENSOR_LEFT_KEY	"ALV0" /* r-o {alv (6 bytes) */
 #define LIGHT_SENSOR_RIGHT_KEY	"ALV1" /* r-o {alv (6 bytes) */
 #define BACKLIGHT_KEY		"LKSB" /* w-o {lkb (2 bytes) */
@@ -68,6 +76,19 @@
 #define MOTION_SENSOR_Z_KEY	"MO_Z" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_KEY	"MOCN" /* r/w ui16 */
 
+/*
+ * Interrupt controls.
+ * If the norm of the position (sqrt(MO_X^2+MO_Y^2+MO_Z^2)) is smaller than
+ * MOLT (free fall), or bigger than MOHT (high acceleration) for longer than the
+ * value of MOLD (or MOHD), SMC will trigger an interrupt.
+ */
+#define MOTION_LOW_NORM			"MOLT" /* r/w sp78 (2 bytes) */
+#define MOTION_HIGH_NORM		"MOHT" /* r/w sp78 (2 bytes) */
+#define MOTION_LOW_NORM_INTERVAL	"MOLD" /* r/w ui8 */
+#define MOTION_HIGH_NORM_INTERVAL	"MOHD" /* r/w ui8 */
+
+#define MSDW_KEY		"MSDW" /* r/w flag (1 byte) */
+
 #define FANS_COUNT		"FNum" /* r-o ui8 */
 #define FANS_MANUAL		"FS! " /* r-w ui16 */
 #define FAN_ACTUAL_SPEED	"F0Ac" /* r-o fpe2 (2 bytes) */
@@ -351,12 +372,83 @@ static int applesmc_read_motion_sensor(int index, s16* value)
 }
 
 /*
+ * applesmc_init_check_key_value - checks if a given key contains the bytes in
+ * buffer, if not, writes these bytes.
+ * In case of failure retry every INIT_WAIT_MSECS msec, and timeout if it
+ * waited more than INIT_TIMEOUT_MSECS in total.
+ * Returns zero on success or a negative error on failure. Callers must
+ * hold applesmc_lock.
+ */
+static int applesmc_init_check_key_value(const char *key, u8 *buffer, u8 len)
+{
+	int total, ret, i, compare;
+	u8 rdbuffer[APPLESMC_MAX_DATA_LENGTH];
+
+	if (len > APPLESMC_MAX_DATA_LENGTH) {
+		printk(KERN_ERR "applesmc_init_check_key_value: cannot "
+					"read/write more than %d bytes",
+					APPLESMC_MAX_DATA_LENGTH);
+		return -EINVAL;
+	}
+
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		ret = applesmc_read_key(key, rdbuffer, len);
+		if (!ret) {
+			compare = 1;
+			for (i = 0; i < len; i++) {
+				if (rdbuffer[i] != buffer[i]) {
+					compare = 0;
+					break;
+				}
+			}
+
+			if (compare) {
+				return 0;
+			}
+		}
+		ret = applesmc_write_key(key, buffer, len);
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	if (ret)
+		return ret;
+	else
+		return -EIO;
+}
+
+irqreturn_t applesmc_irq_handler(int irq, void *dev_id)
+{
+	u8 int_type = inb(APPLESMC_INT_PORT);
+
+	switch (int_type) {
+	case 0x60:
+		printk(KERN_INFO "applesmc: received a free fall interrupt\n");
+		break;
+	case 0x6f:
+		printk(KERN_INFO
+			"applesmc: received a high acceleration interrupt\n");
+		break;
+	case 0x80:
+		printk(KERN_INFO "applesmc: received a shock interrupt\n");
+		break;
+	default:
+		printk(KERN_INFO
+			"applesmc: received an unknown interrupt %x\n",
+			int_type);
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
  * applesmc_device_init - initialize the accelerometer.  Returns zero on success
  * and negative error code on failure.  Can sleep.
  */
 static int applesmc_device_init(void)
 {
-	int total, ret = -ENXIO;
+	int total;
+	int ret = -ENXIO;
+	int ret1, ret2;
 	u8 buffer[2];
 
 	if (!applesmc_accelerometer)
@@ -364,32 +456,79 @@ static int applesmc_device_init(void)
 
 	mutex_lock(&applesmc_lock);
 
+	/* Accept interrupts */
+	buffer[0] = 0x01;
 	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
-		if (debug)
-			printk(KERN_DEBUG "applesmc try %d\n", total);
-		if (!applesmc_read_key(MOTION_SENSOR_KEY, buffer, 2) &&
-				(buffer[0] != 0x00 || buffer[1] != 0x00)) {
-			if (total == INIT_TIMEOUT_MSECS) {
-				printk(KERN_DEBUG "applesmc: device has"
-						" already been initialized"
-						" (0x%02x, 0x%02x).\n",
-						buffer[0], buffer[1]);
-			} else {
-				printk(KERN_DEBUG "applesmc: device"
-						" successfully initialized"
-						" (0x%02x, 0x%02x).\n",
-						buffer[0], buffer[1]);
-			}
-			ret = 0;
-			goto out;
-		}
-		buffer[0] = 0xe0;
-		buffer[1] = 0x00;
-		applesmc_write_key(MOTION_SENSOR_KEY, buffer, 2);
+		ret1 = applesmc_write_key(INTERRUPT_OK_KEY, buffer, 1);
 		msleep(INIT_WAIT_MSECS);
+
+		if (!ret1)
+			break;
+	}
+	if (ret1)
+		printk(KERN_WARNING "applesmc: Cannot set NTOK key, "
+					"will not receive interrupts.\n");
+
+	/* Setup interrupt controls. */
+	buffer[0] = 20; /* 20 msecs */
+	ret1 = applesmc_init_check_key_value(MOTION_LOW_NORM_INTERVAL,
+								buffer, 1);
+
+	buffer[0] = 20; /* 20 msecs */
+	ret2 = applesmc_init_check_key_value(MOTION_HIGH_NORM_INTERVAL,
+								buffer, 1);
+
+	if (ret1 || ret2) {
+		printk(KERN_WARNING "applesmc: Cannot set motion sensor "
+					"interrupt interval, might not receive "
+					"some interrupts.");
 	}
 
-	printk(KERN_WARNING "applesmc: failed to init the device\n");
+	buffer[0] = 0x00;
+	buffer[1] = 0x60;
+	ret1 = applesmc_init_check_key_value(MOTION_LOW_NORM, buffer, 2);
+
+	buffer[0] = 0x01;
+	buffer[1] = 0xc0;
+	ret2 = applesmc_init_check_key_value(MOTION_HIGH_NORM, buffer, 2);
+
+	if (ret1 || ret2) {
+		printk(KERN_WARNING "applesmc: Cannot set motion sensor "
+				"min/max norm parameters, "
+				"might not receive some interrupts.");
+	}
+
+	/* Mysterious key. */
+	buffer[0] = 0x01;
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		ret1 = applesmc_write_key(MSDW_KEY, buffer, 1);
+		msleep(INIT_WAIT_MSECS);
+
+		if (!ret1)
+			break;
+	}
+	if (ret1)
+		printk(KERN_WARNING "applesmc: Cannot set MSDW key\n");
+
+	/* Initialize the device. */
+	buffer[0] = 0xe0;
+	buffer[1] = 0xf8;
+	if (applesmc_init_check_key_value(MOTION_SENSOR_KEY, buffer, 2)) {
+		printk(KERN_WARNING "applesmc: failed to init "
+							"the accelerometer\n");
+		goto out;
+	}
+
+	ret1 = request_irq(APPLESMC_IRQ, applesmc_irq_handler, IRQF_DISABLED,
+						"applesmc_irq_handler", NULL);
+
+	if (ret1) {
+		printk(KERN_WARNING "applesmc: cannot setup irq handler\n");
+	}
+
+	printk(KERN_DEBUG "applesmc: accelerometer "
+						"successfully initialized.\n");
+	ret = 0;
 
 out:
 	mutex_unlock(&applesmc_lock);
@@ -434,9 +573,16 @@ static int applesmc_resume(struct platform_device *dev)
 	return applesmc_device_init();
 }
 
+static int applesmc_remove(struct platform_device *dev)
+{
+	free_irq(6, NULL);
+	return 0;
+}
+
 static struct platform_driver applesmc_driver = {
 	.probe = applesmc_probe,
 	.resume = applesmc_resume,
+	.remove = applesmc_remove,
 	.driver	= {
 		.name = "applesmc",
 		.owner = THIS_MODULE,
@@ -898,6 +1044,123 @@ static ssize_t applesmc_key_at_index_store(struct device *dev,
 	return count;
 }
 
+static ssize_t applesmc_accelerometer_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	int ret;
+	unsigned int value = 0;
+	u8 buffer[2];
+	char *key;
+	int length;
+	struct sensor_device_attribute_2 *sensor_attr =
+						to_sensor_dev_attr_2(attr);
+
+	switch (sensor_attr->index) {
+	case 0:
+		key = MOTION_LOW_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 1:
+		key = MOTION_HIGH_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 2:
+		key = MOTION_LOW_NORM;
+		length = 2;
+		break;
+	case 3:
+		key = MOTION_HIGH_NORM;
+		length = 2;
+		break;
+	default:
+		printk(KERN_ERR
+			"Invalid index for applesmc_accelerometer_show");
+		return -EINVAL;
+	}
+
+	mutex_lock(&applesmc_lock);
+
+	ret = applesmc_read_key(key, buffer, length);
+	if (length == 2)
+		value = ((unsigned int)buffer[0] << 8) | buffer[1];
+	else if (length == 1)
+		value = buffer[0];
+	else {
+		printk("Invalid length for applesmc_param_show");
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&applesmc_lock);
+	if (ret)
+		return ret;
+	else
+		return snprintf(sysfsbuf, PAGE_SIZE, "%u\n", value);
+}
+
+static ssize_t applesmc_accelerometer_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *sysfsbuf, size_t count)
+{
+	int ret;
+	u32 value;
+	u8 buffer[2];
+	char *key;
+	int length;
+	struct sensor_device_attribute_2 *sensor_attr =
+						to_sensor_dev_attr_2(attr);
+
+	switch (sensor_attr->index) {
+	case 0:
+		key = MOTION_LOW_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 1:
+		key = MOTION_HIGH_NORM_INTERVAL;
+		length = 1;
+		break;
+	case 2:
+		key = MOTION_LOW_NORM;
+		length = 2;
+		break;
+	case 3:
+		key = MOTION_HIGH_NORM;
+		length = 2;
+		break;
+	default:
+		printk("Invalid index for applesmc_accelerometer_show");
+		return -EINVAL;
+	}
+
+	value = simple_strtoul(sysfsbuf, NULL, 10);
+
+	if (length == 2) {
+		if (value > 0xffff)
+			return -EINVAL;
+
+		buffer[0] = (value >> 8) & 0xff;
+		buffer[1] = value & 0xff;
+	} else if (length == 1) {
+		if (value > 0xff)
+			return -EINVAL;
+
+		buffer[0] = value & 0xff;
+	} else {
+		printk("Invalid length for applesmc_param_store");
+		return -EINVAL;
+	}
+
+	mutex_lock(&applesmc_lock);
+
+	ret = applesmc_write_key(key, buffer, length);
+
+	mutex_unlock(&applesmc_lock);
+
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
 static struct led_classdev applesmc_backlight = {
 	.name			= "smc:kbd_backlight",
 	.default_trigger	= "nand-disk",
@@ -909,10 +1172,22 @@ static DEVICE_ATTR(name, 0444, applesmc_name_show, NULL);
 static DEVICE_ATTR(position, 0444, applesmc_position_show, NULL);
 static DEVICE_ATTR(calibrate, 0644,
 			applesmc_calibrate_show, applesmc_calibrate_store);
+static SENSOR_DEVICE_ATTR(low_norm_trigger_interval, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 0);
+static SENSOR_DEVICE_ATTR(high_norm_trigger_interval, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 1);
+static SENSOR_DEVICE_ATTR(low_norm_trigger, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 2);
+static SENSOR_DEVICE_ATTR(high_norm_trigger, 0644,
+		applesmc_accelerometer_show, applesmc_accelerometer_store, 3);
 
 static struct attribute *accelerometer_attributes[] = {
 	&dev_attr_position.attr,
 	&dev_attr_calibrate.attr,
+	&sensor_dev_attr_low_norm_trigger.dev_attr.attr,
+	&sensor_dev_attr_high_norm_trigger.dev_attr.attr,
+	&sensor_dev_attr_low_norm_trigger_interval.dev_attr.attr,
+	&sensor_dev_attr_high_norm_trigger_interval.dev_attr.attr,
 	NULL
 };
 
HWMON: applesmc - convert to use input-polldev.

From: Nicolas Boichat <nicolas@boichat.ch>

Switch to using input-polldev skeleton instead of implementing
polling loop by itself. This also fixes problem with trylock
on a mutex in atomic context.

Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
---

 drivers/hwmon/Kconfig    |    1 +
 drivers/hwmon/applesmc.c |   83 +++++++++++++++++-----------------------------
 2 files changed, 31 insertions(+), 53 deletions(-)

diff --git a/drivers/hwmon/Kconfig b/drivers/hwmon/Kconfig
index 13eea47..f0ab2ac 100644
--- a/drivers/hwmon/Kconfig
+++ b/drivers/hwmon/Kconfig
@@ -623,6 +623,7 @@ config SENSORS_APPLESMC
 	depends on INPUT && X86
 	select NEW_LEDS
 	select LEDS_CLASS
+	select INPUT_POLLDEV
 	default n
 	help
 	  This driver provides support for the Apple System Management
diff --git a/drivers/hwmon/applesmc.c b/drivers/hwmon/applesmc.c
index fd1281f..eb81a64 100644
--- a/drivers/hwmon/applesmc.c
+++ b/drivers/hwmon/applesmc.c
@@ -28,7 +28,7 @@
 
 #include <linux/delay.h>
 #include <linux/platform_device.h>
-#include <linux/input.h>
+#include <linux/input-polldev.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/timer.h>
@@ -59,9 +59,9 @@
 
 #define LIGHT_SENSOR_LEFT_KEY	"ALV0" /* r-o {alv (6 bytes) */
 #define LIGHT_SENSOR_RIGHT_KEY	"ALV1" /* r-o {alv (6 bytes) */
-#define BACKLIGHT_KEY 		"LKSB" /* w-o {lkb (2 bytes) */
+#define BACKLIGHT_KEY		"LKSB" /* w-o {lkb (2 bytes) */
 
-#define CLAMSHELL_KEY 		"MSLD" /* r-o ui8 (unused) */
+#define CLAMSHELL_KEY		"MSLD" /* r-o ui8 (unused) */
 
 #define MOTION_SENSOR_X_KEY	"MO_X" /* r-o sp78 (2 bytes) */
 #define MOTION_SENSOR_Y_KEY	"MO_Y" /* r-o sp78 (2 bytes) */
@@ -99,7 +99,7 @@ static const char* fan_speed_keys[] = {
 #define INIT_TIMEOUT_MSECS	5000	/* wait up to 5s for device init ... */
 #define INIT_WAIT_MSECS		50	/* ... in 50ms increments */
 
-#define APPLESMC_POLL_PERIOD	(HZ/20)	/* poll for input every 1/20s */
+#define APPLESMC_POLL_INTERVAL	50	/* msecs */
 #define APPLESMC_INPUT_FUZZ	4	/* input event threshold */
 #define APPLESMC_INPUT_FLAT	4
 
@@ -121,8 +121,7 @@ static const int debug;
 static struct platform_device *pdev;
 static s16 rest_x;
 static s16 rest_y;
-static struct timer_list applesmc_timer;
-static struct input_dev *applesmc_idev;
+static struct input_polled_dev *applesmc_idev;
 static struct class_device *hwmon_class_dev;
 
 /* Indicates whether this computer has an accelerometer. */
@@ -134,7 +133,7 @@ static unsigned int applesmc_light;
 /* Indicates which temperature sensors set to use. */
 static unsigned int applesmc_temperature_set;
 
-static struct mutex applesmc_lock;
+static DEFINE_MUTEX(applesmc_lock);
 
 /*
  * Last index written to key_at_index sysfs file, and value to use for all other
@@ -451,27 +450,12 @@ static void applesmc_calibrate(void)
 	rest_x = -rest_x;
 }
 
-static int applesmc_idev_open(struct input_dev *dev)
-{
-	add_timer(&applesmc_timer);
-
-	return 0;
-}
-
-static void applesmc_idev_close(struct input_dev *dev)
-{
-	del_timer_sync(&applesmc_timer);
-}
-
-static void applesmc_idev_poll(unsigned long unused)
+static void applesmc_idev_poll(struct input_polled_dev *dev)
 {
+	struct input_dev *idev = dev->input;
 	s16 x, y;
 
-	/* Cannot sleep.  Try nonblockingly.  If we fail, try again later. */
-	if (!mutex_trylock(&applesmc_lock)) {
-		mod_timer(&applesmc_timer, jiffies + APPLESMC_POLL_PERIOD);
-		return;
-	}
+	mutex_lock(&applesmc_lock);
 
 	if (applesmc_read_motion_sensor(SENSOR_X, &x))
 		goto out;
@@ -479,13 +463,11 @@ static void applesmc_idev_poll(unsigned long unused)
 		goto out;
 
 	x = -x;
-	input_report_abs(applesmc_idev, ABS_X, x - rest_x);
-	input_report_abs(applesmc_idev, ABS_Y, y - rest_y);
-	input_sync(applesmc_idev);
+	input_report_abs(idev, ABS_X, x - rest_x);
+	input_report_abs(idev, ABS_Y, y - rest_y);
+	input_sync(idev);
 
 out:
-	mod_timer(&applesmc_timer, jiffies + APPLESMC_POLL_PERIOD);
-
 	mutex_unlock(&applesmc_lock);
 }
 
@@ -817,8 +799,7 @@ static ssize_t applesmc_key_at_index_read_show(struct device *dev,
 
 	if (!ret) {
 		return info[0];
-	}
-	else {
+	} else {
 		return ret;
 	}
 }
@@ -1089,6 +1070,7 @@ static int applesmc_dmi_match(struct dmi_system_id *id)
 /* Create accelerometer ressources */
 static int applesmc_create_accelerometer(void)
 {
+	struct input_dev *idev;
 	int ret;
 
 	ret = sysfs_create_group(&pdev->dev.kobj,
@@ -1096,40 +1078,37 @@ static int applesmc_create_accelerometer(void)
 	if (ret)
 		goto out;
 
-	applesmc_idev = input_allocate_device();
+	applesmc_idev = input_allocate_polled_device();
 	if (!applesmc_idev) {
 		ret = -ENOMEM;
 		goto out_sysfs;
 	}
 
+	applesmc_idev->poll = applesmc_idev_poll;
+	applesmc_idev->poll_interval = APPLESMC_POLL_INTERVAL;
+
 	/* initial calibrate for the input device */
 	applesmc_calibrate();
 
-	/* initialize the input class */
-	applesmc_idev->name = "applesmc";
-	applesmc_idev->id.bustype = BUS_HOST;
-	applesmc_idev->dev.parent = &pdev->dev;
-	applesmc_idev->evbit[0] = BIT(EV_ABS);
-	applesmc_idev->open = applesmc_idev_open;
-	applesmc_idev->close = applesmc_idev_close;
-	input_set_abs_params(applesmc_idev, ABS_X,
+	/* initialize the input device */
+	idev = applesmc_idev->input;
+	idev->name = "applesmc";
+	idev->id.bustype = BUS_HOST;
+	idev->dev.parent = &pdev->dev;
+	idev->evbit[0] = BIT(EV_ABS);
+	input_set_abs_params(idev, ABS_X,
 			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
-	input_set_abs_params(applesmc_idev, ABS_Y,
+	input_set_abs_params(idev, ABS_Y,
 			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
 
-	ret = input_register_device(applesmc_idev);
+	ret = input_register_polled_device(applesmc_idev);
 	if (ret)
 		goto out_idev;
 
-	/* start up our timer for the input device */
-	init_timer(&applesmc_timer);
-	applesmc_timer.function = applesmc_idev_poll;
-	applesmc_timer.expires = jiffies + APPLESMC_POLL_PERIOD;
-
 	return 0;
 
 out_idev:
-	input_free_device(applesmc_idev);
+	input_free_polled_device(applesmc_idev);
 
 out_sysfs:
 	sysfs_remove_group(&pdev->dev.kobj, &accelerometer_attributes_group);
@@ -1142,8 +1121,8 @@ out:
 /* Release all ressources used by the accelerometer */
 static void applesmc_release_accelerometer(void)
 {
-	del_timer_sync(&applesmc_timer);
-	input_unregister_device(applesmc_idev);
+	input_unregister_polled_device(applesmc_idev);
+	input_free_polled_device(applesmc_idev);
 	sysfs_remove_group(&pdev->dev.kobj, &accelerometer_attributes_group);
 }
 
@@ -1180,8 +1159,6 @@ static int __init applesmc_init(void)
 	int count;
 	int i;
 
-	mutex_init(&applesmc_lock);
-
 	if (!dmi_check_system(applesmc_whitelist)) {
 		printk(KERN_WARNING "applesmc: supported laptop not found!\n");
 		ret = -ENODEV;
