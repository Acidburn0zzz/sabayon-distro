--- a/drivers/acpi/blacklist.c	2006-06-26 08:32:21.000000000 +0200
+++ a/drivers/acpi/blacklist.c	2006-06-26 08:32:59.000000000 +0200
@@ -78,6 +78,10 @@
 static int __init blacklist_by_year(void)
 {
 	int year = dmi_get_year(DMI_BIOS_DATE);
+
+	if (efi_enabled)
+		return 0;
+
 	/* Doesn't exist? Likely an old system */
 	if (year == -1) 
 		return 1;
Index: linux-2.6.19-rc2/arch/i386/kernel/msr.c
===================================================================
--- linux-2.6.19-rc2.orig/arch/i386/kernel/msr.c	2006-10-17 23:10:39.470361250 +0200
+++ linux-2.6.19-rc2/arch/i386/kernel/msr.c	2006-10-17 23:15:54.470047500 +0200
@@ -90,7 +90,7 @@
 		cmd->err = rdmsr_eio(cmd->reg, &cmd->data[0], &cmd->data[1]);
 }
 
-static inline int do_wrmsr(int cpu, u32 reg, u32 eax, u32 edx)
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx)
 {
 	struct msr_command cmd;
 	int ret;
@@ -111,7 +111,7 @@
 	return ret;
 }
 
-static inline int do_rdmsr(int cpu, u32 reg, u32 * eax, u32 * edx)
+int msr_read(int cpu, u32 reg, u32 * eax, u32 * edx)
 {
 	struct msr_command cmd;
 	int ret;
@@ -136,19 +136,22 @@
 
 #else				/* ! CONFIG_SMP */
 
-static inline int do_wrmsr(int cpu, u32 reg, u32 eax, u32 edx)
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx)
 {
 	return wrmsr_eio(reg, eax, edx);
 }
 
-static inline int do_rdmsr(int cpu, u32 reg, u32 *eax, u32 *edx)
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx)
 {
 	return rdmsr_eio(reg, eax, edx);
 }
 
 #endif				/* ! CONFIG_SMP */
 
-static loff_t msr_seek(struct file *file, loff_t offset, int orig)
+EXPORT_SYMBOL_GPL(msr_write);
+EXPORT_SYMBOL_GPL(msr_read);
+
+static loff_t msr_fseek(struct file *file, loff_t offset, int orig)
 {
 	loff_t ret = -EINVAL;
 
@@ -166,7 +169,7 @@
 	return ret;
 }
 
-static ssize_t msr_read(struct file *file, char __user * buf,
+static ssize_t msr_fread(struct file *file, char __user * buf,
 			size_t count, loff_t * ppos)
 {
 	u32 __user *tmp = (u32 __user *) buf;
@@ -179,7 +182,7 @@
 		return -EINVAL;	/* Invalid chunk size */
 
 	for (; count; count -= 8) {
-		err = do_rdmsr(cpu, reg, &data[0], &data[1]);
+		err = msr_read(cpu, reg, &data[0], &data[1]);
 		if (err)
 			return err;
 		if (copy_to_user(tmp, &data, 8))
@@ -190,7 +193,7 @@
 	return ((char __user *)tmp) - buf;
 }
 
-static ssize_t msr_write(struct file *file, const char __user *buf,
+static ssize_t msr_fwrite(struct file *file, const char __user *buf,
 			 size_t count, loff_t *ppos)
 {
 	const u32 __user *tmp = (const u32 __user *)buf;
@@ -206,7 +209,7 @@
 	for (rv = 0; count; count -= 8) {
 		if (copy_from_user(&data, tmp, 8))
 			return -EFAULT;
-		err = do_wrmsr(cpu, reg, data[0], data[1]);
+		err = msr_write(cpu, reg, data[0], data[1]);
 		if (err)
 			return err;
 		tmp += 2;
@@ -215,7 +218,7 @@
 	return ((char __user *)tmp) - buf;
 }
 
-static int msr_open(struct inode *inode, struct file *file)
+static int msr_fopen(struct inode *inode, struct file *file)
 {
 	unsigned int cpu = iminor(file->f_dentry->d_inode);
 	struct cpuinfo_x86 *c = &(cpu_data)[cpu];
@@ -233,10 +236,10 @@
  */
 static struct file_operations msr_fops = {
 	.owner = THIS_MODULE,
-	.llseek = msr_seek,
-	.read = msr_read,
-	.write = msr_write,
-	.open = msr_open,
+	.llseek = msr_fseek,
+	.read = msr_fread,
+	.write = msr_fwrite,
+	.open = msr_fopen,
 };
 
 static int msr_class_device_create(int i)
Index: linux-2.6.19-rc2/include/asm-i386/msr.h
===================================================================
--- linux-2.6.19-rc2.orig/include/asm-i386/msr.h	2006-10-17 23:10:39.446359750 +0200
+++ linux-2.6.19-rc2/include/asm-i386/msr.h	2006-10-17 23:10:52.211157500 +0200
@@ -78,6 +78,9 @@
 			  : "=a" (low), "=d" (high) \
 			  : "c" (counter))
 
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx);
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx);
+
 /* symbolic names for some interesting MSRs */
 /* Intel defined MSRs. */
 #define MSR_IA32_P5_MC_ADDR		0
Index: linux-2.6.19-rc2/include/asm-x86_64/msr.h
===================================================================
--- linux-2.6.19-rc2.orig/include/asm-x86_64/msr.h	2006-10-17 23:10:39.382355750 +0200
+++ linux-2.6.19-rc2/include/asm-x86_64/msr.h	2006-10-17 23:18:29.347726750 +0200
@@ -160,7 +160,8 @@
 #define MSR_IA32_UCODE_WRITE		0x79
 #define MSR_IA32_UCODE_REV		0x8b
 
-
+int msr_write(int cpu, u32 reg, u32 eax, u32 edx);
+int msr_read(int cpu, u32 reg, u32 *eax, u32 *edx);
 #endif
 
 /* AMD/K8 specific MSRs */ 
Index: linux-2.6.19-rc2/drivers/hwmon/coretemp.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-2.6.19-rc2/drivers/hwmon/coretemp.c	2006-10-17 23:12:39.589868250 +0200
@@ -0,0 +1,400 @@
+/*
+ * coretemp.c - Linux kernel module for hardware monitoring
+ *
+ * Copyright (C) 2006 Rudolf Marek <r.marek@assembler.cz>
+ *
+ * Inspired from many hwmon drivers
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301 USA.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h>
+#include <linux/hwmon.h>
+#include <linux/sysfs.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/list.h>
+#include <linux/platform_device.h>
+#include <asm/msr.h>
+#include <linux/cpu.h>
+
+#define DRVNAME		"coretemp"
+
+typedef enum { SHOW_TEMP, SHOW_TJMAX, SHOW_LABEL, SHOW_NAME } SHOW;
+
+/*
+ * Functions declaration
+ */
+
+static struct coretemp_data *coretemp_update_device(struct device *dev);
+
+struct coretemp_data {
+	struct class_device *class_dev;
+	struct mutex update_lock;
+	const char *name;
+	u32 id;
+	char valid;		/* zero until following fields are valid */
+	unsigned long last_updated;	/* in jiffies */
+	int temp;
+	int tjmax;
+	/* registers values */
+	u32 therm_status;
+};
+
+static struct coretemp_data *coretemp_update_device(struct device *dev);
+
+/*
+ * Sysfs stuff
+ */
+
+
+static ssize_t show_name(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	int ret;
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct coretemp_data *data = dev_get_drvdata(dev);
+
+	if (attr->index == SHOW_NAME)
+		ret = sprintf(buf, "%s\n", data->name);
+	else	/* show label */
+		ret = sprintf(buf, "Core %d\n", data->id);
+	return ret;
+}
+
+static ssize_t show_alarm(struct device *dev, struct device_attribute
+			  *devattr, char *buf)
+{
+	struct coretemp_data *data = coretemp_update_device(dev);
+	/* read the Out-of-spec log, never clear */
+	return sprintf(buf, "%d\n", (data->therm_status >> 5) & 1);
+}
+
+static ssize_t show_temp(struct device *dev,
+			 struct device_attribute *devattr, char *buf)
+{
+	struct sensor_device_attribute *attr = to_sensor_dev_attr(devattr);
+	struct coretemp_data *data = coretemp_update_device(dev);
+	return sprintf(buf, "%d\n",
+		       attr->index ==
+		       SHOW_TEMP ? data->temp : data->tjmax);
+}
+
+static SENSOR_DEVICE_ATTR(temp1_input, S_IRUGO, show_temp, NULL,
+			  SHOW_TEMP);
+static SENSOR_DEVICE_ATTR(temp1_crit, S_IRUGO, show_temp, NULL,
+			  SHOW_TJMAX);
+static DEVICE_ATTR(temp1_crit_alarm, S_IRUGO, show_alarm, NULL);
+static SENSOR_DEVICE_ATTR(temp1_label, S_IRUGO, show_name, NULL, SHOW_LABEL);
+static SENSOR_DEVICE_ATTR(name, S_IRUGO, show_name, NULL, SHOW_NAME);
+
+static struct attribute *coretemp_attributes[] = {
+	&sensor_dev_attr_name.dev_attr.attr,
+	&sensor_dev_attr_temp1_label.dev_attr.attr,
+	&dev_attr_temp1_crit_alarm.attr,
+	&sensor_dev_attr_temp1_input.dev_attr.attr,
+	&sensor_dev_attr_temp1_crit.dev_attr.attr,
+	NULL
+};
+
+static const struct attribute_group coretemp_group = {
+	.attrs = coretemp_attributes,
+};
+
+static struct coretemp_data *coretemp_update_device(struct device *dev)
+{
+	struct coretemp_data *data = dev_get_drvdata(dev);
+
+	mutex_lock(&data->update_lock);
+
+	if (!data->valid || time_after(jiffies, data->last_updated + HZ)) {
+		u32 eax, edx;
+
+		data->valid = 0;
+		msr_read(data->id, MSR_IA32_THERM_STATUS, &eax, &edx);
+		data->therm_status = eax;
+
+		/* update only if data has been valid */
+		if (eax & 0x80000000) {
+			data->temp = data->tjmax - (((data->therm_status >> 16)
+							& 0x7f) * 1000);
+			data->valid = 1;
+		}
+		data->last_updated = jiffies;
+	}
+
+	mutex_unlock(&data->update_lock);
+	return data;
+}
+
+static int __devinit coretemp_probe(struct platform_device *pdev)
+{
+	struct coretemp_data *data;
+	struct cpuinfo_x86 *c = &(cpu_data)[pdev->id];
+	int err;
+	u32 eax, edx;
+
+	if (!(data = kzalloc(sizeof(struct coretemp_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "Out of memory\n");
+		goto exit;
+	}
+
+	data->id = pdev->id;
+	data->name = "coretemp";
+	mutex_init(&data->update_lock);
+	/* Tjmax default is 100C */
+	data->tjmax = 100000;
+
+	/* Some processors have Tjmax 85 following magic should detect it */
+	/* family is always 0x6 */
+
+	if (((c->x86_model == 0xf) && (c->x86_mask > 3 )) ||
+		(c->x86_model == 0xe))  {
+
+		err = msr_read(data->id, 0xee, &eax, &edx);
+		if (err) {
+			dev_warn(&pdev->dev,
+				 "Unable to access MSR 0xEE, Tjmax left at %d\n",
+				 data->tjmax);
+		} else if (eax & 0x40000000) {
+			data->tjmax = 85000;
+		}
+	}
+
+	/* test if we can access the THERM_STATUS MSR */
+	err = msr_read(data->id, MSR_IA32_THERM_STATUS, &eax, &edx);
+
+	if (err) {
+		dev_err(&pdev->dev,
+			"Unable to access THERM_STATUS MSR, giving up\n");
+		goto exit_free;
+	}
+	platform_set_drvdata(pdev, data);
+
+	if ((err = sysfs_create_group(&pdev->dev.kobj, &coretemp_group)))
+		goto exit_free;
+
+	data->class_dev = hwmon_device_register(&pdev->dev);
+	if (IS_ERR(data->class_dev)) {
+		err = PTR_ERR(data->class_dev);
+		dev_err(&pdev->dev, "Class registration failed (%d)\n",
+			err);
+		goto exit_class;
+	}
+
+	return 0;
+
+exit_class:
+	sysfs_remove_group(&pdev->dev.kobj, &coretemp_group);
+exit_free:
+	kfree(data);
+exit:
+	return err;
+}
+
+static int __devexit coretemp_remove(struct platform_device *pdev)
+{
+	struct coretemp_data *data = platform_get_drvdata(pdev);
+
+	hwmon_device_unregister(data->class_dev);
+	sysfs_remove_group(&pdev->dev.kobj, &coretemp_group);
+	platform_set_drvdata(pdev, NULL);
+	kfree(data);
+	return 0;
+}
+
+static struct platform_driver coretemp_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = DRVNAME,
+		   },
+	.probe = coretemp_probe,
+	.remove = __devexit_p(coretemp_remove),
+};
+
+struct pdev_entry {
+	struct list_head list;
+	struct platform_device *pdev;
+	unsigned int cpu;
+};
+
+static LIST_HEAD(pdev_list);
+static DEFINE_MUTEX(pdev_list_mutex);
+
+static int __cpuinit coretemp_devices_add(unsigned int cpu)
+{
+	int err;
+	struct platform_device *pdev;
+	struct pdev_entry *pdev_entry;
+
+	pdev = platform_device_alloc(DRVNAME, cpu);
+	if (!pdev) {
+		err = -ENOMEM;
+		printk(KERN_ERR DRVNAME ": Device allocation failed\n");
+		goto exit;
+
+	}
+
+	pdev_entry = kzalloc(sizeof(struct pdev_entry), GFP_KERNEL);
+
+	if (!pdev_entry) {
+		err = -ENOMEM;
+		goto exit_device_put;
+	}
+
+	err = platform_device_add(pdev);
+
+	if (err) {
+		printk(KERN_ERR DRVNAME ": Device addition failed (%d)\n",
+		       err);
+		goto exit_device_free;
+	}
+
+	pdev_entry->pdev = pdev;
+	pdev_entry->cpu = cpu;
+	mutex_lock(&pdev_list_mutex);
+	list_add_tail(&pdev_entry->list, &pdev_list);
+	mutex_unlock(&pdev_list_mutex);
+
+	return 0;
+
+exit_device_free:
+	kfree(pdev_entry);
+exit_device_put:
+	platform_device_put(pdev);
+exit:
+	return err;
+}
+
+#ifdef CONFIG_HOTPLUG_CPU
+void coretemp_devices_remove(unsigned int cpu)
+{
+	struct pdev_entry *p, *n;
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		if (p->cpu == cpu) {
+			platform_device_unregister(p->pdev);
+			list_del(&p->list);
+			kfree(p);
+		}
+	}
+	mutex_unlock(&pdev_list_mutex);
+}
+
+static int coretemp_cpu_callback(struct notifier_block *nfb,
+				 unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long) hcpu;
+
+	switch (action) {
+	case CPU_ONLINE:
+		coretemp_devices_add(cpu);
+		break;
+	case CPU_DEAD:
+		coretemp_devices_remove(cpu);
+		break;
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block __cpuinitdata coretemp_cpu_notifier = {
+	.notifier_call = coretemp_cpu_callback,
+};
+#endif				/* !CONFIG_HOTPLUG_CPU */
+
+static int __init coretemp_init(void)
+{
+	int i, err = -ENODEV;
+	struct pdev_entry *p, *n;
+
+	if (current_cpu_data.x86_vendor != X86_VENDOR_INTEL)
+		goto exit;
+
+	err = platform_driver_register(&coretemp_driver);
+	if (err)
+		goto exit;
+
+	for_each_online_cpu(i) {
+		struct cpuinfo_x86 *c = &(cpu_data)[i];
+
+		/* check if family 6, models e, f */
+		if ((c->cpuid_level < 0) || (c->x86 != 0x6) ||
+		    !((c->x86_model == 0xe) || (c->x86_model == 0xf))) {
+
+			/* supported CPU not found, but report the unknown
+			   family 6 CPU */
+			if ((c->x86 == 0x6) && (c->x86_model > 0xf))
+				printk(KERN_WARNING DRVNAME ": Unknown CPU, please"
+ 			   " report to the lm-sensors@lm-sensors.org\n");
+			continue;
+		}
+
+		err = coretemp_devices_add(i);
+		if (err)
+			goto exit_driver;
+	}
+	if (list_empty(&pdev_list)) {
+		err = -ENODEV;
+		goto exit_driver_unreg;
+	}
+
+#ifdef CONFIG_HOTPLUG_CPU
+	register_hotcpu_notifier(&coretemp_cpu_notifier);
+#endif
+	return 0;
+
+exit_driver:
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		platform_device_unregister(p->pdev);
+		list_del(&p->list);
+		kfree(p);
+	}
+	mutex_unlock(&pdev_list_mutex);
+exit_driver_unreg:
+	platform_driver_unregister(&coretemp_driver);
+exit:
+	return err;
+}
+
+static void __exit coretemp_exit(void)
+{
+	struct pdev_entry *p, *n;
+#ifdef CONFIG_HOTPLUG_CPU
+	unregister_hotcpu_notifier(&coretemp_cpu_notifier);
+#endif
+	mutex_lock(&pdev_list_mutex);
+	list_for_each_entry_safe(p, n, &pdev_list, list) {
+		platform_device_unregister(p->pdev);
+		list_del(&p->list);
+		kfree(p);
+	}
+	mutex_unlock(&pdev_list_mutex);
+	platform_driver_unregister(&coretemp_driver);
+}
+
+MODULE_AUTHOR("Rudolf Marek <r.marek@assembler.cz>");
+MODULE_DESCRIPTION("Intel Core temperature monitor");
+MODULE_LICENSE("GPL");
+
+module_init(coretemp_init)
+module_exit(coretemp_exit)
Index: linux-2.6.19-rc2/drivers/hwmon/Kconfig
===================================================================
--- linux-2.6.19-rc2.orig/drivers/hwmon/Kconfig	2006-10-17 23:05:20.178406750 +0200
+++ linux-2.6.19-rc2/drivers/hwmon/Kconfig	2006-10-17 23:11:36.021895500 +0200
@@ -131,6 +131,15 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called atxp1.
 
+config SENSORS_CORETEMP
+	tristate "Intel Core (2) Duo/Solo temperature sensor"
+	depends on HWMON && X86 && EXPERIMENTAL
+	select X86_MSR
+	help
+	  If you say yes here you get support for the temperature
+	  sensor inside your CPU. Supported all are all known variants
+	  of Intel Core family.
+
 config SENSORS_DS1621
 	tristate "Dallas Semiconductor DS1621 and DS1625"
 	depends on HWMON && I2C
Index: linux-2.6.19-rc2/drivers/hwmon/Makefile
===================================================================
--- linux-2.6.19-rc2.orig/drivers/hwmon/Makefile	2006-10-17 23:05:20.138404250 +0200
+++ linux-2.6.19-rc2/drivers/hwmon/Makefile	2006-10-17 23:11:36.025895750 +0200
@@ -20,6 +19,7 @@
 obj-$(CONFIG_SENSORS_ADM1031)	+= adm1031.o
 obj-$(CONFIG_SENSORS_ADM9240)	+= adm9240.o
 obj-$(CONFIG_SENSORS_ATXP1)	+= atxp1.o
+obj-$(CONFIG_SENSORS_CORETEMP)	+= coretemp.o
 obj-$(CONFIG_SENSORS_DS1621)	+= ds1621.o
 obj-$(CONFIG_SENSORS_F71805F)	+= f71805f.o
 obj-$(CONFIG_SENSORS_FSCHER)	+= fscher.o
--- linux-2.6.16.1/drivers/usb/input/Makefile	2006-03-28 07:49:02.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/Makefile	2006-05-22 13:14:40.000000000 +0100
@@ -36,6 +36,7 @@
 obj-$(CONFIG_USB_HID)		+= usbhid.o
 obj-$(CONFIG_USB_KBD)		+= usbkbd.o
 obj-$(CONFIG_USB_KBTAB)		+= kbtab.o
+obj-$(CONFIG_USB_APPLEIR)		+= appleir.o
 obj-$(CONFIG_USB_KEYSPAN_REMOTE)	+= keyspan_remote.o
 obj-$(CONFIG_USB_MOUSE)		+= usbmouse.o
 obj-$(CONFIG_USB_MTOUCH)	+= mtouchusb.o
--- linux-2.6.16.1/drivers/usb/input/Kconfig	2006-03-28 07:49:02.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/Kconfig	2006-05-22 13:15:16.000000000 +0100
@@ -183,6 +183,10 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called acecad.
 
+config USB_APPLEIR
+	tristate "Apple Mac Mini USB IR receiver (built in)"
+	depends on USB && INPUT
+	
 config USB_KBTAB
 	tristate "KB Gear JamStudio tablet support"
 	depends on USB && INPUT
--- linux-2.6.16.1/drivers/usb/input/appleir.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.16.1-imac-sky2-rtc/drivers/usb/input/appleir.c	2006-05-29 09:47:40.000000000 +0100
@@ -0,0 +1,390 @@
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/usb.h>
+#include <linux/usb/input.h>
+#include <asm/unaligned.h>
+#include <asm/byteorder.h>
+
+/*
+ * Version Information
+ *
+ */
+
+#if 0
+#define DUMP_PACKETS
+#else
+#undef DUMP_PACKETS
+#endif
+
+#define DRIVER_VERSION "v1.1"
+#define DRIVER_AUTHOR "James McKenzie"
+#define DRIVER_DESC "USB Apple MacMini IR Receiver driver"
+#define DRIVER_LICENSE "GPL"
+
+MODULE_AUTHOR (DRIVER_AUTHOR);
+MODULE_DESCRIPTION (DRIVER_DESC);
+MODULE_LICENSE (DRIVER_LICENSE);
+
+#ifndef USB_VENDOR_ID_APPLE
+#define USB_VENDOR_ID_APPLE	0x05ac
+#endif
+#ifndef USB_DEVICE_ID_APPLE_IR
+#define USB_DEVICE_ID_APPLE_IR  0x8240
+#endif
+
+#define URB_SIZE 32
+
+#define MAX_KEYS 8
+#define MAX_KEYS_MASK (MAX_KEYS - 1 )
+
+struct appleir
+{
+  struct input_dev *dev;
+  uint8_t *data;
+  dma_addr_t dma_buf;
+  struct usb_device *usbdev;
+  struct urb *urb;
+  int timer_initted;
+  struct timer_list key_up_timer;
+  int current_key;
+  char phys[32];
+};
+
+
+static struct usb_device_id appleir_ids[] = {
+  {USB_DEVICE (USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IR),.driver_info = 0},
+  {}
+};
+
+MODULE_DEVICE_TABLE (usb, appleir_ids);
+
+
+/* I have two devices both of which report the following */
+/* 25 87 ee 83 0a  	+  */
+/* 25 87 ee 83 0c  	-  */
+/* 25 87 ee 83 09	<< */
+/* 25 87 ee 83 06	>> */
+/* 25 87 ee 83 05	>" */
+/* 25 87 ee 83 03	menu */
+/* 26 00 00 00 00	for key repeat*/
+
+/* Thomas Glanzmann reports the following responses */
+/* 25 87 ee ca 0b	+  */
+/* 25 87 ee ca 0d	-  */
+/* 25 87 ee ca 08	<< */
+/* 25 87 ee ca 07	>> */
+/* 25 87 ee ca 04	>" */
+/* 25 87 ee ca 02 	menu */
+/* 26 00 00 00 00       for key repeat*/
+/* He also observes the following event sometimes */
+/* sent after a key is release, which I interpret */
+/* as a flat battery message */
+/* 25 87 e0 ca 06	flat battery */
+
+
+static int keymap[MAX_KEYS] = {
+  KEY_RESERVED, KEY_MENU,
+  KEY_PLAYPAUSE, KEY_NEXTSONG,
+  KEY_PREVIOUSSONG, KEY_VOLUMEUP,
+  KEY_VOLUMEDOWN, KEY_RESERVED
+};
+
+static void
+dump_packet (struct appleir *appleir, char *msg, uint8_t * data, int len)
+{
+  int i;
+
+  printk (KERN_ERR "appleir: %s (%d bytes)", msg, len);
+
+  for (i = 0; i < len; ++i)
+    {
+      printk (" %02x", data[i]);
+    }
+
+  printk ("\n");
+}
+
+
+static void
+key_up (struct appleir *appleir, int key)
+{
+  //printk (KERN_ERR "key %d up\n", key);
+  input_report_key (appleir->dev, key, 0);
+  input_sync (appleir->dev);
+}
+
+static void
+key_down (struct appleir *appleir, int key)
+{
+  //printk (KERN_ERR "key %d down\n", key);
+  input_report_key (appleir->dev, key, 1);
+  input_sync (appleir->dev);
+}
+
+static void
+battery_flat (struct appleir *appleir)
+{
+  printk (KERN_ERR "appleir: possible flat battery?\n");
+}
+
+static void
+key_up_tick (unsigned long data)
+{
+  struct appleir *appleir = (struct appleir *) data;
+
+  if (appleir->current_key)
+    {
+      key_up (appleir, appleir->current_key);
+      appleir->current_key = 0;
+    }
+}
+
+static void
+new_data (struct appleir *appleir, uint8_t * data, int len)
+{
+  static const uint8_t keydown[] = { 0x25, 0x87, 0xee };
+  static const uint8_t keyrepeat[] = { 0x26, 0x00, 0x00, 0x00, 0x00 };
+  static const uint8_t flatbattery[] = { 0x25, 0x87, 0xe0 };
+
+#ifdef DUMP_PACKETS
+  dump_packet (appleir, "received", data, len);
+#endif
+
+  if (len != 5)
+    return;
+
+  if (!memcmp (data, keydown, sizeof (keydown)))
+    {
+      /*If we already have a key down, take it up before marking */
+      /*this one down */
+      if (appleir->current_key)
+        key_up (appleir, appleir->current_key);
+      appleir->current_key = keymap[(data[4] >> 1) & MAX_KEYS_MASK];
+
+      key_down (appleir, appleir->current_key);
+      /*remote doesn't do key up, either pull them up, in the test */
+      /*above, or here set a timer which pulls them up after 1/8 s */
+      mod_timer (&appleir->key_up_timer, jiffies + HZ / 8);
+
+      return;
+    }
+
+  if (!memcmp (data, keyrepeat, sizeof (keyrepeat)))
+    {
+      key_down (appleir, appleir->current_key);
+      /*remote doesn't do key up, either pull them up, in the test */
+      /*above, or here set a timer which pulls them up after 1/8 s */
+      mod_timer (&appleir->key_up_timer, jiffies + HZ / 8);
+      return;
+    }
+
+  if (!memcmp (data, flatbattery, sizeof (flatbattery)))
+    {
+      battery_flat (appleir);
+      /*Fall through */
+    }
+
+  dump_packet (appleir, "unknown packet", data, len);
+}
+
+static void
+appleir_urb (struct urb *urb, struct pt_regs *regs)
+{
+  struct appleir *appleir = urb->context;
+  int retval;
+
+  switch (urb->status)
+    {
+    case 0:
+      new_data (appleir, urb->transfer_buffer, urb->actual_length);
+      break;
+    case -ECONNRESET:
+    case -ENOENT:
+    case -ESHUTDOWN:
+      /* this urb is terminated, clean up */
+      dbg ("%s - urb shutting down with status: %d", __FUNCTION__,
+           urb->status);
+      return;
+    default:
+      dbg ("%s - nonzero urb status received: %d", __FUNCTION__, urb->status);
+    }
+
+  retval = usb_submit_urb (urb, GFP_ATOMIC);
+  if (retval)
+    err ("%s - usb_submit_urb failed with result %d", __FUNCTION__, retval);
+}
+
+
+static int
+appleir_open (struct input_dev *dev)
+{
+  struct appleir *appleir = dev->private;
+
+  //appleir->urb->dev = appleir->usbdev;
+
+  if (usb_submit_urb (appleir->urb, GFP_KERNEL))
+    return -EIO;
+
+  return 0;
+}
+
+static void
+appleir_close (struct input_dev *dev)
+{
+  struct appleir *appleir = dev->private;
+  usb_kill_urb (appleir->urb);
+  del_timer_sync (&appleir->key_up_timer);
+}
+
+
+
+
+static int
+appleir_probe (struct usb_interface *intf, const struct usb_device_id *id)
+{
+  struct usb_device *dev = interface_to_usbdev (intf);
+  struct usb_endpoint_descriptor *endpoint;
+  struct appleir *appleir = NULL;
+  struct input_dev *input_dev;
+  int i;
+
+  appleir = kzalloc (sizeof (struct appleir), GFP_KERNEL);
+  if (!appleir)
+    goto fail;
+
+  memset (appleir, 0, sizeof (struct appleir));
+
+
+  appleir->data =
+    usb_buffer_alloc (dev, URB_SIZE, GFP_KERNEL, &appleir->dma_buf);
+  if (!appleir->data)
+    goto fail;
+
+  appleir->urb = usb_alloc_urb (0, GFP_KERNEL);
+  if (!appleir->urb)
+    goto fail;
+
+  appleir->usbdev = dev;
+
+  input_dev = input_allocate_device ();
+  if (!input_dev)
+    goto fail;
+
+  appleir->dev = input_dev;
+
+
+  usb_make_path (dev, appleir->phys, sizeof (appleir->phys));
+  strlcpy (appleir->phys, "/input0", sizeof (appleir->phys));
+
+  input_dev->name = "Apple Mac mini infrared remote control driver";
+  input_dev->phys = appleir->phys;
+  usb_to_input_id (dev, &input_dev->id);
+  input_dev->cdev.dev = &intf->dev;
+  input_dev->private = appleir;
+
+  input_dev->evbit[0] = BIT (EV_KEY) | BIT (EV_REP);
+  input_dev->ledbit[0] = 0;
+
+  for (i = 0; i < MAX_KEYS; i++)
+    {
+      set_bit (keymap[i], input_dev->keybit);
+    }
+
+  clear_bit (0, input_dev->keybit);
+
+  input_dev->open = appleir_open;
+  input_dev->close = appleir_close;
+
+  endpoint = &intf->cur_altsetting->endpoint[0].desc;
+
+  usb_fill_int_urb (appleir->urb, dev,
+                    usb_rcvintpipe (dev, endpoint->bEndpointAddress),
+                    appleir->data, 8,
+                    appleir_urb, appleir, endpoint->bInterval);
+
+  appleir->urb->transfer_dma = appleir->dma_buf;
+  appleir->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
+
+  usb_set_intfdata (intf, appleir);
+
+  init_timer (&appleir->key_up_timer);
+
+  appleir->key_up_timer.function = key_up_tick;
+  appleir->key_up_timer.data = (unsigned long) appleir;
+
+  appleir->timer_initted++;
+
+  input_register_device (appleir->dev);
+
+  return 0;
+
+fail:
+
+  if (appleir)
+    {
+
+
+      if (appleir->data)
+        usb_buffer_free (dev, URB_SIZE, appleir->data, appleir->dma_buf);
+
+      if (appleir->timer_initted)
+        del_timer_sync (&appleir->key_up_timer);
+
+      if (appleir->dev)
+        input_free_device (appleir->dev);
+
+      kfree (appleir);
+    }
+
+  return -ENOMEM;
+}
+
+static void
+appleir_disconnect (struct usb_interface *intf)
+{
+  struct appleir *appleir = usb_get_intfdata (intf);
+
+  usb_set_intfdata (intf, NULL);
+  if (appleir)
+    {
+      input_unregister_device (appleir->dev);
+      if (appleir->timer_initted)
+        del_timer_sync (&appleir->key_up_timer);
+      usb_kill_urb (appleir->urb);
+      usb_free_urb (appleir->urb);
+      usb_buffer_free (interface_to_usbdev (intf), URB_SIZE, appleir->data,
+                       appleir->dma_buf);
+      kfree (appleir);
+    }
+}
+
+static struct usb_driver appleir_driver = {
+  .name = "appleir",
+  .probe = appleir_probe,
+  .disconnect = appleir_disconnect,
+  .id_table = appleir_ids,
+};
+
+static int __init
+appleir_init (void)
+{
+  int retval;
+  retval = usb_register (&appleir_driver);
+  if (retval)
+    goto out;
+  info (DRIVER_VERSION ":" DRIVER_DESC);
+out:
+  return retval;
+}
+
+static void __exit
+appleir_exit (void)
+{
+  usb_deregister (&appleir_driver);
+}
+
+module_init (appleir_init);
+module_exit (appleir_exit);
--- a/drivers/acpi/sleep/poweroff.c	2006-06-11 05:22:53.000000000 -0700
+++ b/drivers/acpi/sleep/poweroff.c	2006-06-11 05:06:36.000000000 -0700
@@ -63,8 +63,15 @@ static int acpi_shutdown(struct sys_devi
 	}
 }
 
+static int acpi_resume(struct sys_device *x)
+{
+	acpi_set_register(ACPI_BITREG_SCI_ENABLE, 1, ACPI_MTX_DO_NOT_LOCK);
+	return 0;
+}
+
 static struct sysdev_class acpi_sysclass = {
 	set_kset_name("acpi"),
+	.resume = acpi_resume,
 	.shutdown = acpi_shutdown
 };
 


From: Ryan Lortie <desrt@desrt.ca>
Date: Sat, 10 Jun 2006 20:22:56 +0000 (-0400)
Subject: [UBUNTU:ich7-sci-en-quirk] poke the SCI_EN bit on Macbook resume
X-Git-Url: http://www.kernel.org/git/?p=linux/kernel/git/bcollins/ubuntu-dapper.git;a=commitdiff;h=d1d9b907570c5c9178e3d66ff208bd483d1dfd61

[UBUNTU:ich7-sci-en-quirk] poke the SCI_EN bit on Macbook resume

The following patch deals with the problem that the SCI_EN bit is
disabled when the Macbook comes back from sleeping.

It does this by registering a quirk in the exact way that another one is
registered in the same file (for a Toshiba laptop with a similar
problem).

The quirk matches based on DMI product name of "MacBook1,1" so it should
really only affect the Macbook.

The actual bit-poking is done immediately on return from
do_suspend_lowlevel().  If I do it in the 'finish' function it is too
late (as at this point IRQs have been enabled again for some time).

Cheers.

Signed-off-by: Ben Collins <bcollins@ubuntu.com>
---

--- a/drivers/acpi/sleep/main.c
+++ b/drivers/acpi/sleep/main.c
@@ -17,6 +17,7 @@
 #include <linux/suspend.h>
 #include <acpi/acpi_bus.h>
 #include <acpi/acpi_drivers.h>
+#include <asm/io.h>
 #include "sleep.h"
 
 u8 sleep_states[ACPI_S_STATE_COUNT];
@@ -34,6 +35,7 @@ static u32 acpi_suspend_states[] = {
 };
 
 static int init_8259A_after_S1;
+static int ich7_sci_en_quirk_enabled;
 
 /**
  *	acpi_pm_prepare - Do preliminary suspend work.
@@ -92,6 +94,14 @@ static int acpi_pm_enter(suspend_state_t
 
 	case PM_SUSPEND_MEM:
 		do_suspend_lowlevel();
+
+		if (ich7_sci_en_quirk_enabled)
+		{
+			int pm1c = inw(0x404);
+			pm1c |= 0x01; /* SCI_EN */
+			outw (pm1c, 0x404);
+		}
+
 		break;
 
 	case PM_SUSPEND_DISK:
@@ -191,12 +201,36 @@ static int __init init_ints_after_s1(str
 	return 0;
 }
 
+/*
+ * Apple Macbook comes back from sleep with the SCI_EN bit disabled
+ * causing a flood of unacknowledged IRQ9s.  We need to set SCI_EN
+ * as soon as we come back
+ */
+static int __init init_ich7_sci_en_quirk(struct dmi_system_id *d)
+{
+	printk(KERN_WARNING "%s detected (ICH7 SCI_EN quirk enabled)\n",
+               d->ident);
+	ich7_sci_en_quirk_enabled = 1;
+	return 0;
+}
+
+
 static struct dmi_system_id __initdata acpisleep_dmi_table[] = {
 	{
 	 .callback = init_ints_after_s1,
 	 .ident = "Toshiba Satellite 4030cdt",
 	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "S4030CDT/4.3"),},
 	 },
+	{
+	 .callback = init_ich7_sci_en_quirk,
+	 .ident = "Apple MacBook",
+	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "MacBook1,1"),},
+	 },
+	{
+	 .callback = init_ich7_sci_en_quirk,
+	 .ident = "Apple MacBook",
+	 .matches = {DMI_MATCH(DMI_PRODUCT_NAME, "MacBook2,1"),},
+	 },
 	{},
 };
 
diff -pruN linux/sound/pci/hda.vanilla/patch_sigmatel.c linux/sound/pci/hda/patch_sigmatel.c
--- linux/sound/pci/hda.vanilla/patch_sigmatel.c	2006-11-26 11:20:30.000000000 +0800
+++ linux/sound/pci/hda/patch_sigmatel.c	2006-11-26 12:13:42.000000000 +0800
@@ -364,11 +364,39 @@ static unsigned int d945gtp5_pin_configs
 	0x02a19320, 0x40000100,
 };
 
+/* Microphone working, but no front (old Bootcamp, proto2.ini) */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0121E230, 0x90A70120, 0x9017E110, 0x400000FE,
+	0x400000FD, 0x0181E021, 0x1145E040, 0x400000FA,
+	0x400000FC, 0x400000FB
+};*/
+
+/* Microphone working, but no front (old Bootcamp, proto.ini) */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0121E220, 0x400000FF, 0x9017E110, 0x400000FE,
+	0x400000FD, 0x0181E040, 0x1145E030, 0x11C5E040,
+	0x400000FC, 0x400000FB
+};*/
+
+/* Jason's working pins */
+/*static unsigned int macmini_pin_configs[10] = {
+	0x0321E230, 0x03A1E020, 0x9017E110, 0x400000FD,
+	0x400000FE, 0x0381E021, 0x1345E240, 0x13C5E22E,
+	0x400000FC, 0x400000FB,
+};*/
+
+/* Nicolas' working pins, map unmapped pins from Jason's pins with the default */
+static unsigned int macmini_pin_configs[10] = {
+	0x0321E230, 0x03A1E020, 0x9017E110, 0x01014010,
+	0x01a19021, 0x0381E021, 0x1345E240, 0x13C5E22E,
+	0x02a19320, 0x400000FB,
+};
+
 static unsigned int *stac922x_brd_tbl[STAC_922X_MODELS] = {
 	[STAC_REF] =	ref922x_pin_configs,
 	[STAC_D945GTP3] = d945gtp3_pin_configs,
 	[STAC_D945GTP5] = d945gtp5_pin_configs,
-	[STAC_MACMINI] = d945gtp5_pin_configs,
+	[STAC_MACMINI] = macmini_pin_configs,
 };
 
 static struct hda_board_config stac922x_cfg_tbl[] = {
