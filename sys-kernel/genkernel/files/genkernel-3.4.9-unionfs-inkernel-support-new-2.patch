diff -Nurp genkernel-3.4.9_pre9.orig/gen_compile.sh genkernel-3.4.9_pre9/gen_compile.sh
--- genkernel-3.4.9_pre9.orig/gen_compile.sh	2007-11-14 00:09:21.000000000 +0100
+++ genkernel-3.4.9_pre9/gen_compile.sh	2007-11-15 12:12:21.000000000 +0100
@@ -401,13 +401,10 @@ compile_unionfs_utils() {
 			gen_die 'Unionfs directory ${UNIONFS_DIR} is invalid!'
 		cd "${UNIONFS_DIR}"
 		print_info 1 'unionfs tools: >> Compiling...'
-		sed -i utils/Makefile -e 's|${CC} -o|${CC} -static -o|g'
-		sed -i Makefile -e 's|${CC} -o|${CC} -static -o|g'
-		compile_generic utils utils
-
-		if [ ! -e "uniondbg" ]; then
-			cd utils
-		fi
+		#./bootstrap &> /dev/null
+		./configure >> ${DEBUGFILE} 2>&1 || gen_die 'Configuring unionfs-utils failed!'
+		sed -i Makefile -e 's|LDFLAGS = |LDFLAGS = -all-static|g'
+		compile_generic '' utils
 		print_info 1 'unionfs: >> Copying to cache...'
 		strip uniondbg unionctl
 		cp uniondbg ${TEMP}/unionfs/sbin/ || 
diff -Nurp genkernel-3.4.9_pre9.orig/gen_compile.sh.orig genkernel-3.4.9_pre9/gen_compile.sh.orig
--- genkernel-3.4.9_pre9.orig/gen_compile.sh.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre9/gen_compile.sh.orig	2007-11-14 00:09:21.000000000 +0100
@@ -0,0 +1,652 @@
+#!/bin/bash
+
+compile_kernel_args() {
+	local ARGS
+
+	ARGS=''
+	if [ "${KERNEL_CROSS_COMPILE}" != '' ]
+	then
+		ARGS="${ARGS} CROSS_COMPILE=\"${KERNEL_CROSS_COMPILE}\""
+	else
+		if [ "${KERNEL_CC}" != '' ]
+		then
+			ARGS="CC=\"${KERNEL_CC}\""
+		fi
+		if [ "${KERNEL_LD}" != '' ]
+		then
+			ARGS="${ARGS} LD=\"${KERNEL_LD}\""
+		fi
+		if [ "${KERNEL_AS}" != '' ]
+		then
+			ARGS="${ARGS} AS=\"${KERNEL_AS}\""
+		fi
+	fi
+	echo -n "${ARGS}"
+}
+
+compile_utils_args()
+{
+	local ARGS
+
+	ARGS=''
+	if [ "${UTILS_ARCH}" != '' ]
+	then
+		ARGS="ARCH=\"${UTILS_ARCH}\""
+	fi
+	if [ "${UTILS_CC}" != '' ]
+	then
+		ARGS="CC=\"${UTILS_CC}\""
+	fi
+	if [ "${UTILS_LD}" != '' ]
+	then
+		ARGS="${ARGS} LD=\"${UTILS_LD}\""
+	fi
+	if [ "${UTILS_AS}" != '' ]
+	then
+		ARGS="${ARGS} AS=\"${UTILS_AS}\""
+	fi
+
+	echo -n "${ARGS}"
+}
+
+export_utils_args()
+{
+	save_args
+	if [ "${UTILS_ARCH}" != '' ]
+	then
+		export ARCH="${UTILS_ARCH}"
+	fi
+	if [ "${UTILS_CC}" != '' ]
+	then
+		export CC="${UTILS_CC}"
+	fi
+	if [ "${UTILS_LD}" != '' ]
+	then
+		export LD="${UTILS_LD}"
+	fi
+	if [ "${UTILS_AS}" != '' ]
+	then
+		export AS="${UTILS_AS}"
+	fi
+}
+
+unset_utils_args()
+{
+	if [ "${UTILS_ARCH}" != '' ]
+	then
+		unset ARCH
+	fi
+	if [ "${UTILS_CC}" != '' ]
+	then
+		unset CC
+	fi
+	if [ "${UTILS_LD}" != '' ]
+	then
+		unset LD
+	fi
+	if [ "${UTILS_AS}" != '' ]
+	then
+		unset AS
+	fi
+	reset_args
+}
+
+export_kernel_args()
+{
+	if [ "${KERNEL_CC}" != '' ]
+	then
+		export CC="${KERNEL_CC}"
+	fi
+	if [ "${KERNEL_LD}" != '' ]
+	then
+		export LD="${KERNEL_LD}"
+	fi
+	if [ "${KERNEL_AS}" != '' ]
+	then
+		export AS="${KERNEL_AS}"
+	fi
+	if [ "${KERNEL_CROSS_COMPILE}" != '' ]
+	then
+		export CROSS_COMPILE="${KERNEL_CROSS_COMPILE}"
+	fi
+}
+
+unset_kernel_args()
+{
+	if [ "${KERNEL_CC}" != '' ]
+	then
+		unset CC
+	fi
+	if [ "${KERNEL_LD}" != '' ]
+	then
+		unset LD
+	fi
+	if [ "${KERNEL_AS}" != '' ]
+	then
+		unset AS
+	fi
+	if [ "${KERNEL_CROSS_COMPILE}" != '' ]
+	then
+		unset CROSS_COMPILE
+	fi
+}
+save_args()
+{
+	if [ "${ARCH}" != '' ]
+	then
+		export ORIG_ARCH="${ARCH}"
+	fi
+	if [ "${CC}" != '' ]
+	then
+		export ORIG_CC="${CC}"
+	fi
+	if [ "${LD}" != '' ]
+	then
+		export ORIG_LD="${LD}"
+	fi
+	if [ "${AS}" != '' ]
+	then
+		export ORIG_AS="${AS}"
+	fi
+	if [ "${CROSS_COMPILE}" != '' ]
+	then
+		export ORIG_CROSS_COMPILE="${CROSS_COMPILE}"
+	fi
+}
+reset_args()
+{
+	if [ "${ORIG_ARCH}" != '' ]
+	then
+		export ARCH="${ORIG_ARCH}"
+		unset ORIG_ARCH
+	fi
+	if [ "${ORIG_CC}" != '' ]
+	then
+		export CC="${ORIG_CC}"
+		unset ORIG_CC
+	fi
+	if [ "${ORIG_LD}" != '' ]
+	then
+		export LD="${ORIG_LD}"
+		unset ORIG_LD
+	fi
+	if [ "${ORIG_AS}" != '' ]
+	then
+		export AS="${ORIG_AS}"
+		unset ORIG_AS
+	fi
+	if [ "${ORIG_CROSS_COMPILE}" != '' ]
+	then
+		export CROSS_COMPILE="${ORIG_CROSS_COMPILE}"
+		unset ORIG_CROSS_COMPILE
+	fi
+}
+
+
+compile_generic() {
+	local RET
+	[ "$#" -lt '2' ] &&
+		gen_die 'compile_generic(): improper usage!'
+	local target=${1}
+	local argstype=${2}
+
+	if [ "${argstype}" = 'kernel' ] || [ "${argstype}" = 'runtask' ]
+	then
+		export_kernel_args
+		MAKE=${KERNEL_MAKE}
+	elif [ "${2}" = 'utils' ]
+	then
+		export_utils_args
+		MAKE=${UTILS_MAKE}
+	fi
+	case "${argstype}" in
+		kernel) ARGS="`compile_kernel_args`" ;;
+		utils) ARGS="`compile_utils_args`" ;;
+		*) ARGS="" ;; # includes runtask
+	esac
+	shift 2
+
+	# the eval usage is needed in the next set of code
+	# as ARGS can contain spaces and quotes, eg:
+	# ARGS='CC="ccache gcc"'
+	if [ "${argstype}" == 'runtask' ]
+	then
+		print_info 2 "COMMAND: ${MAKE} ${MAKEOPTS/-j?/j1} ${ARGS} ${target} $*" 1 0 1
+		eval ${MAKE} -s ${MAKEOPTS/-j?/-j1} "${ARGS}" ${target} $*
+		RET=$?
+	elif [ "${LOGLEVEL}" -gt "1" ]
+	then
+		# Output to stdout and logfile
+		print_info 2 "COMMAND: ${MAKE} ${MAKEOPTS} ${ARGS} ${target} $*" 1 0 1
+		eval ${MAKE} ${MAKEOPTS} ${ARGS} ${target} $* 2>&1 | tee -a ${LOGFILE}
+		RET=${PIPESTATUS[0]}
+	else
+		# Output to logfile only
+		print_info 2 "COMMAND: ${MAKE} ${MAKEOPTS} ${ARGS} ${1} $*" 1 0 1
+		eval ${MAKE} ${MAKEOPTS} ${ARGS} ${target} $* >> ${LOGFILE} 2>&1
+		RET=$?
+	fi
+	[ "${RET}" -ne '0' ] &&
+		gen_die "Failed to compile the \"${target}\" target..."
+
+	unset MAKE
+	unset ARGS
+	if [ "${argstype}" = 'kernel' ]
+	then
+		unset_kernel_args
+	elif [ "${argstype}" = 'utils' ]
+	then
+		unset_utils_args
+	fi
+}
+
+extract_dietlibc_bincache() {
+	cd "${TEMP}"
+	rm -rf "${TEMP}/diet" > /dev/null
+	/bin/tar -jxpf "${DIETLIBC_BINCACHE}" ||
+		gen_die 'Could not extract dietlibc bincache!'
+	[ ! -d "${TEMP}/diet" ] &&
+		gen_die "${TEMP}/diet directory not found!"
+	cd - > /dev/null
+}
+
+clean_dietlibc_bincache() {
+	cd "${TEMP}"
+	rm -rf "${TEMP}/diet" > /dev/null
+	cd - > /dev/null
+}
+
+compile_dep() {
+	# Only run ``make dep'' for 2.4 kernels
+	if [ "${VER}" -eq '2' -a "${KERN_24}" -eq '1' ]
+	then
+		print_info 1 "kernel: >> Making dependencies..."
+		cd ${KERNEL_DIR}
+		compile_generic dep kernel
+	fi
+}
+
+compile_modules() {
+	print_info 1 "        >> Compiling ${KV} modules..."
+	cd ${KERNEL_DIR}
+	compile_generic modules kernel
+	export UNAME_MACHINE="${ARCH}"
+	# On 2.4 kernels, if MAKEOPTS > -j1 it can cause failures
+	if [ "${VER}" -eq '2' -a "${KERN_24}" -eq '1' ]
+	then
+		MAKEOPTS_SAVE="${MAKEOPTS}"
+		MAKEOPTS="${MAKEOPTS_SAVE/-j?/-j1}"
+	fi
+	[ "${INSTALL_MOD_PATH}" != '' ] && export INSTALL_MOD_PATH
+	compile_generic "modules_install" kernel
+	[ "${VER}" -eq '2' -a "${KERN_24}" -eq '1' ] && MAKEOPTS="${MAKEOPTS_SAVE}"
+	export MAKEOPTS
+	unset UNAME_MACHINE
+}
+
+compile_kernel() {
+	[ "${KERNEL_MAKE}" = '' ] &&
+		gen_die "KERNEL_MAKE undefined - I don't know how to compile a kernel for this arch!"
+	cd ${KERNEL_DIR}
+	print_info 1 "        >> Compiling ${KV} ${KERNEL_MAKE_DIRECTIVE/_install/ [ install ]/}..."
+	compile_generic "${KERNEL_MAKE_DIRECTIVE}" kernel
+	if [ "${KERNEL_MAKE_DIRECTIVE_2}" != '' ]
+	then
+		print_info 1 "        >> Starting supplimental compile of ${KV}: ${KERNEL_MAKE_DIRECTIVE_2}..."
+		compile_generic "${KERNEL_MAKE_DIRECTIVE_2}" kernel
+	fi
+	if ! isTrue "${CMD_NOINSTALL}"
+	then
+		copy_image_with_preserve "kernel" \
+			"${KERNEL_BINARY}" \
+			"kernel-${KNAME}-${ARCH}-${KV}"
+
+		copy_image_with_preserve "System.map" \
+			"System.map" \
+			"System.map-${KNAME}-${ARCH}-${KV}"
+
+		if [ "${ENABLE_PEGASOS_HACKS}" = 'yes' ]
+		then
+			copy_image_with_preserve "kernelz" \
+				"${KERNEL_BINARY_2}" \
+				"kernelz-${KV}"
+		fi
+	else
+		cp "${KERNEL_BINARY}" "${TMPDIR}/kernel-${KNAME}-${ARCH}-${KV}" ||
+			gen_die "Could not copy the kernel binary to ${TMPDIR}!"
+		cp "System.map" "${TMPDIR}/System.map-${KNAME}-${ARCH}-${KV}" ||
+			gen_die "Could not copy System.map to ${TMPDIR}!"
+		if [ "${ENABLE_PEGASOS_HACKS}" = 'yes' ]
+		then
+			cp "${KERNEL_BINARY_2}" "${TMPDIR}/kernelz-${KV}" ||
+				gen_die "Could not copy the kernelz binary to ${TMPDIR}!"
+		fi
+	fi
+}
+
+compile_unionfs_modules() {
+	if [ ! -f "${UNIONFS_MODULES_BINCACHE}" ]
+	then
+		[ -f "${UNIONFS_SRCTAR}" ] ||
+			gen_die "Could not find unionfs source tarball: ${UNIONFS_SRCTAR}!"
+		cd "${TEMP}"
+		rm -rf ${UNIONFS_DIR} > /dev/null
+		rm -rf unionfs* > /dev/null
+		mkdir unionfs
+		/bin/tar xzpf ${UNIONFS_SRCTAR} ||
+			gen_die 'Could not extract unionfs source tarball!'
+		[ -d "${UNIONFS_DIR}" ] ||
+			gen_die 'Unionfs directory ${UNIONFS_DIR} is invalid!'
+		cd "${UNIONFS_DIR}"
+		print_info 1 'unionfs modules: >> Compiling...'
+		echo "LINUXSRC=${KERNEL_DIR}" >> fistdev.mk
+		echo 'TOPINC=-I$(LINUXSRC)/include' >> fistdev.mk
+		echo "MODDIR= /lib/modules/${KV}" >> fistdev.mk
+		echo "KVERS=${KV}" >> fistdev.mk
+		echo "KERNELVERSION=${KV}" >> fistdev.mk
+		# Fix for hardened/selinux systems to have extened attributes
+		# per r2d2's request.  Also add -DUNIONFS_UNSUPPORTED for 2.6.16
+		echo "EXTRACFLAGS=-DUNIONFS_XATTR -DFIST_SETXATTR_CONSTVOID -DUNIONFS_UNSUPPORTED" \
+			>> fistdev.mk
+		# Here we do something really nasty and disable debugging, along with
+		# change our default CFLAGS
+		echo "UNIONFS_DEBUG_CFLAG=-DUNIONFS_NDEBUG" >> fistdev.mk
+		echo "UNIONFS_OPT_CFLAG= -O2 -pipe" >> fistdev.mk
+
+		if [ "${PAT}" -ge '6' ]
+		then
+			# ARCH is used by unionfs - and conflicts with genkernel
+			ARCH_PUSH=${ARCH}
+			unset ARCH
+			# Compile unionfs module within the unionfs
+			# environment not within the kernelsrc dir
+			make unionfs.ko || gen_die 'failed to compile unionfs'
+			ARCH=${ARCH_PUSH}
+		else
+			gen_die 'unionfs is only supported on 2.6 targets'
+		fi
+		print_info 1 'unionfs: >> Copying to cache...'
+	
+		mkdir -p ${TEMP}/unionfs/lib/modules/${KV}/kernel/fs/unionfs
+		
+		if [ -f unionfs.ko ]
+		then 
+			cp -f unionfs.ko ${TEMP}/unionfs/lib/modules/${KV}/kernel/fs/unionfs
+		else
+			cp -f unionfs.o ${TEMP}/unionfs/lib/modules/${KV}/kernel/fs/unionfs
+ 		fi
+	
+		cd ${TEMP}/unionfs
+		/bin/tar -cjf "${UNIONFS_MODULES_BINCACHE}" . ||
+			gen_die 'Could not create unionfs modules binary cache'
+	
+		cd "${TEMP}"
+		rm -rf "${UNIONFS_DIR}" > /dev/null
+		rm -rf unionfs > /dev/null
+	fi
+}
+
+compile_unionfs_utils() {
+	if [ ! -f "${UNIONFS_BINCACHE}" ]
+	then
+		[ -f "${UNIONFS_SRCTAR}" ] ||
+			gen_die "Could not find unionfs source tarball: ${UNIONFS_SRCTAR}!"
+		cd "${TEMP}"
+		rm -rf ${UNIONFS_DIR} > /dev/null
+		rm -rf unionfs* > /dev/null
+		mkdir -p unionfs/sbin
+		/bin/tar -zxpf ${UNIONFS_SRCTAR} ||
+			gen_die 'Could not extract unionfs source tarball!'
+		[ -d "${UNIONFS_DIR}" ] ||
+			gen_die 'Unionfs directory ${UNIONFS_DIR} is invalid!'
+		cd "${UNIONFS_DIR}"
+		print_info 1 'unionfs tools: >> Compiling...'
+		sed -i utils/Makefile -e 's|${CC} -o|${CC} -static -o|g'
+		sed -i Makefile -e 's|${CC} -o|${CC} -static -o|g'
+		compile_generic utils utils
+
+		if [ ! -e "uniondbg" ]; then
+			cd utils
+		fi
+		print_info 1 'unionfs: >> Copying to cache...'
+		strip uniondbg unionctl
+		cp uniondbg ${TEMP}/unionfs/sbin/ || 
+			gen_die 'Could not copy the uniondbg binary to the tmp directory'
+		cp unionctl ${TEMP}/unionfs/sbin/ ||
+			gen_die 'Could not copy the unionctl binary to the tmp directory'
+		cd ${TEMP}/unionfs
+		/bin/tar -cjf "${UNIONFS_BINCACHE}" . ||
+			gen_die 'Could not create unionfs tools binary cache'
+		
+		cd "${TEMP}"
+		rm -rf "${UNIONFS_DIR}" > /dev/null
+		rm -rf unionfs > /dev/null
+	fi
+}
+
+compile_busybox() {
+	[ -f "${BUSYBOX_SRCTAR}" ] ||
+		gen_die "Could not find busybox source tarball: ${BUSYBOX_SRCTAR}!"
+	[ -f "${BUSYBOX_CONFIG}" ] ||
+		gen_die "Cound not find busybox config file: ${BUSYBOX_CONFIG}!"
+	cd "${TEMP}"
+	rm -rf "${BUSYBOX_DIR}" > /dev/null
+	/bin/tar -jxpf ${BUSYBOX_SRCTAR} ||
+		gen_die 'Could not extract busybox source tarball!'
+	[ -d "${BUSYBOX_DIR}" ] ||
+		gen_die 'Busybox directory ${BUSYBOX_DIR} is invalid!'
+	cp "${BUSYBOX_CONFIG}" "${BUSYBOX_DIR}/.config"
+	sed -i ${BUSYBOX_DIR}/.config -e 's/#\? \?CONFIG_FEATURE_INSTALLER[ =].*/CONFIG_FEATURE_INSTALLER=y/g'
+	cd "${BUSYBOX_DIR}"
+	patch -p1 < "${GK_SHARE}/pkg/busybox-1.1.3+gentoo-mdadm.patch"
+	print_info 1 'busybox: >> Configuring...'
+	yes '' 2>/dev/null | compile_generic oldconfig utils
+
+	# Delete cache if stored config's MD5 does not match one to be used
+	if [ -f "${BUSYBOX_BINCACHE}" -a -f "${BUSYBOX_CONFIG}" ]
+	then
+		oldconfig_md5=$(tar -xjf "${BUSYBOX_BINCACHE}" -O .config | md5sum)
+		newconfig_md5=$(md5sum < .config)
+		if [ "${oldconfig_md5}" != "${newconfig_md5}" ]
+		then
+			print_info 1 "busybox: >> Removing stale cache..."
+			rm -rf "${BUSYBOX_BINCACHE}"
+		else
+			print_info 1 "busybox: >> Using cache"
+		fi
+	fi
+
+	if [ ! -f "${BUSYBOX_BINCACHE}" ]
+	then
+		print_info 1 'busybox: >> Compiling...'
+		compile_generic all utils
+		print_info 1 'busybox: >> Copying to cache...'
+		[ -f "${TEMP}/${BUSYBOX_DIR}/busybox" ] ||
+			gen_die 'Busybox executable does not exist!'
+		strip "${TEMP}/${BUSYBOX_DIR}/busybox" ||
+			gen_die 'Could not strip busybox binary!'
+		tar -cj -C "${TEMP}/${BUSYBOX_DIR}" -f "${BUSYBOX_BINCACHE}" busybox .config ||
+			gen_die 'Could not create the busybox bincache!'
+	fi
+
+	cd "${TEMP}"
+	rm -rf "${BUSYBOX_DIR}" > /dev/null
+}
+
+compile_lvm() {
+	compile_device_mapper
+	if [ ! -f "${LVM_BINCACHE}" ]
+	then
+		[ -f "${LVM_SRCTAR}" ] ||
+			gen_die "Could not find LVM source tarball: ${LVM_SRCTAR}! Please place it there, or place another version, changing /etc/genkernel.conf as necessary!"
+		cd "${TEMP}"
+		rm -rf ${LVM_DIR} > /dev/null
+		/bin/tar -zxpf ${LVM_SRCTAR} ||
+			gen_die 'Could not extract LVM source tarball!'
+		[ -d "${LVM_DIR}" ] ||
+			gen_die 'LVM directory ${LVM_DIR} is invalid!'
+		rm -rf "${TEMP}/device-mapper" > /dev/null
+		/bin/tar -jxpf "${DEVICE_MAPPER_BINCACHE}" -C "${TEMP}" ||
+			gen_die "Could not extract device-mapper binary cache!";
+		
+		cd "${LVM_DIR}"
+		print_info 1 'lvm: >> Configuring...'
+			LDFLAGS="-L${TEMP}/device-mapper/lib" \
+			CFLAGS="-I${TEMP}/device-mapper/include" \
+			CPPFLAGS="-I${TEMP}/device-mapper/include" \
+			./configure --enable-static_link --prefix=${TEMP}/lvm >> ${LOGFILE} 2>&1 ||
+				gen_die 'Configure of lvm failed!'
+		print_info 1 'lvm: >> Compiling...'
+			compile_generic '' utils
+			compile_generic 'install' utils
+
+		cd "${TEMP}/lvm"
+		print_info 1 '      >> Copying to bincache...'
+		strip "sbin/lvm.static" ||
+			gen_die 'Could not strip lvm.static!'
+		/bin/tar -cjf "${LVM_BINCACHE}" sbin/lvm.static ||
+			gen_die 'Could not create binary cache'
+
+		cd "${TEMP}"
+		rm -rf "${TEMP}/device-mapper" > /dev/null
+		rm -rf "${LVM_DIR}" lvm
+	fi
+}
+
+compile_dmraid() {
+	compile_device_mapper
+	if [ ! -f "${DMRAID_BINCACHE}" ]
+	then
+		[ -f "${DMRAID_SRCTAR}" ] ||
+			gen_die "Could not find DMRAID source tarball: ${DMRAID_SRCTAR}! Please place it there, or place another version, changing /etc/genkernel.conf as necessary!"
+		cd "${TEMP}"
+		rm -rf ${DMRAID_DIR} > /dev/null
+		/bin/tar -jxpf ${DMRAID_SRCTAR} ||
+			gen_die 'Could not extract DMRAID source tarball!'
+		[ -d "${DMRAID_DIR}" ] ||
+			gen_die 'DMRAID directory ${DMRAID_DIR} is invalid!'
+		rm -rf "${TEMP}/device-mapper" > /dev/null
+		/bin/tar -jxpf "${DEVICE_MAPPER_BINCACHE}" -C "${TEMP}" ||
+			gen_die "Could not extract device-mapper binary cache!";
+		
+		cd "${DMRAID_DIR}"
+		print_info 1 'dmraid: >> Configuring...'
+		
+		LDFLAGS="-L${TEMP}/device-mapper/lib" \
+		CFLAGS="-I${TEMP}/device-mapper/include" \
+		CPPFLAGS="-I${TEMP}/device-mapper/include" \
+		./configure --enable-static_link --prefix=${TEMP}/dmraid >> ${LOGFILE} 2>&1 ||
+			gen_die 'Configure of dmraid failed!'
+
+		# We dont necessarily have selinux installed yet... look into
+		# selinux global support in the future.
+		sed -i tools/Makefile -e "s|DMRAIDLIBS += -lselinux||g"
+		###echo "DMRAIDLIBS += -lselinux -lsepol" >> tools/Makefile
+		mkdir -p "${TEMP}/dmraid"
+		print_info 1 'dmraid: >> Compiling...'
+		compile_generic '' utils
+		#compile_generic 'install' utils
+		mkdir ${TEMP}/dmraid/sbin
+		install -m 0755 -s tools/dmraid "${TEMP}/dmraid/sbin/dmraid"
+		print_info 1 '      >> Copying to bincache...'
+		cd "${TEMP}/dmraid"
+		/bin/tar -cjf "${DMRAID_BINCACHE}" sbin/dmraid ||
+			gen_die 'Could not create binary cache'
+
+		cd "${TEMP}"
+		rm -rf "${TEMP}/device-mapper" > /dev/null
+		rm -rf "${DMRAID_DIR}" dmraid
+	fi
+}
+
+compile_devfsd() {
+	local ARGS
+	if [ ! -f "${DEVFSD_BINCACHE}" ]
+	then
+		[ ! -f "${DEVFSD_SRCTAR}" ] &&
+			gen_die "Could not find devfsd source tarball: ${DEVFSD_SRCTAR}"
+		cd "${TEMP}"
+		rm -rf "${DEVFSD_DIR}"
+		/bin/tar -jxpf "${DEVFSD_SRCTAR}"
+		[ ! -d "${DEVFSD_DIR}" ] &&
+			gen_die "Devfsd directory ${DEVFSD_DIR} invalid"
+		cd "${DEVFSD_DIR}"
+
+		print_info 1 'devfsd: >> Compiling...'
+		compile_generic 'LDFLAGS=-static' utils
+
+		print_info 1 '        >> Copying to cache...'
+		[ -f "${TEMP}/${DEVFSD_DIR}/devfsd" ] || gen_die 'The devfsd executable does not exist after the compilation of devfsd!'
+		strip "${TEMP}/${DEVFSD_DIR}/devfsd" || gen_die 'Could not strip devfsd!'
+		bzip2 "${TEMP}/${DEVFSD_DIR}/devfsd" || gen_die 'Compression of devfsd failed!'
+		[ -f "${TEMP}/${DEVFSD_DIR}/devfsd.bz2" ] || gen_die 'Could not find compressed devfsd.bz2 binary!'
+		mv "${TEMP}/${DEVFSD_DIR}/devfsd.bz2" "${DEVFSD_BINCACHE}" || gen_die 'Could not move compressed binary to the package cache!'
+
+		cd "${TEMP}"
+		rm -rf "${DEVFSD_DIR}" > /dev/null
+	fi
+}
+
+compile_device_mapper() {
+	if [ ! -f "${DEVICE_MAPPER_BINCACHE}" ]
+	then
+		[ ! -f "${DEVICE_MAPPER_SRCTAR}" ] &&
+			gen_die "Could not find device-mapper source tarball: ${DEVICE_MAPPER_SRCTAR}. Please place it there, or place another version, changing /etc/genkernel.conf as necessary!"
+		cd "${TEMP}"
+		rm -rf "${DEVICE_MAPPER_DIR}"
+		/bin/tar -zxpf "${DEVICE_MAPPER_SRCTAR}"
+		[ ! -d "${DEVICE_MAPPER_DIR}" ] &&
+			gen_die "device-mapper directory ${DEVICE_MAPPER_DIR} invalid"
+		cd "${DEVICE_MAPPER_DIR}"
+		./configure --prefix=${TEMP}/device-mapper --enable-static_link \
+			--disable-selinux >> ${LOGFILE} 2>&1 ||
+			gen_die 'Configuring device-mapper failed!'
+		print_info 1 'device-mapper: >> Compiling...'
+		compile_generic '' utils
+		compile_generic 'install' utils
+		print_info 1 '        >> Copying to cache...'
+		cd "${TEMP}"
+		rm -rf "${TEMP}/device-mapper/man" ||
+			gen_die 'Could not remove manual pages!'
+		strip "${TEMP}/device-mapper/sbin/dmsetup" ||
+			gen_die 'Could not strip dmsetup binary!'
+		/bin/tar -jcpf "${DEVICE_MAPPER_BINCACHE}" device-mapper ||
+			gen_die 'Could not tar up the device-mapper binary!'
+		[ -f "${DEVICE_MAPPER_BINCACHE}" ] ||
+			gen_die 'device-mapper cache not created!'
+		cd "${TEMP}"
+		rm -rf "${DEVICE_MAPPER_DIR}" > /dev/null
+		rm -rf "${TEMP}/device-mapper" > /dev/null
+	fi
+}
+
+compile_e2fsprogs() {
+	if [ ! -f "${BLKID_BINCACHE}" ]
+	then
+		[ ! -f "${E2FSPROGS_SRCTAR}" ] &&
+			gen_die "Could not find e2fsprogs source tarball: ${E2FSPROGS_SRCTAR}. Please place it there, or place another version, changing /etc/genkernel.conf as necessary!"
+		cd "${TEMP}"
+		rm -rf "${E2FSPROGS_DIR}"
+		tar -zxpf "${E2FSPROGS_SRCTAR}"
+		[ ! -d "${E2FSPROGS_DIR}" ] &&
+			gen_die "e2fsprogs directory ${E2FSPROGS_DIR} invalid"
+		cd "${E2FSPROGS_DIR}"
+		print_info 1 'e2fsprogs: >> Configuring...'
+		./configure  --with-ldopts=-static >> ${LOGFILE} 2>&1 ||
+			gen_die 'Configuring e2fsprogs failed!'
+		print_info 1 'e2fsprogs: >> Compiling...'
+		MAKE=${UTILS_MAKE} compile_generic "" ""
+		print_info 1 'blkid: >> Copying to cache...'
+		[ -f "${TEMP}/${E2FSPROGS_DIR}/misc/blkid" ] ||
+			gen_die 'Blkid executable does not exist!'
+		strip "${TEMP}/${E2FSPROGS_DIR}/misc/blkid" ||
+			gen_die 'Could not strip blkid binary!'
+		bzip2 "${TEMP}/${E2FSPROGS_DIR}/misc/blkid" ||
+			gen_die 'bzip2 compression of blkid failed!'
+		mv "${TEMP}/${E2FSPROGS_DIR}/misc/blkid.bz2" "${BLKID_BINCACHE}" ||
+			gen_die 'Could not copy the blkid binary to the package directory, does the directory exist?'
+
+		cd "${TEMP}"
+		rm -rf "${E2FSPROGS_DIR}" > /dev/null
+	fi
+}
diff -Nurp genkernel-3.4.9_pre9.orig/generic/initrd.scripts genkernel-3.4.9_pre9/generic/initrd.scripts
--- genkernel-3.4.9_pre9.orig/generic/initrd.scripts	2007-11-14 00:09:21.000000000 +0100
+++ genkernel-3.4.9_pre9/generic/initrd.scripts	2007-11-15 12:12:21.000000000 +0100
@@ -186,13 +186,10 @@ mount_sysfs() {
 # $1 = union absolute path (starting with /)
 # $2 = path to data directory
 #
-union_insert_dir() {
-	# detect branch 0 because newer unionfs doesn't support "0,1,2"
-	BRANCH_0="/"$(/sbin/unionctl $1 --list | cut -d/ -f2- | cut -d'(' -f1)
-	/sbin/unionctl $1 --add --after $BRANCH_0 --mode ro $2
-	if [ $? = '0' ]
-	then
-		good_msg "Addition of $2 to $1 after branch $BRANCH_0 successful"
+union_setup_dir() {
+	mount -t unionfs -o dirs=$1=rw:$2=ro none $1
+	if [ "$?" -eq '0' ]; then
+		good_msg "Addition of $2 to $1 after"
 	fi
 }
 
@@ -806,54 +803,10 @@ setup_unionfs() {
 	then
 		# Directory used for rw changes in union mount filesystem
 		UNION=/union
-		MEMORY=/memory
-		if [ -z "$UID" ]
-		then
-			CHANGES=$MEMORY/unionfs_changes/default
-		else
-			CHANGES=$MEMORY/unionfs_changes/$UID
-		fi
-
-		mkdir -p ${MEMORY}
 		mkdir -p ${UNION}
+		mount -t tmpfs none ${UNION}
 		good_msg "Loading unionfs module"
 		modprobe unionfs > /dev/null 2>&1
-		if [ -n "${UNIONFS}" ]
-		then
-			CHANGESDEV=${UNIONFS}
-			good_msg "mounting $CHANGESDEV to $MEMORY for unionfs support"
-			mount -t auto $CHANGESDEV $MEMORY
-			# mount tmpfs only in the case when changes= boot parameter was
-			# empty or we were not able to mount the storage device
-			ret=$?
-			if [ "${ret}" -ne 0 ]
-			then
-				bad_msg "mount of $CHANGESDEV failed falling back to ramdisk based unionfs"
-				mount -t tmpfs tmpfs $MEMORY
-			fi
-			if [ "${CDROOT}" -eq '1' -a ! -f ${MEMORY}/livecd.unionfs  ]
-			then
-				umount $MEMORY
-				bad_msg "failed to find livecd.unionfs file on $CHANGESDEV"
-				bad_msg "create a livecd.unionfs file on this device if you wish to use it for unionfs"
-				bad_msg "falling back to ramdisk based unionfs for safety"
-				mount -t tmpfs tmpfs $MEMORY
-			fi
-		else 
-			good_msg "Mounting ramdisk to $MEMORY for unionfs support..."
-			mount -t tmpfs tmpfs $MEMORY 
-		fi 
-
-		mkdir -p $CHANGES 
-		mount -t unionfs -o dirs=$CHANGES=rw unionfs ${UNION}
-		ret=$?
-		if [ "${ret}" -ne 0 ]
-		then 
-			bad_msg "Can't setup union ${UNION} in directory!"
-			USE_UNIONFS_NORMAL=0
-		fi
-	else
-		USE_UNIONFS_NORMAL=0
 	fi
 }
 
diff -Nurp genkernel-3.4.9_pre9.orig/generic/initrd.scripts.orig genkernel-3.4.9_pre9/generic/initrd.scripts.orig
--- genkernel-3.4.9_pre9.orig/generic/initrd.scripts.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre9/generic/initrd.scripts.orig	2007-11-14 00:09:21.000000000 +0100
@@ -0,0 +1,899 @@
+#!/bin/ash
+
+. /etc/initrd.defaults
+
+backup() {
+	echo -ne "\033[0G\033[0K"
+}
+
+strlen() {
+	if [ -z "$1" ]
+	then
+		echo "usage: strlen <variable_name>"
+		die
+	fi
+	eval echo "\${#${1}}"
+}
+
+parse_opt() {
+	case "$1" in
+		*\=*)
+			local key_name="`echo "$1" | cut -f1 -d=`"
+			local key_len=`strlen key_name`
+			local value_start=$((key_len+2))
+			echo "$1" | cut -c ${value_start}-
+		;;
+	esac
+}
+
+modules_load() {
+	for module in $*
+	do
+		echo ${module} >> /etc/modules/extra_load
+	done
+
+	modules_scan extra_load
+}
+
+modules_scan() {
+	local MODS
+	[ -d /etc/modules/${1} ] || touch /etc/modules/${1}
+
+	[ -f /etc/modules/${1} ] && MODS=`cat /etc/modules/${1}`
+	for x in ${MODS}
+	do
+		MLOAD=`echo ${MLIST} | sed -e "s/.*${x}.*/${x}/"`
+		if [ "${MLOAD}" = "${x}" ] # Only module to no-load
+		then
+			echo -e "${BOLD}   ::${NORMAL} Skipping ${x}..."
+		elif [ "${MLOAD}" = "${MLIST}" ] # == No change == No specified no-load
+		then
+			[ -n "${DEBUG}" ] && echo -ne "${BOLD}   ::${NORMAL} Checking for ${x}..."
+			# find -name does not work since the return status is always zero
+			if find /lib/modules | grep /"${x}${KSUFF}" >/dev/null 2>&1
+			then
+				echo -ne "${BOLD}   ::${NORMAL} Scanning for ${x}..."
+				modprobe ${x} -n
+				backup
+				echo -ne "${NORMAL}"
+			fi
+		else
+			echo -e "${BOLD}   ::${NORMAL} Skipping ${x}..."
+		fi
+	done
+}
+
+findcdmount() {
+	if [ "$#" -gt "0" ]
+	then
+		for x in $*
+		do
+			# Check for a block device to mount
+			if [ -b "${x}" ]
+			then
+				good_msg "Attempting to mount media:- ${x}"
+				if [ -z "${CDROOT_DEV}" ]
+				then
+					mount -r -t auto ${x} ${NEW_ROOT}/mnt/cdrom \
+						> /dev/null 2>&1
+				else
+					mount -r -t iso9660 ${x} ${NEW_ROOT}/mnt/cdrom \
+						> /dev/null 2>&1
+				fi
+				if [ "$?" = '0' ]
+				then
+					# Check for a LiveCD
+					if [ -f ${NEW_ROOT}/mnt/cdrom/${SUBDIR}/livecd ]
+					then
+						REAL_ROOT="${x}"
+						break
+					else
+						umount ${NEW_ROOT}/mnt/cdrom
+					fi
+				fi
+			fi
+		done
+		if [ "${REAL_ROOT}" != '' ]
+		then
+			good_msg "Media found on ${x}"
+		fi
+	fi
+}
+
+findkeymount() {
+        if [ "$#" -gt "0" ]
+        then
+                for x in $*
+                do
+                        # Check for a block device to mount
+                        if [ -b "${x}" ]
+                        then
+				if [ ${crypt_silent} = '' ]
+				then
+	                                good_msg "Attempting to mount key media:- ${x}"
+				fi
+
+                                mount -r -t auto ${x} ${NEW_ROOT}/mnt/keydev \
+                                                > /dev/null 2>&1
+                                if [ "$?" = '0' ]
+                                then
+                                        # Check for the key
+                                        if [ -e ${NEW_ROOT}/mnt/keydev/${LUKS_ROOT_KEY} ]
+                                        then
+                                                LUKS_ROOT_KEYDEV="${x}"
+						umount ${NEW_ROOT}/mnt/keydev
+                                                break
+                                        else
+                                                umount ${NEW_ROOT}/mnt/keydev
+                                        fi
+                                fi
+                        fi
+                done
+                if [ "${LUKS_ROOT_KEYDEV}" != '' ]
+                then
+			if [ ${crypt_silent} = '' ]
+			then
+	                        good_msg "Key media found on ${x}"
+			fi
+                fi
+        fi
+}
+
+
+cache_cd_contents() {
+	# Check loop file exists and cache to ramdisk if DO_cache is enabled
+	if [ "${LOOPTYPE}" != "noloop" ] && [ "${LOOPTYPE}" != "sgimips" ]
+	then
+		check_loop
+		if [ "${DO_cache}" ]
+		then
+			# TODO: Check the size of the image versus the size of our tmpfs
+			# along with the amount of available RAM and increase tmpfs size
+			# if necessary. (Not having awk sucks...)
+			# z=0
+			# for i in $(cat /proc/meminfo | grep -e ^MemFree -e ^Cached | \
+			# cut -d: -f2 | cut -dk -f1 | sed -e "s/^\s*//") ; do
+			# z=$(($z + $i)) ; done
+			# echo $z
+			good_msg "Copying loop file for caching..."
+			cp -a ${NEW_ROOT}/mnt/cdrom/${LOOP} ${NEW_ROOT}/mnt/${LOOP}
+			if [ $? -ne 0 ]
+			then
+				bad_msg "Failed to cache the loop file! Lack of space?"
+				rm -rf ${NEW_ROOT}/mnt/livecd.* 2>/dev/null
+				rm -rf ${NEW_ROOT}/mnt/zisofs 2>/dev/null
+			else
+				LOOPEXT='../'
+			fi
+		fi
+	fi
+}
+
+mount_sysfs() {
+	if [ "${KV_2_6_OR_GREATER}" ]
+	then
+		# Udev is semi-broken on non /sys sysfs mount points.
+		mount -t sysfs /sys /sys >/dev/null 2>&1
+		ret=$?
+	
+		# sysfs mount failed .. udev wont work fall back to devfs if available
+		[ "$ret" -eq '0' ] || USE_UDEV_NORMAL=0
+	fi
+}
+
+# Insert a directory tree $2 to an union specified by $1
+# Top-level read-write branch is specified by it's index 0
+# $1 = union absolute path (starting with /)
+# $2 = path to data directory
+#
+union_insert_dir() {
+	# detect branch 0 because newer unionfs doesn't support "0,1,2"
+	BRANCH_0="/"$(/sbin/unionctl $1 --list | cut -d/ -f2- | cut -d'(' -f1)
+	/sbin/unionctl $1 --add --after $BRANCH_0 --mode ro $2
+	if [ $? = '0' ]
+	then
+		good_msg "Addition of $2 to $1 after branch $BRANCH_0 successful"
+	fi
+}
+
+findnfsmount() {
+
+	if [ "${IP}" != '' ] || busybox udhcpc -R rootpath -n -s /bin/udhcpc.scripts
+	then
+		[ -e /rootpath ] && NFSROOT=`cat /rootpath`
+
+		if [ "${NFSROOT}" = '' ]
+		then
+			# Obtain NFSIP	
+			OPTIONS=`busybox dmesg | grep rootserver | sed -e "s/,/ /g"`
+			for OPTION in $OPTIONS
+			do
+				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootserver' ]
+				then
+					NFSIP=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`
+				fi 
+			done
+			
+			# Obtain NFSPATH
+			OPTIONS=`busybox dmesg | grep rootpath | sed -e "s/,/ /g"`	
+			for OPTION in $OPTIONS
+			do
+				if [ `echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 1` = 'rootpath' ]
+				then
+					NFSPATH=`echo $OPTION | sed -e "s/=/ /g" | cut -d " " -f 2`
+		 		fi
+			done
+
+			# Setup NFSROOT
+			if [ "${NFSIP}" != '' ] && [ "$NFSPATH" != '' ]
+			then
+				NFSROOT="${NFSIP}:${NFSPATH}"
+			else
+				bad_msg "The DHCP Server did not send a valid root-path."
+				bad_msg "Please check your DHCP setup, or provide a nfsroot=<...> parameter."
+			fi
+		fi
+
+		if [ "${NFSROOT}" != '' ]
+		then
+			if [ "${CDROOT}" != '0' ]
+			then
+				good_msg "Attempting to mount NFS CD image on ${NFSROOT}"
+				mount -t nfs -o ro,nolock,rsize=1024,wsize=1024 ${NFSROOT} ${NEW_ROOT}/mnt/cdrom
+				if [ "$?" = '0' ]
+				then
+					REAL_ROOT="/dev/nfs"
+				else
+					bad_msg "NFS Mounting failed. Is the path corrent ?"
+				fi
+			else	
+				good_msg "Attemping to mount NFS root on ${NFSROOT}"
+				mount -t nfs -o ro,nolock,rsize=1024,wsize=1024 ${NFSROOT} ${NEW_ROOT}
+				if [ "$?" = '0' ]
+				then
+					REAL_ROOT="/dev/nfs"
+				else
+					bad_msg "NFS Mounting failed. Is the path correct ?"
+				fi
+				# FIXME: Need to start portmap and the other rpc daemons in order to
+				# FIXME: remount rw.
+			fi
+
+		fi
+	fi
+}
+
+kill_devfsd() {
+	killall devfsd > /dev/null 2>&1
+}
+
+check_loop() {
+	if [ "${LOOP}" = '' -o ! -e "mnt/cdrom/${LOOP}" ]
+	then
+	
+		bad_msg "Invalid loop location: ${LOOP}"
+		bad_msg 'Please export LOOP with a valid location, or reboot and pass a proper loop=...'
+		bad_msg 'kernel command line!'
+	
+		run_shell
+	fi
+}
+
+run_shell() {
+	/bin/ash
+}
+
+runUdev() {
+	mount -t tmpfs -o size=100k udev /dev
+	mkdir /dev/pts
+	mkdir /dev/shm
+	echo  > /proc/sys/kernel/hotplug 
+	/sbin/udevd --daemon
+	mkdir -p /dev/.udev/queue
+	/sbin/udevtrigger
+
+	good_msg 'Letting udev process events'
+	loop=0
+	while test -d /dev/.udev/queue; do
+		sleep 1;
+		test "$loop" -gt 30 && break
+		loop=$(($loop + 1))
+	done
+	good_msg "Udev finished proccsing after $loop iterations"
+
+	killall udevd > /dev/null 2>&1
+	ln -snf /proc/self/fd /dev/fd
+	ln -snf /proc/self/fd/0 /dev/stdin
+	ln -snf /proc/self/fd/1 /dev/stdout
+	ln -snf /proc/self/fd/2 /dev/stderr
+	ln -snf /proc/kcore /dev/core
+}
+
+runmdev() {
+	# busybox udev replacement
+	mdev -s
+
+	# catch udev hotplug events
+	echo /sbin/mdev > /proc/sys/kernel/hotplug
+}
+
+test_success() {
+	error_string=$1
+	error_string="${error_string:-run command}"
+	# If last command failed send error message and fall back to a shell	
+	if [ "$?" != '0' ]
+	then
+		bad_msg 'Failed to $1; failing back to the shell...'
+		run_shell
+	fi
+}
+
+good_msg() {
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	echo -e "${GOOD}>>${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+}
+
+bad_msg() {
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	splash 'verbose' > /dev/null &
+	echo -e "${BAD}!!${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+} 
+
+warn_msg() {
+	msg_string=$1
+	msg_string="${msg_string:-...}"
+	echo -e "${WARN}**${NORMAL}${BOLD} ${msg_string} ${NORMAL}"
+} 
+
+bind_mount_dev() {
+	# bind-mount /dev/ so that loop devices can be found
+	mount -o bind ${NEW_ROOT}/dev /dev
+}
+
+start_dev_mgr() {
+	# Check udev is available...
+	if [ "${KV_2_6_OR_GREATER}" -a ! "${USE_UDEV_NORMAL}" -eq '0' ]
+	then
+		USE_UDEV_NORMAL=1
+	else
+		USE_UDEV_NORMAL=0
+	fi
+
+	if [ "${USE_UDEV_NORMAL}" -eq '1' ]
+	then
+		cd /sys
+		[ "${DO_slowusb}" ] && sleep 10
+		kill_devfsd
+		good_msg 'Activating mdev'
+#		runUdev
+		runmdev
+		[ "${DO_slowusb}" ] && sleep 20
+		cd /
+	else
+		good_msg 'Activating devfs'
+		mount -t devfs devfs /dev 2>/dev/null
+		devfsd /dev -np
+	fi
+}
+
+bootstrapCD() {
+	# Locate the cdrom device with our media on it.
+	# CDROM DEVICES
+	DEVICES="/dev/cdroms/* /dev/ide/cd/* /dev/sr*"
+	# USB Keychain/Storage
+	DEVICES="$DEVICES /dev/sd*"
+	# IDE devices
+	DEVICES="$DEVICES /dev/hd*"
+	# USB using the USB Block Driver
+	DEVICES="$DEVICES /dev/ubd* /dev/ubd/*"
+	# iSeries devices
+	DEVICES="$DEVICES /dev/iseries/vcd*"
+	# The device was specified on the command line.  Shold we even be doing a
+	# scan at this point?  I think not.
+	[ -n "${CDROOT_DEV}" ] && DEVICES="$DEVICES ${CDROOT_DEV}"
+
+	findcdmount $DEVICES
+}
+
+bootstrapKey() {
+        # Locate the device with our key on it.
+        # USB Keychain/Storage
+        KEYDEVS="/dev/sd*"
+        # CDROM DEVICES
+        KEYDEVS="${KEYDEVS} /dev/cdroms/* /dev/ide/cd/* /dev/sr*"
+        # IDE devices
+        KEYDEVS="${KEYDEVS} /dev/hd*"
+        # USB using the USB Block Driver
+        KEYDEVS="${KEYDEVS} /dev/ubd* /dev/ubd/*"
+        # iSeries devices
+        KEYDEVS="${KEYDEVs} /dev/iseries/vcd*"
+
+        findkeymount ${KEYDEVS}
+}
+
+
+cmdline_hwopts() {
+	# Scan CMDLINE for any "doscsi" or "noscsi"-type arguments
+	
+	local FOUND
+	local TMP_HWOPTS
+
+	for x in $HWOPTS
+	do
+		for y in $CMDLINE
+		do
+			if [ "${y}" = "do${x}" ]
+			then
+				MY_HWOPTS="${MY_HWOPTS} $x"
+			elif [ "${y}" = "no${x}" ]
+			then
+				MY_HWOPTS="`echo ${MY_HWOPTS} | sed -e \"s/${x}//g\" -`"
+			fi
+		done
+	done
+   
+	# Shouldnt need to sort this as the following loop should figure out the
+	# duplicates and strip them out
+	#MY_HWOPTS=`echo ${MY_HWOPTS}|  sort`
+	
+	for x in ${MY_HWOPTS}
+	do
+		FOUND=0
+		for y in ${TMP_HWOPTS}
+		do
+			if [ "${y}" = "${x}" ]
+			then 
+				FOUND=1
+			fi
+		done
+		if [ ! "${FOUND}" = '1' ]
+		then
+			TMP_HWOPTS="${TMP_HWOPTS} ${x}"
+		fi
+	done
+
+	MY_HWOPTS=${TMP_HWOPTS}
+}
+
+load_modules() {
+	# Load modules listed in MY_HWOPTS if /lib/modules exists
+	
+	if [ -d '/lib/modules' ]
+	then
+		good_msg 'Loading modules'
+		# Load appropriate kernel modules
+		for modules in $MY_HWOPTS
+		do
+			modules_scan $modules
+			eval DO_`echo $modules | sed 's/-//'`=1
+		done
+	else
+		good_msg 'Skipping module load; no modules in the initrd!'
+	fi
+}
+
+detect_sbp2_devices() {
+	# http://www.linux1394.org/sbp2.php
+	
+	# /proc
+	# /proc/scsi/sbp2/0, /proc/scsi/sbp2/1, etc.
+	#
+	# You may manually add/remove SBP-2 devices via the procfs with:
+	# add-single-device <h> <b> <t> <l> or remove-single-device <h> <b> <t> <l>,
+	# where:
+	#
+	# <h> = host (starting at zero for first SCSI adapter)
+	# <b> = bus (normally zero)
+	# <t> = target (starting at zero for first SBP-2 device)
+	# <l> - lun (normally zero) 
+	# e.g. To manually add/detect a new SBP-2 device
+	# echo "scsi add-single-device 0 0 0 0" > /proc/scsi/scsi
+	# e.g. To manually remove a SBP-2 device after it's been unplugged
+	# echo "scsi remove-single-device 0 0 0 0" > /proc/scsi/scsi
+	# e.g. To check to see which SBP-2/SCSI devices are currently registered
+	# cat /proc/scsi/scsi 
+
+	[ -e /proc/scsi/scsi ] && echo 'scsi add-single-device 0 0 0 0' > /proc/scsi/scsi
+}
+
+setup_keymap() {
+	if [ "${DO_keymap}" ]
+	then
+		if [ ! -e /dev/vc/0 -a ! -e /dev/tty0 ]
+		then
+			DEVBIND=1
+			mount -o bind ${NEW_ROOT}/dev /dev
+		fi
+		[ ! -e /dev/tty0 ] && ln -s /dev/tty1 /dev/tty0
+
+		chooseKeymap
+
+		[ "${DEVBIND}" -eq '1' ] && umount /dev
+		
+		if [ -e /etc/sysconfig/keyboard -a "${CDROOT}" -eq '1' ]
+		then
+			mkdir -p ${NEW_ROOT}/etc/sysconfig/
+			cp /etc/sysconfig/keyboard ${NEW_ROOT}/etc/sysconfig/keyboard
+		fi
+	fi
+}
+
+chooseKeymap() {
+	good_msg "Loading keymaps"
+	cat /lib/keymaps/keymapList
+	read -t 10 -p '<< Load keymap (Enter for default): ' keymap
+	case ${keymap} in
+		1|azerty) keymap=azerty ;;
+		2|be) keymap=be ;;
+		3|bg) keymap=bg ;;
+		4|br-a) keymap=br-a ;;
+		5|br-l) keymap=br-l ;;
+		6|by) keymap=by ;;
+		7|cf) keymap=cf ;;
+		8|croat) keymap=croat ;;
+		9|cz) keymap=cz ;;
+		10|de) keymap=de ;;
+		11|dk) keymap=dk ;;
+		12|dvorak) keymap=dvorak ;;
+		13|es) keymap=es ;;
+		14|et) keymap=et ;;
+		15|fi) keymap=fi ;;
+		16|fr) keymap=fr ;;
+		17|gr) keymap=gr ;;
+		18|hu) keymap=hu ;;
+		19|il) keymap=il ;;
+		20|is) keymap=is ;;
+		21|it) keymap=it ;;
+		22|jp) keymap=jp ;;
+		23|la) keymap=la ;;
+		24|lt) keymap=lt ;;
+		25|mk) keymap=mk ;;
+		26|nl) keymap=nl ;;
+		27|no) keymap=no ;;
+		28|pl) keymap=pl ;;
+		29|pt) keymap=pt ;;
+		30|ro) keymap=ro ;;
+		31|ru) keymap=ru ;;
+		32|se) keymap=se ;;
+		33|sg) keymap=sg ;;
+		34|sk-y) keymap=sk-y ;;
+		35|sk-z) keymap=sk-z ;;
+		36|slovene) keymap=slovene ;;
+		37|trf) keymap=trf ;;
+		38|trq) keymap=trq ;;
+		39|ua) keymap=ua ;;
+		40|uk) keymap=uk ;;
+		41|us) keymap=us ;;
+		42|wangbe) keymap=wangbe ;;
+	esac
+	if [ -e /lib/keymaps/${keymap}.map ]
+	then
+		good_msg "Loading the ''${keymap}'' keymap"
+		loadkmap < /lib/keymaps/${keymap}.map
+#		xkeymap=${keymap}
+#		echo ${keymap} | egrep -e "[0-9]+" >/dev/null 2>&1
+#		if [ "$?" -eq '0'  ]
+#		then
+#			xkeymap=`tail -n 7 /lib/keymaps/keymapList | grep ${keymap} | sed -r "s/.*\s+${keymap}\s+([a-z-]+).*/\1/g" | egrep -v 1`
+#		fi
+		mkdir -p /etc/sysconfig
+#		echo "XKEYBOARD=${xkeymap}" > /etc/sysconfig/keyboard
+		echo "XKEYBOARD=${keymap}" > /etc/sysconfig/keyboard
+	elif [ "$keymap" = '' ]
+	then
+		echo
+		good_msg "Keeping default keymap"
+	else
+		bad_msg "Sorry, but keymap ''${keymap}'' is invalid!"
+		chooseKeymap
+	fi
+}
+
+startVolumes() {
+	#good_msg 'Checking if volumes need to be started...'
+
+	# Here, we check for /dev/device-mapper, and if it exists, we setup a
+	# a symlink, which should hopefully fix bug #142775 and bug #147015
+	if [ -e /dev/device-mapper ] && [ ! -e /dev/mapper/control ]
+	then
+		mkdir -p /dev/mapper
+		ln -sf /dev/device-mapper /dev/mapper/control
+	fi
+	
+	if [ "${USE_MDADM}" -eq '1' ]
+	then
+		if [ ! -e '/etc/mdadm.conf' ]
+		then
+			/sbin/mdadm --examine > /etc/mdadm.conf
+		fi
+		/sbin/mdadm --assemble
+	fi
+
+	if [ "${USE_DMRAID_NORMAL}" -eq '1' ]
+	then
+		if [ -e '/sbin/dmraid' ]
+		then
+			good_msg "Activating Device-Mapper RAID(s)"
+			if [ '${DMRAID_OPTS}' = '' ]
+			then
+				/sbin/dmraid -ay
+			else
+				/sbin/dmraid -ay ${DMRAID_OPTS}
+			fi
+		fi
+	fi
+
+	if [ "${USE_LVM_NORMAL}" -eq '1' ]
+	then
+		if [ -e '/bin/vgscan' -a -e '/bin/vgchange' ]
+		then
+			for dev in ${RAID_DEVICES}
+			do
+				setup_md_device "${dev}"
+			done
+
+			good_msg "Scanning for Volume Groups"
+			/bin/vgscan --ignorelockingfailure --mknodes 2>/dev/null
+			sleep 2
+			good_msg "Activating Volume Groups"
+			/bin/vgchange -ay --ignorelockingfailure 2>/dev/null
+
+			# Disable EVMS since lvm is activated and they dont work together.
+			if [ "${USE_EVMS_NORMAL}" -eq '1' ]
+			then
+				bad_msg "Disabling EVMS Support because LVM started"
+				bad_msg "Do not add dolvm to the cmdline if this is not what you want"
+				bad_msg "LVM and EVMS do not work well together"
+				USE_EVMS_NORMAL=0
+			fi
+		else
+			bad_msg "vgscan or vgchange not found: skipping LVM volume group activation!"
+		fi
+	fi
+
+	if [ "${USE_EVMS_NORMAL}" -eq '1' ]
+	then
+		if [ -e '/sbin/evms_activate' ]
+		then
+			good_msg "Activating EVMS"
+			evms_activate
+		fi
+	fi
+}
+
+# Open a LUKS device
+# $1 LUKS device
+# $2 LUKS name
+openLUKS() {
+	LUKS_DEVICE="$1"
+	LUKS_NAME="$2"
+	if [ -e /sbin/cryptsetup ]
+	then
+		while [ 1 ]
+		do
+			if [ "${LUKS_DEVICE}" = '' ]
+			then
+				# LUKS device could not be opened. Prompt user for device.
+				bad_msg "The LUKS ${LUKS_NAME} block device is not detected."
+				echo "   Please specify a ${LUKS_NAME} LUKS device to open, "q" to skip, or "shell" for a shell..."
+				echo -n "LUKS ${LUKS_NAME}() :: "
+				read LUKS_DEVICE
+				continue
+			elif [ "${LUKS_DEVICE}" = 'shell' ]
+			then
+				run_shell
+				
+				LUKS_DEVICE=''
+				continue
+			elif [ "${LUKS_DEVICE}" = 'q' ]
+			then
+				break
+			else
+				setup_md_device ${LUKS_DEVICE}
+				if cryptsetup isLuks ${LUKS_DEVICE}
+				then
+					good_msg "Opening LUKS device ${LUKS_DEVICE}"
+					
+					cryptsetup luksOpen ${LUKS_DEVICE} ${LUKS_NAME}
+					if [ ! "$?" -eq '0' ]
+					then
+						bad_msg "Failed open LUKS device ${LUKS_DEVICE}"
+					else
+						break
+					fi
+				else
+					bad_msg "The LUKS device ${LUKS_DEVICE} does not contain a LUKS header"
+				fi
+			fi
+			LUKS_DEVICE=''
+		done
+	else
+		bad_msg "The initrd does not support LUKS"
+	fi
+}
+
+startLUKS() {
+	if [ -n "${LUKS_ROOT}" ]
+	then
+		openLUKS "${LUKS_ROOT}" "root" 
+		if [ -n "${REAL_ROOT}" ]
+		then
+			# Rescan volumes
+			startVolumes
+		else
+			REAL_ROOT="/dev/mapper/root"
+		fi
+	fi
+	if [ -n "${LUKS_SWAP}" ]
+	then
+		openLUKS "${LUKS_SWAP}" "swap" 
+		break
+	fi
+}
+
+sdelay() {
+	# Sleep a specific number of seconds if SDELAY is set otherwise only sleep
+	# 1 second
+	if [ -n "${SDELAY}" ]
+	then
+		sleep ${SDELAY}
+	else
+		sleep 1
+	fi
+}
+
+quiet_kmsg() {
+	# if QUIET is set make the kernel less chatty
+	[ -n "$QUIET" ] && echo '0' > /proc/sys/kernel/printk
+}
+
+verbose_kmsg() {
+	# if QUIET is set make the kernel less chatty
+	[ -n "$QUIET" ] && echo '6' > /proc/sys/kernel/printk
+}
+
+
+cdupdate() {
+	if [ "${CDROOT}" -eq '1' ]
+	then
+		if [ -x /${NEW_ROOT}/mnt/cdrom/cdupdate.sh ]
+		then
+			good_msg "Running cdupdate.sh"
+			${NEW_ROOT}/mnt/cdrom/cdupdate.sh
+			if [ "$?" != '0' ]
+			then
+				bad_msg "Executing cdupdate.sh failed!"
+				run_shell
+			fi
+		else
+			good_msg 'No cdupdate.sh script found, skipping...'
+		fi
+	fi
+}
+
+setup_md_device() {
+	local device
+
+	[ -z "$1" ] && device="${REAL_ROOT}" || device="$1"
+	[ -z "${device}" ] && return # LiveCD
+
+	if [ `echo ${device}|sed -e 's#\(luks:\)\?\(/dev/md\)[[:digit:]]\+#\2#'` = "/dev/md" ]
+	then
+		good_msg 'Detected real_root as a md device. Setting up the device node...'
+		MD_NUMBER=`echo ${device}|sed -e 's#\(luks:\)\?/dev/md\([[:digit:]]\+\)#\2#'`
+		if [ ! -e /dev/md${MD_NUMBER} ]
+		then
+			mknod /dev/md${MD_NUMBER} b 9 ${MD_NUMBER} >/dev/null 2>&1
+			[ "$?" -ne 0 ] && bad_msg "Creation of /dev/md${MD_NUMBER} failed..."
+		fi
+		mdstart ${MDPART} /dev/md${MD_NUMBER}
+	fi
+}
+
+rundebugshell() {
+	if [ -n "$DEBUG" ]
+	then
+		good_msg 'Starting debug shell as requested by "debug" option.'
+		good_msg 'Type "exit" to continue with normal bootup.'
+		[ -x /bin/sh ] && /bin/sh || /bin/ash
+	fi
+}
+
+setup_unionfs() {
+	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		# Directory used for rw changes in union mount filesystem
+		UNION=/union
+		MEMORY=/memory
+		if [ -z "$UID" ]
+		then
+			CHANGES=$MEMORY/unionfs_changes/default
+		else
+			CHANGES=$MEMORY/unionfs_changes/$UID
+		fi
+
+		mkdir -p ${MEMORY}
+		mkdir -p ${UNION}
+		good_msg "Loading unionfs module"
+		modprobe unionfs > /dev/null 2>&1
+		if [ -n "${UNIONFS}" ]
+		then
+			CHANGESDEV=${UNIONFS}
+			good_msg "mounting $CHANGESDEV to $MEMORY for unionfs support"
+			mount -t auto $CHANGESDEV $MEMORY
+			# mount tmpfs only in the case when changes= boot parameter was
+			# empty or we were not able to mount the storage device
+			ret=$?
+			if [ "${ret}" -ne 0 ]
+			then
+				bad_msg "mount of $CHANGESDEV failed falling back to ramdisk based unionfs"
+				mount -t tmpfs tmpfs $MEMORY
+			fi
+			if [ "${CDROOT}" -eq '1' -a ! -f ${MEMORY}/livecd.unionfs  ]
+			then
+				umount $MEMORY
+				bad_msg "failed to find livecd.unionfs file on $CHANGESDEV"
+				bad_msg "create a livecd.unionfs file on this device if you wish to use it for unionfs"
+				bad_msg "falling back to ramdisk based unionfs for safety"
+				mount -t tmpfs tmpfs $MEMORY
+			fi
+		else 
+			good_msg "Mounting ramdisk to $MEMORY for unionfs support..."
+			mount -t tmpfs tmpfs $MEMORY 
+		fi 
+
+		mkdir -p $CHANGES 
+		mount -t unionfs -o dirs=$CHANGES=rw unionfs ${UNION}
+		ret=$?
+		if [ "${ret}" -ne 0 ]
+		then 
+			bad_msg "Can't setup union ${UNION} in directory!"
+			USE_UNIONFS_NORMAL=0
+		fi
+	else
+		USE_UNIONFS_NORMAL=0
+	fi
+}
+
+tuxonice_resume() {
+	[ -d /proc/suspend2 -o -d /sys/power/suspend2 -o -d /sys/power/tuxonice ] || return
+
+	local splash_theme
+
+	if grep "splash=" /proc/cmdline > /dev/null 2>&1; then
+		splash_theme=$(cat /proc/cmdline | sed 's/.*splash=/splash=/' | sed 's/ .*//' | sed 's/.*theme://' | sed 's/,.*//')
+	fi
+
+	local tuxonice_userui_program="/sys/power/tuxonice/user_interface/program"
+	local tuxonice_do_resume="/sys/power/tuxonice/do_resume"
+
+	#
+	# Backward compatibility
+	#
+	if [ -e /sys/power/suspend2 ]; then
+		tuxonice_userui_program="/sys/power/suspend2/user_interface/program"
+		tuxonice_do_resume="/sys/power/suspend2/do_resume"
+	elif [ -e /proc/suspend2 ]; then
+		tuxonice_userui_program="/proc/suspend2/userui_program"
+		tuxonice_do_resume="/proc/suspend2/do_resume"
+	fi
+
+	modules_scan tuxonice
+
+	if ! grep suspend_noui /proc/cmdline > /dev/null 2>&1; then
+		which suspend2ui_text > /dev/null 2>&1 && which suspend2ui_text > "${tuxonice_userui_program}"
+		which tuxoniceui_text > /dev/null 2>&1 && which tuxoniceui_text > "${tuxonice_userui_program}"
+
+		if [ -n "${splash_theme}" ]; then
+			ln -s /etc/splash/${splash_theme} /etc/splash/suspend2
+			ln -s /etc/splash/${splash_theme} /etc/splash/tuxonice
+
+			which suspend2ui_fbsplash > /dev/null 2>&1 && which suspend2ui_fbsplash > "${tuxonice_userui_program}"
+			which tuxoniceui_fbsplash > /dev/null 2>&1 && which tuxoniceui_fbsplash > "${tuxonice_userui_program}"
+		fi
+
+		echo > "${tuxonice_do_resume}"
+	fi
+}
diff -Nurp genkernel-3.4.9_pre9.orig/generic/linuxrc genkernel-3.4.9_pre9/generic/linuxrc
--- genkernel-3.4.9_pre9.orig/generic/linuxrc	2007-11-14 00:09:21.000000000 +0100
+++ genkernel-3.4.9_pre9/generic/linuxrc	2007-11-15 12:12:21.000000000 +0100
@@ -78,30 +78,18 @@ do
 			LOOPTYPE=`parse_opt "${x}"`
 		;;
 		unionfs)
-			if [ ! -x /sbin/unionctl ]
-			then
-				USE_UNIONFS_NORMAL=0
-				bad_msg 'Unionctl not found: aborting use of unionfs!'
-			else
-				USE_UNIONFS_NORMAL=1
-			fi
+			USE_UNIONFS_NORMAL=1
 		;;
 		unionfs\=*)
-			if [ ! -x /sbin/unionctl ]
+			USE_UNIONFS_NORMAL=1
+			CMD_UNIONFS=`parse_opt "${x}"`
+			echo ${CMD_UNIONFS}|grep , >/dev/null 2>&1
+			if [ "$?" -eq '0' ]
 			then
-				USE_UNIONFS_NORMAL=0
-				bad_msg 'Unionctl not found: aborting use of unionfs!'
+				UID=`echo ${CMD_UNIONFS#*,}`
+				UNIONFS=`echo ${CMD_UNIONFS%,*}`
 			else
-				USE_UNIONFS_NORMAL=1
-				CMD_UNIONFS=`parse_opt "${x}"`
-				echo ${CMD_UNIONFS}|grep , >/dev/null 2>&1
-				if [ "$?" -eq '0' ]
-				then
-					UID=`echo ${CMD_UNIONFS#*,}`
-					UNIONFS=`echo ${CMD_UNIONFS%,*}`
-				else
-					UNIONFS=${CMD_UNIONFS}
-				fi
+				UNIONFS=${CMD_UNIONFS}
 			fi
 		;;
 		# Start Volume manager options 
@@ -603,7 +591,14 @@ then
 
 	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
 	then
-		union_insert_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
+		union_setup_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
+
+		mkdir -p ${UNION}/mnt/livecd
+		if [ ! -e "${UNION}/mnt/cdrom" ]; then
+			mkdir ${UNION}/mnt/cdrom -p
+		fi
+		mount --bind ${NEW_ROOT}/${FS_LOCATION} ${UNION}/mnt/livecd
+		mount --bind ${NEW_ROOT}/mnt/cdrom ${UNION}/mnt/cdrom
 		
 		# Make sure fstab notes livecd is mounted ro.  Makes system skip remount which fails on unionfs dirs.
 		sed -e 's|\(.*\s/\s*tmpfs\s*\)defaults\(.*\)|\1defaults,ro\2|' /${UNION}/etc/fstab > /${UNION}/etc/fstab.new
@@ -697,7 +692,7 @@ then
 else
 	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
 	then
-		union_insert_dir ${UNION} ${NEW_ROOT}
+		union_setup_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
 		mkdir -p ${UNION}/tmp/.initrd
 	fi
 fi
@@ -713,16 +708,6 @@ fi
 
 verbose_kmsg
 
-# Move the /memory mount point to what will be the system root so that 
-# init scripts will be able to unmount it properly at next reboot
-#
-# Eventually, all "unions over /" mounts should go in that /.unions/
-if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
-then
-	mkdir -p /${CHROOT}/.unions/memory 2>/dev/null
-	mount -o move /memory /${CHROOT}/.unions/memory || echo '*: Failed to move unionfs /memory into the system root!'
-fi
-
 if [ "$0" = '/linuxrc' ] || [ "$0" = 'linuxrc' ]
 then
 	[ ! -e ${CHROOT}/dev/console ] && mknod ${CHROOT}/dev/console c 5 1
diff -Nurp genkernel-3.4.9_pre9.orig/generic/linuxrc.orig genkernel-3.4.9_pre9/generic/linuxrc.orig
--- genkernel-3.4.9_pre9.orig/generic/linuxrc.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre9/generic/linuxrc.orig	2007-11-14 00:09:21.000000000 +0100
@@ -0,0 +1,801 @@
+#!/bin/sh
+
+. /etc/initrd.defaults
+. /etc/initrd.scripts
+
+splash() {
+	return 0
+}
+
+[ -e /etc/initrd.splash ] && . /etc/initrd.splash
+
+# Clean input/output
+exec >${CONSOLE} <${CONSOLE} 2>&1
+
+if [ "$$" != '1' ]
+then
+	echo '/linuxrc has to be run as the init process as the one'
+	echo 'with a PID of 1. Try adding init="/linuxrc" to the'
+	echo 'kernel command line or running "exec /linuxrc".'
+	exit 1
+fi
+
+mount -t proc proc /proc >/dev/null 2>&1
+mount -o remount,rw / >/dev/null 2>&1
+
+# Set up symlinks
+if [ "$0" = '/init' ]
+then
+	/bin/busybox --install -s
+
+	[ -e /linuxrc ] && rm /linuxrc
+	 
+	if [ -e /bin/lvm ]
+	then
+		ln -s /bin/lvm /bin/vgscan
+		ln -s /bin/lvm /bin/vgchange
+	fi
+fi
+
+quiet_kmsg
+
+CMDLINE="`cat /proc/cmdline`"
+# Scan CMDLINE for any specified real_root= or cdroot arguments
+REAL_ROOT=''
+FAKE_ROOT=''
+REAL_ROOTFLAGS=''
+for x in ${CMDLINE}
+do
+	case "${x}" in
+		real_root\=*)
+			REAL_ROOT=`parse_opt "${x}"`
+		;;
+		root\=*)
+			FAKE_ROOT=`parse_opt "${x}"`
+		;;
+		subdir\=*)
+			SUBDIR=`parse_opt "${x}"`
+		;;
+		real_init\=*)
+			REAL_INIT=`parse_opt "${x}"`
+		;;
+		init_opts\=*)
+			INIT_OPTS=`parse_opt "${x}"`
+		;;
+		# Livecd options
+		cdroot)
+			CDROOT=1
+		;;
+		cdroot\=*)
+			CDROOT=1
+			CDROOT_DEV=`parse_opt "${x}"`
+		;;
+		# Start livecd loop, looptype options
+		loop\=*)
+			LOOP=`parse_opt "${x}"`
+		;;
+		looptype\=*)
+			LOOPTYPE=`parse_opt "${x}"`
+		;;
+		unionfs)
+			if [ ! -x /sbin/unionctl ]
+			then
+				USE_UNIONFS_NORMAL=0
+				bad_msg 'Unionctl not found: aborting use of unionfs!'
+			else
+				USE_UNIONFS_NORMAL=1
+			fi
+		;;
+		unionfs\=*)
+			if [ ! -x /sbin/unionctl ]
+			then
+				USE_UNIONFS_NORMAL=0
+				bad_msg 'Unionctl not found: aborting use of unionfs!'
+			else
+				USE_UNIONFS_NORMAL=1
+				CMD_UNIONFS=`parse_opt "${x}"`
+				echo ${CMD_UNIONFS}|grep , >/dev/null 2>&1
+				if [ "$?" -eq '0' ]
+				then
+					UID=`echo ${CMD_UNIONFS#*,}`
+					UNIONFS=`echo ${CMD_UNIONFS%,*}`
+				else
+					UNIONFS=${CMD_UNIONFS}
+				fi
+			fi
+		;;
+		# Start Volume manager options 
+		dolvm)
+			USE_LVM_NORMAL=1
+		;;
+		dolvm2)
+			bad_msg 'Using dolvm2 is deprecated, use dolvm, instead.'
+			USE_LVM_NORMAL=1
+		;;
+		domdadm)
+			USE_MDADM=1
+		;;
+		dodmraid)
+			USE_DMRAID_NORMAL=1
+		;;
+		dodmraid\=*)
+			DMRAID_OPTS=`parse_opt "${x}"`
+			USE_DMRAID_NORMAL=1
+		;;
+		doevms)
+			USE_EVMS_NORMAL=1
+		;;
+		doevms2)
+			bad_msg 'Using doevms2 is deprecated, use doevms, instead.'
+			USE_EVMS_NORMAL=1
+		;;
+		# Debug Options
+		debug)
+			DEBUG='yes'
+		;;
+		 # Scan delay options 
+		scandelay\=*)
+			SDELAY=`parse_opt "${x}"`
+		;;
+		scandelay)
+			SDELAY=10
+		;;
+		# Module no-loads
+		doload\=*)
+			MDOLIST=`parse_opt "${x}"`
+			MDOLIST="`echo ${MDOLIST} | sed -e 's/,/ /g'`"
+		;;
+		nodetect)
+			NODETECT=1
+		;;
+		noload\=*)
+			MLIST=`parse_opt "${x}"`
+			MLIST="`echo ${MLIST} | sed -e 's/,/ /g'`"
+			export MLIST
+		;;
+		# Redirect output to a specific tty
+		CONSOLE\=*)
+			CONSOLE=`parse_opt "${x}"`
+			exec >${CONSOLE} <${CONSOLE} 2>&1
+		;;
+		# /dev/md
+		lvmraid\=*)
+			RAID_DEVICES="`parse_opt ${x}`"
+			RAID_DEVICES="`echo ${RAID_DEVICES} | sed -e 's/,/ /g'`"
+		;;
+		part\=*)
+			MDPART=`parse_opt "${x}"`
+		;;
+		# NFS
+		ip\=*)
+			IP=`parse_opt "${x}"`
+		;;
+		nfsroot\=*)
+			NFSROOT=`parse_opt "${x}"`
+		;;
+		crypt_root\=*)
+			LUKS_ROOT=`parse_opt "${x}"`
+		;;
+		crypt_swap\=*)
+			LUKS_SWAP=`parse_opt "${x}"`
+		;;
+		crypt_silent\=*)
+			LUKS_SILENT=`parse_opt "${x}"`
+		;;
+		real_rootflags\=*)
+			REAL_ROOTFLAGS=`parse_opt "${x}"`
+		;;
+	esac
+done
+
+if [ -z "${REAL_ROOT}" -a \( "${CDROOT}" -eq 0 \)  -a \( "${FAKE_ROOT}" != "/dev/ram0" \) ]
+then
+	REAL_ROOT="${FAKE_ROOT}"	
+fi
+
+splash 'init'
+
+detect_sbp2_devices
+cmdline_hwopts
+
+# Load modules listed in MY_HWOPTS if /lib/modules exists
+if [ -d '/lib/modules' ]
+then
+	good_msg 'Loading modules'
+	# Load appropriate kernel modules
+	if [ "${NODETECT}" -ne '1' ]
+	then
+		for modules in $MY_HWOPTS
+		do
+			modules_scan $modules
+			eval DO_`echo $modules | sed 's/-//'`=1
+		done
+	fi
+	# Always eval doload=...
+	modules_load $MDOLIST
+else
+	for modules in $MY_HWOPTS
+	do
+		eval DO_`echo $modules | sed 's/-//'`=1
+	done
+	good_msg 'Skipping module load; no modules in the initrd!'
+fi
+
+# Mount sysfs
+mount_sysfs
+
+# Delay if needed for USB hardware
+sdelay
+
+# Start udev/devfs
+start_dev_mgr
+
+# Setup md device nodes if they dont exist
+setup_md_device
+
+# Scan volumes
+startVolumes
+
+# Initialize LUKS root device except for livecd's
+if [ "${CDROOT}" -ne '1' ]
+then
+	startLUKS
+fi
+
+# Set up unionfs
+mkdir -p ${NEW_ROOT}
+setup_unionfs
+
+if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+then
+	CHROOT=${UNION}
+else
+	CHROOT=${NEW_ROOT}
+fi
+
+# Run debug shell if requested
+rundebugshell
+
+tuxonice_resume
+
+if [ "${CDROOT}" -eq '1' ]
+then
+	if [ ! "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		good_msg "Making tmpfs for ${NEW_ROOT}"
+		mount -t tmpfs tmpfs ${NEW_ROOT}
+	fi
+	
+	for i in dev mnt mnt/cdrom mnt/livecd mnt/keydev tmp tmp/.initrd mnt/gentoo sys
+	do
+		mkdir -p ${NEW_ROOT}/$i
+		chmod 755 ${NEW_ROOT}/$i
+	done
+	[ ! -e ${NEW_ROOT}/dev/null ] && mknod ${NEW_ROOT}/dev/null c 1 3
+	[ ! -e ${NEW_ROOT}/dev/console ] && mknod ${NEW_ROOT}/dev/console c 5 1
+
+	# For SGI LiveCDs ...
+	if [ "${LOOPTYPE}" = "sgimips" ]
+	then
+		[ ! -e ${NEW_ROOT}/dev/sr0 ] && mknod ${NEW_ROOT}/dev/sr0 b 11 0
+		[ ! -e ${NEW_ROOT}/dev/loop0 ] && mknod ${NEW_ROOT}/dev/loop0 b 7 0
+	fi
+
+	# Required for gensplash to work.  Not an issue with the initrd as this
+	# device isnt created there and is not needed.
+	if [ -e /dev/tty1 ]
+	then
+		[ ! -e ${NEW_ROOT}/dev/tty1 ] && mknod ${NEW_ROOT}/dev/tty1 c 4 1
+	fi
+
+	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
+	then
+		bootstrapCD
+	fi
+
+	if [ "${REAL_ROOT}" = '' ]
+	then
+		echo -n -e "${WARN}>>${NORMAL}${BOLD} No bootable medium found. Waiting for new devices"
+		
+		COUNTER=0
+		while [ $COUNTER -lt 3 ]; do
+			sleep 3
+			echo -n '.'
+			let COUNTER=$COUNTER+1
+		done	
+		
+		sleep 1
+		echo -e "${NORMAL}"
+		bootstrapCD
+	fi
+
+	if [ "${REAL_ROOT}" = '' ]
+	then
+		# Undo stuff
+		umount  ${NEW_ROOT}/dev 2>/dev/null
+		umount  ${NEW_ROOT}/sys 2>/dev/null
+		umount /sys 2>/dev/null
+
+		umount  ${NEW_ROOT}
+		rm -rf  ${NEW_ROOT}/*
+
+		bad_msg 'Could not find CD to boot, something else needed!'
+		CDROOT=0
+	fi
+fi
+
+setup_keymap
+
+# Determine root device
+good_msg 'Determining root device...'
+while true
+do
+	while [ "${got_good_root}" != '1' ]
+	do
+		case "${REAL_ROOT}" in
+			LABEL\=*|UUID\=*)
+			
+				ROOT_DEV=""
+				retval=1
+				
+				if [ "${retval}" -ne '0' ]; then
+					ROOT_DEV=`findfs "${REAL_ROOT}" 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "$retval" -ne '0' ]; then
+					ROOT_DEV=`busybox findfs "${REAL_ROOT}" 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "${retval}" -ne '0' ]; then
+					ROOT_DEV=`blkid -t "${REAL_ROOT}" | cut -d ":" -f 1 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "${retval}" -eq '0' ] && [ -n "${ROOT_DEV}" ]; then
+					good_msg "Detected real_root=${ROOT_DEV}"
+					REAL_ROOT="${ROOT_DEV}"
+				else
+					bad_msg "Could not find root block device: ${REAL_ROOT}"
+					echo '   Please specify a device to boot, or "shell" for a shell...'
+					echo -n 'boot() :: '
+					read REAL_ROOT
+					got_good_root=0
+					continue
+				fi
+				;;
+		esac
+				
+		if [ "${REAL_ROOT}" = 'shell' ]
+		then
+			run_shell
+
+			REAL_ROOT=''
+			got_good_root=0
+			continue
+		
+		elif [ "${REAL_ROOT}" = '' ]
+		then
+			# No REAL_ROOT determined/specified. Prompt user for root block device.
+			bad_msg "The root block device is unspecified or not detected."
+			echo '   Please specify a device to boot, or "shell" for a shell...'
+			echo -n 'boot() :: '
+			read REAL_ROOT
+			got_good_root=0
+
+		# Check for a block device or /dev/nfs
+		elif [ -b "${REAL_ROOT}" ] || [ "${REAL_ROOT}" = "/dev/nfs" ]
+		then
+			got_good_root=1
+
+		else
+			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
+			REAL_ROOT=""
+			got_good_root=0
+		fi
+	done
+
+
+	if [ "${CDROOT}" -eq '1' -a "${got_good_root}" = '1' -a "${REAL_ROOT}" != "/dev/nfs" ]
+	then
+		# CD already mounted; no further checks necessary
+		break
+	elif [ "${LOOPTYPE}" = "sgimips" ]
+	then
+		# sgimips mounts the livecd root partition directly
+		# there is no isofs filesystem to worry about
+		break
+	else
+		good_msg "Mounting root..."
+
+		# Try to mount the device as ${NEW_ROOT}
+		if [ "${REAL_ROOT}" = '/dev/nfs' ]; then
+			findnfsmount
+		else
+			# mount ro so fsck doesn't barf later
+#			REAL_ROOT_TYPE=`vol_id -t ${REAL_ROOT}`
+#			mount -t ${REAL_ROOT_TYPE} -o ro ${REAL_ROOT} ${NEW_ROOT}
+			if [ "${REAL_ROOTFLAGS}" = '' ]; then
+				mount -o ro ${REAL_ROOT} ${NEW_ROOT}
+			else
+				good_msg "Using mount -o ro,${REAL_ROOTFLAGS}"
+				mount -o ro,${REAL_ROOTFLAGS} ${REAL_ROOT} ${NEW_ROOT}
+			fi
+		fi
+		
+		# If mount is successful break out of the loop 
+		# else not a good root and start over.
+
+		if [ "$?" = '0' ]
+		then
+			break
+		else
+			bad_msg "Could not mount specified ROOT, try again"
+			got_good_root=0
+			REAL_ROOT=''
+		fi
+	fi
+done
+# End determine root device
+
+#verbose_kmsg
+
+# If cdroot is set determine the looptype to boot
+if [ "${CDROOT}" = '1' ]
+then
+	good_msg 'Determining looptype ...'
+	cd ${NEW_ROOT}
+
+	# Find loop and looptype if we have NFS-mounted a livecd
+	if  [ "${LOOP}" = '' ] && [ "${REAL_ROOT}" = '/dev/nfs' ]
+	then
+		if [ -e "${NEW_ROOT}/mnt/cdrom/livecd.loop" ]; then
+			LOOP='/livecd.loop'
+			LOOPTYPE='normal'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/zisofs" ]; then
+			LOOP='/zisofs'
+			LOOPTYPE='zisofs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/livecd.squashfs" ]; then
+			LOOP='/livecd.squashfs'
+			LOOPTYPE='squashfs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/image.squashfs" ]; then
+			LOOP='/image.squashfs'
+			LOOPTYPE='squashfs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/livecd.gcloop" ]; then
+			LOOP='/livecd.gcloop'
+			LOOPTYPE='gcloop'
+				else
+			LOOPTYPE='noloop'
+		fi
+	fi
+
+	# Failsafe the loop type wasn't set
+	if [ "${LOOPTYPE}" = '' ]
+	then
+		warn_msg 'Warning: loop type unspecified!'
+		if [ "${LOOP}" = '/livecd.loop' ]
+		then
+			LOOPTYPE='normal'
+		elif [ "${LOOP}" = '/zisofs' ]
+		then
+			LOOPTYPE='zisofs'
+		elif [ "${LOOP}" = '/livecd.squashfs' ]
+		then
+			LOOPTYPE='squashfs'
+		elif [ "${LOOP}" = '/image.squashfs' ]
+		then
+			LOOPTYPE='squashfs'
+		elif [ "${LOOP}" = '/livecd.gcloop' ]
+		then
+			LOOPTYPE='gcloop'
+		else
+			LOOPTYPE='noloop'
+		fi
+	fi
+
+	cache_cd_contents
+	
+
+        # If encrypted, find key and mount, otherwise mount as usual
+	if [ "${LUKS_ROOT}" != '' ] 
+	then
+		if [ "${LUKS_SILENT}" = '' ]
+		then
+			good_msg 'You booted an encrypted livecd'
+		fi
+
+		LUKS_ROOT_KEY=$(head -n 1 ${NEW_ROOT}/mnt/cdrom/livecd)
+
+		if [ "${LUKS_ROOT_KEY}" ]
+		then
+			bootstrapKey
+		fi
+		
+		losetup /dev/loop0 ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}
+		
+		test_success 'Preparing loop filesystem'
+		
+		LUKS_ROOT='/dev/loop0'
+		
+		startLUKS
+		
+		case ${LOOPTYPE} in
+			normal)
+				MOUNTTYPE="ext2"
+				;;
+			*)
+				MOUNTTYPE="${LOOPTYPE}"
+				;;
+		esac		
+
+
+		mount -t ${MOUNTTYPE} -o ro /dev/mapper/root ${NEW_ROOT}/mnt/livecd 
+		
+		test_success 'Mount filesystem'	
+		FS_LOCATION='mnt/livecd'
+
+
+
+	# Setup the loopback mounts, if unencrypted
+	else
+		if [ "${LOOPTYPE}" = 'normal' ]
+		then
+			good_msg 'Mounting loop filesystem'
+			mount -t ext2 -o loop,ro ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP} ${NEW_ROOT}/mnt/livecd
+			test_success 'Mount filesystem'
+			FS_LOCATION='mnt/livecd'
+	
+	
+		elif [ "${LOOPTYPE}" = 'squashfs' ]
+		then
+			good_msg 'Mounting squashfs filesystem'
+			mount -t squashfs -o loop,ro ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP} ${NEW_ROOT}/mnt/livecd
+			
+			test_success 'Mount filesystem'
+			FS_LOCATION='mnt/livecd'
+		
+		elif [ "${LOOPTYPE}" = 'gcloop' ]
+		then
+			good_msg 'Mounting gcloop filesystem'
+			echo ' ' | losetup -E 19 -e ucl-0 -p0 ${NEW_ROOT}/dev/loop0 ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}
+			test_success 'losetup the loop device'
+	
+			mount -t ext2 -o ro ${NEW_ROOT}/dev/loop0 ${NEW_ROOT}/mnt/livecd
+			test_success 'Mount the losetup loop device'
+			FS_LOCATION='mnt/livecd'
+		
+		elif [ "${LOOPTYPE}" = 'zisofs' ]
+		then
+			FS_LOCATION="mnt/cdrom/${LOOPEXT}${LOOP}"
+		
+		elif [ "${LOOPTYPE}" = 'noloop' ]
+		then
+			FS_LOCATION='mnt/cdrom'
+	
+		elif [ "${LOOPTYPE}" = 'sgimips' ]
+		then
+			# getdvhoff finds the starting offset (in bytes) of the squashfs
+			# partition on the cdrom and returns this offset for losetup
+			#
+			# All currently supported SGI Systems use SCSI CD-ROMs, so
+			# so we know that the CD-ROM is usually going to be /dev/sr0.
+			#
+			# We use the value given to losetup to set /dev/loop0 to point
+			# to the liveCD root partition, and then mount /dev/loop0 as
+			# the LiveCD rootfs
+			good_msg 'Locating the SGI LiveCD Root Partition'
+			echo ' ' | \
+				losetup -o $(/bin/getdvhoff ${NEW_ROOT}${REAL_ROOT} 0) \
+					${NEW_ROOT}${CDROOT_DEV} \
+					${NEW_ROOT}${REAL_ROOT}
+			test_success 'losetup /dev/sr0 /dev/loop0'
+	
+			good_msg 'Mounting the Root Partition'
+			mount -t squashfs -o ro ${NEW_ROOT}${CDROOT_DEV} ${NEW_ROOT}/mnt/livecd
+			test_success 'mount /dev/loop0 /'
+			FS_LOCATION='mnt/livecd'
+		fi
+	fi
+#
+# End cdrom looptype determination and mounting if necessary
+#
+
+	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		union_insert_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
+		
+		# Make sure fstab notes livecd is mounted ro.  Makes system skip remount which fails on unionfs dirs.
+		sed -e 's|\(.*\s/\s*tmpfs\s*\)defaults\(.*\)|\1defaults,ro\2|' /${UNION}/etc/fstab > /${UNION}/etc/fstab.new
+		mv /${UNION}/etc/fstab.new /${UNION}/etc/fstab
+	fi
+
+	# Unpacking additional packages from NFS mount
+	# This is useful for adding kernel modules to /lib
+	# We do this now, so that additional packages can add whereever they want.
+	if [ "${REAL_ROOT}" = '/dev/nfs' ]
+	then
+		if [ -e "${CHROOT}/mnt/cdrom/add" ]
+		then
+				for targz in `ls ${CHROOT}/mnt/cdrom/add/*.tar.gz`
+				do	
+					tarname=`basename ${targz}`
+					good_msg "Adding additional package ${tarname}"
+					(cd ${CHROOT} ; /bin/tar -xzf ${targz})
+				done
+		fi
+	fi
+
+	
+	if [ ! "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		good_msg "Copying read-write image contents to tmpfs"
+		# Copy over stuff that should be writable
+		(cd ${NEW_ROOT}/${FS_LOCATION}; cp -a ${ROOT_TREES} ${NEW_ROOT})
+
+		# Now we do the links.
+		for x in ${ROOT_LINKS}
+		do
+			if [ -L "${NEW_ROOT}/${FS_LOCATION}/${x}" ]
+			then
+				ln -s "`readlink ${NEW_ROOT}/${FS_LOCATION}/${x}`" "${x}" 2>/dev/null
+			else
+				# List all subdirectories of x
+				for directory in `find "${NEW_ROOT}/${FS_LOCATION}/${x}" -type d 2>/dev/null`
+				do
+					## Strip the prefix of the FS_LOCATION
+					directory=${directory#${NEW_ROOT}/${FS_LOCATION}/}
+
+					## Skip this directory if we already linked a parent directory
+					if [ "${curent_parrent}" != '' ]; then
+						var=`echo "${directory}" | grep "^${curent_parrent}"`
+						if [ "${var}" != '' ]; then
+							continue
+						fi
+					fi
+					## Test if the directory exists already
+					if [ -e "/${NEW_ROOT}/${directory}" ]
+					then
+						# It does exist, link all the individual files
+						for file in `ls /${NEW_ROOT}/${FS_LOCATION}/${directory}`
+						do
+						if [ ! -d "/${NEW_ROOT}/${FS_LOCATION}/${directory}/${file}" ] && [ ! -e "${NEW_ROOT}/${directory}/${file}" ]; then
+								ln -s "/${FS_LOCATION}/${directory}/${file}" "${directory}/${file}" 2> /dev/null
+							fi
+						done
+					else
+						# It does not exist, make a link to the livecd
+						ln -s "/${FS_LOCATION}/${directory}" "${directory}" 2>/dev/null
+						current_parent=${directory}
+					fi
+				done
+			fi
+		done
+
+		if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+		then
+			sleep 10
+		fi
+		mkdir initrd proc tmp sys 2>/dev/null
+		chmod 1777 tmp
+	fi
+	
+	#UML=`cat /proc/cpuinfo|grep UML|sed -e 's|model name.*: ||'`
+	#if [ "${UML}" = 'UML' ]
+	#then
+	#	# UML Fixes
+	#	good_msg 'Updating for uml system'
+	#fi
+
+	# Let Init scripts know that we booted from CD
+	export CDBOOT
+	CDBOOT=1
+	if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+	then
+		sleep 10
+	fi
+else
+	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		union_insert_dir ${UNION} ${NEW_ROOT}
+		mkdir -p ${UNION}/tmp/.initrd
+	fi
+fi
+
+# Execute script on the cdrom just before boot to update things if necessary
+cdupdate
+
+if [ "${SUBDIR}" != '' -a -e "${CHROOT}/${SUBDIR}" ]
+then
+	good_msg "Entering ${SUBDIR} to boot"
+	CHROOT=${CHROOT}/${SUBDIR}
+fi
+
+verbose_kmsg
+
+# Move the /memory mount point to what will be the system root so that 
+# init scripts will be able to unmount it properly at next reboot
+#
+# Eventually, all "unions over /" mounts should go in that /.unions/
+if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+then
+	mkdir -p /${CHROOT}/.unions/memory 2>/dev/null
+	mount -o move /memory /${CHROOT}/.unions/memory || echo '*: Failed to move unionfs /memory into the system root!'
+fi
+
+if [ "$0" = '/linuxrc' ] || [ "$0" = 'linuxrc' ]
+then
+	[ ! -e ${CHROOT}/dev/console ] && mknod ${CHROOT}/dev/console c 5 1
+	echo -ne "${GOOD}>>${NORMAL}${BOLD} Booting"
+
+	cd ${CHROOT}
+	mkdir ${CHROOT}/proc ${CHROOT}/sys 2>/dev/null
+	pivot_root . tmp/.initrd
+	if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+	then
+		sleep 10
+	fi
+	echo -n '.'
+
+	if /tmp/.initrd/bin/[ "${USE_DEVFS_NORMAL}" -eq '1' -a "${CDROOT}" -eq '0' ]
+	then
+		umount /tmp/.initrd/proc || echo '*: Failed to unmount the initrd /proc!'
+		mount -n --move /tmp/.initrd/dev dev || echo '*: Failed to move over the /dev tree!'
+		rm -rf /tmp/.initrd/dev || echo '*: Failed to remove the initrd /dev!'
+	elif /tmp/.initrd/bin/[ "${USE_UDEV_NORMAL}" -eq '1' ]
+	then
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/fd ] && rm /tmp/.initrd/dev/fd
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stdin ] && rm /tmp/.initrd/dev/stdin
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stdout ] && rm /tmp/.initrd/dev/stdout
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stderr ] && rm /tmp/.initrd/dev/stderr
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/core ] && rm /tmp/.initrd/dev/core 
+		umount /tmp/.initrd/dev || echo '*: Failed to unmount the initrd /dev!'
+		umount /tmp/.initrd/proc || echo '*: Failed to unmount the initrd /proc!'
+		umount /tmp/.initrd/sys || echo '*: Failed to unmount the initrd /sys!'
+	elif /tmp/.initrd/bin/[ "${CDROOT}" -eq '1' ]
+	then
+		umount /tmp/.initrd/proc || echo "*: Failed to unmount the initrd /proc!"
+		umount /dev 2>/dev/null
+		mount -n --move /tmp/.initrd/dev dev 2>/dev/null
+		rm -rf /tmp/.initrd/dev || echo '*: Failed to remove the initrd /dev!'
+
+		umount /sys 2>/dev/null
+		umount /tmp/.initrd/sys 2>/dev/null
+	fi
+	echo -n '.'
+
+	# /usr/src/linux/Documentation/initrd.txt:
+	#	exec chroot . /sbin/init </dev/console >/dev/console 2>&1
+
+	exec <dev/console >dev/console 2>&1
+	echo '.'
+	exec chroot . /bin/sh <<- EOF
+		umount /tmp/.initrd || echo "*: Failed to unmount the initrd!"
+		/sbin/blockdev --flushbufs /dev/ram0 >/dev/null 2>&1
+		exec ${REAL_INIT:-/sbin/init} ${INIT_OPTS}
+EOF
+elif [ "$0" = '/init' ]
+then
+	[ ! -e ${CHROOT}/dev/console ] && mknod ${CHROOT}/dev/console c 5 1
+	[ ! -e ${CHROOT}/dev/tty1 ] && mknod ${CHROOT}/dev/tty1 c 4 1
+	echo -ne "${GOOD}>>${NORMAL}${BOLD} Booting (initramfs)"
+
+	cd ${CHROOT}
+	mkdir ${CHROOT}/proc ${CHROOT}/sys 2>/dev/null
+	echo -n '.'
+		umount /sys || echo '*: Failed to unmount the initrd /sys!'
+		umount /proc || echo '*: Failed to unmount the initrd /proc!'
+	echo -n '.'
+
+	exec switch_root -c "/dev/console" "${CHROOT}" ${REAL_INIT:-/sbin/init} ${INIT_OPTS}
+fi
+
+splash 'verbose'
+
+echo 'A fatal error has probably occured since /sbin/init did not'
+echo 'boot correctly. Trying to open a shell...'
+echo
+exec /bin/bash
+exec /bin/sh
+exec /bin/ash
+exec sh
diff -Nurp genkernel-3.4.9_pre9.orig/gen_initramfs.sh genkernel-3.4.9_pre9/gen_initramfs.sh
--- genkernel-3.4.9_pre9.orig/gen_initramfs.sh	2007-11-14 00:09:21.000000000 +0100
+++ genkernel-3.4.9_pre9/gen_initramfs.sh	2007-11-15 12:13:47.000000000 +0100
@@ -74,21 +74,6 @@ append_blkid(){
 	rm -rf "${TEMP}/initramfs-blkid-temp" > /dev/null
 }
 
-append_unionfs_modules(){
-	if [ -d "${TEMP}/initramfs-unionfs-modules-temp" ]
-	then
-		rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
-	fi
-	print_info 1 'UNIONFS MODULES: Adding support (compiling)...'
-	compile_unionfs_modules
-	mkdir -p "${TEMP}/initramfs-unionfs-modules-temp/"
-	/bin/tar -jxpf "${UNIONFS_MODULES_BINCACHE}" -C "${TEMP}/initramfs-unionfs-modules-temp" ||
-		gen_die "Could not extract unionfs modules binary cache!";
-	cd "${TEMP}/initramfs-unionfs-modules-temp/"
-	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
-	rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
-}
-
 append_unionfs_tools(){
 	if [ -d "${TEMP}/initramfs-unionfs-tools-temp" ]
 	then
@@ -449,7 +434,6 @@ create_initramfs() {
 	append_data 'auxilary'
 	append_data 'busybox' "${BUSYBOX}"
 #	append_data 'devfs' "${DEVFS}"
-	append_data 'unionfs_modules' "${UNIONFS}"
 	append_data 'unionfs_tools' "${UNIONFS}"
 	append_data 'lvm' "${LVM}"
 	append_data 'dmraid' "${DMRAID}"
diff -Nurp genkernel-3.4.9_pre9.orig/gen_initramfs.sh.orig genkernel-3.4.9_pre9/gen_initramfs.sh.orig
--- genkernel-3.4.9_pre9.orig/gen_initramfs.sh.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre9/gen_initramfs.sh.orig	2007-11-14 00:09:21.000000000 +0100
@@ -0,0 +1,499 @@
+#!/bin/bash
+
+CPIO_ARGS="--quiet -o -H newc"
+
+append_base_layout() {
+	if [ -d "${TEMP}/initramfs-base-temp" ]
+	then
+		rm -rf "${TEMP}/initramfs-base-temp" > /dev/null
+	fi
+	mkdir -p ${TEMP}/initramfs-base-temp/dev
+	mkdir -p ${TEMP}/initramfs-base-temp/bin
+	mkdir -p ${TEMP}/initramfs-base-temp/etc
+	mkdir -p ${TEMP}/initramfs-base-temp/usr
+	mkdir -p ${TEMP}/initramfs-base-temp/proc
+	mkdir -p ${TEMP}/initramfs-base-temp/temp
+	mkdir -p ${TEMP}/initramfs-base-temp/sys
+	mkdir -p ${TEMP}/initramfs-temp/.initrd
+	mkdir -p ${TEMP}/initramfs-base-temp/var/lock/dmraid
+	mkdir -p ${TEMP}/initramfs-base-temp/sbin
+	mkdir -p ${TEMP}/initramfs-base-temp/usr/bin
+	mkdir -p ${TEMP}/initramfs-base-temp/usr/sbin
+	ln -s  lib  ${TEMP}/initramfs-base-temp/lib64
+
+	echo "/dev/ram0     /           ext2    defaults	0 0" > ${TEMP}/initramfs-base-temp/etc/fstab
+	echo "proc          /proc       proc    defaults    0 0" >> ${TEMP}/initramfs-base-temp/etc/fstab
+	
+	cd ${TEMP}/initramfs-base-temp/dev
+	mknod -m 660 console c 5 1
+	mknod -m 660 null c 1 3
+	mknod -m 600 tty1 c 4 1
+	cd "${TEMP}/initramfs-base-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-base-temp" > /dev/null
+}
+
+append_busybox() {
+	if [ -d "${TEMP}/initramfs-busybox-temp" ]
+	then
+		rm -rf "${TEMP}/initramfs-busybox-temp" > /dev/null
+	fi
+	mkdir -p "${TEMP}/initramfs-busybox-temp/bin/" 
+
+	cp "${GK_SHARE}/generic/udhcpc.scripts" ${TEMP}/initramfs-busybox-temp/bin/
+	chmod +x "${TEMP}/initramfs-busybox-temp/bin/udhcpc.scripts"
+	cp "${BUSYBOX_BINCACHE}" "${TEMP}/initramfs-busybox-temp/bin/busybox.tar.bz2" ||
+		gen_die 'Could not copy busybox from bincache!'
+	tar -xjf "${TEMP}/initramfs-busybox-temp/bin/busybox.tar.bz2" -C "${TEMP}/initramfs-busybox-temp/bin" busybox ||
+		gen_die 'Could not extract busybox bincache!'
+	chmod +x "${TEMP}/initramfs-busybox-temp/bin/busybox"
+
+	for i in '[' ash sh mount uname echo cut; do
+		rm -f ${TEMP}/initramfs-busybox-temp/bin/$i > /dev/null
+		ln ${TEMP}/initramfs-busybox-temp/bin/busybox ${TEMP}/initramfs-busybox-temp/bin/$i ||
+			gen_die "Busybox error: could not link ${i}!"
+	done
+	
+	cd "${TEMP}/initramfs-busybox-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-busybox-temp" > /dev/null
+}
+
+append_blkid(){
+	if [ -d "${TEMP}/initramfs-blkid-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-blkid-temp/"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-blkid-temp/bin/"
+	[ "${DISKLABEL}" -eq '1' ] && { /bin/bzip2 -dc "${BLKID_BINCACHE}" > "${TEMP}/initramfs-blkid-temp/bin/blkid" ||
+		gen_die "Could not extract blkid binary cache!"; }
+	chmod a+x "${TEMP}/initramfs-blkid-temp/bin/blkid"
+	cd "${TEMP}/initramfs-blkid-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-blkid-temp" > /dev/null
+}
+
+append_unionfs_modules(){
+	if [ -d "${TEMP}/initramfs-unionfs-modules-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
+	fi
+	print_info 1 'UNIONFS MODULES: Adding support (compiling)...'
+	compile_unionfs_modules
+	mkdir -p "${TEMP}/initramfs-unionfs-modules-temp/"
+	/bin/tar -jxpf "${UNIONFS_MODULES_BINCACHE}" -C "${TEMP}/initramfs-unionfs-modules-temp" ||
+		gen_die "Could not extract unionfs modules binary cache!";
+	cd "${TEMP}/initramfs-unionfs-modules-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
+}
+
+append_unionfs_tools(){
+	if [ -d "${TEMP}/initramfs-unionfs-tools-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-unionfs-tools-temp/"
+	fi
+	print_info 1 'UNIONFS TOOLS: Adding support (compiling)...'
+	compile_unionfs_utils
+	mkdir -p "${TEMP}/initramfs-unionfs-tools-temp/bin/"
+	/bin/tar -jxpf "${UNIONFS_BINCACHE}" -C "${TEMP}/initramfs-unionfs-tools-temp" ||
+		gen_die "Could not extract unionfs tools binary cache!";
+	cd "${TEMP}/initramfs-unionfs-tools-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-unionfs-tools-temp/"
+}
+
+#append_suspend(){
+#	if [ -d "${TEMP}/initramfs-suspend-temp" ];
+#	then
+#		rm -r "${TEMP}/initramfs-suspend-temp/"
+#	fi
+#	print_info 1 'SUSPEND: Adding support (compiling binaries)...'
+#	compile_suspend
+#	mkdir -p "${TEMP}/initramfs-suspend-temp/"
+#	/bin/tar -jxpf "${SUSPEND_BINCACHE}" -C "${TEMP}/initramfs-suspend-temp" ||
+#		gen_die "Could not extract suspend binary cache!"
+#	mkdir -p "${TEMP}/initramfs-suspend-temp/etc"
+#	cp -f /etc/suspend.conf "${TEMP}/initramfs-suspend-temp/etc" ||
+#		gen_die 'Could not copy /etc/suspend.conf'
+#	cd "${TEMP}/initramfs-suspend-temp/"
+#	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+#	rm -r "${TEMP}/initramfs-suspend-temp/"
+#}
+
+append_dmraid(){
+	if [ -d "${TEMP}/initramfs-dmraid-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-dmraid-temp/"
+	fi
+	print_info 1 'DMRAID: Adding support (compiling binaries)...'
+	compile_dmraid
+	mkdir -p "${TEMP}/initramfs-dmraid-temp/"
+	/bin/tar -jxpf "${DMRAID_BINCACHE}" -C "${TEMP}/initramfs-dmraid-temp" ||
+		gen_die "Could not extract dmraid binary cache!";
+	cd "${TEMP}/initramfs-dmraid-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-dmraid-temp/"
+}
+
+append_lvm(){
+	if [ -d "${TEMP}/initramfs-lvm-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-lvm-temp/"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-lvm-temp/bin/"
+	mkdir -p "${TEMP}/initramfs-lvm-temp/etc/lvm/"
+	if [ -e '/sbin/lvm' ] && LC_ALL="C" ldd /sbin/lvm|grep -q 'not a dynamic executable'
+	then
+		print_info 1 '		LVM: Adding support (using local static binaries)...'
+		cp /sbin/lvm "${TEMP}/initramfs-lvm-temp/bin/lvm" ||
+			gen_die 'Could not copy over lvm!'
+	else
+		print_info 1 '		LVM: Adding support (compiling binaries)...'
+		compile_lvm
+		/bin/tar -jxpf "${LVM_BINCACHE}" -C "${TEMP}/initramfs-lvm-temp" ||
+			gen_die "Could not extract lvm binary cache!";
+		mv ${TEMP}/initramfs-lvm-temp/sbin/lvm.static ${TEMP}/initramfs-lvm-temp/bin/lvm ||
+			gen_die 'LVM error: Could not move lvm.static to lvm!'
+	fi
+	if [ -x /sbin/lvm ]
+	then
+#		lvm dumpconfig 2>&1 > /dev/null || gen_die 'Could not copy over lvm.conf!'
+#		ret=$?
+#		if [ ${ret} != 0 ]
+#		then
+			cp /etc/lvm/lvm.conf "${TEMP}/initramfs-lvm-temp/etc/lvm/" ||
+				gen_die 'Could not copy over lvm.conf!'
+#		else
+#			gen_die 'Could not copy over lvm.conf!'
+#		fi
+	fi
+	cd "${TEMP}/initramfs-lvm-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-lvm-temp/"
+}
+
+append_evms(){
+	if [ -d "${TEMP}/initramfs-evms-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-evms-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-evms-temp/lib/evms"
+	mkdir -p "${TEMP}/initramfs-evms-temp/etc/"
+	mkdir -p "${TEMP}/initramfs-evms-temp/bin/"
+	mkdir -p "${TEMP}/initramfs-evms-temp/sbin/"
+	if [ "${EVMS}" -eq '1' ]
+	then
+		print_info 1 '		EVMS: Adding support...'
+		mkdir -p ${TEMP}/initramfs-evms-temp/lib
+		cp -a /lib/ld-* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		if [ -n "`ls /lib/libgcc_s*`" ]
+		then
+			cp -a /lib/libgcc_s* "${TEMP}/initramfs-evms-temp/lib" \
+				|| gen_die 'Could not copy files for EVMS!'
+		fi
+		cp -a /lib/libc-* /lib/libc.* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libdl-* /lib/libdl.* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libpthread* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libuuid*so* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libevms*so* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/evms "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/evms/* "${TEMP}/initramfs-evms-temp/lib/evms" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /etc/evms.conf "${TEMP}/initramfs-evms-temp/etc" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp /sbin/evms_activate "${TEMP}/initramfs-evms-temp/sbin" \
+			|| gen_die 'Could not copy over evms_activate!'
+
+		# Fix EVMS complaining that it can't find the swap utilities.
+		# These are not required in the initramfs
+		for swap_libs in "${TEMP}/initramfs-evms-temp/lib/evms/*/swap*.so"
+		do
+			rm ${swap_libs}
+		done
+	fi
+	cd "${TEMP}/initramfs-evms-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-evms-temp/"
+}
+
+append_mdadm(){
+	if [ -d "${TEMP}/initramfs-mdadm-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-mdadm-temp/"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-mdadm-temp/etc/"
+	if [ "${MDADM}" -eq '1' ]
+	then
+		cp -a /etc/mdadm.conf "${TEMP}/initramfs-mdadm-temp/etc" \
+			|| gen_die "Could not copy mdadm.conf!"
+	fi
+	cd "${TEMP}/initramfs-mdadm-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-mdadm-temp" > /dev/null
+}
+
+append_splash(){
+	if [ -x /usr/bin/splash_geninitramfs ] || [ -x /sbin/splash_geninitramfs ]
+	then
+		[ -z "${SPLASH_THEME}" ] && [ -e /etc/conf.d/splash ] && source /etc/conf.d/splash
+		[ -z "${SPLASH_THEME}" ] && SPLASH_THEME=default
+		print_info 1 "  >> Installing splash [ using the ${SPLASH_THEME} theme ]..."
+		if [ -d "${TEMP}/initramfs-splash-temp" ]
+		then
+			rm -r "${TEMP}/initramfs-splash-temp/"
+		fi
+		mkdir -p "${TEMP}/initramfs-splash-temp"
+		cd /
+		local tmp=""
+		[ -n "${SPLASH_RES}" ] && tmp="-r ${SPLASH_RES}"
+		splash_geninitramfs -c "${TEMP}/initramfs-splash-temp" ${tmp} ${SPLASH_THEME} || gen_die "Could not build splash cpio archive"
+		if [ -e "/usr/share/splashutils/initrd.splash" ]; then
+			mkdir -p "${TEMP}/initramfs-splash-temp/etc"
+			cp -f "/usr/share/splashutils/initrd.splash" "${TEMP}/initramfs-splash-temp/etc"
+		fi
+		cd "${TEMP}/initramfs-splash-temp/"
+		find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}" \
+			|| gen_die "compressing splash cpio"
+		rm -r "${TEMP}/initramfs-splash-temp/"
+	else
+		print_warning 1 '               >> No splash detected; skipping!'
+	fi
+}
+
+append_overlay(){
+	cd ${INITRAMFS_OVERLAY}
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+}
+print_list()
+{
+	local x
+	for x in ${*}
+	do
+		echo ${x}
+	done
+}
+
+append_modules() {
+	local group
+	local group_modules
+	local MOD_EXT=".ko"
+
+	print_info 2 "initramfs: >> Searching for modules..."
+	if [ "${INSTALL_MOD_PATH}" != '' ]
+	then
+	  cd ${INSTALL_MOD_PATH}
+	else
+	  cd /
+	fi
+	
+	if [ -d "${TEMP}/initramfs-modules-${KV}-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-modules-${KV}-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-modules-${KV}-temp/lib/modules/${KV}"	
+	for i in `gen_dep_list`
+	do
+		mymod=`find ./lib/modules/${KV} -name "${i}${MOD_EXT}" 2>/dev/null| head -n 1 `
+		if [ -z "${mymod}" ]
+		then
+			print_warning 2 "Warning :: ${i}${MOD_EXT} not found; skipping..."
+			continue;
+		fi
+		
+		print_info 2 "initramfs: >> Copying ${i}${MOD_EXT}..."
+		cp -ax --parents "${mymod}" "${TEMP}/initramfs-modules-${KV}-temp"
+	done
+	
+	cp -ax --parents ./lib/modules/${KV}/modules* ${TEMP}/initramfs-modules-${KV}-temp 2>/dev/null
+
+	mkdir -p "${TEMP}/initramfs-modules-${KV}-temp/etc/modules"
+	for group_modules in ${!MODULES_*}; do
+		group="$(echo $group_modules | cut -d_ -f2 | tr "[:upper:]" "[:lower:]")"
+		print_list ${!group_modules} > "${TEMP}/initramfs-modules-${KV}-temp/etc/modules/${group}"
+	done
+	cd "${TEMP}/initramfs-modules-${KV}-temp/"
+	find . | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
+	rm -r "${TEMP}/initramfs-modules-${KV}-temp/"	
+}
+
+# check for static linked file with objdump
+is_static() {
+	LANG="C" LC_ALL="C" objdump -T $1 2>&1 | grep "not a dynamic object" > /dev/null
+	return $?
+}
+
+append_auxilary() {
+	if [ -d "${TEMP}/initramfs-aux-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-aux-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-aux-temp/etc"	
+	mkdir -p "${TEMP}/initramfs-aux-temp/sbin"	
+	if [ -f "${CMD_LINUXRC}" ]
+	then
+		cp "${CMD_LINUXRC}" "${TEMP}/initramfs-aux-temp/init"
+		print_info 2 "        >> Copying user specified linuxrc: ${CMD_LINUXRC} to init"
+	else	
+		if [ -f "${GK_SHARE}/${ARCH}/linuxrc" ]
+		then
+			cp "${GK_SHARE}/${ARCH}/linuxrc" "${TEMP}/initramfs-aux-temp/init"
+		else
+			cp "${GK_SHARE}/generic/linuxrc" "${TEMP}/initramfs-aux-temp/init"
+		fi
+	fi
+
+	# Make sure it's executable
+	chmod 0755 "${TEMP}/initramfs-aux-temp/init"
+
+	# Make a symlink to init .. incase we are bundled inside the kernel as one
+	# big cpio.
+	cd ${TEMP}/initramfs-aux-temp
+	ln -s init linuxrc
+#	ln ${TEMP}/initramfs-aux-temp/init ${TEMP}/initramfs-aux-temp/linuxrc 
+
+	if [ -f "${GK_SHARE}/${ARCH}/initrd.scripts" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/initrd.scripts" "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	else	
+		cp "${GK_SHARE}/generic/initrd.scripts" "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	fi
+
+	if [ -f "${GK_SHARE}/${ARCH}/initrd.defaults" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/initrd.defaults" "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	else
+		cp "${GK_SHARE}/generic/initrd.defaults" "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	fi
+	
+	echo -n 'HWOPTS="$HWOPTS ' >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"	
+	for group_modules in ${!MODULES_*}; do
+		group="$(echo $group_modules | cut -d_ -f2 | tr "[:upper:]" "[:lower:]")"
+		echo -n "${group} " >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	done
+	echo '"' >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"	
+
+	if [ -f "${GK_SHARE}/${ARCH}/modprobe" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	else
+		cp "${GK_SHARE}/generic/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	fi
+	if isTrue $CMD_DOKEYMAPAUTO
+	then
+		echo 'MY_HWOPTS="${MY_HWOPTS} keymap"' >> ${TEMP}/initramfs-aux-temp/etc/initrd.defaults
+	fi
+	mkdir -p "${TEMP}/initramfs-aux-temp/lib/keymaps"
+	/bin/tar -C "${TEMP}/initramfs-aux-temp/lib/keymaps" -zxf "${GK_SHARE}/generic/keymaps.tar.gz"
+	if isTrue $CMD_SLOWUSB
+	then
+		echo 'MY_HWOPTS="${MY_HWOPTS} slowusb"' >> ${TEMP}/initramfs-aux-temp/etc/initrd.defaults
+	fi
+	if isTrue ${LUKS}
+	then
+		if is_static /bin/cryptsetup
+		then
+			print_info 1 "Including LUKS support"
+			rm -f ${TEMP}/initramfs-aux-temp/sbin/cryptsetup
+			cp /bin/cryptsetup ${TEMP}/initramfs-aux-temp/sbin/cryptsetup
+			chmod +x "${TEMP}/initramfs-aux-temp/sbin/cryptsetup"
+		else
+			print_info 1 "LUKS support requires static cryptsetup at /bin/cryptsetup"
+			print_info 1 "Not including LUKS support"
+		fi
+	fi
+
+	cd ${TEMP}/initramfs-aux-temp/sbin && ln -s ../init init
+	cd ${TEMP}
+	chmod +x "${TEMP}/initramfs-aux-temp/init"
+	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	chmod +x "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	cd "${TEMP}/initramfs-aux-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
+	rm -r "${TEMP}/initramfs-aux-temp/"	
+}
+
+append_data() {
+	local name=$1 var=$2
+	local func="append_${name}"
+
+	if [ $# -eq 1 ] || [ ${var} -eq 1 ]
+	then
+	    print_info 1 "        >> Appending ${name} cpio data..."
+	    ${func}
+	fi
+}
+
+create_initramfs() {
+	print_info 1 "initramfs: >> Initializing..."
+
+	# Create empty cpio
+	CPIO="${TMPDIR}/initramfs-${KV}"
+	echo | cpio ${CPIO_ARGS} -F "${CPIO}" 2>/dev/null \
+		|| gen_die "Could not create empty cpio at ${CPIO}"
+
+	append_data 'base_layout'
+	append_data 'auxilary'
+	append_data 'busybox' "${BUSYBOX}"
+#	append_data 'devfs' "${DEVFS}"
+	append_data 'unionfs_modules' "${UNIONFS}"
+	append_data 'unionfs_tools' "${UNIONFS}"
+	append_data 'lvm' "${LVM}"
+	append_data 'dmraid' "${DMRAID}"
+	append_data 'evms' "${EVMS}"
+	append_data 'mdadm' "${MDADM}"
+	
+	if [ "${NOINITRDMODULES}" -eq '0' ]
+	then
+		append_data 'modules'
+	else
+		print_info 1 "initramfs: Not copying modules..."
+	fi
+
+	append_data 'blkid' "${DISKLABEL}"
+	append_data 'splash' "${SPLASH}"
+
+	# This should always be appended last
+	if [ "${INITRAMFS_OVERLAY}" != '' ]
+	then
+		append_data 'overlay'
+	fi
+
+	gzip -9 "${CPIO}"
+	mv -f "${CPIO}.gz" "${CPIO}"
+
+	if [ "${ENABLE_PEGASOS_HACKS}" = 'yes' ]
+	then
+			# Pegasos hack for merging the initramfs into the kernel at compile time
+			cp ${TMPDIR}/initramfs-${KV} ${KERNEL_DIR}/arch/powerpc/boot/ramdisk.image.gz &&
+			rm ${TMPDIR}/initramfs-${KV}
+	elif [ ${BUILD_INITRAMFS} -eq '1' ]
+	then
+		# Mips also mimics Pegasos to merge the initramfs into the kernel
+		cp ${TMPDIR}/initramfs-${KV} ${KERNEL_DIR}/initramfs.cpio.gz
+		gunzip -f ${KERNEL_DIR}/initramfs.cpio.gz
+	fi
+
+	if ! isTrue "${CMD_NOINSTALL}"
+	then
+		if [ "${ENABLE_PEGASOS_HACKS}" != 'yes' ]
+		then
+			copy_image_with_preserve "initramfs" \
+				"${TMPDIR}/initramfs-${KV}" \
+				"initramfs-${KNAME}-${ARCH}-${KV}"
+		fi
+	fi
+}
