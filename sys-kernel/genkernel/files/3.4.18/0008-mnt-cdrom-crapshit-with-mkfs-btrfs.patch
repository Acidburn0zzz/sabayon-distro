--- genkernel-3.4.18.orig/defaults/initrd.defaults
+++ genkernel-3.4.18/defaults/initrd.defaults
@@ -71,6 +71,7 @@ CDROOT='0'
 CDROOT_DEV=''
 CDROOT_TYPE='auto'
 NEW_ROOT='/newroot'
+CDROOT_PATH='/mnt/cdrom'
 CONSOLE='/dev/console'
 
 LOOPS='/livecd.loop /zisofs /livecd.squashfs /image.squashfs /livecd.gcloop'
--- genkernel-3.4.18.orig/defaults/initrd.scripts
+++ genkernel-3.4.18/defaults/initrd.scripts
@@ -61,11 +61,10 @@ findmediamount() {
 	# $1 = mount dir name / media name
 	# $2 = recognition file
 	# $3 = variable to have the device path
-	# $4 = directory before /mnt, like NEW_ROOT
+	# $4 = actual mount dir path (full path)
 	# args remaining are possible devices 
 
-	local media=$1 recon=$2 vrbl=$3
-	local mntdir="${4}/mnt/${media}"
+	local media=$1 recon=$2 vrbl=$3 mntdir=$4
 	shift 4
 
 	good_msg "Looking for the ${media}" ${CRYPT_SILENT}
@@ -108,11 +107,6 @@ findmediamount() {
 				fi
 				good_msg "Attempting to mount media:- ${x}" ${CRYPT_SILENT}
 
-#				if [ "${media}" = "cdrom" ]; then
-#					mount -r -t iso9660 ${x} ${mntdir} &>/dev/null
-#				else
-#					mount -r -t auto ${x} ${mntdir} &>/dev/null
-#				fi
 				mount -r -t ${CDROOT_TYPE} ${x} ${mntcddir} >/dev/null 2>&1
 				if [ "$?" = '0' ]
 				then
@@ -166,7 +160,7 @@ bootstrapCD() {
 	# a bunch of extra devices
 	[ -n "${CDROOT_DEV}" ] && DEVICES="${CDROOT_DEV}"
 
-	findmediamount "cdrom" "${SUBDIR}/livecd" "REAL_ROOT" "${NEW_ROOT}" ${DEVICES}
+	findmediamount "cdrom" "${SUBDIR}/livecd" "REAL_ROOT" "${CDROOT_PATH}" ${DEVICES}
 }
 
 bootstrapKey() {
@@ -174,7 +168,7 @@ bootstrapKey() {
 	local KEYDEVS=`devicelist`
 	eval local keyloc='"${CRYPT_'${1}'_KEY}"'
 
-	findmediamount "key" "${keyloc}" "CRYPT_${1}_KEYDEV" "" ${KEYDEVS}
+	findmediamount "key" "${keyloc}" "CRYPT_${1}_KEYDEV" "/mnt/key" ${KEYDEVS}
 }
 
 cache_cd_contents() {
@@ -195,7 +189,7 @@ cache_cd_contents() {
 			good_msg "Copying loop file for caching..."
 			# Verify that the needed directory exists
 			mkdir -p "$(dirname ${NEW_ROOT}/mnt/${LOOP})"
-			cp -a ${NEW_ROOT}/mnt/cdrom/${LOOP} ${NEW_ROOT}/mnt/${LOOP}
+			cp -a ${CDROOT_PATH}/${LOOP} ${NEW_ROOT}/mnt/${LOOP}
 			if [ $? -ne 0 ]
 			then
 				bad_msg "Failed to cache the loop file! Lack of space?"
@@ -266,7 +260,7 @@ findnfsmount() {
 			if [ "${CDROOT}" != '0' ]
 			then
 				good_msg "Attempting to mount NFS CD image on ${NFSROOT} with options ${NFSOPTIONS}"
-				mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${NEW_ROOT}/mnt/cdrom
+				mount -t nfs -o ${NFSOPTIONS} ${NFSROOT} ${CDROOT_PATH}
 				if [ "$?" = '0' ]
 				then
 					REAL_ROOT="/dev/nfs"
@@ -291,7 +285,7 @@ findnfsmount() {
 }
 
 check_loop() {
-	if [ "${LOOP}" = '' -o ! -e "mnt/cdrom/${LOOP}" ]
+	if [ "${LOOP}" = '' -o ! -e "${CDROOT_PATH}/${LOOP}" ]
 	then
 	
 		bad_msg "Invalid loop location: ${LOOP}"
@@ -950,10 +944,10 @@ verbose_kmsg() {
 cdupdate() {
 	if [ "${CDROOT}" = '1' ]
 	then
-		if [ -x /${NEW_ROOT}/mnt/cdrom/cdupdate.sh ]
+		if [ -x /${CDROOT_PATH}/cdupdate.sh ]
 		then
 			good_msg "Running cdupdate.sh"
-			${NEW_ROOT}/mnt/cdrom/cdupdate.sh
+			${CDROOT_PATH}/cdupdate.sh
 			if [ "$?" != '0' ]
 			then
 				bad_msg "Executing cdupdate.sh failed!"
@@ -1068,10 +1062,9 @@ tuxonice_resume() {
 }
 
 find_loop() {
-	CDROM="${NEW_ROOT}/mnt/cdrom"
 	for loop in ${LOOPS}
 	do
-		if [ -e "${CDROM}""${loop}" ]
+		if [ -e "${CDROOT_PATH}""${loop}" ]
 		then
 			LOOP="${loop}"
 		fi
@@ -1101,8 +1094,7 @@ setup_squashfs_aufs() {
 	good_msg "Loading aufs"
 	modprobe aufs > /dev/null 2>&1
 
-	cd "${NEW_ROOT}"
-	mount -t squashfs -o loop,ro "mnt/cdrom${LOOPEXT}${LOOP}" "${static}"
+	mount -t squashfs -o loop,ro "${CDROOT_PATH}/${LOOPEXT}${LOOP}" "${static}"
 	mount -t tmpfs none "${overlay}"
 	mount -t aufs -o br:${overlay}:${static} aufs "${NEW_ROOT}"
 
@@ -1111,9 +1103,10 @@ setup_squashfs_aufs() {
 	echo "aufs / aufs defaults 0 0" > "${NEW_ROOT}"/etc/fstab
 	for i in "${overlay}" "${static}"; do mount --move "${i}" "${NEW_ROOT}${i}"; done
 
-	# have handy /mnt/cdrom as well
-	[ ! -d "${NEW_ROOT}/mnt/cdrom" ] && mkdir -p "${NEW_ROOT}/mnt/cdrom"
-	mount --bind mnt/cdrom "${NEW_ROOT}/mnt/cdrom"
+	# have handy /mnt/cdrom (CDROOT_PATH) as well
+	local new_cdroot="${NEW_ROOT}${CDROOT_PATH}"
+	[ ! -d "${new_cdroot}" ] && mkdir -p "${new_cdroot}"
+	mount --bind "${CDROOT_PATH}" "${new_cdroot}"
 	)
 }
 
@@ -1174,6 +1167,8 @@ setup_unionfs() {
 			bad_msg "Can't setup union mount!"
 			USE_UNIONFS_NORMAL=0
 		fi
+		[ ! -d "${NEW_ROOT}${CDROOT_PATH}" ] && mkdir -p "${NEW_ROOT}${CDROOT_PATH}"
+		mount --bind "${CDROOT_PATH}" "${NEW_ROOT}${CDROOT_PATH}"
 	else
 		USE_UNIONFS_NORMAL=0
 	fi
--- genkernel-3.4.18.orig/defaults/linuxrc
+++ genkernel-3.4.18/defaults/linuxrc
@@ -363,11 +363,12 @@ then
 	good_msg "Making tmpfs for ${NEW_ROOT}"
 	mount -n -t tmpfs tmpfs "${NEW_ROOT}"
 	
-	for i in dev mnt mnt/cdrom mnt/livecd mnt/key tmp tmp/.initrd mnt/gentoo sys
+	for i in dev mnt mnt/livecd mnt/key tmp tmp/.initrd mnt/gentoo sys
 	do
 		mkdir -p "${NEW_ROOT}/${i}"
 		chmod 755 "${NEW_ROOT}/${i}"
 	done
+	[ ! -d "${CDROOT_PATH}" ] && mkdir -p "${CDROOT_PATH}"
 	[ ! -e "${NEW_ROOT}/dev/null" ] && mknod "${NEW_ROOT}"/dev/null c 1 3
 	[ ! -e "${NEW_ROOT}/dev/console" ] && mknod "${NEW_ROOT}"/dev/console c 5 1
 
@@ -542,11 +543,11 @@ then
 	# If encrypted, find key and mount, otherwise mount as usual
 	if [ -n "${CRYPT_ROOT}" ]
 	then
-		CRYPT_ROOT_KEY="$(head -n 1 ${NEW_ROOT}/mnt/cdrom/livecd)"
+		CRYPT_ROOT_KEY="$(head -n 1 "${CDROOT_PATH}"/livecd)"
 		CRYPT_ROOT='/dev/loop0'
 		good_msg 'You booted an encrypted livecd' "${CRYPT_SILENT}"
 
-		losetup /dev/loop0 "${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}"
+		losetup /dev/loop0 "${CDROOT_PATH}/${LOOPEXT}${LOOP}"
 		test_success 'Preparing loop filesystem'
 
 		startLUKS
@@ -567,14 +568,14 @@ then
 		if [ "${LOOPTYPE}" = 'normal' ]
 		then
 			good_msg 'Mounting loop filesystem'
-			mount -t ext2 -o loop,ro "${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}" "${NEW_ROOT}/mnt/livecd"
+			mount -t ext2 -o loop,ro "${CDROOT_PATH}/${LOOPEXT}${LOOP}" "${NEW_ROOT}/mnt/livecd"
 			test_success 'Mount filesystem'
 			FS_LOCATION='mnt/livecd'
 		elif [ "${LOOPTYPE}" = 'squashfs' ]
 		then
 			if [ "${USE_AUFS_NORMAL}" != '1' ]; then
 				good_msg 'Mounting squashfs filesystem'
-				mount -t squashfs -o loop,ro "${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}" "${NEW_ROOT}/mnt/livecd"
+				mount -t squashfs -o loop,ro "${CDROOT_PATH}/${LOOPEXT}${LOOP}" "${NEW_ROOT}/mnt/livecd"
 			else
 				good_msg 'Mounting squashfs & aufs filesystems'
 				setup_squashfs_aufs
@@ -584,7 +585,7 @@ then
 		elif [ "${LOOPTYPE}" = 'gcloop' ]
 		then
 			good_msg 'Mounting gcloop filesystem'
-			echo ' ' | losetup -E 19 -e ucl-0 -p0 "${NEW_ROOT}/dev/loop0" "${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}"
+			echo ' ' | losetup -E 19 -e ucl-0 -p0 "${NEW_ROOT}/dev/loop0" "${CDROOT_PATH}/${LOOPEXT}${LOOP}"
 			test_success 'losetup the loop device'
 
 			mount -t ext2 -o ro "${NEW_ROOT}/dev/loop0" "${NEW_ROOT}/mnt/livecd"
@@ -592,10 +593,10 @@ then
 			FS_LOCATION='mnt/livecd'
 		elif [ "${LOOPTYPE}" = 'zisofs' ]
 		then
-			FS_LOCATION="mnt/cdrom/${LOOPEXT}${LOOP}"
+			FS_LOCATION="${CDROOT_PATH/\/}/${LOOPEXT}${LOOP}"
 		elif [ "${LOOPTYPE}" = 'noloop' ]
 		then
-			FS_LOCATION='mnt/cdrom'
+			FS_LOCATION="${CDROOT_PATH/\/}"
 		elif [ "${LOOPTYPE}" = 'sgimips' ]
 		then
 			# getdvhoff finds the starting offset (in bytes) of the squashfs
@@ -628,9 +629,9 @@ then
 	# We do this now, so that additional packages can add whereever they want.
 	if [ "${REAL_ROOT}" = '/dev/nfs' ]
 	then
-		if [ -e "${NEW_ROOT}/mnt/cdrom/add" ]
+		if [ -e "${CDROOT_PATH}/add" ]
 		then
-				for targz in `ls ${NEW_ROOT}/mnt/cdrom/add/*.tar.gz`
+				for targz in `ls ${CDROOT_PATH}/add/*.tar.gz`
 				do	
 					tarname=`basename ${targz}`
 					good_msg "Adding additional package ${tarname}"
@@ -642,7 +643,7 @@ then
 
 	if [ "${USE_UNIONFS_NORMAL}" = '1' ]
 	then
-		setup_unionfs ${NEW_ROOT} ${NEW_ROOT}/${FS_LOCATION}
+		setup_unionfs ${NEW_ROOT} /${FS_LOCATION}
 		CHROOT=/union
 	elif [ "${USE_AUFS_NORMAL}" != '1' ]; then
 	
