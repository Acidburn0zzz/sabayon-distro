diff -Nurp genkernel-3.4.9_pre3.orig/gen_compile.sh genkernel-3.4.9_pre3/gen_compile.sh
--- genkernel-3.4.9_pre3.orig/gen_compile.sh	2007-09-17 21:52:20.000000000 +0200
+++ genkernel-3.4.9_pre3/gen_compile.sh	2007-10-10 02:19:17.000000000 +0200
@@ -403,13 +403,10 @@ compile_unionfs_utils() {
 			gen_die 'Unionfs directory ${UNIONFS_DIR} is invalid!'
 		cd "${UNIONFS_DIR}"
 		print_info 1 'unionfs tools: >> Compiling...'
-		sed -i utils/Makefile -e 's|${CC} -o|${CC} -static -o|g'
-		sed -i Makefile -e 's|${CC} -o|${CC} -static -o|g'
-		compile_generic utils utils
-
-		if [ ! -e "uniondbg" ]; then
-			cd utils
-		fi
+		./bootstrap &> /dev/null
+		./configure >> ${DEBUGFILE} 2>&1 || gen_die 'Configuring unionfs-utils failed!'
+		sed -i Makefile -e 's|LDFLAGS = |LDFLAGS = -all-static|g'
+		compile_generic '' utils
 		print_info 1 'unionfs: >> Copying to cache...'
 		strip uniondbg unionctl
 		cp uniondbg ${TEMP}/unionfs/sbin/ || 
diff -Nurp genkernel-3.4.9_pre3.orig/generic/linuxrc genkernel-3.4.9_pre3/generic/linuxrc
--- genkernel-3.4.9_pre3.orig/generic/linuxrc	2007-09-17 21:52:20.000000000 +0200
+++ genkernel-3.4.9_pre3/generic/linuxrc	2007-10-10 02:19:17.000000000 +0200
@@ -596,6 +596,9 @@ then
 	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
 	then
 		union_insert_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
+
+		mkdir ${UNION}/mnt/livecd
+		mount --bind ${NEW_ROOT}/${FS_LOCATION} ${UNION}/mnt/livecd
 		
 		# Make sure fstab notes livecd is mounted ro.  Makes system skip remount which fails on unionfs dirs.
 		sed -e 's|\(.*\s/\s*tmpfs\s*\)defaults\(.*\)|\1defaults,ro\2|' /${UNION}/etc/fstab > /${UNION}/etc/fstab.new
diff -Nurp genkernel-3.4.9_pre3.orig/generic/linuxrc.orig genkernel-3.4.9_pre3/generic/linuxrc.orig
--- genkernel-3.4.9_pre3.orig/generic/linuxrc.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre3/generic/linuxrc.orig	2007-09-17 21:52:20.000000000 +0200
@@ -0,0 +1,793 @@
+#!/bin/sh
+# Copyright 2003-2007 Gentoo Foundation 
+# Distributed under the terms of the GNU General Public License v2
+
+. /etc/initrd.defaults
+. /etc/initrd.scripts
+
+splash() {
+	return 0
+}
+
+[ -e /etc/initrd.splash ] && . /etc/initrd.splash
+
+# Clean input/output
+exec >${CONSOLE} <${CONSOLE} 2>&1
+
+if [ "$$" != '1' ]
+then
+	echo '/linuxrc has to be run as the init process as the one'
+	echo 'with a PID of 1. Try adding init="/linuxrc" to the'
+	echo 'kernel command line or running "exec /linuxrc".'
+	exit 1
+fi
+
+mount -t proc proc /proc >/dev/null 2>&1
+mount -o remount,rw / >/dev/null 2>&1
+
+# Set up symlinks
+if [ "$0" = '/init' ]
+then
+	/bin/busybox --install -s
+
+	[ -e /linuxrc ] && rm /linuxrc
+	 
+	if [ -e /bin/lvm ]
+	then
+		ln -s /bin/lvm /bin/vgscan
+		ln -s /bin/lvm /bin/vgchange
+	fi
+fi
+
+quiet_kmsg
+
+CMDLINE="`cat /proc/cmdline`"
+# Scan CMDLINE for any specified real_root= or cdroot arguments
+REAL_ROOT=''
+FAKE_ROOT=''
+REAL_ROOTFLAGS=''
+for x in ${CMDLINE}
+do
+	case "${x}" in
+		real_root\=*)
+			REAL_ROOT=`parse_opt "${x}"`
+		;;
+		root\=*)
+			FAKE_ROOT=`parse_opt "${x}"`
+		;;
+		subdir\=*)
+			SUBDIR=`parse_opt "${x}"`
+		;;
+		real_init\=*)
+			REAL_INIT=`parse_opt "${x}"`
+		;;
+		init_opts\=*)
+			INIT_OPTS=`parse_opt "${x}"`
+		;;
+		# Livecd options
+		cdroot)
+			CDROOT=1
+		;;
+		cdroot\=*)
+			CDROOT=1
+			CDROOT_DEV=`parse_opt "${x}"`
+		;;
+		# Start livecd loop, looptype options
+		loop\=*)
+			LOOP=`parse_opt "${x}"`
+		;;
+		looptype\=*)
+			LOOPTYPE=`parse_opt "${x}"`
+		;;
+		unionfs)
+			if [ ! -x /sbin/unionctl ]
+			then
+				USE_UNIONFS_NORMAL=0
+				bad_msg 'Unionctl not found: aborting use of unionfs!'
+			else
+				USE_UNIONFS_NORMAL=1
+			fi
+		;;
+		unionfs\=*)
+			if [ ! -x /sbin/unionctl ]
+			then
+				USE_UNIONFS_NORMAL=0
+				bad_msg 'Unionctl not found: aborting use of unionfs!'
+			else
+				USE_UNIONFS_NORMAL=1
+				CMD_UNIONFS=`parse_opt "${x}"`
+				echo ${CMD_UNIONFS}|grep , >/dev/null 2>&1
+				if [ "$?" -eq '0' ]
+				then
+					UID=`echo ${CMD_UNIONFS#*,}`
+					UNIONFS=`echo ${CMD_UNIONFS%,*}`
+				else
+					UNIONFS=${CMD_UNIONFS}
+				fi
+			fi
+		;;
+		# Start Volume manager options 
+		dolvm)
+			USE_LVM_NORMAL=1
+		;;
+		dodmraid)
+			USE_DMRAID_NORMAL=1
+		;;
+		dodmraid\=*)
+			DMRAID_OPTS=`parse_opt "${x}"`
+			USE_DMRAID_NORMAL=1
+		;;
+		doevms)
+			USE_EVMS_NORMAL=1
+		;;
+		# Debug Options
+		debug)
+			DEBUG='yes'
+		;;
+		 # Scan delay options 
+		scandelay\=*)
+			SDELAY=`parse_opt "${x}"`
+		;;
+		scandelay)
+			SDELAY=10
+		;;
+		# Module no-loads
+		doload\=*)
+			MDOLIST=`parse_opt "${x}"`
+			MDOLIST="`echo ${MDOLIST} | sed -e \"s/,/ /g\"`"
+		;;
+		nodetect)
+			NODETECT=1
+		;;
+		noload\=*)
+			MLIST=`parse_opt "${x}"`
+			MLIST="`echo ${MLIST} | sed -e \"s/,/ /g\"`"
+			export MLIST
+		;;
+		# Redirect output to a specific tty
+		CONSOLE\=*)
+			CONSOLE=`parse_opt "${x}"`
+			exec >${CONSOLE} <${CONSOLE} 2>&1
+		;;
+		# /dev/md
+		lvmraid\=*)
+			RAID_DEVICES="`parse_opt ${x}`"
+			RAID_DEVICES="`echo ${RAID_DEVICES} | sed -e 's/,/ /g'`"
+		;;
+		part\=*)
+			MDPART=`parse_opt "${x}"`
+		;;
+		# NFS
+		ip\=*)
+			IP=`parse_opt "${x}"`
+		;;
+		nfsroot\=*)
+			NFSROOT=`parse_opt "${x}"`
+		;;
+		crypt_root\=*)
+			LUKS_ROOT=`parse_opt "${x}"`
+		;;
+		crypt_swap\=*)
+			LUKS_SWAP=`parse_opt "${x}"`
+		;;
+		crypt_silent\=*)
+			LUKS_SILENT=`parse_opt "${x}"`
+		;;
+		real_rootflags\=*)
+			REAL_ROOTFLAGS=`parse_opt "${x}"`
+		;;
+	esac
+done
+
+if [ -z "${REAL_ROOT}" -a \( "${CDROOT}" -eq 0 \)  -a \( "${FAKE_ROOT}" != "/dev/ram0" \) ]
+then
+	REAL_ROOT="${FAKE_ROOT}"	
+fi
+
+splash 'init'
+
+detect_sbp2_devices
+cmdline_hwopts
+
+# Load modules listed in MY_HWOPTS if /lib/modules exists
+if [ -d '/lib/modules' ]
+then
+	good_msg 'Loading modules'
+	# Load appropriate kernel modules
+	if [ "${NODETECT}" -ne '1' ]
+	then
+		for modules in $MY_HWOPTS
+		do
+			modules_scan $modules
+			eval DO_`echo $modules | sed 's/-//'`=1
+		done
+	fi
+	# Always eval doload=...
+	modules_load $MDOLIST
+else
+	for modules in $MY_HWOPTS
+	do
+		eval DO_`echo $modules | sed 's/-//'`=1
+	done
+	good_msg 'Skipping module load; no modules in the initrd!'
+fi
+
+# Mount sysfs
+mount_sysfs
+
+# Delay if needed for USB hardware
+sdelay
+
+# Start udev/devfs
+start_dev_mgr
+
+# Setup md device nodes if they dont exist
+setup_md_device
+
+# Scan volumes
+startVolumes
+
+# Initialize LUKS root device except for livecd's
+if [ "${CDROOT}" -ne '1' ]
+then
+	startLUKS
+fi
+
+# Set up unionfs
+mkdir -p ${NEW_ROOT}
+setup_unionfs
+
+if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+then
+	CHROOT=${UNION}
+else
+	CHROOT=${NEW_ROOT}
+fi
+
+# Run debug shell if requested
+rundebugshell
+
+#suspend_resume
+suspend2_resume
+
+if [ "${CDROOT}" -eq '1' ]
+then
+	if [ ! "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		good_msg "Making tmpfs for ${NEW_ROOT}"
+		mount -t tmpfs tmpfs ${NEW_ROOT}
+	fi
+	
+	for i in dev mnt mnt/cdrom mnt/livecd mnt/keydev tmp tmp/.initrd mnt/gentoo sys
+	do
+		mkdir -p ${NEW_ROOT}/$i
+		chmod 755 ${NEW_ROOT}/$i
+	done
+	[ ! -e ${NEW_ROOT}/dev/null ] && mknod ${NEW_ROOT}/dev/null c 1 3
+	[ ! -e ${NEW_ROOT}/dev/console ] && mknod ${NEW_ROOT}/dev/console c 5 1
+
+	# For SGI LiveCDs ...
+	if [ "${LOOPTYPE}" = "sgimips" ]
+	then
+		[ ! -e ${NEW_ROOT}/dev/sr0 ] && mknod ${NEW_ROOT}/dev/sr0 b 11 0
+		[ ! -e ${NEW_ROOT}/dev/loop0 ] && mknod ${NEW_ROOT}/dev/loop0 b 7 0
+	fi
+
+	# Required for gensplash to work.  Not an issue with the initrd as this
+	# device isnt created there and is not needed.
+	if [ -e /dev/tty1 ]
+	then
+		[ ! -e ${NEW_ROOT}/dev/tty1 ] && mknod ${NEW_ROOT}/dev/tty1 c 4 1
+	fi
+
+	if [ "${REAL_ROOT}" != "/dev/nfs" ] && [ "${LOOPTYPE}" != "sgimips" ]
+	then
+		bootstrapCD
+	fi
+
+	if [ "${REAL_ROOT}" = '' ]
+	then
+		echo -n -e "${WARN}>>${NORMAL}${BOLD} No bootable medium found. Waiting for new devices"
+		
+		COUNTER=0
+		while [ $COUNTER -lt 3 ]; do
+			sleep 3
+			echo -n '.'
+			let COUNTER=$COUNTER+1
+		done	
+		
+		sleep 1
+		echo -e "${NORMAL}"
+		bootstrapCD
+	fi
+
+	if [ "${REAL_ROOT}" = '' ]
+	then
+		# Undo stuff
+		umount  ${NEW_ROOT}/dev 2>/dev/null
+		umount  ${NEW_ROOT}/sys 2>/dev/null
+		umount /sys 2>/dev/null
+
+		umount  ${NEW_ROOT}
+		rm -rf  ${NEW_ROOT}/*
+
+		bad_msg 'Could not find CD to boot, something else needed!'
+		CDROOT=0
+	fi
+fi
+
+setup_keymap
+
+# Determine root device
+good_msg 'Determining root device...'
+while true
+do
+	while [ "${got_good_root}" != '1' ]
+	do
+		case "${REAL_ROOT}" in
+			LABEL\=*|UUID\=*)
+			
+				ROOT_DEV=""
+				retval=1
+				
+				if [ "${retval}" -ne '0' ]; then
+					ROOT_DEV=`findfs "${REAL_ROOT}" 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "$retval" -ne '0' ]; then
+					ROOT_DEV=`busybox findfs "${REAL_ROOT}" 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "${retval}" -ne '0' ]; then
+					ROOT_DEV=`blkid -t "${REAL_ROOT}" | cut -d ":" -f 1 2>/dev/null`
+					retval=$?
+				fi
+				
+				if [ "${retval}" -eq '0' ] && [ -n "${ROOT_DEV}" ]; then
+					good_msg "Detected real_root=${ROOT_DEV}"
+					REAL_ROOT="${ROOT_DEV}"
+				else
+					bad_msg "Could not find root block device: ${REAL_ROOT}"
+					echo '   Please specify a device to boot, or "shell" for a shell...'
+					echo -n 'boot() :: '
+					read REAL_ROOT
+					got_good_root=0
+					continue
+				fi
+				;;
+		esac
+				
+		if [ "${REAL_ROOT}" = 'shell' ]
+		then
+			run_shell
+
+			REAL_ROOT=''
+			got_good_root=0
+			continue
+		
+		elif [ "${REAL_ROOT}" = '' ]
+		then
+			# No REAL_ROOT determined/specified. Prompt user for root block device.
+			bad_msg "The root block device is unspecified or not detected."
+			echo '   Please specify a device to boot, or "shell" for a shell...'
+			echo -n 'boot() :: '
+			read REAL_ROOT
+			got_good_root=0
+
+		# Check for a block device or /dev/nfs
+		elif [ -b "${REAL_ROOT}" ] || [ "${REAL_ROOT}" = "/dev/nfs" ]
+		then
+			got_good_root=1
+
+		else
+			bad_msg "Block device ${REAL_ROOT} is not a valid root device..."
+			REAL_ROOT=""
+			got_good_root=0
+		fi
+	done
+
+
+	if [ "${CDROOT}" -eq '1' -a "${got_good_root}" = '1' -a "${REAL_ROOT}" != "/dev/nfs" ]
+	then
+		# CD already mounted; no further checks necessary
+		break
+	elif [ "${LOOPTYPE}" = "sgimips" ]
+	then
+		# sgimips mounts the livecd root partition directly
+		# there is no isofs filesystem to worry about
+		break
+	else
+		good_msg "Mounting root..."
+
+		# Try to mount the device as ${NEW_ROOT}
+		if [ "${REAL_ROOT}" = '/dev/nfs' ]; then
+			findnfsmount
+		else
+			# mount ro so fsck doesn't barf later
+#			REAL_ROOT_TYPE=`vol_id -t ${REAL_ROOT}`
+#			mount -t ${REAL_ROOT_TYPE} -o ro ${REAL_ROOT} ${NEW_ROOT}
+			if [ "${REAL_ROOTFLAGS}" = '' ]; then
+				mount -o ro ${REAL_ROOT} ${NEW_ROOT}
+			else
+				good_msg "Using mount -o ro,${REAL_ROOTFLAGS}"
+				mount -o ro,${REAL_ROOTFLAGS} ${REAL_ROOT} ${NEW_ROOT}
+			fi
+		fi
+		
+		# If mount is successful break out of the loop 
+		# else not a good root and start over.
+
+		if [ "$?" = '0' ]
+		then
+			break
+		else
+			bad_msg "Could not mount specified ROOT, try again"
+			got_good_root=0
+			REAL_ROOT=''
+		fi
+	fi
+done
+# End determine root device
+
+#verbose_kmsg
+
+# If cdroot is set determine the looptype to boot
+if [ "${CDROOT}" = '1' ]
+then
+	good_msg 'Determining looptype ...'
+	cd ${NEW_ROOT}
+
+	# Find loop and looptype if we have NFS-mounted a livecd
+	if  [ "${LOOP}" = '' ] && [ "${REAL_ROOT}" = '/dev/nfs' ]
+	then
+		if [ -e "${NEW_ROOT}/mnt/cdrom/livecd.loop" ]; then
+			LOOP='/livecd.loop'
+			LOOPTYPE='normal'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/zisofs" ]; then
+			LOOP='/zisofs'
+			LOOPTYPE='zisofs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/livecd.squashfs" ]; then
+			LOOP='/livecd.squashfs'
+			LOOPTYPE='squashfs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/image.squashfs" ]; then
+			LOOP='/image.squashfs'
+			LOOPTYPE='squashfs'
+				elif [ -e "${NEW_ROOT}/mnt/cdrom/livecd.gcloop" ]; then
+			LOOP='/livecd.gcloop'
+			LOOPTYPE='gcloop'
+				else
+			LOOPTYPE='noloop'
+		fi
+	fi
+
+	# Failsafe the loop type wasn't set
+	if [ "${LOOPTYPE}" = '' ]
+	then
+		warn_msg 'Warning: loop type unspecified!'
+		if [ "${LOOP}" = '/livecd.loop' ]
+		then
+			LOOPTYPE='normal'
+		elif [ "${LOOP}" = '/zisofs' ]
+		then
+			LOOPTYPE='zisofs'
+		elif [ "${LOOP}" = '/livecd.squashfs' ]
+		then
+			LOOPTYPE='squashfs'
+		elif [ "${LOOP}" = '/image.squashfs' ]
+		then
+			LOOPTYPE='squashfs'
+		elif [ "${LOOP}" = '/livecd.gcloop' ]
+		then
+			LOOPTYPE='gcloop'
+		else
+			LOOPTYPE='noloop'
+		fi
+	fi
+
+	cache_cd_contents
+	
+
+        # If encrypted, find key and mount, otherwise mount as usual
+	if [ "${LUKS_ROOT}" != '' ] 
+	then
+		if [ "${LUKS_SILENT}" = '' ]
+		then
+			good_msg 'You booted an encrypted livecd'
+		fi
+
+		LUKS_ROOT_KEY=$(head -n 1 ${NEW_ROOT}/mnt/cdrom/livecd)
+
+		if [ "${LUKS_ROOT_KEY}" ]
+		then
+			bootstrapKey
+		fi
+		
+		losetup /dev/loop0 ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}
+		
+		test_success 'Preparing loop filesystem'
+		
+		LUKS_ROOT='/dev/loop0'
+		
+		startLUKS
+		
+		case ${LOOPTYPE} in
+			normal)
+				MOUNTTYPE="ext2"
+				;;
+			*)
+				MOUNTTYPE="${LOOPTYPE}"
+				;;
+		esac		
+
+
+		mount -t ${MOUNTTYPE} -o ro /dev/mapper/root ${NEW_ROOT}/mnt/livecd 
+		
+		test_success 'Mount filesystem'	
+		FS_LOCATION='mnt/livecd'
+
+
+
+	# Setup the loopback mounts, if unencrypted
+	else
+		if [ "${LOOPTYPE}" = 'normal' ]
+		then
+			good_msg 'Mounting loop filesystem'
+			mount -t ext2 -o loop,ro ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP} ${NEW_ROOT}/mnt/livecd
+			test_success 'Mount filesystem'
+			FS_LOCATION='mnt/livecd'
+	
+	
+		elif [ "${LOOPTYPE}" = 'squashfs' ]
+		then
+			good_msg 'Mounting squashfs filesystem'
+			mount -t squashfs -o loop,ro ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP} ${NEW_ROOT}/mnt/livecd
+			
+			test_success 'Mount filesystem'
+			FS_LOCATION='mnt/livecd'
+		
+		elif [ "${LOOPTYPE}" = 'gcloop' ]
+		then
+			good_msg 'Mounting gcloop filesystem'
+			echo ' ' | losetup -E 19 -e ucl-0 -p0 ${NEW_ROOT}/dev/loop0 ${NEW_ROOT}/mnt/cdrom/${LOOPEXT}${LOOP}
+			test_success 'losetup the loop device'
+	
+			mount -t ext2 -o ro ${NEW_ROOT}/dev/loop0 ${NEW_ROOT}/mnt/livecd
+			test_success 'Mount the losetup loop device'
+			FS_LOCATION='mnt/livecd'
+		
+		elif [ "${LOOPTYPE}" = 'zisofs' ]
+		then
+			FS_LOCATION="mnt/cdrom/${LOOPEXT}${LOOP}"
+		
+		elif [ "${LOOPTYPE}" = 'noloop' ]
+		then
+			FS_LOCATION='mnt/cdrom'
+	
+		elif [ "${LOOPTYPE}" = 'sgimips' ]
+		then
+			# getdvhoff finds the starting offset (in bytes) of the squashfs
+			# partition on the cdrom and returns this offset for losetup
+			#
+			# All currently supported SGI Systems use SCSI CD-ROMs, so
+			# so we know that the CD-ROM is usually going to be /dev/sr0.
+			#
+			# We use the value given to losetup to set /dev/loop0 to point
+			# to the liveCD root partition, and then mount /dev/loop0 as
+			# the LiveCD rootfs
+			good_msg 'Locating the SGI LiveCD Root Partition'
+			echo ' ' | \
+				losetup -o $(/bin/getdvhoff ${NEW_ROOT}${REAL_ROOT} 0) \
+					${NEW_ROOT}${CDROOT_DEV} \
+					${NEW_ROOT}${REAL_ROOT}
+			test_success 'losetup /dev/sr0 /dev/loop0'
+	
+			good_msg 'Mounting the Root Partition'
+			mount -t squashfs -o ro ${NEW_ROOT}${CDROOT_DEV} ${NEW_ROOT}/mnt/livecd
+			test_success 'mount /dev/loop0 /'
+			FS_LOCATION='mnt/livecd'
+		fi
+	fi
+#
+# End cdrom looptype determination and mounting if necessary
+#
+
+	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		union_insert_dir ${UNION} ${NEW_ROOT}/${FS_LOCATION}
+		
+		# Make sure fstab notes livecd is mounted ro.  Makes system skip remount which fails on unionfs dirs.
+		sed -e 's|\(.*\s/\s*tmpfs\s*\)defaults\(.*\)|\1defaults,ro\2|' /${UNION}/etc/fstab > /${UNION}/etc/fstab.new
+		mv /${UNION}/etc/fstab.new /${UNION}/etc/fstab
+	fi
+
+	# Unpacking additional packages from NFS mount
+	# This is useful for adding kernel modules to /lib
+	# We do this now, so that additional packages can add whereever they want.
+	if [ "${REAL_ROOT}" = '/dev/nfs' ]
+	then
+		if [ -e "${CHROOT}/mnt/cdrom/add" ]
+		then
+				for targz in `ls ${CHROOT}/mnt/cdrom/add/*.tar.gz`
+				do	
+					tarname=`basename ${targz}`
+					good_msg "Adding additional package ${tarname}"
+					(cd ${CHROOT} ; /bin/tar -xzf ${targz})
+				done
+		fi
+	fi
+
+	
+	if [ ! "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		good_msg "Copying read-write image contents to tmpfs"
+		# Copy over stuff that should be writable
+		(cd ${NEW_ROOT}/${FS_LOCATION}; cp -a ${ROOT_TREES} ${NEW_ROOT})
+
+		# Now we do the links.
+		for x in ${ROOT_LINKS}
+		do
+			if [ -L "${NEW_ROOT}/${FS_LOCATION}/${x}" ]
+			then
+				ln -s "`readlink ${NEW_ROOT}/${FS_LOCATION}/${x}`" "${x}" 2>/dev/null
+			else
+				# List all subdirectories of x
+				for directory in `find "${NEW_ROOT}/${FS_LOCATION}/${x}" -type d 2>/dev/null`
+				do
+					## Strip the prefix of the FS_LOCATION
+					directory=${directory#${NEW_ROOT}/${FS_LOCATION}/}
+
+					## Skip this directory if we already linked a parent directory
+					if [ "${curent_parrent}" != '' ]; then
+						var=`echo "${directory}" | grep "^${curent_parrent}"`
+						if [ "${var}" != '' ]; then
+							continue
+						fi
+					fi
+					## Test if the directory exists already
+					if [ -e "/${NEW_ROOT}/${directory}" ]
+					then
+						# It does exist, link all the individual files
+						for file in `ls /${NEW_ROOT}/${FS_LOCATION}/${directory}`
+						do
+						if [ ! -d "/${NEW_ROOT}/${FS_LOCATION}/${directory}/${file}" ] && [ ! -e "${NEW_ROOT}/${directory}/${file}" ]; then
+								ln -s "/${FS_LOCATION}/${directory}/${file}" "${directory}/${file}" 2> /dev/null
+							fi
+						done
+					else
+						# It does not exist, make a link to the livecd
+						ln -s "/${FS_LOCATION}/${directory}" "${directory}" 2>/dev/null
+						current_parent=${directory}
+					fi
+				done
+			fi
+		done
+
+		if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+		then
+			sleep 10
+		fi
+		mkdir initrd proc tmp sys 2>/dev/null
+		chmod 1777 tmp
+	fi
+	
+	#UML=`cat /proc/cpuinfo|grep UML|sed -e 's|model name.*: ||'`
+	#if [ "${UML}" = 'UML' ]
+	#then
+	#	# UML Fixes
+	#	good_msg 'Updating for uml system'
+	#fi
+
+	# Let Init scripts know that we booted from CD
+	export CDBOOT
+	CDBOOT=1
+	if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+	then
+		sleep 10
+	fi
+else
+	if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+	then
+		union_insert_dir ${UNION} ${NEW_ROOT}
+		mkdir -p ${UNION}/tmp/.initrd
+	fi
+fi
+
+# Execute script on the cdrom just before boot to update things if necessary
+cdupdate
+
+if [ "${SUBDIR}" != '' -a -e "${CHROOT}/${SUBDIR}" ]
+then
+	good_msg "Entering ${SUBDIR} to boot"
+	CHROOT=${CHROOT}/${SUBDIR}
+fi
+
+verbose_kmsg
+
+# Move the /memory mount point to what will be the system root so that 
+# init scripts will be able to unmount it properly at next reboot
+#
+# Eventually, all "unions over /" mounts should go in that /.unions/
+if [ "${USE_UNIONFS_NORMAL}" -eq '1' ]
+then
+	mkdir -p /${CHROOT}/.unions/memory 2>/dev/null
+	mount -o move /memory /${CHROOT}/.unions/memory || echo '*: Failed to move unionfs /memory into the system root!'
+fi
+
+if [ "$0" = '/linuxrc' ] || [ "$0" = 'linuxrc' ]
+then
+	[ ! -e ${CHROOT}/dev/console ] && mknod ${CHROOT}/dev/console c 5 1
+	echo -ne "${GOOD}>>${NORMAL}${BOLD} Booting"
+
+	cd ${CHROOT}
+	mkdir ${CHROOT}/proc ${CHROOT}/sys 2>/dev/null
+	pivot_root . tmp/.initrd
+	if [ "${DO_slowusb}" ] || [ "${FORCE_slowusb}" ]
+	then
+		sleep 10
+	fi
+	echo -n '.'
+
+	if /tmp/.initrd/bin/[ "${USE_DEVFS_NORMAL}" -eq '1' -a "${CDROOT}" -eq '0' ]
+	then
+		umount /tmp/.initrd/proc || echo '*: Failed to unmount the initrd /proc!'
+		mount -n --move /tmp/.initrd/dev dev || echo '*: Failed to move over the /dev tree!'
+		rm -rf /tmp/.initrd/dev || echo '*: Failed to remove the initrd /dev!'
+	elif /tmp/.initrd/bin/[ "${USE_UDEV_NORMAL}" -eq '1' ]
+	then
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/fd ] && rm /tmp/.initrd/dev/fd
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stdin ] && rm /tmp/.initrd/dev/stdin
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stdout ] && rm /tmp/.initrd/dev/stdout
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/stderr ] && rm /tmp/.initrd/dev/stderr
+		/tmp/.initrd/bin/[ -e /tmp/.initrd/dev/core ] && rm /tmp/.initrd/dev/core 
+		umount /tmp/.initrd/dev || echo '*: Failed to unmount the initrd /dev!'
+		umount /tmp/.initrd/proc || echo '*: Failed to unmount the initrd /proc!'
+		umount /tmp/.initrd/sys || echo '*: Failed to unmount the initrd /sys!'
+	elif /tmp/.initrd/bin/[ "${CDROOT}" -eq '1' ]
+	then
+		umount /tmp/.initrd/proc || echo "*: Failed to unmount the initrd /proc!"
+		umount /dev 2>/dev/null
+		mount -n --move /tmp/.initrd/dev dev 2>/dev/null
+		rm -rf /tmp/.initrd/dev || echo '*: Failed to remove the initrd /dev!'
+
+		umount /sys 2>/dev/null
+		umount /tmp/.initrd/sys 2>/dev/null
+	fi
+	echo -n '.'
+
+	# /usr/src/linux/Documentation/initrd.txt:
+	#	exec chroot . /sbin/init </dev/console >/dev/console 2>&1
+
+	exec <dev/console >dev/console 2>&1
+	echo '.'
+	exec chroot . /bin/sh <<- EOF
+		umount /tmp/.initrd || echo "*: Failed to unmount the initrd!"
+		/sbin/blockdev --flushbufs /dev/ram0 >/dev/null 2>&1
+		exec ${REAL_INIT:-/sbin/init} ${INIT_OPTS}
+EOF
+elif [ "$0" = '/init' ]
+then
+	[ ! -e ${CHROOT}/dev/console ] && mknod ${CHROOT}/dev/console c 5 1
+	[ ! -e ${CHROOT}/dev/tty1 ] && mknod ${CHROOT}/dev/tty1 c 4 1
+	echo -ne "${GOOD}>>${NORMAL}${BOLD} Booting (initramfs)"
+
+	cd ${CHROOT}
+	mkdir ${CHROOT}/proc ${CHROOT}/sys 2>/dev/null
+	echo -n '.'
+		umount /sys || echo '*: Failed to unmount the initrd /sys!'
+		umount /proc || echo '*: Failed to unmount the initrd /proc!'
+	echo -n '.'
+
+	exec switch_root -c "/dev/console" "${CHROOT}" ${REAL_INIT:-/sbin/init} ${INIT_OPTS}
+fi
+
+splash 'verbose'
+
+echo 'A fatal error has probably occured since /sbin/init did not'
+echo 'boot correctly. Trying to open a shell...'
+echo
+exec /bin/bash
+exec /bin/sh
+exec /bin/ash
+exec sh
diff -Nurp genkernel-3.4.9_pre3.orig/gen_initramfs.sh genkernel-3.4.9_pre3/gen_initramfs.sh
--- genkernel-3.4.9_pre3.orig/gen_initramfs.sh	2007-09-17 21:52:20.000000000 +0200
+++ genkernel-3.4.9_pre3/gen_initramfs.sh	2007-10-10 02:20:19.000000000 +0200
@@ -74,21 +74,6 @@ append_blkid(){
 	rm -rf "${TEMP}/initramfs-blkid-temp" > /dev/null
 }
 
-append_unionfs_modules(){
-	if [ -d "${TEMP}/initramfs-unionfs-modules-temp" ]
-	then
-		rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
-	fi
-	print_info 1 'UNIONFS MODULES: Adding support (compiling)...'
-	compile_unionfs_modules
-	mkdir -p "${TEMP}/initramfs-unionfs-modules-temp/"
-	/bin/tar -jxpf "${UNIONFS_MODULES_BINCACHE}" -C "${TEMP}/initramfs-unionfs-modules-temp" ||
-		gen_die "Could not extract unionfs modules binary cache!";
-	cd "${TEMP}/initramfs-unionfs-modules-temp/"
-	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
-	rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
-}
-
 append_unionfs_tools(){
 	if [ -d "${TEMP}/initramfs-unionfs-tools-temp" ]
 	then
@@ -431,7 +416,6 @@ create_initramfs() {
 	append_data 'auxilary'
 	append_data 'busybox' "${BUSYBOX}"
 	append_data 'devfs' "${DEVFS}"
-	append_data 'unionfs_modules' "${UNIONFS}"
 	append_data 'unionfs_tools' "${UNIONFS}"
 	append_data 'lvm' "${LVM}"
 	append_data 'dmraid' "${DMRAID}"
diff -Nurp genkernel-3.4.9_pre3.orig/gen_initramfs.sh.orig genkernel-3.4.9_pre3/gen_initramfs.sh.orig
--- genkernel-3.4.9_pre3.orig/gen_initramfs.sh.orig	1970-01-01 01:00:00.000000000 +0100
+++ genkernel-3.4.9_pre3/gen_initramfs.sh.orig	2007-09-17 21:52:20.000000000 +0200
@@ -0,0 +1,480 @@
+#!/bin/bash
+
+CPIO_ARGS="--quiet -o -H newc"
+
+append_base_layout() {
+	if [ -d "${TEMP}/initramfs-base-temp" ]
+	then
+		rm -rf "${TEMP}/initramfs-base-temp" > /dev/null
+	fi
+	mkdir -p ${TEMP}/initramfs-base-temp/dev
+	mkdir -p ${TEMP}/initramfs-base-temp/bin
+	mkdir -p ${TEMP}/initramfs-base-temp/etc
+	mkdir -p ${TEMP}/initramfs-base-temp/usr
+	mkdir -p ${TEMP}/initramfs-base-temp/proc
+	mkdir -p ${TEMP}/initramfs-base-temp/temp
+	mkdir -p ${TEMP}/initramfs-base-temp/sys
+	mkdir -p ${TEMP}/initramfs-temp/.initrd
+	mkdir -p ${TEMP}/initramfs-base-temp/var/lock/dmraid
+	mkdir -p ${TEMP}/initramfs-base-temp/sbin
+	mkdir -p ${TEMP}/initramfs-base-temp/usr/bin
+	mkdir -p ${TEMP}/initramfs-base-temp/usr/sbin
+	ln -s  lib  ${TEMP}/initramfs-base-temp/lib64
+
+	echo "/dev/ram0     /           ext2    defaults	0 0" > ${TEMP}/initramfs-base-temp/etc/fstab
+	echo "proc          /proc       proc    defaults    0 0" >> ${TEMP}/initramfs-base-temp/etc/fstab
+	
+	cd ${TEMP}/initramfs-base-temp/dev
+	mknod -m 660 console c 5 1
+	mknod -m 660 null c 1 3
+	mknod -m 600 tty1 c 4 1
+	cd "${TEMP}/initramfs-base-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-base-temp" > /dev/null
+}
+
+append_busybox() {
+	if [ -d "${TEMP}/initramfs-busybox-temp" ]
+	then
+		rm -rf "${TEMP}/initramfs-busybox-temp" > /dev/null
+	fi
+	mkdir -p "${TEMP}/initramfs-busybox-temp/bin/" 
+
+	cp "${GK_SHARE}/generic/udhcpc.scripts" ${TEMP}/initramfs-busybox-temp/bin/
+	chmod +x "${TEMP}/initramfs-busybox-temp/bin/udhcpc.scripts"
+	cp "${BUSYBOX_BINCACHE}" "${TEMP}/initramfs-busybox-temp/bin/busybox.tar.bz2" ||
+		gen_die 'Could not copy busybox from bincache!'
+	tar -xjf "${TEMP}/initramfs-busybox-temp/bin/busybox.tar.bz2" -C "${TEMP}/initramfs-busybox-temp/bin" busybox ||
+		gen_die 'Could not extract busybox bincache!'
+	chmod +x "${TEMP}/initramfs-busybox-temp/bin/busybox"
+
+	for i in '[' ash sh mount uname echo cut; do
+		rm -f ${TEMP}/initramfs-busybox-temp/bin/$i > /dev/null
+		ln ${TEMP}/initramfs-busybox-temp/bin/busybox ${TEMP}/initramfs-busybox-temp/bin/$i ||
+			gen_die "Busybox error: could not link ${i}!"
+	done
+	
+	cd "${TEMP}/initramfs-busybox-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-busybox-temp" > /dev/null
+}
+
+append_blkid(){
+	if [ -d "${TEMP}/initramfs-blkid-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-blkid-temp/"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-blkid-temp/bin/"
+	[ "${DISKLABEL}" -eq '1' ] && { /bin/bzip2 -dc "${BLKID_BINCACHE}" > "${TEMP}/initramfs-blkid-temp/bin/blkid" ||
+		gen_die "Could not extract blkid binary cache!"; }
+	chmod a+x "${TEMP}/initramfs-blkid-temp/bin/blkid"
+	cd "${TEMP}/initramfs-blkid-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -rf "${TEMP}/initramfs-blkid-temp" > /dev/null
+}
+
+append_unionfs_modules(){
+	if [ -d "${TEMP}/initramfs-unionfs-modules-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
+	fi
+	print_info 1 'UNIONFS MODULES: Adding support (compiling)...'
+	compile_unionfs_modules
+	mkdir -p "${TEMP}/initramfs-unionfs-modules-temp/"
+	/bin/tar -jxpf "${UNIONFS_MODULES_BINCACHE}" -C "${TEMP}/initramfs-unionfs-modules-temp" ||
+		gen_die "Could not extract unionfs modules binary cache!";
+	cd "${TEMP}/initramfs-unionfs-modules-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-unionfs-modules-temp/"
+}
+
+append_unionfs_tools(){
+	if [ -d "${TEMP}/initramfs-unionfs-tools-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-unionfs-tools-temp/"
+	fi
+	print_info 1 'UNIONFS TOOLS: Adding support (compiling)...'
+	compile_unionfs_utils
+	mkdir -p "${TEMP}/initramfs-unionfs-tools-temp/bin/"
+	/bin/tar -jxpf "${UNIONFS_BINCACHE}" -C "${TEMP}/initramfs-unionfs-tools-temp" ||
+		gen_die "Could not extract unionfs tools binary cache!";
+	cd "${TEMP}/initramfs-unionfs-tools-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-unionfs-tools-temp/"
+}
+
+#append_suspend(){
+#	if [ -d "${TEMP}/initramfs-suspend-temp" ];
+#	then
+#		rm -r "${TEMP}/initramfs-suspend-temp/"
+#	fi
+#	print_info 1 'SUSPEND: Adding support (compiling binaries)...'
+#	compile_suspend
+#	mkdir -p "${TEMP}/initramfs-suspend-temp/"
+#	/bin/tar -jxpf "${SUSPEND_BINCACHE}" -C "${TEMP}/initramfs-suspend-temp" ||
+#		gen_die "Could not extract suspend binary cache!"
+#	mkdir -p "${TEMP}/initramfs-suspend-temp/etc"
+#	cp -f /etc/suspend.conf "${TEMP}/initramfs-suspend-temp/etc" ||
+#		gen_die 'Could not copy /etc/suspend.conf'
+#	cd "${TEMP}/initramfs-suspend-temp/"
+#	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+#	rm -r "${TEMP}/initramfs-suspend-temp/"
+#}
+
+append_dmraid(){
+	if [ -d "${TEMP}/initramfs-dmraid-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-dmraid-temp/"
+	fi
+	print_info 1 'DMRAID: Adding support (compiling binaries)...'
+	compile_dmraid
+	mkdir -p "${TEMP}/initramfs-dmraid-temp/"
+	/bin/tar -jxpf "${DMRAID_BINCACHE}" -C "${TEMP}/initramfs-dmraid-temp" ||
+		gen_die "Could not extract dmraid binary cache!";
+	cd "${TEMP}/initramfs-dmraid-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-dmraid-temp/"
+}
+
+append_lvm(){
+	if [ -d "${TEMP}/initramfs-lvm-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-lvm-temp/"
+	fi
+	cd ${TEMP}
+	mkdir -p "${TEMP}/initramfs-lvm-temp/bin/"
+	mkdir -p "${TEMP}/initramfs-lvm-temp/etc/lvm/"
+	if [ -e '/sbin/lvm' ] && LC_ALL="C" ldd /sbin/lvm|grep -q 'not a dynamic executable'
+	then
+		print_info 1 '		LVM: Adding support (using local static binaries)...'
+		cp /sbin/lvm "${TEMP}/initramfs-lvm-temp/bin/lvm" ||
+			gen_die 'Could not copy over lvm!'
+	else
+		print_info 1 '		LVM: Adding support (compiling binaries)...'
+		compile_lvm
+		/bin/tar -jxpf "${LVM_BINCACHE}" -C "${TEMP}/initramfs-lvm-temp" ||
+			gen_die "Could not extract lvm binary cache!";
+		mv ${TEMP}/initramfs-lvm-temp/sbin/lvm.static ${TEMP}/initramfs-lvm-temp/bin/lvm ||
+			gen_die 'LVM error: Could not move lvm.static to lvm!'
+	fi
+	if [ -x /sbin/lvm ]
+	then
+#		lvm dumpconfig 2>&1 > /dev/null || gen_die 'Could not copy over lvm.conf!'
+#		ret=$?
+#		if [ ${ret} != 0 ]
+#		then
+			cp /etc/lvm/lvm.conf "${TEMP}/initramfs-lvm-temp/etc/lvm/" ||
+				gen_die 'Could not copy over lvm.conf!'
+#		else
+#			gen_die 'Could not copy over lvm.conf!'
+#		fi
+	fi
+	cd "${TEMP}/initramfs-lvm-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-lvm-temp/"
+}
+
+append_evms(){
+	if [ -d "${TEMP}/initramfs-evms-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-evms-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-evms-temp/lib/evms"
+	mkdir -p "${TEMP}/initramfs-evms-temp/etc/"
+	mkdir -p "${TEMP}/initramfs-evms-temp/bin/"
+	mkdir -p "${TEMP}/initramfs-evms-temp/sbin/"
+	if [ "${EVMS}" -eq '1' ]
+	then
+		print_info 1 '		EVMS: Adding support...'
+		mkdir -p ${TEMP}/initramfs-evms-temp/lib
+		cp -a /lib/ld-* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		if [ -n "`ls /lib/libgcc_s*`" ]
+		then
+			cp -a /lib/libgcc_s* "${TEMP}/initramfs-evms-temp/lib" \
+				|| gen_die 'Could not copy files for EVMS!'
+		fi
+		cp -a /lib/libc-* /lib/libc.* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libdl-* /lib/libdl.* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libpthread* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libuuid*so* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/libevms*so* "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/evms "${TEMP}/initramfs-evms-temp/lib" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /lib/evms/* "${TEMP}/initramfs-evms-temp/lib/evms" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp -a /etc/evms.conf "${TEMP}/initramfs-evms-temp/etc" \
+			|| gen_die 'Could not copy files for EVMS!'
+		cp /sbin/evms_activate "${TEMP}/initramfs-evms-temp/sbin" \
+			|| gen_die 'Could not copy over evms_activate!'
+
+		# Fix EVMS complaining that it can't find the swap utilities.
+		# These are not required in the initramfs
+		for swap_libs in "${TEMP}/initramfs-evms-temp/lib/evms/*/swap*.so"
+		do
+			rm ${swap_libs}
+		done
+	fi
+	cd "${TEMP}/initramfs-evms-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-evms-temp/"
+}
+
+append_splash(){
+	if [ -x /usr/bin/splash_geninitramfs ] || [ -x /sbin/splash_geninitramfs ]
+	then
+		[ -z "${SPLASH_THEME}" ] && [ -e /etc/conf.d/splash ] && source /etc/conf.d/splash
+		[ -z "${SPLASH_THEME}" ] && SPLASH_THEME=default
+		print_info 1 "  >> Installing splash [ using the ${SPLASH_THEME} theme ]..."
+		if [ -d "${TEMP}/initramfs-splash-temp" ]
+		then
+			rm -r "${TEMP}/initramfs-splash-temp/"
+		fi
+		mkdir -p "${TEMP}/initramfs-splash-temp"
+		cd /
+		local tmp=""
+		[ -n "${SPLASH_RES}" ] && tmp="-r ${SPLASH_RES}"
+		splash_geninitramfs -c "${TEMP}/initramfs-splash-temp" ${tmp} ${SPLASH_THEME} || gen_die "Could not build splash cpio archive"
+		if [ -e "/usr/share/splashutils/initrd.splash" ]; then
+			mkdir -p "${TEMP}/initramfs-splash-temp/etc"
+			cp -f "/usr/share/splashutils/initrd.splash" "${TEMP}/initramfs-splash-temp/etc"
+		fi
+		cd "${TEMP}/initramfs-splash-temp/"
+		find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}" \
+			|| gen_die "compressing splash cpio"
+		rm -r "${TEMP}/initramfs-splash-temp/"
+	else
+		print_warning 1 '               >> No splash detected; skipping!'
+	fi
+}
+
+append_overlay(){
+	cd ${INITRAMFS_OVERLAY}
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+}
+print_list()
+{
+	local x
+	for x in ${*}
+	do
+		echo ${x}
+	done
+}
+
+append_modules() {
+	local group
+	local group_modules
+	local MOD_EXT=".ko"
+
+	print_info 2 "initramfs: >> Searching for modules..."
+	if [ "${INSTALL_MOD_PATH}" != '' ]
+	then
+	  cd ${INSTALL_MOD_PATH}
+	else
+	  cd /
+	fi
+	
+	if [ -d "${TEMP}/initramfs-modules-${KV}-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-modules-${KV}-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-modules-${KV}-temp/lib/modules/${KV}"	
+	for i in `gen_dep_list`
+	do
+		mymod=`find ./lib/modules/${KV} -name "${i}${MOD_EXT}" 2>/dev/null| head -n 1 `
+		if [ -z "${mymod}" ]
+		then
+			print_warning 2 "Warning :: ${i}${MOD_EXT} not found; skipping..."
+			continue;
+		fi
+		
+		print_info 2 "initramfs: >> Copying ${i}${MOD_EXT}..."
+		cp -ax --parents "${mymod}" "${TEMP}/initramfs-modules-${KV}-temp"
+	done
+	
+	cp -ax --parents ./lib/modules/${KV}/modules* ${TEMP}/initramfs-modules-${KV}-temp 2>/dev/null
+
+	mkdir -p "${TEMP}/initramfs-modules-${KV}-temp/etc/modules"
+	for group_modules in ${!MODULES_*}; do
+		group="$(echo $group_modules | cut -d_ -f2 | tr "[:upper:]" "[:lower:]")"
+		print_list ${!group_modules} > "${TEMP}/initramfs-modules-${KV}-temp/etc/modules/${group}"
+	done
+	cd "${TEMP}/initramfs-modules-${KV}-temp/"
+	find . | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	cd "${TEMP}"
+	rm -r "${TEMP}/initramfs-modules-${KV}-temp/"	
+}
+
+# check for static linked file with objdump
+is_static() {
+	LANG="C" LC_ALL="C" objdump -T $1 2>&1 | grep "not a dynamic object" > /dev/null
+	return $?
+}
+
+append_auxilary() {
+	if [ -d "${TEMP}/initramfs-aux-temp" ]
+	then
+		rm -r "${TEMP}/initramfs-aux-temp/"
+	fi
+	mkdir -p "${TEMP}/initramfs-aux-temp/etc"	
+	mkdir -p "${TEMP}/initramfs-aux-temp/sbin"	
+	if [ -f "${CMD_LINUXRC}" ]
+	then
+		cp "${CMD_LINUXRC}" "${TEMP}/initramfs-aux-temp/init"
+		print_info 2 "        >> Copying user specified linuxrc: ${CMD_LINUXRC} to init"
+	else	
+		if [ -f "${GK_SHARE}/${ARCH}/linuxrc" ]
+		then
+			cp "${GK_SHARE}/${ARCH}/linuxrc" "${TEMP}/initramfs-aux-temp/init"
+		else
+			cp "${GK_SHARE}/generic/linuxrc" "${TEMP}/initramfs-aux-temp/init"
+		fi
+	fi
+
+	# Make sure it's executable
+	chmod 0755 "${TEMP}/initramfs-aux-temp/init"
+
+	# Make a symlink to init .. incase we are bundled inside the kernel as one
+	# big cpio.
+	cd ${TEMP}/initramfs-aux-temp
+	ln -s init linuxrc
+#	ln ${TEMP}/initramfs-aux-temp/init ${TEMP}/initramfs-aux-temp/linuxrc 
+
+	if [ -f "${GK_SHARE}/${ARCH}/initrd.scripts" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/initrd.scripts" "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	else	
+		cp "${GK_SHARE}/generic/initrd.scripts" "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	fi
+
+	if [ -f "${GK_SHARE}/${ARCH}/initrd.defaults" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/initrd.defaults" "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	else
+		cp "${GK_SHARE}/generic/initrd.defaults" "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	fi
+	
+	echo -n 'HWOPTS="$HWOPTS ' >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"	
+	for group_modules in ${!MODULES_*}; do
+		group="$(echo $group_modules | cut -d_ -f2 | tr "[:upper:]" "[:lower:]")"
+		echo -n "${group} " >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	done
+	echo '"' >> "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"	
+
+	if [ -f "${GK_SHARE}/${ARCH}/modprobe" ]
+	then
+		cp "${GK_SHARE}/${ARCH}/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	else
+		cp "${GK_SHARE}/generic/modprobe" "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	fi
+	if isTrue $CMD_DOKEYMAPAUTO
+	then
+		echo 'MY_HWOPTS="${MY_HWOPTS} keymap"' >> ${TEMP}/initramfs-aux-temp/etc/initrd.defaults
+	fi
+	mkdir -p "${TEMP}/initramfs-aux-temp/lib/keymaps"
+	/bin/tar -C "${TEMP}/initramfs-aux-temp/lib/keymaps" -zxf "${GK_SHARE}/generic/keymaps.tar.gz"
+	if isTrue $CMD_SLOWUSB
+	then
+		echo 'MY_HWOPTS="${MY_HWOPTS} slowusb"' >> ${TEMP}/initramfs-aux-temp/etc/initrd.defaults
+	fi
+	if isTrue ${LUKS}
+	then
+		if is_static /bin/cryptsetup
+		then
+			print_info 1 "Including LUKS support"
+			rm -f ${TEMP}/initramfs-aux-temp/sbin/cryptsetup
+			cp /bin/cryptsetup ${TEMP}/initramfs-aux-temp/sbin/cryptsetup
+			chmod +x "${TEMP}/initramfs-aux-temp/sbin/cryptsetup"
+		else
+			print_info 1 "LUKS support requires static cryptsetup at /bin/cryptsetup"
+			print_info 1 "Not including LUKS support"
+		fi
+	fi
+
+	cd ${TEMP}/initramfs-aux-temp/sbin && ln -s ../init init
+	cd ${TEMP}
+	chmod +x "${TEMP}/initramfs-aux-temp/init"
+	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.scripts"
+	chmod +x "${TEMP}/initramfs-aux-temp/etc/initrd.defaults"
+	chmod +x "${TEMP}/initramfs-aux-temp/sbin/modprobe"
+	cd "${TEMP}/initramfs-aux-temp/"
+	find . -print | cpio ${CPIO_ARGS} --append -F "${CPIO}"
+	rm -r "${TEMP}/initramfs-aux-temp/"	
+}
+
+append_data() {
+	local name=$1 var=$2
+	local func="append_${name}"
+
+	if [ $# -eq '1' ] || [ "${var}" -eq '1' ]
+	then
+	    print_info 1 "        >> Appending ${name} cpio data..."
+	    ${func}
+	fi
+}
+
+create_initramfs() {
+	print_info 1 "initramfs: >> Initializing..."
+
+	# Create empty cpio
+	CPIO="${TMPDIR}/initramfs-${KV}"
+	echo | cpio ${CPIO_ARGS} -F "${CPIO}" 2>/dev/null \
+		|| gen_die "Could not create empty cpio at ${CPIO}"
+
+	append_data 'base_layout'
+	append_data 'auxilary'
+	append_data 'busybox' "${BUSYBOX}"
+	append_data 'devfs' "${DEVFS}"
+	append_data 'unionfs_modules' "${UNIONFS}"
+	append_data 'unionfs_tools' "${UNIONFS}"
+	append_data 'lvm' "${LVM}"
+	append_data 'dmraid' "${DMRAID}"
+	append_data 'evms' "${EVMS}"
+	
+	if [ "${NOINITRDMODULES}" = '' ]
+	then
+		append_data 'modules'
+	else
+		print_info 1 "initramfs: Not copying modules..."
+	fi
+
+	append_data 'blkid' "${DISKLABEL}"
+	append_data 'splash' "${SPLASH}"
+
+	# This should always be appended last
+	if [ "${INITRAMFS_OVERLAY}" != '' ]
+	then
+		append_data 'overlay'
+	fi
+
+	gzip -9 "${CPIO}"
+	mv -f "${CPIO}.gz" "${CPIO}"
+
+	# Pegasos hack for merging the initramfs into the kernel at compile time
+	[ "${KERNEL_MAKE_DIRECTIVE}" == 'zImage.initrd' -a "${GENERATE_Z_IMAGE}" = '1' ] ||
+		[ "${KERNEL_MAKE_DIRECTIVE_2}" == 'zImage.initrd' -a "${GENERATE_Z_IMAGE}" = '1' ] &&
+			cp ${TMPDIR}/initramfs-${KV} ${KERNEL_DIR}/arch/powerpc/boot/ramdisk.image.gz &&
+			rm ${TMPDIR}/initramfs-${KV}
+
+	# Mips also mimics Pegasos to merge the initramfs into the kernel
+	if [ ${BUILD_INITRAMFS} -eq 1 ]; then
+		cp ${TMPDIR}/initramfs-${KV} ${KERNEL_DIR}/initramfs.cpio.gz
+		gunzip -f ${KERNEL_DIR}/initramfs.cpio.gz
+	fi
+
+	if ! isTrue "${CMD_NOINSTALL}"
+	then
+		if [ "${GENERATE_Z_IMAGE}" != '1' ]
+		then
+			copy_image_with_preserve "initramfs" \
+				"${TMPDIR}/initramfs-${KV}" \
+				"initramfs-${KNAME}-${ARCH}-${KV}"
+		fi
+	fi
+}

