Index: Python/pythonrun.c
===================================================================
--- Python/pythonrun.c	(revisione 75748)
+++ Python/pythonrun.c	(revisione 75749)
@@ -17,6 +17,7 @@
 #include "ast.h"
 #include "eval.h"
 #include "marshal.h"
+#include "abstract.h"
 
 #ifdef HAVE_SIGNAL_H
 #include <signal.h>
@@ -61,6 +62,7 @@
 			      PyCompilerFlags *);
 static void err_input(perrdetail *);
 static void initsigs(void);
+static void wait_for_thread_shutdown(void);
 static void call_sys_exitfunc(void);
 static void call_ll_exitfuncs(void);
 extern void _PyUnicode_Init(void);
@@ -387,6 +389,8 @@
 	if (!initialized)
 		return;
 
+	wait_for_thread_shutdown();
+
 	/* The interpreter is still entirely intact at this point, and the
 	 * exit funcs may be relying on that.  In particular, if some thread
 	 * or exit func is still waiting to do an import, the import machinery
@@ -1663,6 +1667,32 @@
 #include "pythread.h"
 #endif
 
+/* Wait until threading._shutdown completes, provided
+   the threading module was imported in the first place.
+   The shutdown routine will wait until all non-daemon
+   "threading" threads have completed. */
+static void
+wait_for_thread_shutdown(void)
+{
+#ifdef WITH_THREAD
+	PyObject *result;
+	PyThreadState *tstate = PyThreadState_GET();
+	PyObject *threading = PyMapping_GetItemString(tstate->interp->modules,
+						      "threading");
+	if (threading == NULL) {
+		/* threading not imported */
+		PyErr_Clear();
+		return;
+	}
+	result = PyObject_CallMethod(threading, "_shutdown", "");
+	if (result == NULL)
+		PyErr_WriteUnraisable(threading);
+	else
+		Py_DECREF(result);
+	Py_DECREF(threading);
+#endif
+}
+
 #define NEXITFUNCS 32
 static void (*exitfuncs[NEXITFUNCS])(void);
 static int nexitfuncs = 0;
Index: Misc/NEWS
===================================================================
--- Misc/NEWS	(revisione 75748)
+++ Misc/NEWS	(revisione 75749)
@@ -4,6 +4,22 @@
 
 (editors: check NEWS.help for information about editing NEWS using ReST.)
 
+What's New in Python 2.6.5
+==========================
+
+*Release date: XX-XXX-20XX*
+
+Core and Builtins
+-----------------
+
+- Issue #1722344: threading._shutdown() is now called in Py_Finalize(), which
+  fixes the problem of some exceptions being thrown at shutdown when the
+  interpreter is killed. Patch by Adam Olsen.
+
+Library
+-------
+
+
 What's New in Python 2.6.4 final?
 =================================
 
Index: Misc/ACKS
===================================================================
--- Misc/ACKS	(revisione 75748)
+++ Misc/ACKS	(revisione 75749)
@@ -517,6 +517,7 @@
 Tim O'Malley
 Pascal Oberndoerfer
 Jeffrey Ollie
+Adam Olsen
 Grant Olson
 Piet van Oostrum
 Jason Orendorff
Index: Lib/test/test_threading.py
===================================================================
--- Lib/test/test_threading.py	(revisione 75748)
+++ Lib/test/test_threading.py	(revisione 75749)
@@ -284,7 +284,31 @@
         self.failIf(rc == 2, "interpreted was blocked")
         self.failUnless(rc == 0, "Unexpected error")
 
+    def test_join_nondaemon_on_shutdown(self):
+        # Issue 1722344
+        # Raising SystemExit skipped threading._shutdown
+        import subprocess
+        p = subprocess.Popen([sys.executable, "-c", """if 1:
+                import threading
+                from time import sleep
 
+                def child():
+                    sleep(1)
+                    # As a non-daemon thread we SHOULD wake up and nothing
+                    # should be torn down yet
+                    print "Woke up, sleep function is:", sleep
+
+                threading.Thread(target=child).start()
+                raise SystemExit
+            """],
+            stdout=subprocess.PIPE,
+            stderr=subprocess.PIPE)
+        stdout, stderr = p.communicate()
+        self.assertEqual(stdout.strip(),
+            "Woke up, sleep function is: <built-in function sleep>")
+        stderr = re.sub(r"^\[\d+ refs\]", "", stderr, re.MULTILINE).strip()
+        self.assertEqual(stderr, "")
+
     def test_enumerate_after_join(self):
         # Try hard to trigger #1703448: a thread is still returned in
         # threading.enumerate() after it has been join()ed.
Index: Modules/main.c
===================================================================
--- Modules/main.c	(revisione 75748)
+++ Modules/main.c	(revisione 75749)
@@ -222,33 +222,6 @@
 }
 
 
-/* Wait until threading._shutdown completes, provided
-   the threading module was imported in the first place.
-   The shutdown routine will wait until all non-daemon
-   "threading" threads have completed. */
-#include "abstract.h"
-static void
-WaitForThreadShutdown(void)
-{
-#ifdef WITH_THREAD
-	PyObject *result;
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *threading = PyMapping_GetItemString(tstate->interp->modules,
-						      "threading");
-	if (threading == NULL) {
-		/* threading not imported */
-		PyErr_Clear();
-		return;
-	}
-	result = PyObject_CallMethod(threading, "_shutdown", "");
-	if (result == NULL)
-		PyErr_WriteUnraisable(threading);
-	else
-		Py_DECREF(result);
-	Py_DECREF(threading);
-#endif
-}
-
 /* Main program */
 
 int
@@ -620,8 +593,6 @@
 		sts = PyRun_AnyFileFlags(stdin, "<stdin>", &cf) != 0;
 	}
 
-	WaitForThreadShutdown();
-
 	Py_Finalize();
 #ifdef RISCOS
 	if (Py_RISCOSWimpFlag)
