From a07a840b26827e1a2c8cccd255177b693c5b91e8 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Wed, 18 Mar 2009 08:38:12 +0000
Subject: Don't fail when building against server 1.5

The driver had all the right guards, but synclient and syndaemon didn't.
Check for xserver 1.6 and higher and disable property support in synclient
and syndaemon.

Note that the property headers still get installed even without support for
properties in the driver. This ensures that apps looking for synaptics >=
thisversion don't fail miserably.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
Signed-off-by: Henrik Rydberg <rydberg@euromail.se>
Signed-off-by: Christoph Brill <egore@gmx.de>
---
diff --git a/configure.ac b/configure.ac
index 6da52c0..4280fff 100644
--- a/configure.ac
+++ b/configure.ac
@@ -85,6 +85,13 @@ PKG_CHECK_MODULES(XORG, xorg-server xproto $REQUIRED_MODULES)
 sdkdir=$(pkg-config --variable=sdkdir xorg-server)
 AC_SUBST([sdkdir])
 
+PKG_CHECK_MODULES(XORG16, [xorg-server >= 1.6],
+                  HAVE_PROPERTIES="yes"; AC_DEFINE(HAVE_PROPERTIES, 1,
+                                                   "Input Device Property support"),
+                  HAVE_PROPERTIES="no");
+AM_CONDITIONAL(HAVE_PROPERTIES, [ test "$HAVE_PROPERTIES" = "yes" ])
+AC_SUBST(HAVE_PROPERTIES)
+
 CFLAGS="$CFLAGS $XORG_CFLAGS "' -I$(top_srcdir)/src'
 AC_SUBST([CFLAGS])
 
diff --git a/tools/synclient.c b/tools/synclient.c
index 40279d4..82ce61b 100644
--- a/tools/synclient.c
+++ b/tools/synclient.c
@@ -45,11 +45,13 @@
 #include <X11/extensions/XInput.h>
 #include "synaptics.h"
 #include "synaptics-properties.h"
+#ifdef HAVE_PROPERTIES
 #include <xserver-properties.h>
 
 #ifndef XATOM_FLOAT
 #define XATOM_FLOAT "FLOAT"
 #endif
+#endif
 
 enum ParaType {
     PT_INT,
@@ -397,6 +399,7 @@ shm_init()
 }
 
 
+#ifdef HAVE_PROPERTIES
 /** Init display connection or NULL on error */
 static Display*
 dp_init()
@@ -665,12 +668,15 @@ dp_show_settings(Display *dpy, XDevice *dev)
 	XFree(data);
     }
 }
+#endif
 
 static void
 usage(void)
 {
     fprintf(stderr, "Usage: synclient [-s] [-m interval] [-h] [-l] [-V] [-?] [var1=value1 [var2=value2] ...]\n");
+#ifdef HAVE_PROPERTIES
     fprintf(stderr, "  -s Use SHM area instead of device properties.\n");
+#endif
     fprintf(stderr, "  -m monitor changes to the touchpad state (implies -s)\n"
 	    "     interval specifies how often (in ms) to poll the touchpad state\n");
     fprintf(stderr, "  -h Show detected hardware properties (implies -s)\n");
@@ -689,9 +695,13 @@ main(int argc, char *argv[])
     int do_monitor = 0;
     int dump_hw = 0;
     int dump_settings = 0;
-    int use_shm = 0;
+    int use_shm = 1;
     int first_cmd;
 
+#ifdef HAVE_PROPERTIES
+    use_shm = 0;
+#endif
+
     /* Parse command line parameters */
     while ((c = getopt(argc, argv, "sm:hlV")) != -1) {
 	switch (c) {
@@ -718,6 +728,7 @@ main(int argc, char *argv[])
 	    usage();
 	}
     }
+
     first_cmd = optind;
     if (!do_monitor && !dump_hw && !dump_settings && first_cmd == argc)
 	usage();
@@ -741,7 +752,9 @@ main(int argc, char *argv[])
 	    shm_show_settings(synshm);
 	if (do_monitor)
 	    shm_monitor(synshm, delay);
-    } else /* Device properties */
+    }
+#ifdef HAVE_PROPERTIES
+    else /* Device properties */
     {
 	Display *dpy;
 	XDevice *dev;
@@ -757,6 +770,7 @@ main(int argc, char *argv[])
 	XCloseDevice(dpy, dev);
 	XCloseDisplay(dpy);
     }
+#endif
 
     return 0;
 }
diff --git a/tools/syndaemon.c b/tools/syndaemon.c
index 751c2c9..2a46550 100644
--- a/tools/syndaemon.c
+++ b/tools/syndaemon.c
@@ -63,7 +63,7 @@ static int ignore_modifier_combos;
 static int ignore_modifier_keys;
 static int background;
 static const char *pid_file;
-static int use_shm;
+static int use_shm = 1;
 static Display *display;
 static XDevice *dev;
 static Atom touchpad_off_prop;
@@ -108,6 +108,7 @@ toggle_touchpad(enum TouchpadState value)
     pad_disabled = value;
     if (use_shm)
         synshm->touchpad_off = value;
+#ifdef HAVE_PROPERTIES
     else {
         unsigned char data = value;
         /* This potentially overwrites a different client's setting, but ...*/
@@ -115,6 +116,7 @@ toggle_touchpad(enum TouchpadState value)
 				PropModeReplace, &data, 1);
 	XFlush(display);
     }
+#endif
 }
 
 static void
@@ -453,6 +455,7 @@ void record_main_loop(Display* display, double idle_time) {
 }
 #endif /* HAVE_XRECORD */
 
+#ifdef HAVE_PROPERTIES
 static XDevice *
 dp_get_device(Display *dpy)
 {
@@ -517,6 +520,7 @@ unwind:
     }
     return dev;
 }
+#endif
 
 static int
 shm_init()
@@ -548,6 +552,10 @@ main(int argc, char *argv[])
     int c;
     int use_xrecord = 0;
 
+#ifdef HAVE_PROPERTIES
+    use_shm = 0;
+#endif
+
     /* Parse command line parameters */
     while ((c = getopt(argc, argv, "i:m:dtp:kKR?")) != EOF) {
 	switch(c) {
@@ -596,8 +604,10 @@ main(int argc, char *argv[])
 
     if (use_shm && !shm_init())
 	exit(2);
+#ifdef HAVE_PROPERTIES
     else if (!use_shm && !(dev = dp_get_device(display)))
 	exit(2);
+#endif
 
     /* Install a signal handler to restore synaptics parameters on exit */
     install_signal_handler();
--
cgit v0.8.2
