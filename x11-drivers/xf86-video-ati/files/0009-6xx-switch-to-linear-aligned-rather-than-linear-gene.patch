From 7ac3a2e0bcdadff7c7172a9f833f526b526da16b Mon Sep 17 00:00:00 2001
From: Alex Deucher <alexdeucher@gmail.com>
Date: Thu, 10 Feb 2011 14:24:50 -0500
Subject: [PATCH 09/11] 6xx+: switch to linear aligned rather than linear general

linear aligned is supposedly more performant, but more
importantly, linear general only works on the CB without
slices.  The texture blocks technically don't support
linear general although, I think linear general gets
upgraded to linear aligned in the hw which is why it
currently works.

Signed-off-by: Alex Deucher <alexdeucher@gmail.com>
---
 src/drmmode_display.c               |    6 +---
 src/evergreen_exa.c                 |   26 +++++++++++++++++++++
 src/evergreen_textured_videofuncs.c |   12 ++++++++++
 src/r600_exa.c                      |   42 ++++++++++++++++++++++++++++++++++-
 src/r600_textured_videofuncs.c      |   12 ++++++++++
 src/radeon.h                        |    1 +
 6 files changed, 94 insertions(+), 5 deletions(-)

diff --git a/src/drmmode_display.c b/src/drmmode_display.c
index d5ad211..06cfd95 100644
--- a/src/drmmode_display.c
+++ b/src/drmmode_display.c
@@ -1130,10 +1130,8 @@ int drmmode_get_pitch_align(ScrnInfoPtr scrn, int bpe, uint32_t tiling)
 			/* further restrictions for scanout */
 			pitch_align = MAX(info->group_bytes / bpe, pitch_align);
 		} else {
-			/* general surface requirements */
-			pitch_align = info->group_bytes / bpe;
-			/* further restrictions for scanout */
-			pitch_align = MAX(32, pitch_align);
+			/* linear aligned requirements */
+			pitch_align = MAX(64, info->group_bytes / bpe);
 		}
 	} else {
 		/* general surface requirements */
diff --git a/src/evergreen_exa.c b/src/evergreen_exa.c
index f10879f..0aeac85 100644
--- a/src/evergreen_exa.c
+++ b/src/evergreen_exa.c
@@ -53,11 +53,17 @@ EVERGREENSetAccelState(ScrnInfoPtr pScrn,
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     struct radeon_accel_state *accel_state = info->accel_state;
+    uint32_t pitch = 0;
     int ret;
 
     if (src0) {
 	memcpy(&accel_state->src_obj[0], src0, sizeof(struct r600_accel_object));
 	accel_state->src_size[0] = src0->pitch * src0->height * (src0->bpp/8);
+	ret = radeon_bo_get_tiling(accel_state->src_obj[0].bo,
+				   &accel_state->src_obj[0].tiling_flags,
+				   &pitch);
+	if (ret)
+	    RADEON_FALLBACK(("src0 radeon_bo_get_tiling failed\n"));
     } else {
 	memset(&accel_state->src_obj[0], 0, sizeof(struct r600_accel_object));
 	accel_state->src_size[0] = 0;
@@ -66,6 +72,11 @@ EVERGREENSetAccelState(ScrnInfoPtr pScrn,
     if (src1) {
 	memcpy(&accel_state->src_obj[1], src1, sizeof(struct r600_accel_object));
 	accel_state->src_size[1] = src1->pitch * src1->height * (src1->bpp/8);
+	ret = radeon_bo_get_tiling(accel_state->src_obj[1].bo,
+				   &accel_state->src_obj[1].tiling_flags,
+				   &pitch);
+	if (ret)
+	    RADEON_FALLBACK(("src1 radeon_bo_get_tiling failed\n"));
     } else {
 	memset(&accel_state->src_obj[1], 0, sizeof(struct r600_accel_object));
 	accel_state->src_size[1] = 0;
@@ -74,6 +85,11 @@ EVERGREENSetAccelState(ScrnInfoPtr pScrn,
     if (dst) {
 	memcpy(&accel_state->dst_obj, dst, sizeof(struct r600_accel_object));
 	accel_state->dst_size = dst->pitch * dst->height * (dst->bpp/8);
+	ret = radeon_bo_get_tiling(accel_state->dst_obj.bo,
+				   &accel_state->dst_obj.tiling_flags,
+				   &pitch);
+	if (ret)
+	    RADEON_FALLBACK(("dst radeon_bo_get_tiling failed\n"));
     } else {
 	memset(&accel_state->dst_obj, 0, sizeof(struct r600_accel_object));
 	accel_state->dst_size = 0;
@@ -229,6 +245,8 @@ EVERGREENPrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     if (accel_state->planemask & 0xff000000)
 	cb_conf.pmask |= 8; /* A */
     cb_conf.rop = accel_state->rop;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     evergreen_set_render_target(pScrn, &cb_conf, accel_state->dst_obj.domain);
 
     evergreen_set_spi(pScrn, 0, 0);
@@ -391,6 +409,8 @@ EVERGREENDoPrepareCopy(ScrnInfoPtr pScrn)
     tex_res.base_level          = 0;
     tex_res.last_level          = 0;
     tex_res.perf_modulation     = 0;
+    if (accel_state->src_obj[0].tiling_flags == 0)
+	tex_res.array_mode          = 1;
     evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
     tex_samp.id                 = 0;
@@ -430,6 +450,8 @@ EVERGREENDoPrepareCopy(ScrnInfoPtr pScrn)
     if (accel_state->planemask & 0xff000000)
 	cb_conf.pmask |= 8; /* A */
     cb_conf.rop = accel_state->rop;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     evergreen_set_render_target(pScrn, &cb_conf, accel_state->dst_obj.domain);
 
     evergreen_set_spi(pScrn, (1 - 1), 1);
@@ -990,6 +1012,8 @@ static Bool EVERGREENTextureSetup(PicturePtr pPict, PixmapPtr pPix,
     tex_res.base_level          = 0;
     tex_res.last_level          = 0;
     tex_res.perf_modulation     = 0;
+    if (accel_state->src_obj[unit].tiling_flags == 0)
+	tex_res.array_mode          = 1;
     evergreen_set_tex_resource  (pScrn, &tex_res, accel_state->src_obj[unit].domain);
 
     tex_samp.id                 = unit;
@@ -1298,6 +1322,8 @@ static Bool EVERGREENPrepareComposite(int op, PicturePtr pSrcPicture,
     cb_conf.blendcntl |= CB_BLEND0_CONTROL__ENABLE_bit;
     cb_conf.rop = 3;
     cb_conf.pmask = 0xf;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     evergreen_set_render_target(pScrn, &cb_conf, accel_state->dst_obj.domain);
 
     if (pMask)
diff --git a/src/evergreen_textured_videofuncs.c b/src/evergreen_textured_videofuncs.c
index 5bccfa6..39a18d6 100644
--- a/src/evergreen_textured_videofuncs.c
+++ b/src/evergreen_textured_videofuncs.c
@@ -265,6 +265,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.last_level          = 0;
 	tex_res.perf_modulation     = 0;
 	tex_res.interlaced          = 0;
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.array_mode          = 1;
 	evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
 	/* Y sampler */
@@ -296,6 +298,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planev_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planev_offset;
 	tex_res.size                = tex_res.pitch * (pPriv->h >> 1);
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.array_mode          = 1;
 	evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
 	/* U or V sampler */
@@ -317,6 +321,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planeu_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planeu_offset;
 	tex_res.size                = tex_res.pitch * (pPriv->h >> 1);
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.array_mode          = 1;
 	evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -354,6 +360,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.last_level          = 0;
 	tex_res.perf_modulation     = 0;
 	tex_res.interlaced          = 0;
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.array_mode          = 1;
 	evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
 	/* Y sampler */
@@ -389,6 +397,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset;
 	tex_res.size                = accel_state->src_size[0];
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.array_mode          = 1;
 	evergreen_set_tex_resource(pScrn, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -425,6 +435,8 @@ EVERGREENDisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     cb_conf.blend_clamp = 1;
     cb_conf.pmask = 0xf;
     cb_conf.rop = 3;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     evergreen_set_render_target(pScrn, &cb_conf, accel_state->dst_obj.domain);
 
     evergreen_set_spi(pScrn, (1 - 1), 1);
diff --git a/src/r600_exa.c b/src/r600_exa.c
index ea65de9..1103c35 100644
--- a/src/r600_exa.c
+++ b/src/r600_exa.c
@@ -53,10 +53,23 @@ R600SetAccelState(ScrnInfoPtr pScrn,
 {
     RADEONInfoPtr info = RADEONPTR(pScrn);
     struct radeon_accel_state *accel_state = info->accel_state;
+    uint32_t pitch = 0;
+#if defined(XF86DRM_MODE)
+    int ret;
+#endif
 
     if (src0) {
 	memcpy(&accel_state->src_obj[0], src0, sizeof(struct r600_accel_object));
 	accel_state->src_size[0] = src0->pitch * src0->height * (src0->bpp/8);
+#if defined(XF86DRM_MODE)
+	if (info->cs) {
+	    ret = radeon_bo_get_tiling(accel_state->src_obj[0].bo,
+				       &accel_state->src_obj[0].tiling_flags,
+				       &pitch);
+	    if (ret)
+		RADEON_FALLBACK(("src0 radeon_bo_get_tiling failed\n"));
+	}
+#endif
     } else {
 	memset(&accel_state->src_obj[0], 0, sizeof(struct r600_accel_object));
 	accel_state->src_size[0] = 0;
@@ -65,6 +78,15 @@ R600SetAccelState(ScrnInfoPtr pScrn,
     if (src1) {
 	memcpy(&accel_state->src_obj[1], src1, sizeof(struct r600_accel_object));
 	accel_state->src_size[1] = src1->pitch * src1->height * (src1->bpp/8);
+#if defined(XF86DRM_MODE)
+	if (info->cs) {
+	    ret = radeon_bo_get_tiling(accel_state->src_obj[1].bo,
+				       &accel_state->src_obj[1].tiling_flags,
+				       &pitch);
+	    if (ret)
+		RADEON_FALLBACK(("src1 radeon_bo_get_tiling failed\n"));
+	}
+#endif
     } else {
 	memset(&accel_state->src_obj[1], 0, sizeof(struct r600_accel_object));
 	accel_state->src_size[1] = 0;
@@ -73,6 +95,15 @@ R600SetAccelState(ScrnInfoPtr pScrn,
     if (dst) {
 	memcpy(&accel_state->dst_obj, dst, sizeof(struct r600_accel_object));
 	accel_state->dst_size = dst->pitch * dst->height * (dst->bpp/8);
+#if defined(XF86DRM_MODE)
+	if (info->cs) {
+	    ret = radeon_bo_get_tiling(accel_state->dst_obj.bo,
+				       &accel_state->dst_obj.tiling_flags,
+				       &pitch);
+	    if (ret)
+		RADEON_FALLBACK(("dst radeon_bo_get_tiling failed\n"));
+	}
+#endif
     } else {
 	memset(&accel_state->dst_obj, 0, sizeof(struct r600_accel_object));
 	accel_state->dst_size = 0;
@@ -107,7 +138,6 @@ R600SetAccelState(ScrnInfoPtr pScrn,
     accel_state->ps_size = 512;
 #if defined(XF86DRM_MODE)
     if (info->cs) {
-	int ret;
 	accel_state->vs_mc_addr = vs_offset;
 	accel_state->ps_mc_addr = ps_offset;
 
@@ -243,6 +273,8 @@ R600PrepareSolid(PixmapPtr pPix, int alu, Pixel pm, Pixel fg)
     if (accel_state->planemask & 0xff000000)
 	cb_conf.pmask |= 8; /* A */
     cb_conf.rop = accel_state->rop;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     r600_set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
     r600_set_spi(pScrn, accel_state->ib, 0, 0);
@@ -402,6 +434,8 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     tex_res.base_level          = 0;
     tex_res.last_level          = 0;
     tex_res.perf_modulation     = 0;
+    if (accel_state->src_obj[0].tiling_flags == 0)
+	tex_res.tile_mode           = 1;
     r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
     tex_samp.id                 = 0;
@@ -442,6 +476,8 @@ R600DoPrepareCopy(ScrnInfoPtr pScrn)
     if (accel_state->planemask & 0xff000000)
 	cb_conf.pmask |= 8; /* A */
     cb_conf.rop = accel_state->rop;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     r600_set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
     r600_set_spi(pScrn, accel_state->ib, (1 - 1), 1);
@@ -1003,6 +1039,8 @@ static Bool R600TextureSetup(PicturePtr pPict, PixmapPtr pPix,
     tex_res.base_level          = 0;
     tex_res.last_level          = 0;
     tex_res.perf_modulation     = 0;
+    if (accel_state->src_obj[unit].tiling_flags == 0)
+	tex_res.tile_mode           = 1;
     r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[unit].domain);
 
     tex_samp.id                 = unit;
@@ -1350,6 +1388,8 @@ static Bool R600PrepareComposite(int op, PicturePtr pSrcPicture,
     cb_conf.blend_enable = 1;
     cb_conf.pmask = 0xf;
     cb_conf.rop = 3;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     r600_set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
     if (pMask)
diff --git a/src/r600_textured_videofuncs.c b/src/r600_textured_videofuncs.c
index 8eabb08..0fb919b 100644
--- a/src/r600_textured_videofuncs.c
+++ b/src/r600_textured_videofuncs.c
@@ -280,6 +280,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.last_level          = 0;
 	tex_res.perf_modulation     = 0;
 	tex_res.interlaced          = 0;
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.tile_mode           = 1;
 	r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* Y sampler */
@@ -311,6 +313,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planev_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planev_offset;
 	tex_res.size                = tex_res.pitch * (pPriv->h >> 1);
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.tile_mode           = 1;
 	r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* U or V sampler */
@@ -332,6 +336,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset + pPriv->planeu_offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset + pPriv->planeu_offset;
 	tex_res.size                = tex_res.pitch * (pPriv->h >> 1);
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.tile_mode           = 1;
 	r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -370,6 +376,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.last_level          = 0;
 	tex_res.perf_modulation     = 0;
 	tex_res.interlaced          = 0;
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.tile_mode           = 1;
 	r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* Y sampler */
@@ -406,6 +414,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
 	tex_res.base                = accel_state->src_obj[0].offset;
 	tex_res.mip_base            = accel_state->src_obj[0].offset;
 	tex_res.size                = accel_state->src_size[0];
+	if (accel_state->src_obj[0].tiling_flags == 0)
+	    tex_res.tile_mode           = 1;
 	r600_set_tex_resource(pScrn, accel_state->ib, &tex_res, accel_state->src_obj[0].domain);
 
 	/* UV sampler */
@@ -442,6 +452,8 @@ R600DisplayTexturedVideo(ScrnInfoPtr pScrn, RADEONPortPrivPtr pPriv)
     cb_conf.blend_clamp = 1;
     cb_conf.pmask = 0xf;
     cb_conf.rop = 3;
+    if (accel_state->dst_obj.tiling_flags == 0)
+	cb_conf.array_mode = 1;
     r600_set_render_target(pScrn, accel_state->ib, &cb_conf, accel_state->dst_obj.domain);
 
     r600_set_spi(pScrn, accel_state->ib, (1 - 1), 1);
diff --git a/src/radeon.h b/src/radeon.h
index 4da9bf7..67a9b49 100644
--- a/src/radeon.h
+++ b/src/radeon.h
@@ -683,6 +683,7 @@ struct r600_accel_object {
     int bpp;
     uint32_t domain;
     struct radeon_bo *bo;
+    uint32_t tiling_flags;
 };
 
 struct radeon_vbo_object {
-- 
1.7.3.2

