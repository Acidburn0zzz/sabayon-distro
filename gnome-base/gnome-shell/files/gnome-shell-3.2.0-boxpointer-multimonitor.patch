From 7a8a189c483b48de581c490a44d69030ba7a6923 Mon Sep 17 00:00:00 2001
From: Jasper St. Pierre <jstpierre@mecheye.net>
Date: Thu, 22 Sep 2011 19:52:58 +0000
Subject: boxpointer: Don't constrain box pointer to primary monitor

A boxPointer should be able to be attached to any actor, not just ones on the
primary monitor. Assume that the sourceActor doesn't straddle monitors, and
constrain the boxPointer to the monitor the sourceActor is on.

https://bugzilla.gnome.org/show_bug.cgi?id=659861
---
diff --git a/js/ui/boxpointer.js b/js/ui/boxpointer.js
index 1523ef6..979e2d1 100644
--- a/js/ui/boxpointer.js
+++ b/js/ui/boxpointer.js
@@ -329,7 +329,7 @@ BoxPointer.prototype = {
         // We also want to keep it onscreen, and separated from the
         // edge by the same distance as the main part of the box is
         // separated from its sourceActor
-        let primary = Main.layoutManager.primaryMonitor;
+        let monitor = Main.layoutManager.findMonitorForActor(sourceActor);
         let themeNode = this.actor.get_theme_node();
         let borderWidth = themeNode.get_length('-arrow-border-width');
         let arrowBase = themeNode.get_length('-arrow-base');
@@ -364,8 +364,8 @@ BoxPointer.prototype = {
         case St.Side.BOTTOM:
             resX = sourceCenterX - (halfMargin + (natWidth - margin) * alignment);
 
-            resX = Math.max(resX, primary.x + 10);
-            resX = Math.min(resX, primary.x + primary.width - (10 + natWidth));
+            resX = Math.max(resX, monitor.x + 10);
+            resX = Math.min(resX, monitor.x + monitor.width - (10 + natWidth));
             this.setArrowOrigin(sourceCenterX - resX);
             break;
 
@@ -373,8 +373,8 @@ BoxPointer.prototype = {
         case St.Side.RIGHT:
             resY = sourceCenterY - (halfMargin + (natHeight - margin) * alignment);
 
-            resY = Math.max(resY, primary.y + 10);
-            resY = Math.min(resY, primary.y + primary.height - (10 + natHeight));
+            resY = Math.max(resY, monitor.y + 10);
+            resY = Math.min(resY, monitor.y + monitor.height - (10 + natHeight));
 
             this.setArrowOrigin(sourceCenterY - resY);
             break;
diff --git a/js/ui/layout.js b/js/ui/layout.js
index d473ae0..f21fcca 100644
--- a/js/ui/layout.js
+++ b/js/ui/layout.js
@@ -369,6 +369,10 @@ LayoutManager.prototype = {
     // Removes @actor from the chrome
     removeChrome: function(actor) {
         this._chrome.removeActor(actor);
+    },
+
+    findMonitorForActor: function(actor) {
+        return this._chrome.findMonitorForActor(actor);
     }
 };
 Signals.addSignalMethods(LayoutManager.prototype);
@@ -700,7 +704,7 @@ Chrome.prototype = {
             else if (this._inOverview)
                 visible = true;
             else if (!actorData.visibleInFullscreen &&
-                     this._findMonitorForActor(actorData.actor).inFullscreen)
+                     this.findMonitorForActor(actorData.actor).inFullscreen)
                 visible = false;
             else
                 visible = true;
@@ -762,7 +766,7 @@ Chrome.prototype = {
 
     // This call guarantees that we return some monitor to simplify usage of it
     // In practice all tracked actors should be visible on some monitor anyway
-    _findMonitorForActor: function(actor) {
+    findMonitorForActor: function(actor) {
         let [x, y] = actor.get_transformed_position();
         let [w, h] = actor.get_transformed_size();
         let monitor = this._findMonitorForRect(x, y, w, h);
--
cgit v0.9.0.2
